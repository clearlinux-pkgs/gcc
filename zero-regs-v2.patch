From ab315c2ba15d8eeea45ea3d2853d237d7c9bd81d Mon Sep 17 00:00:00 2001
From: Athenas Jimenez Gonzalez <athenas.jimenez.gonzalez@intel.com>
Date: Thu, 3 May 2018 15:46:19 +0000
Subject: [PATCH] zero regs v2

---
 gcc/config/i386/i386.c   | 98 ++++++++++++++++++++++++++++++++++++++--
 gcc/config/i386/i386.h   |  4 ++
 gcc/config/i386/i386.md  |  6 +--
 gcc/config/i386/i386.opt |  4 ++
 4 files changed, 105 insertions(+), 7 deletions(-)

diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 6a2141e48..a6f79b1cb 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -5858,6 +5858,10 @@ ix86_set_func_type (tree fndecl)
 	  if (lookup_attribute ("no_caller_saved_registers",
 				TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))
 	    cfun->machine->no_caller_saved_registers = true;
+      if (ix86_zero_caller_saved_regs
+          || lookup_attribute ("zero_caller_saved_regs",
+                   TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))
+        cfun->machine->zero_caller_saved_regs = true;
 	}
     }
 }
@@ -14085,7 +14089,7 @@ ix86_expand_prologue (void)
       insn = emit_insn (gen_set_got (pic));
       RTX_FRAME_RELATED_P (insn) = 1;
       add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);
-      emit_insn (gen_prologue_use (pic));
+      emit_insn (gen_pro_epilogue_use (pic));
       /* Deleting already emmitted SET_GOT if exist and allocated to
 	 REAL_PIC_OFFSET_TABLE_REGNUM.  */
       ix86_elim_entry_set_got (pic);
@@ -14114,7 +14118,7 @@ ix86_expand_prologue (void)
      Further, prevent alloca modifications to the stack pointer from being
      combined with prologue modifications.  */
   if (TARGET_SEH)
-    emit_insn (gen_prologue_use (stack_pointer_rtx));
+    emit_insn (gen_pro_epilogue_use (stack_pointer_rtx));
 }
 
 /* Emit code to restore REG using a POP insn.  */
@@ -14187,6 +14191,84 @@ ix86_emit_restore_regs_using_pop (void)
       ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno));
 }
 
+/* Emit code to zero touched caller-saved general registers upon
+   function return.  */
+
+static void
+ix86_emit_zero_caller_saved_regs (void)
+{
+  /* No need to zero caller-saved registers in main ().  Don't zero
+     caller-saved registers if __builtin_eh_return is called since it
+     isn't a normal function return.  */
+  if (!cfun->machine->zero_caller_saved_regs
+      || crtl->calls_eh_return
+      || MAIN_NAME_P (DECL_NAME (current_function_decl)))
+    return;
+
+  edge e;
+  edge_iterator ei;
+
+  unsigned int regno;
+
+  HARD_REG_SET live_outgoing_regs;
+  CLEAR_HARD_REG_SET (live_outgoing_regs);
+
+  /* Check for live outgoing registers.  */
+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)
+    {
+      basic_block bb = e->src;
+      bitmap live_out = df_get_live_out (bb);
+
+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+   {
+     /* Only zero general registers.  */
+     if (!GENERAL_REGNO_P (regno))
+       continue;
+
+     /* No need to check it again if it is live.  */
+     if (TEST_HARD_REG_BIT (live_outgoing_regs, regno))
+       continue;
+
+     /* A register is considered LIVE if
+        1. It is a fixed register.
+        2. If isn't a caller-saved register.
+        3. If it is a live outgoing register.
+        4. If it is neverd used.
+        */
+     if (fixed_regs[regno]
+         || !call_used_regs[regno]
+         || REGNO_REG_SET_P (live_out, regno)
+         || !df_regs_ever_live_p (regno))
+       SET_HARD_REG_BIT (live_outgoing_regs, regno);
+   }
+    }
+
+  rtx zero = NULL_RTX;
+
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    {
+      if (!GENERAL_REGNO_P (regno))
+   continue;
+
+      if (TEST_HARD_REG_BIT (live_outgoing_regs, regno))
+   continue;
+
+      /* Zero out dead caller-saved register.  We only need to zero the
+    lower 32 bits.  */
+      rtx reg = gen_rtx_REG (SImode, regno);
+      if (zero == NULL_RTX)
+   {
+     zero = reg;
+     emit_move_insn (reg, const0_rtx);
+   }
+      else {
+   emit_move_insn (reg, zero); zero = NULL_RTX;
+      }
+      /* Mark it in use  */
+      emit_insn (gen_pro_epilogue_use (reg));
+    }
+}
+
 /* Emit code and notes for the LEAVE instruction.  If insn is non-null,
    omits the emit and only attaches the notes.  */
 
@@ -14832,7 +14914,10 @@ ix86_expand_epilogue (int style)
 	  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
 	}
       else
-	emit_jump_insn (gen_simple_return_pop_internal (popc));
+    {
+      ix86_emit_zero_caller_saved_regs ();
+      emit_jump_insn (gen_simple_return_pop_internal (popc));
+    }
     }
   else if (!m->call_ms2sysv || !restore_stub_is_tail)
     {
@@ -14859,7 +14944,10 @@ ix86_expand_epilogue (int style)
 	  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
 	}
       else
-	emit_jump_insn (gen_simple_return_internal ());
+    {
+      ix86_emit_zero_caller_saved_regs ();
+      emit_jump_insn (gen_simple_return_internal ());
+    }
     }
 
   /* Restore the state back to the state from the prologue,
@@ -46088,6 +46176,8 @@ static const struct attribute_spec ix86_attribute_table[] =
     ix86_handle_fndecl_attribute, NULL },
   { "function_return", 1, 1, true, false, false, false,
     ix86_handle_fndecl_attribute, NULL },
+  { "zero_caller_saved_regs", 0, 0, true, false, false,
+    NULL, false },
 
   /* End element.  */
   { NULL, 0, 0, false, false, false, false, NULL, NULL }
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 795ad2a32..7786aebba 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2611,6 +2611,10 @@ struct GTY(()) machine_function {
      the "interrupt" or "no_caller_saved_registers" attribute.  */
   BOOL_BITFIELD no_caller_saved_registers : 1;
 
+  /* If true, the current function should zero out touched caller-saved
+     general registers upon function return.  */
+  BOOL_BITFIELD zero_caller_saved_regs : 1;
+
   /* If true, there is register available for argument passing.  This
      is used only in ix86_function_ok_for_sibcall by 32-bit to determine
      if there is scratch register available for indirect sibcall.  In
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index ad9ccf9d1..02b1d4c01 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -204,7 +204,7 @@
   UNSPECV_STACK_PROBE
   UNSPECV_PROBE_STACK_RANGE
   UNSPECV_ALIGN
-  UNSPECV_PROLOGUE_USE
+  UNSPECV_PRO_EPILOGUE_USE
   UNSPECV_SPLIT_STACK_RETURN
   UNSPECV_CLD
   UNSPECV_NOPS
@@ -13094,8 +13094,8 @@
 
 ;; As USE insns aren't meaningful after reload, this is used instead
 ;; to prevent deleting instructions setting registers for PIC code
-(define_insn "prologue_use"
-  [(unspec_volatile [(match_operand 0)] UNSPECV_PROLOGUE_USE)]
+(define_insn "pro_epilogue_use"
+  [(unspec_volatile [(match_operand 0)] UNSPECV_PRO_EPILOGUE_USE)]
   ""
   ""
   [(set_attr "length" "0")])
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index d9bd909a8..d8697bfba 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -1048,6 +1048,10 @@ mindirect-branch-register
 Target Report Var(ix86_indirect_branch_register) Init(0)
 Force indirect call and jump via register.
 
+mzero-caller-saved-regs
+Target Report Var(ix86_zero_caller_saved_regs) Init(0)
+Zero out touched caller-saved general registers upon function return.
+
 mmovdiri
 Target Report Mask(ISA_MOVDIRI) Var(ix86_isa_flags) Save
 Support MOVDIRI built-in functions and code generation.
-- 
2.17.0

