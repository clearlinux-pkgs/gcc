diff --git a/ChangeLog b/ChangeLog
index 6cdf86a..82d7d88 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+2015-12-04  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-01  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	PR libffi/65726
+	* Makefile.def (lang_env_dependencies): Make libffi depend
+	on cxx.
+	* Makefile.in: Regenerate.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/Makefile.def b/Makefile.def
index e0ea2fb..5abea3e 100644
--- a/Makefile.def
+++ b/Makefile.def
@@ -522,6 +522,7 @@ dependencies = { module=all-m4; on=all-build-texinfo; };
 // on libgcc and newlib/libgloss.
 lang_env_dependencies = { module=libjava; cxx=true; };
 lang_env_dependencies = { module=libitm; cxx=true; };
+lang_env_dependencies = { module=libffi; cxx=true; };
 lang_env_dependencies = { module=libcilkrts; cxx=true; };
 lang_env_dependencies = { module=liboffloadmic; cxx=true; };
 lang_env_dependencies = { module=newlib; no_c=true; };
diff --git a/Makefile.in b/Makefile.in
index 36b4008..57a1e45 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -50485,6 +50485,7 @@ configure-target-winsup: maybe-all-target-newlib maybe-all-target-libgloss
 
 
 configure-target-libffi: maybe-all-target-newlib maybe-all-target-libgloss
+configure-target-libffi: maybe-all-target-libstdc++-v3
 
 configure-target-libjava: maybe-all-target-newlib maybe-all-target-libgloss
 configure-target-libjava: maybe-all-target-libstdc++-v3
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 4e0a4c6..55cbe58 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,10 @@
+2016-02-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68741
+	* inclhack.def (hpux_vsscanf): New fix.
+	* fixincl.x: Regenerated.
+	* tests/base/stdio.h [HPUX_VSSCANF_CHECK]: New test.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
index 79af6d1..a7d8edc 100644
--- a/fixincludes/fixincl.x
+++ b/fixincludes/fixincl.x
@@ -1,12 +1,12 @@
 /*  -*- buffer-read-only: t -*- vi: set ro:
- *
- *DO NOT EDIT THIS FILE   (fixincl.x)
- *
- *It has been AutoGen-ed  August 13, 2015 at 05:25:50 PM by AutoGen 5.18.3
- *From the definitions    inclhack.def
- *and the template file   fixincl
+ * 
+ * DO NOT EDIT THIS FILE   (fixincl.x)
+ * 
+ * It has been AutoGen-ed  Monday February  1, 2016 at 03:24:02 PM EST
+ * From the definitions    inclhack.def
+ * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Aug 13 17:25:50 UTC 2015
+/* DO NOT SVN-MERGE THIS FILE, EITHER Mon  1 Feb 2016 15:24:02 EST
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 230 fixup descriptions.
+ * This file contains 231 fixup descriptions.
  *
  * See README for more information.
  *
@@ -4326,6 +4326,43 @@ static const char* apzHpux11_VsnprintfPatch[] = {
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Hpux_Vsscanf fix
+ */
+tSCC zHpux_VsscanfName[] =
+     "hpux_vsscanf";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zHpux_VsscanfList[] =
+  "stdio.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzHpux_VsscanfMachs[] = {
+        "*-*-hpux*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zHpux_VsscanfSelect0[] =
+       "(extern int vsscanf\\()char";
+
+#define    HPUX_VSSCANF_TEST_CT  1
+static tTestDesc aHpux_VsscanfTests[] = {
+  { TT_EGREP,    zHpux_VsscanfSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Hpux_Vsscanf
+ */
+static const char* apzHpux_VsscanfPatch[] = {
+    "format",
+    "%1const char",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Hpux8_Bogus_Inlines fix
  */
 tSCC zHpux8_Bogus_InlinesName[] =
@@ -9448,9 +9485,9 @@ static const char* apzX11_SprintfPatch[] = {
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          267
+#define REGEX_COUNT          268
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            230
+#define FIX_COUNT            231
 
 /*
  *  Enumerate the fixes
@@ -9556,6 +9593,7 @@ typedef enum {
     HPUX11_SIZE_T_FIXIDX,
     HPUX11_SNPRINTF_FIXIDX,
     HPUX11_VSNPRINTF_FIXIDX,
+    HPUX_VSSCANF_FIXIDX,
     HPUX8_BOGUS_INLINES_FIXIDX,
     HPUX_C99_INTPTR_FIXIDX,
     HPUX_C99_INTTYPES_FIXIDX,
@@ -10189,6 +10227,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      HPUX11_VSNPRINTF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aHpux11_VsnprintfTests,   apzHpux11_VsnprintfPatch, 0 },
 
+  {  zHpux_VsscanfName,    zHpux_VsscanfList,
+     apzHpux_VsscanfMachs,
+     HPUX_VSSCANF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aHpux_VsscanfTests,   apzHpux_VsscanfPatch, 0 },
+
   {  zHpux8_Bogus_InlinesName,    zHpux8_Bogus_InlinesList,
      apzHpux8_Bogus_InlinesMachs,
      HPUX8_BOGUS_INLINES_TEST_CT, FD_MACH_ONLY,
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index fc72add..8b6d1fe 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -2273,6 +2273,20 @@ fix = {
 };
 
 /*
+ *  Fix missing const in hpux vsscanf declaration
+ */
+fix = {
+    hackname = hpux_vsscanf;
+    mach    = "*-*-hpux*";
+    files   = stdio.h;
+    select  = '(extern int vsscanf\()char';
+    c_fix   = format;
+    c_fix_arg = "%1const char";
+
+    test_text = 'extern int vsscanf(char *, const char *, __va_list);';
+};
+
+/*
  *  get rid of bogus inline definitions in HP-UX 8.0
  */
 fix = {
diff --git a/fixincludes/tests/base/stdio.h b/fixincludes/tests/base/stdio.h
index 275931c..4ca4faf 100644
--- a/fixincludes/tests/base/stdio.h
+++ b/fixincludes/tests/base/stdio.h
@@ -59,6 +59,11 @@ extern int vsnprintf(char *, _hpux_size_t, const char *, __gnuc_va_list);
 #endif  /* HPUX11_VSNPRINTF_CHECK */
 
 
+#if defined( HPUX_VSSCANF_CHECK )
+extern int vsscanf(const char *, const char *, __gnuc_va_list);
+#endif  /* HPUX_VSSCANF_CHECK */
+
+
 #if defined( IRIX_STDIO_DUMMY_VA_LIST_CHECK )
 extern int printf( const char *, __gnuc_va_list );
 #endif  /* IRIX_STDIO_DUMMY_VA_LIST_CHECK */
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 8316552..8261c65 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,1219 @@
+2016-03-10  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR target/70168
+	* config/rs6000/rs6000.c (rs6000_expand_atomic_compare_and_swap):
+	Handle overlapping retval and newval.
+
+2016-03-10  Alan Modra  <amodra@gmail.com>
+
+	PR rtl-optimization/69195
+	PR rtl-optimization/47992
+	* ira.c (recorded_label_ref): Delete.
+	(update_equiv_regs): Return void.
+	(indirect_jump_optimize): New function.
+	(ira): Call indirect_jump_optimize and delete_trivially_dead_insns
+	before regstat_compute_ri.  Don't rebuild_jump_labels here.
+
+2016-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69666
+	PR middle-end/69920
+	* tree-sra.c (sra_modify_assign): Do not attempt to create
+	default_def replacements for unscalarizable regions.  Do not
+	remove loads of uninitialized aggregates to SSA_NAMEs.
+
+2016-03-07  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2016-02-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/65932
+	PR target/67714
+	* config/arm/arm.c (arm_new_rtx_costs, MULT case): Properly extract
+	the operands of the SIGN_EXTENDs from a SMUL[TB][TB] rtx.
+
+2016-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70059
+	* config/i386/sse.md (vec_set_lo_<mode><mask_name>,
+	<extract_type_2>_vinsert<shuffletype><extract_suf_2>_mask): Formatting
+	fixes.
+	(vec_set_hi_<mode><mask_name>): Likewise.  Swap VEC_CONCAT operands.
+
+2016-03-03  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2015-10-14  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* targhooks.c (default_target_option_pragma_parse): Do not warn if
+	called on behalf of "#pragma GCC pop_options".
+
+2016-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/70007
+	* gcse.c (compute_ld_motion_mems): Tidy up and also invalidate memory
+	references present in REG_EQUAL notes attached to non-SET patterns.
+
+2016-02-27  Jeff Law  <law@redhat.com>
+
+	Revert
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/69740
+	* cfghooks.c (remove_edge): Request loop fixups if we delete
+	an edge that might turn an irreducible loop into a natural
+	loop.
+
+2016-02-26  Richard Biener  <rguenther@suse.de>
+	    Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/69740
+	* cfghooks.c (remove_edge): Request loop fixups if we delete
+	an edge that might turn an irreducible loop into a natural
+	loop.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vector.md: Add missing commutative operand markers
+	to the patterns which qualify for one.
+	* config/s390/vx-builtins.md: Likewise.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vector.md (VI, VI_QHS): Add single element vector
+	types to mode iterators.
+	(vec_double): ... and mode attribute.
+	* config/s390/vx-builtins.md (non_vec_int): Likewise.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vector.md ("<ti*>add<mode>3", "<ti*>sub<mode>3"):
+	Change the predicate of op2 from nonimmediate to general and let
+	reload fix it if necessary.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vecintrin.h (vec_sub_u128): Define missing macro.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_expand_vcond): Use the compare operand
+	mode.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-protos.h: Add s390_expand_vec_movstr prototype.
+	* config/s390/s390.c (s390_expand_vec_movstr): New function.
+	* config/s390/s390.md ("movstr<P:mode>"): Call
+	s390_expand_vec_movstr.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.md: Add missing output modifier for operand 1
+	to print it as address properly.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/2827.md: Rename ooo_* insn attributes to zEC12_*.
+	* config/s390/2964.md: New file.
+	* config/s390/s390.c (s390_get_sched_attrmask): Use the right set
+	of insn grouping attributes depending on the CPU level.
+	(s390_get_unit_mask): New function.
+	(s390_sched_score): Remove the OOO from the scheduling macros.
+	Add loop to calculate a score for the instruction mix.
+	(s390_sched_reorder): Likewise plus improve debug output.
+	(s390_sched_variable_issue): Rename macros as above.  Calculate
+	the unit distances after actually scheduling an insn.  Improve
+	debug output.
+	(s390_sched_init): Clear last_scheduled_unit_distance array.
+	* config/s390/s390.md: Include 2964.md.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_register_info_set_ranges): Remove
+	superfluous loops.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_emit_call): Add missing 64 bit check.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/69625
+	* config/s390/s390.c (SAVE_SLOT_NONE, SAVE_SLOT_STACK): New
+	defines.
+	(s390_register_info_gprtofpr): Use new macros above.
+	(s390_register_info_stdarg_fpr): Adjust max_fpr to better match
+	its name.
+	(s390_register_info_stdarg_gpr): Adjust max_gpr to better match
+	its name.  Adjust restore and save gpr ranges.
+	(s390_register_info_set_ranges): New function.
+	(s390_register_info): Use new macros above.  Call
+	s390_register_info_set_ranges.
+	(s390_optimize_register_info): Likewise.
+	(s390_hard_regno_rename_ok): Use new macros.
+	(s390_hard_regno_scratch_ok): Likewise.
+	(s390_emit_epilogue): Likewise.
+	(s390_can_use_return_insn): Likewise.
+	(s390_optimize_prologue): Likewise.
+	* config/s390/s390.md (GPR2_REGNUM, GPR6_REGNUM): New constants.
+
+2016-02-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-01-29  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* config/s390/s390-c.c (s390_resolve_overloaded_builtin): Format
+	declaration name with %qs and print it in both error messages.  Also
+	fix indentation.
+
+2016-02-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-01-29  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	PR other/69006
+	* config/s390/s390-c.c (s390_resolve_overloaded_builtin): Remove
+	trailing blank line from error message.
+
+2016-02-25  Robin Dapp  <rdapp@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2015-12-18  Robin Dapp  <rdapp@linux.vnet.ibm.com>
+
+	* config/s390/predicates.md: Change and rename
+	constm1_operand to all_ones_operand
+	* config/s390/s390.c (s390_expand_vcond): Use all_ones_operand
+	* config/s390/vector.md: Likewise
+
+2016-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69776
+	* tree-ssa-sccvn.h (vn_reference_lookup): Adjust prototype.
+	* tree-ssa-sccvn.c (vn_reference_lookup): Add parameter to
+	indicate whether we can use TBAA to disambiguate against stores.
+	Use alias-set zero if not.
+	(visit_reference_op_store): Do not use TBAA when looking up
+	redundant stores.
+	* tree-ssa-pre.c (compute_avail): Use TBAA here.
+	(eliminate_dom_walker::before_dom_children): But not when looking
+	up redundant stores.
+
+	2016-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69776
+	* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Get alias
+	sets from caller.
+	(indirect_refs_may_alias_p): Likewise.
+	(refs_may_alias_p_1): Pass alias sets as from ao_ref.
+	* tree-ssa-sccvn.c (vn_reference_lookup): Also adjust vr alias-set
+	according to tbaa_p.
+	* tree-ssa-dom.c (lookup_avail_expr): Add tbaa_p flag.
+	(optimize_stmt): For redundant store discovery do not allow tbaa.
+
+2016-02-24  Martin Jambor  <mjambor@suse.cz>
+
+	revert:
+	2016-02-23  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69666
+	* tree-sra.c (sra_modify_assign): Do not attempt to create
+	default_def replacements for unscalarizable regions.
+
+2016-02-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-17  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/69609
+	* bb-reorder.c (struct bbro_basic_block_data): Add priority member.
+	(find_traces_1_round): When ending a trace update cached priority
+	of successors.
+	(bb_to_key): Use cached priority when available.
+	(copy_bb): Initialize cached priority.
+	(reorder_basic_blocks_software_trace_cache): Likewise.
+
+	2016-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69719
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Properly use absolute of the difference of the two offsets to
+	compare or adjust the segment length.
+
+	2016-02-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69719
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Adjust previous fix by ensuring that dr_a1 is left of dr_a2.
+
+	2016-02-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69783
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Add trivially correct cases.
+
+2016-02-23  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69666
+	* tree-sra.c (sra_modify_assign): Do not attempt to create
+	default_def replacements for unscalarizable regions.
+
+2016-02-18  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-15  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/69648
+	* lra-constraints.c (update_ebb_live_info): Don't remove sets of
+	pic_offset_table_rtx.
+
+2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (*altivec_lvxl_<mode>_internal): Output
+	correct instruction.
+
+2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-15  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/69752
+	* ira.c (update_equiv_regs): When looking for more than a single SET,
+	also take other side effects into account.
+
+	Backport from mainline
+	2016-02-08  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/68730
+	* lra-remat.c (insn_to_cand_activation): New static variable.
+	(lra_remat): Allocate and free it.
+	(create_cand): New arg activation. Initialize a field in
+	insn_to_cand_activation if it is nonnull.
+	(create_cands): Pass the activation insn to create_cand when making
+	a candidate involving an output reload.  Reorganize code a little.
+	(do_remat): Keep track of active status of candidates in a separate
+	bitmap.
+
+	Backport from mainline
+	2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR tree-optimization/69714
+	* tree-ssa-math-opts.c (find_bswap_or_nop): Revert previous change.
+	Return NULL if we have irrelevant high bytes on BIG_ENDIAN.
+
+2016-02-16  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk:
+	2016-02-04  Jim Wilson  <jim.wilson@linaro.org>
+
+	PR target/65932
+	PR target/67714
+	* config/arm/arm.h (PROMOTE_MODE): Don't set UNSIGNEDP for QImode and
+	HImode.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR lto/67709
+	2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	* omp-low.c (simd_clone_create): Remove call to
+	symtab->call_cgraph_insertion_hooks.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* omp-low.c (simd_clone_create): Set in_other_partition
+	for created clones.
+
+2016-02-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	* config/pa/pa.md (absqi2, absghi2, bswaphi2, bswapsi2, bswapdi2): New.
+
+2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/67260
+	* config/sh/sh.md (sibcall_value_pcrel): Replace =&k scratch reg with
+	fixed R1_REG scratch reg.
+
+2016-02-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-02-11  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/64682
+	PR rtl-optimization/69567
+	PR rtl-optimization/69737
+	* combine.c (distribute_notes) <REG_DEAD>: If the register is set
+	in I2 as well, just lose it.
+
+2016-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-01-18  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/69308
+	* gimple.c (gimple_could_trap_p_1): Handle GIMPLE_COND.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69574
+	* tree-chrec.c (hide_evolution_in_other_loops_than_loop): Instead
+	of asserting return chrec_dont_know.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69579
+	* tree-ssa-loop-ivcanon.c (propagate_constants_for_unrolling):
+	Do not propagate through abnormal PHI results.
+
+	2016-02-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69606
+	* tree-ssa-math-opts.c (bswap_replace): Clear flow sensitive
+	info on the result before moving a stmt.
+
+	2016-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69715
+	* tree-ssa.c (execute_update_addresses_taken): Mark non-decl
+	LHS on calls as non-rewritable.
+
+2016-02-11  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-11  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/69713
+	* config/sh/sh.md (casesi_worker_0): Add T_REG use.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69546
+	* wide-int.cc (wi::divmod_internal): For unsigned division
+	where both operands fit into uhwi, if o1 is 1 and o0 has
+	msb set, if divident_prec is larger than bits per hwi,
+	clear another quotient word and return 2 instead of 1.
+	Similarly for remainder with msb in HWI set, if dividend_prec
+	is larger than bits per hwi.
+
+	2016-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69399
+	* wide-int.h (wi::lrshift): For larger precisions, only
+	use fast path if shift is known to be < HOST_BITS_PER_WIDE_INT.
+
+	2016-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69432
+	* config/i386/i386.c: Include dojump.h.
+	(expand_small_movmem_or_setmem,
+	expand_set_or_movmem_prologue_epilogue_by_misaligned_moves): Spelling
+	fixes.
+	(ix86_expand_set_or_movmem): Call do_pending_stack_adjust () early
+	if dynamic_check != -1.
+
+	2016-01-21  Stefan Sørensen  <stefan.sorensen@spectralink.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69187
+	PR target/65624
+	* config/arm/arm-builtins.c (arm_expand_neon_builtin): Increase
+	args array size by one to avoid buffer overflow.
+
+	2016-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/67653
+	* gimplify.c (gimplify_asm_expr): Warn if it is too late to
+	attempt to mark memory input operand addressable and
+	call prepare_gimple_addressable in that case.  Don't adjust
+	input_location for diagnostics, use error_at instead.
+
+	2016-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/65779
+	* shrink-wrap.c: Include valtrack.h.
+	(move_insn_for_shrink_wrap): Add DEBUG argument.  If
+	MAY_HAVE_DEBUG_INSNS, call dead_debug_add on DEBUG_INSNs
+	in between insn and where it will be moved to.  Call
+	dead_debug_insert_temp.
+	(prepare_shrink_wrap): Adjust caller.  Call dead_debug_local_init
+	first and dead_debug_local_finish at the end.
+	For uses and defs bitmap, handle all regs in between REGNO and
+	END_REGNO, not just the first one.
+
+	PR rtl-optimization/68955
+	PR rtl-optimization/64557
+	* dse.c (record_store, check_mem_read_rtx): Don't call get_addr
+	here.  Fix up formatting.
+	* alias.c (get_addr): Handle VALUE +/- CONST_SCALAR_INT_P.
+
+	2016-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/68269
+	* combine.c (expand_field_assignment): Punt if compute_mode is
+	unsupported scalar mode.
+
+	2016-01-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69214
+	* tree-vrp.c (simplify_cond_using_ranges): Don't propagate
+	innerop into a comparison if SSA_NAME_OCCURS_IN_ABNORMAL_PHI.
+	Formatting fix.
+
+	2016-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/68960
+	* gimple-expr.c (copy_var_decl): If var has DECL_USER_ALIGN set, copy
+	it and DECL_ALIGN too.
+
+	2016-01-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/69055
+	* ubsan.c (ubsan_instrument_float_cast): Call
+	initialize_sanitizer_builtins.
+
+	PR target/69015
+	* ifcvt.c (find_cond_trap): Give up if returnjump_p (jump).
+
+	2015-12-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/67376
+	* fold-const.c (size_low_cst): Removed.
+	(fold_comparison): For POINTER_PLUS_EXPR where base is ADDR_EXPR
+	call get_inner_reference and handle INDIRECT_REF base of it.  Use
+	offset_int for computation of the bitpos.
+	(fold_binary_loc) <case EQ_EXPR, NE_EXPR>: Formatting
+	fixes for X +- Y CMP X and C - X CMP X folding.  Add X CMP X +- Y
+	and X CMP C - X folding.
+
+2016-02-09  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR middle-end/65702
+	* varasm.c (make_decl_rtl): Mark invalid register vars as
+	DECL_EXTERNAL.
+
+2016-02-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2016-02-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/64682
+	PR rtl-optimization/69567
+	* combine.c (distribute_notes) <REG_DEAD>: Place the death note
+	before I2 only if the register is both used and set in I2.
+
+2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69644
+	* config/rs6000/rs6000.c (rs6000_expand_atomic_compare_and_swap):
+	Force oldval into register if it does not satisfy reg_or_short_operand
+	predicate.  Fix up formatting.
+
+2016-02-03  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	PR target/69118
+	* config/i386/sse.md (define_insn "avx512f_maskcmp<mode>3"):
+	Fix target.
+
+2016-02-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/67032
+	* config/i386/i386.c (geode_cost): Increase cost of MMX and SSE moves.
+
+2016-02-02  Alan Modra  <amodra@gmail.com>
+
+	PR target/69548
+	* config/rs6000/predicates.md (quad_int_reg_operand): Don't
+	allow subregs.
+
+2016-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+	PR target/68986
+	* config/i386/i386.c (ix86_compute_frame_layout): Move stack
+	alignment adjustment to ...
+	(ix86_update_stack_boundary): Here.  Don't over-align stack nor
+	change stack_alignment_needed for __tls_get_addr.
+	(ix86_finalize_stack_realign_flags): Use stack_alignment_needed
+	if __tls_get_addr is called.
+
+2016-02-01  Richard Henderson  <rth@redhat.com>
+
+	Backport from mainline.
+	2016-01-28  Richard Henderson  <rth@redhat.com>
+
+	PR target/69305
+	* config/aarch64/aarch64-modes.def (CC_Cmode): New
+	* config/aarch64/aarch64-protos.h: Update.
+	* config/aarch64/aarch64.c (aarch64_zero_extend_const_eq): New.
+	(aarch64_select_cc_mode): Add check for use of CC_Cmode.
+	(aarch64_get_condition_code_1): Handle CC_Cmode.
+	* config/aarch64/aarch64.md (addti3): Use adddi3_compareC.
+	(*add<mode>3_compareC_cconly_imm): New.
+	(*add<mode>3_compareC_cconly): New.
+	(*add<mode>3_compareC_imm): New.
+	(add<mode>3_compareC): New.
+	(add<mode>3_carryin, *addsi3_carryin_uxtw): Sort compare operand
+	to be first.  Use aarch64_carry_operation.
+	(*add<mode>3_carryin_alt1, *addsi3_carryin_alt1_uxtw): Remove.
+	(*add<mode>3_carryin_alt2, *addsi3_carryin_alt2_uxtw): Remove.
+	(*add<mode>3_carryin_alt3, *addsi3_carryin_alt3_uxtw): Remove.
+	(subti3): Use subdi3_compare1.
+	(*sub<mode>3_compare0): Rename from sub<mode>3_compare0.
+	(sub<mode>3_compare1): New.
+	(*sub<mode>3_carryin0, *subsi3_carryin_uxtw): New.
+	(*sub<mode>3_carryin): Use aarch64_borrow_operation.
+	(*subsi3_carryin_uxtw): Likewise.
+	(*ngc<mode>, *ngcsi_uxtw): Likewise.
+	(*sub<mode>3_carryin_alt, *subsi3_carryin_alt_uxtw): New.
+	* config/aarch64/iterators.md (DWI): New.
+	* config/aarch64/predicates.md (aarch64_carry_operation): New.
+	(aarch64_borrow_operation): New.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69459
+	* config/i386/constraints.md (C): Only accept constant zero operand.
+	(BC): New constraint.
+	* config/i386/sse.md (*mov<mode>_internal): Use BC constraint
+	instead of C constraint.
+	* doc/md.texi (Machine Constraints): Update description
+	of C constraint.
+
+2016-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69551
+	* config/i386/i386.c (ix86_expand_vector_set) <case V4SImode>: For
+	SSE1, copy target into the temporary reg first before recursing
+	on it.
+
+2016-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/69542
+	* lra-remat.c (calculate_local_reg_remat_bb_data): Only consider
+	non-debug insns.
+
+2016-01-28  Richard Henderson  <rth@redhat.com>
+
+	PR rtl-opt/69447
+	* lra-remat.c (subreg_regs): New.
+	(dump_candidates_and_remat_bb_data): Dump it.
+	(operand_to_remat): Reject if operand in subreg_regs.
+	(set_bb_regs): Collect subreg_regs.
+	(lra_remat): Init and free subreg_regs.  Compute
+	calculate_local_reg_remat_bb_data before create_cands.
+
+2016-01-28  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69355
+	* tree-sra.c (analyze_access_subtree): Correct hole detection when
+	total_scalarization fails.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* tree-data-ref.c (initialize_data_dependence_relation): Handle
+	DR_NUM_DIMENSIONS == 0.
+
+2016-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/ia64/ia64.c (ia64_expand_vecint_compare): Use gen_int_mode.
+
+2016-01-23  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69426
+	* tree-parloops.c (eliminate_local_variables_stmt): Handle vdef of
+	removed clobber.
+
+2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69403
+	* config/arm/thumb2.md (*thumb2_ior_scc_strict_it): Convert to
+	define_insn_and_split.  Ensure operands[1] and operands[0] do not
+	get assigned the same register.
+
+2016-01-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_save_gprs_to_fprs): Add CFA_REGISTER
+	reg note to the GPR -> FPR save instructions.
+
+2016-01-21  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2016-01-08  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/67781
+	* tree-ssa-math-opts.c (find_bswap_or_nop): Zero out bytes in cmpxchg
+	and cmpnop in two steps: first the ones not accessed in original
+	gimple expression in a endian independent way and then the ones not
+	accessed in the final result in an endian-specific way.
+
+2016-01-20  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68513
+	* match.pd ((x & ~m) | (y & m)): Only perform on GIMPLE.
+
+2016-01-19  Sergei Trofimovich <siarheit@google.com>
+
+	Backport from mainline
+	PR other/60465
+	* config/ia64/ia64.c (ia64_expand_load_address): Use gprel64
+	for local symbolic operands.
+	* config/ia64/predicates.md (local_symbolic_operand64): New
+	predicate.
+
+2016-01-19  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-01-12  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/pr67755
+	* tree-ssa-threadupdate.c (struct ssa_local_info_t): Add new field
+	"need_profile_correction".
+	(thread_block_1): Initialize new field to false by default.  If we
+	have multiple thread paths through a common joiner to different
+	final targets, then set new field to true.
+	(compute_path_counts): Only do count adjustment when it's really
+	needed.
+
+2016-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69135
+	* config/arm/vfp.md (l<vrint_pattern><su_optab><mode>si2): Set "conds"
+	attribute to unconditional.  Remove %? from output template.
+
+2016-01-18  Alexander Fomin  <alexander.fomin@intel.com>
+
+	Backport from mainline
+	2015-10-09  Alexander Fomin  <alexander.fomin@intel.com>
+
+	PR target/67895
+	* config/i386/sse.md (define_insn "sse_cvtsi2ss<round_name>"):
+	Adjust embedded rounding/SAE specifier position.
+	(define_insn "sse_cvtsi2ssq<round_name>"): Likewise.
+	(define_insn "cvtusi2<ssescalarmodesuffix>32<round_name>"): Likewise.
+	(define_insn "cvtusi2<ssescalarmodesuffix>64<round_name>"): Likewise.
+	(define_insn "sse2_cvtsi2sdq<round_name>"): Likewise.
+	(define_insn "avx512dq_rangep<mode><mask_name><round_saeonly_name>"):
+	Likewise.
+	(define_insn "avx512dq_ranges<mode><round_saeonly_name>"): Likewise.
+
+2016-01-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2016-01-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69140
+	* config/i386/i386.c (ix86_frame_pointer_required): Enable
+	frame pointer for TARGET_64BIT_MS_ABI when stack is misaligned.
+
+2016-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2016-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/68799
+	* gimple-ssa-strength-reduction.c (create_phi_basis): Directly
+	look up phi candidates in the statement-candidate map.
+	(phi_add_costs): Likewise.
+	(record_phi_increments): Likewise.
+	(phi_incr_cost): Likewise.
+	(ncd_with_phi): Likewise.
+	(all_phi_incrs_profitable): Likewise.
+
+2016-01-17  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2016-01-12  Kugan Vivekanandarajah  <kuganv@linaro.org>
+		    Jim Wilson  <jim.wilson@linaro.org>
+
+	PR target/69194
+	* config/arm/arm-builtins.c (arm_expand_neon_args): Call
+	copy_to_mode_reg instead of force_reg.
+
+2016-01-15  Alexander Fomin  <alexander.fomin@intel.com>
+
+	Backport from mainline
+	2016-01-13  Alexander Fomin  <alexander.fomin@intel.com>
+
+	PR target/69228
+	* config/i386/sse.md (define_expand "avx512pf_gatherpf<mode>sf"):
+	Change first operand predicate from register_or_constm1_operand
+	to register_operand.
+	(define_expand "avx512pf_gatherpf<mode>df"): Likewise.
+	(define_expand "avx512pf_scatterpf<mode>sf"): Likewise.
+	(define_expand "avx512pf_scatterpf<mode>df"): Likewise.
+	(define_insn "*avx512pf_gatherpf<mode>sf"): Remove.
+	(define_insn "*avx512pf_gatherpf<mode>df"): Likewise.
+	(define_insn "*avx512pf_scatterpf<mode>sf"): Likewise.
+	(define_insn "*avx512pf_scatterpf<mode>df"): Likewise.
+	* config/i386/i386.c (ix86_expand_builtin): Remove first operand
+	comparison with constm1_rtx from vec_prefetch_gen part.
+
+2016-01-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69013
+	* tree-ssa-uninit.c (prune_uninit_phi_opnds_in_unrealizable_paths):
+	Exchange assert for a test.
+
+2016-01-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69198
+	* config/i386/i386.c (ix86_expand_special_args_builtin): Ensure
+	aligned_mem is properly set for AVX512-VL floating point masked
+	stores.
+
+	2015-12-04  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* config/i386/sse.md (<avx512>_store<mode>_mask): Fix
+	operand checked for alignment.
+
+2016-01-12  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline r222186.
+	2015-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/65689
+	* genpreds.c (struct constraint_data): Add maybe_allows_reg and
+	maybe_allows_mem bitfields.
+	(maybe_allows_none_start, maybe_allows_none_end,
+	maybe_allows_reg_start, maybe_allows_reg_end, maybe_allows_mem_start,
+	maybe_allows_mem_end): New variables.
+	(compute_maybe_allows): New function.
+	(add_constraint): Use it to initialize maybe_allows_reg and
+	maybe_allows_mem fields.
+	(choose_enum_order): Sort the non-is_register/is_const_int/is_memory/
+	is_address constraints such that those that allow neither mem nor
+	reg come first, then those that only allow reg but not mem, then
+	those that only allow mem but not reg, then the rest.
+	(write_allows_reg_mem_function): New function.
+	(write_tm_preds_h): Call it.
+	* stmt.c (parse_output_constraint, parse_input_constraint): Use
+	the generated insn_extra_constraint_allows_reg_mem function
+	instead of always setting *allows_reg = true; *allows_mem = true;
+	for unknown extra constraints.
+
+2016-01-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_emit_move_sequence): Handle floating point
+	reloads for other unsupported memory operands.
+
+2016-01-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/66616
+	* cgraphclones.c (duplicate_thunk_for_node): Copy can_change_signature
+	flag.
+
+2016-01-11  Yury Gribov  <y.gribov@samsung.com>
+
+	Backport from mainline
+	2016-01-11  Yury Gribov  <y.gribov@samsung.com>
+
+	PR 67425
+	* common.opt (frandom-seed): Fix parameter name.
+	* doc/invoke.texi (frandom-seed): Ditto and describe parameter.
+
+2016-01-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-12-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/68851
+	* cgraph.c (collect_callers_of_node_1): Do not collect thunks.
+	* cgraph.h (cgraph_node): Change comment of collect_callers.
+
+2016-01-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68648
+	* config/arm/arm.md (*andsi_iorsi3_notsi): Try to simplify
+	the complement of operands[3] during splitting.
+
+2015-12-31  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	* config/i386/sse.md (define_insn "vec_dup<mode>"): Separate EVEX
+	alternative.
+
+2015-12-30  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	* config/i386/sse.md (define_insn "vec_extract_hi_<mode>_maskm"):
+	Remove "prefix_extra".
+	(define_insn "vec_extract_hi_<mode>_mask"): New.
+	(define_insn "vec_extract_hi_<mode>"): Remove masking.
+
+2015-12-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h: Delete FREEBSD_DYNAMIC_LINKER32/64
+	defines. Use FBSD_DYNAMIC_LINKER instead.
+	Rename and simplify LINK_OS_FREEBSD_SPEC_DEF32/64 to
+	LINK_OS_FREEBSD_SPEC_DEF.
+
+2015-12-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	PR target/68872
+	* config/rs6000/rs6000.h (ASM_CPU_SPEC): For -mcpu=powerpc64le,
+	pass %(asm_cpu_power8).
+
+2015-12-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/68910
+	* emit-rtl.c (set_unique_reg_note) <REG_EQUAL>: Add bypass for USEs.
+	* config/sparc/sparc.md (anddi3): Enable only in 64-bit mode.
+	(iordi3): Likewise.
+	(xordi3): Likewise.
+	(one_cmpldi2): Likewise.
+	(*anddi3_sp32): Delete.
+	(*and_not_di_sp32): Likewise.
+	(*iordi3_sp32): Likewise.
+	(*or_not_di_sp32): Likewise.
+	(*xordi3_sp32): Likewise.
+	(*xor_not_di_sp32): Likewise.
+	(32-bit DImode logical operations splitter): Likewise.
+	(*one_cmpldi2_sp32): Likewise.
+
+2015-13-18  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68729
+	* config/pa/pa.c (pa_emit_move_sequence): Reorganize handling of
+	floating-point reloads. Only reload operands that are not valid
+	floating-point memory operands.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/predicates.md (const_mask_operand): New predicate.
+	* config/s390/s390-builtins.def: Set a smaller bitmask for a
+	few builtins.
+	* config/s390/vector.md: Change predicate from immediate_operand
+	to either const_int_operand or const_mask_operand.  Add special
+	insn conditions on patterns which have to exclude certain values.
+	* config/s390/vx-builtins.md: Likewise.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vector.md ("*vec_set<mode>"): Change shift count
+	mode from DI to SI.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-builtin-types.def: New builtin types added.
+	* config/s390/s390-builtins.def: Add s390_vec_splat_* definitions.
+	* config/s390/s390.c (s390_expand_builtin): Always truncate
+	constants to the mode in the pattern.
+	* config/s390/vecintrin.h: Let the vec_splat_* macros point to the
+	respective builtin __builtin_s390_vec_splat_*.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Sort builtin types.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-c.c (s390_get_vstring_flags): Invert the
+	condition for the RT flag.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/constraints.md: Use private backport of
+	const_vec_duplicate_p s390_const_vec_duplicate_p.
+	* config/s390/s390-protos.h: Add prototype for
+	s390_const_vec_duplicate_p.
+	* config/s390/s390.c (s390_const_vec_duplicate_p): New function.
+	(s390_contiguous_bitmask_vector_p): Use s390_const_vec_duplicate_p.
+	(print_operand): Likewise.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/constraints.md ("jKK"): New constraint.
+	* config/s390/s390.c (tm-constrs.h): Include for
+	satisfies_constraint_*.
+	(s390_legitimate_constant_p): Allow jKK constants.  Use
+	satisfies_constraint_* also for the others.
+	(legitimate_reload_vector_constant_p): Likewise.
+	(print_operand): Allow h output modifier on vectors.
+	* config/s390/vector.md ("mov<mode>"): Add vrepi.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/vector.md ("*vec_splats<mode>"): Fix constraint
+	letter I->K.
+
+2015-12-18  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-12-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68835
+	* tree.c (get_int_cst_ext_nunits): Return
+	cst.get_precision () / HOST_BITS_PER_WIDE_INT + 1
+	for all unsigned wi::neg_p (cst) constants.
+	(build_new_int_cst): If cst.get_precision is not a multiple
+	of HOST_BITS_PER_WIDE_INT, zero extend -1 to the precision
+	% HOST_BITS_PER_WIDE_INT.
+
+2015-12-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68779
+	* config/pa/pa.md (atomic_loaddi): Honor -mdisable-fpregs.
+	(atomic_loaddi_1): Likewise.
+	(atomic_storedi): Likewise.
+	(atomic_storedi_1): Likewise.
+	(atomic_loaddf): Likewise.
+	(atomic_loaddf_1): Likewise.
+	(atomic_storedf): Likewise.
+	(atomic_storedf_1): Likewise.
+	Move all atomic patterns to end of file.
+
+2015-12-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-12-02  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/68184
+	* cgraphunit.c (cgraph_node::analyze): Set can_throw_external.
+
+2015-12-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-12-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/68636
+	* builtins.c (get_pointer_alignment_1): Take care of byte to
+	bit alignment computation overflow.
+
+	2015-11-30  Richard Biener  <rguenther@suse.de>
+
+	PR c/68162
+	* dwarf2out.c (gen_type_die_with_usage): Keep variant types
+	of arrays.
+
+2015-12-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/66616
+	* ipa-cp.c (propagate_constants_accross_call): Move thuk check...
+	(call_passes_through_thunk_p): ...here.
+	(find_more_scalar_values_for_callers_subset): Perform thunk checks
+	like propagate_constants_accross_call does.
+
+2015-12-14  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline.
+	2015-12-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	PR rtl-optimization/67609
+	* config/aarch64/aarch64-protos.h
+	(aarch64_cannot_change_mode_class): Bring back.
+	* config/aarch64/aarch64.c
+	(aarch64_cannot_change_mode_class): Likewise.
+	* config/aarch64/aarch64.h (CANNOT_CHANGE_MODE_CLASS): Likewise.
+	* config/aarch64/aarch64.md (aarch64_movdi_<mode>low): Use
+	zero_extract rather than truncate.
+	(aarch64_movdi_<mode>high): Likewise.
+
+2015-12-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-12-11  Martin Liska  <mliska@suse.cz>
+		    Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/67484
+	* config/i386/i386.c (ix86_valid_target_attribute_tree):
+	Use ggc_strdup to copy option_strings to opts->x_ix86_arch_string and
+	opts->x_ix86_tune_string.
+
+2015-12-13  Alexandre Oliva <aoliva@redhat.com>
+
+	PR debug/67355
+	* var-tracking.c (reverse_op): Don't add dummy zero to reverse
+	ops that simplify back to the original value.
+	* alias.c (refs_newer_value_p): Cut off recursion for
+	expressions containing the original value.
+
+2015-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68376
+	PR rtl-optimization/68670
+	* ifcvt.c (noce_try_abs): For one_cmpl allow < 0, >= 0
+	or > -1 conditions regardless of negate, and disallow
+	all other conditions.
+
+2015-12-10  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-09  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h: Remove the redefinition of WCHAR_TYPE.
+
+2015-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-12-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/68701
+	* config/i386/i386.c (ix86_option_override_internal): Enable
+	-maccumulate-outgoing-args when %ebp is fixed due to stack
+	realignment requirements.
+
+2015-12-10  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	Backport from mainline r231224.
+	2015-12-03  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* cfgexpand.c (expand_gimple_stmt_1): Return statement with
+	DECL as return value is allowed to have NULL bounds.
+
+2015-12-10  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2015-04-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/65948
+	* ipa-devirt.c (odr_types_equivalent_p): NULLPTR_TYPE is equivalent
+	to itself.
+
+2015-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68729
+	* config/pa/pa.c (pa_emit_move_sequence): Don't check that mode is
+	consistent with modes of the input and output operands when doing
+	reloads to and from floating point registers.  Do reload for all
+	address forms.
+
+2015-12-09  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2015-12-09  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/68790
+	* ipa-icf.c (sem_function::param_used_p): Return true
+	if ipa_node_params_sum equals to NULL.
+
+2015-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2015-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68680
+	* calls.c (special_function_p): Return ECF_MAY_BE_ALLOCA for
+	BUILT_IN_ALLOCA{,_WITH_ALIGN}.  Don't check for __builtin_alloca
+	by name.
+
+	PR tree-optimization/68671
+	* tree-ssa-reassoc.c (maybe_optimize_range_tests): For basic
+	blocks starting with the successor of first bb we've modified
+	and ending with last_bb call reset_flow_sensitive_info_in_bb.
+
+2015-12-04  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-01  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h (ELFv2_ABI_CHECK): Add new macro.
+	(SUBSUBTARGET_OVERRIDE_OPTIONS): Use it to decide whether to set
+	rs6000_current_abi to ABI_AIX or ABI_ELFv2.
+
+2015-12-04  Richard Biener  <rguenther@suse.de>
+
+	* BASE-VER: Set to 5.3.1.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
@@ -19,7 +1235,7 @@
 	Backport from mainline
 	2015-09-30  Bernd Edlinger  <bernd.edlinger@hotmail.de>
 
-	PR rtl-optimization/67037    
+	PR rtl-optimization/67037
 	* lra-constraints.c (process_addr_reg): Use copy_rtx when necessary.
 
 2015-11-26  David Edelsohn  <dje.gcc@gmail.com>
@@ -291,12 +1507,12 @@
 	(contains_type_p): Fix out of range check, clear dynamic flag.
 
 	2015-10-23  Jan Hubicka  <hubicka@ucw.cz>
- 
+
 	PR ipa/pr67600
 	* ipa-polymorphic-call.c
 	(ipa_polymorphic_call_context::get_dynamic_type): Do not confuse
 	instance offset with offset of outer type.
- 
+
 	2015-10-12  Richard Biener  <rguenther@suse.de>
 
 	PR ipa/67783
@@ -305,7 +1521,7 @@
 	quadratic behavior.
 
 	2015-10-11  Jan Hubicka  <hubicka@ucw.cz>
- 
+
 	PR ipa/67056
 	* ipa-polymorphic-call.c (possible_placement_new): If cur_offset
 	is negative we don't know the type.
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index afb984d..4b99f3c 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20151204
+20160312
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index c4de235..d821587 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,57 @@
+2016-02-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* exp_ch4.adb (Expand_N_Indexed_Component): Active synchronization if
+	the prefix denotes an entity which Has_Atomic_Components.
+
+2016-02-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_enum_underlying_base_type): New function.
+	(LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE): Define to above.
+
+2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/69219
+	* gcc-interface/trans.c (check_inlining_for_nested_subprog): Consider
+	the parent function instead of the current function in order to issue
+	the warning or the error.  Add guard for ignored functions.
+
+2015-12-06  Piotr Trojanek  <piotr.trojanek@gmail.com>
+
+	PR ada/60164
+	* doc/gnat_ugn/gnat_and_program_execution.rst (gnatmem): Fix typo.
+
+2015-12-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/56274
+	* s-osinte-kfreebsd-gnu.ads (pthread_rwlock_t): New subtype.
+	(pthread_rwlockattr_t): Likewise.
+
+2015-12-06  Ludovic Brenta  <ludovic@ludovic-brenta.org>
+
+	PR ada/49944
+	* s-osinte-freebsd.ads: Minor reformatting.
+	(Stack_Base_Available): Correct comments.
+	* s-osinte-kfreebsd-gnu.ads (Time_Slice_Supported, nanosleep,
+	clock_id_t, clock_gettime, Stack_Base_Available, Get_Page_Size,
+	mprotect, pthread_mutexattr_setprotocol,pthread_mutexattr_getprotocol
+	pthread_mutexattr_setprioceiling, pthread_mutexattr_getprioceiling,
+	pthread_attr_setscope, pthread_attr_getscope,
+	pthread_attr_setinheritsched, pthread_attr_getinheritsched,
+	Time_Slice_Supported): Copy from s-osinte-freebsd.ads.
+	* gcc-interface/Makefile.in (x86/kfreebsd): Use the POSIX version of
+	the System.Task_Primitives.Operations package.
+
+2015-12-06  Ludovic Brenta  <ludovic@ludovic-brenta.org>
+
+	PR ada/49940
+	* s-osinte-kfreebsd-gnu.ads (lwp_self): New imported function.
+
+2015-12-04  Jan Sommer <soja-lists@aries.uberspace.de>
+
+	PR ada/68169
+	* s-oscons-tmplt.c: Generate pthread constants for RTEMS
+	* s-osinte-rtems.ads: Declare pthread structs as opaque types in Ada
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst b/gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst
index 9e332d9..db05cc3 100644
--- a/gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst
+++ b/gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst
@@ -3872,7 +3872,7 @@ execution of this erroneous program:
   it to obtain accurate dynamic memory usage history at a minimal cost to the
   execution speed. Note however, that `gnatmem` is not supported on all
   platforms (currently, it is supported on AIX, HP-UX, GNU/Linux, Solaris and
-  Windows NT/2000/XP (x86).
+  Windows NT/2000/XP (x86)).
 
   The `gnatmem` command has the form
 
diff --git a/gcc/ada/exp_ch4.adb b/gcc/ada/exp_ch4.adb
index 3fcd824..c8eb549 100644
--- a/gcc/ada/exp_ch4.adb
+++ b/gcc/ada/exp_ch4.adb
@@ -6,7 +6,7 @@
 --                                                                          --
 --                                 B o d y                                  --
 --                                                                          --
---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -6193,6 +6193,9 @@ package body Exp_Ch4 is
            and then not Atomic_Synchronization_Disabled (Atp))
         or else (Is_Atomic (Typ)
                   and then not Atomic_Synchronization_Disabled (Typ))
+        or else (Is_Entity_Name (P)
+                  and then Has_Atomic_Components (Entity (P))
+                  and then not Atomic_Synchronization_Disabled (Entity (P)))
       then
          Activate_Atomic_Synchronization (N);
       end if;
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index 4474aae..e1ca515 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -1365,9 +1365,7 @@ ifeq ($(strip $(filter-out %86 kfreebsd%,$(target_cpu) $(target_os))),)
   s-osinte.adb<s-osinte-posix.adb \
   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
   s-osprim.adb<s-osprim-posix.adb \
-  s-taprop.adb<s-taprop-linux.adb \
-  s-tasinf.ads<s-tasinf-linux.ads \
-  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
   $(ATOMICS_TARGET_PAIRS) \
@@ -1398,9 +1396,7 @@ ifeq ($(strip $(filter-out x86_64 kfreebsd%,$(target_cpu) $(target_os))),)
   s-osinte.adb<s-osinte-posix.adb \
   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
   s-osprim.adb<s-osprim-posix.adb \
-  s-taprop.adb<s-taprop-linux.adb \
-  s-tasinf.ads<s-tasinf-linux.ads \
-  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
   system.ads<system-freebsd-x86_64.ads
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
index edaab97..d3c039a 100644
--- a/gcc/ada/gcc-interface/misc.c
+++ b/gcc/ada/gcc-interface/misc.c
@@ -568,6 +568,15 @@ gnat_descriptive_type (const_tree type)
     return NULL_TREE;
 }
 
+/* Return the underlying base type of an enumeration type.  */
+
+static tree
+gnat_enum_underlying_base_type (const_tree)
+{
+  /* Enumeration types are base types in Ada.  */
+  return void_type_node;
+}
+
 /* Return true if types T1 and T2 are identical for type hashing purposes.
    Called only after doing all language independent checks.  At present,
    this function is only called when both types are FUNCTION_TYPE.  */
@@ -1001,6 +1010,8 @@ gnat_init_ts (void)
 #undef  LANG_HOOKS_DESCRIPTIVE_TYPE
 #define LANG_HOOKS_DESCRIPTIVE_TYPE	gnat_descriptive_type
 #undef  LANG_HOOKS_ATTRIBUTE_TABLE
+#undef  LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE
+#define LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE gnat_enum_underlying_base_type
 #define LANG_HOOKS_ATTRIBUTE_TABLE	gnat_internal_attribute_table
 #undef  LANG_HOOKS_BUILTIN_FUNCTION
 #define LANG_HOOKS_BUILTIN_FUNCTION	gnat_builtin_function
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index 1e4d373..d142989 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -1502,7 +1502,7 @@ Pragma_to_gnu (Node_Id gnat_node)
 }
 
 
-/* Check the inlining status of nested function FNDECL in the current context.
+/* Check the inline status of nested function FNDECL wrt its parent function.
 
    If a non-inline nested function is referenced from an inline external
    function, we cannot honor both requests at the same time without cloning
@@ -1510,24 +1510,27 @@ Pragma_to_gnu (Node_Id gnat_node)
    We could inline it as well but it's probably better to err on the side
    of too little inlining.
 
-   This must be invoked only on nested functions present in the source code
+   This must be done only on nested functions present in the source code
    and not on nested functions generated by the compiler, e.g. finalizers,
-   because they are not marked inline and we don't want them to block the
-   inlining of the parent function.  */
+   because they may be not marked inline and we don't want them to block
+   the inlining of the parent function.  */
 
 static void
 check_inlining_for_nested_subprog (tree fndecl)
 {
-  if (!DECL_DECLARED_INLINE_P (fndecl)
-      && current_function_decl
-      && DECL_EXTERNAL (current_function_decl)
-      && DECL_DECLARED_INLINE_P (current_function_decl))
+  if (DECL_IGNORED_P (current_function_decl) || DECL_IGNORED_P (fndecl))
+    return;
+
+  if (DECL_DECLARED_INLINE_P (fndecl))
+    return;
+
+  tree parent_decl = decl_function_context (fndecl);
+  if (DECL_EXTERNAL (parent_decl) && DECL_DECLARED_INLINE_P (parent_decl))
     {
       const location_t loc1 = DECL_SOURCE_LOCATION (fndecl);
-      const location_t loc2 = DECL_SOURCE_LOCATION (current_function_decl);
+      const location_t loc2 = DECL_SOURCE_LOCATION (parent_decl);
 
-      if (lookup_attribute ("always_inline",
-			    DECL_ATTRIBUTES (current_function_decl)))
+      if (lookup_attribute ("always_inline", DECL_ATTRIBUTES (parent_decl)))
 	{
 	  error_at (loc1, "subprogram %q+F not marked Inline_Always", fndecl);
 	  error_at (loc2, "parent subprogram cannot be inlined");
@@ -1539,8 +1542,8 @@ check_inlining_for_nested_subprog (tree fndecl)
 	  warning_at (loc2, OPT_Winline, "parent subprogram cannot be inlined");
 	}
 
-      DECL_DECLARED_INLINE_P (current_function_decl) = 0;
-      DECL_UNINLINABLE (current_function_decl) = 1;
+      DECL_DECLARED_INLINE_P (parent_decl) = 0;
+      DECL_UNINLINABLE (parent_decl) = 1;
     }
 }
 
diff --git a/gcc/ada/s-oscons-tmplt.c b/gcc/ada/s-oscons-tmplt.c
index 053d4a7..1ddc413 100644
--- a/gcc/ada/s-oscons-tmplt.c
+++ b/gcc/ada/s-oscons-tmplt.c
@@ -157,7 +157,7 @@ pragma Style_Checks ("M32766");
 # include <_types.h>
 #endif
 
-#ifdef __linux__
+#if defined (__linux__) || defined (__rtems__)
 # include <pthread.h>
 # include <signal.h>
 #endif
@@ -1456,7 +1456,8 @@ CND(CLOCK_THREAD_CPUTIME_ID, "Thread CPU clock")
 CNS(CLOCK_RT_Ada, "")
 #endif
 
-#if defined (__APPLE__) || defined (__linux__) || defined (DUMMY)
+#if defined (__APPLE__) || defined (__linux__) || defined (__rtems__) || \
+  defined (DUMMY)
 /*
 
    --  Sizes of pthread data types
@@ -1499,7 +1500,7 @@ CND(PTHREAD_RWLOCKATTR_SIZE, "pthread_rwlockattr_t")
 CND(PTHREAD_RWLOCK_SIZE,     "pthread_rwlock_t")
 CND(PTHREAD_ONCE_SIZE,       "pthread_once_t")
 
-#endif /* __APPLE__ || __linux__ */
+#endif /* __APPLE__ || __linux__ || __rtems__*/
 
 /*
 
diff --git a/gcc/ada/s-osinte-freebsd.ads b/gcc/ada/s-osinte-freebsd.ads
index 625d2dc..343301b 100644
--- a/gcc/ada/s-osinte-freebsd.ads
+++ b/gcc/ada/s-osinte-freebsd.ads
@@ -31,7 +31,7 @@
 --                                                                          --
 ------------------------------------------------------------------------------
 
---  This is the FreeBSD PTHREADS version of this package
+--  This is the FreeBSD (POSIX Threads) version of this package
 
 --  This package encapsulates all direct interfaces to OS services
 --  that are needed by the tasking run-time (libgnarl).
@@ -197,7 +197,7 @@ package System.OS_Interface is
 
    type timespec is private;
 
-   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   function nanosleep (rqtp, rmtp : access timespec) return int;
    pragma Import (C, nanosleep, "nanosleep");
 
    type clockid_t is new int;
@@ -322,10 +322,7 @@ package System.OS_Interface is
    --  No alternate signal stack is used on this platform
 
    Stack_Base_Available : constant Boolean := False;
-   --  Indicates whether the stack base is available on this target. This
-   --  allows us to share s-osinte.adb between all the FSU run time. Note that
-   --  this value can only be true if pthread_t has a complete definition that
-   --  corresponds exactly to the C header files.
+   --  Indicates whether the stack base is available on this target
 
    function Get_Stack_Base (thread : pthread_t) return Address;
    pragma Inline (Get_Stack_Base);
diff --git a/gcc/ada/s-osinte-kfreebsd-gnu.ads b/gcc/ada/s-osinte-kfreebsd-gnu.ads
index be46c2e..3f6ef9b 100644
--- a/gcc/ada/s-osinte-kfreebsd-gnu.ads
+++ b/gcc/ada/s-osinte-kfreebsd-gnu.ads
@@ -7,7 +7,7 @@
 --                                  S p e c                                 --
 --                                                                          --
 --               Copyright (C) 1991-1994, Florida State University          --
---            Copyright (C) 1995-2014, Free Software Foundation, Inc.       --
+--            Copyright (C) 1995-2015, Free Software Foundation, Inc.       --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -30,7 +30,7 @@
 --                                                                          --
 ------------------------------------------------------------------------------
 
---  This is the GNU/kFreeBSD (GNU/LinuxThreads) version of this package
+--  This is the GNU/kFreeBSD (POSIX Threads) version of this package
 
 --  This package encapsulates all direct interfaces to OS services
 --  that are needed by children of System.
@@ -198,8 +198,24 @@ package System.OS_Interface is
    -- Time --
    ----------
 
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
    type timespec is private;
 
+   function nanosleep (rqtp, rmtp : access timespec) return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is private;
+
+   CLOCK_REALTIME : constant clockid_t;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
    function To_Duration (TS : timespec) return Duration;
    pragma Inline (To_Duration);
 
@@ -236,6 +252,16 @@ package System.OS_Interface is
    function getpid return pid_t;
    pragma Import (C, getpid, "getpid");
 
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
    -------------
    -- Threads --
    -------------
@@ -261,6 +287,18 @@ package System.OS_Interface is
    type pthread_key_t       is private;
 
    PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on kfreebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
 
    -----------
    -- Stack --
@@ -284,9 +322,29 @@ package System.OS_Interface is
    Alternate_Stack_Size : constant := 0;
    --  No alternate signal stack is used on this platform
 
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target
+
    function Get_Stack_Base (thread : pthread_t) return Address;
    pragma Inline (Get_Stack_Base);
-   --  This is a dummy procedure to share some GNULLI files
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
 
    ---------------------------------------
    -- Nonstandard Thread Initialization --
@@ -375,6 +433,36 @@ package System.OS_Interface is
    -- POSIX.1c  Section 13 --
    --------------------------
 
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
    type struct_sched_param is record
       sched_priority : int;  --  scheduling priority
    end record;
@@ -386,6 +474,28 @@ package System.OS_Interface is
       param  : access struct_sched_param) return int;
    pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
 
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
    function pthread_attr_setschedpolicy
      (attr   : access pthread_attr_t;
       policy : int) return int;
@@ -496,6 +606,9 @@ private
    end record;
    pragma Convention (C, timespec);
 
+   type clockid_t is new int;
+   CLOCK_REALTIME : constant clockid_t := 0;
+
    type pthread_attr_t is record
       detachstate   : int;
       schedpolicy   : int;
diff --git a/gcc/ada/s-osinte-rtems.ads b/gcc/ada/s-osinte-rtems.ads
index 8b9ae12..5a143cc 100644
--- a/gcc/ada/s-osinte-rtems.ads
+++ b/gcc/ada/s-osinte-rtems.ads
@@ -51,6 +51,8 @@
 --  It is designed to be a bottom-level (leaf) package.
 
 with Interfaces.C;
+with System.OS_Constants;
+
 package System.OS_Interface is
    pragma Preelaborate;
 
@@ -60,6 +62,7 @@ package System.OS_Interface is
    subtype rtems_id       is Interfaces.C.unsigned;
 
    subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
    subtype short          is Interfaces.C.short;
    subtype long           is Interfaces.C.long;
    subtype unsigned       is Interfaces.C.unsigned;
@@ -68,7 +71,6 @@ package System.OS_Interface is
    subtype unsigned_char  is Interfaces.C.unsigned_char;
    subtype plain_char     is Interfaces.C.plain_char;
    subtype size_t         is Interfaces.C.size_t;
-
    -----------
    -- Errno --
    -----------
@@ -76,11 +78,11 @@ package System.OS_Interface is
    function errno return int;
    pragma Import (C, errno, "__get_errno");
 
-   EAGAIN    : constant := 11;
-   EINTR     : constant := 4;
-   EINVAL    : constant := 22;
-   ENOMEM    : constant := 12;
-   ETIMEDOUT : constant := 116;
+   EAGAIN    : constant := System.OS_Constants.EAGAIN;
+   EINTR     : constant := System.OS_Constants.EINTR;
+   EINVAL    : constant := System.OS_Constants.EINVAL;
+   ENOMEM    : constant := System.OS_Constants.ENOMEM;
+   ETIMEDOUT : constant := System.OS_Constants.ETIMEDOUT;
 
    -------------
    -- Signals --
@@ -448,6 +450,7 @@ package System.OS_Interface is
       ss_low_priority     : int;
       ss_replenish_period : timespec;
       ss_initial_budget   : timespec;
+      sched_ss_max_repl   : int;
    end record;
    pragma Convention (C, struct_sched_param);
 
@@ -621,43 +624,34 @@ private
    end record;
    pragma Convention (C, timespec);
 
-   CLOCK_REALTIME :  constant clockid_t := 1;
-   CLOCK_MONOTONIC : constant clockid_t := 4;
+   CLOCK_REALTIME :  constant clockid_t := System.OS_Constants.CLOCK_REALTIME;
+   CLOCK_MONOTONIC : constant clockid_t := System.OS_Constants.CLOCK_MONOTONIC;
+
+   subtype char_array is Interfaces.C.char_array;
 
    type pthread_attr_t is record
-      is_initialized  : int;
-      stackaddr       : System.Address;
-      stacksize       : int;
-      contentionscope : int;
-      inheritsched    : int;
-      schedpolicy     : int;
-      schedparam      : struct_sched_param;
-      cputime_clocked_allowed : int;
-      detatchstate    : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_ATTR_SIZE);
    end record;
    pragma Convention (C, pthread_attr_t);
+   for pthread_attr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_condattr_t is record
-      flags           : int;
-      process_shared  : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_CONDATTR_SIZE);
    end record;
    pragma Convention (C, pthread_condattr_t);
+   for pthread_condattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_mutexattr_t is record
-      is_initialized  : int;
-      process_shared  : int;
-      prio_ceiling    : int;
-      protocol        : int;
-      mutex_type      : int;
-      recursive       : int;
-   end record;
+      Data : char_array (1 .. OS_Constants.PTHREAD_MUTEXATTR_SIZE);
+   end  record;
    pragma Convention (C, pthread_mutexattr_t);
+   for pthread_mutexattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_rwlockattr_t is record
-      is_initialized  : int;
-      process_shared  : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_RWLOCKATTR_SIZE);
    end record;
    pragma Convention (C, pthread_rwlockattr_t);
+   for pthread_rwlockattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_t is new rtems_id;
 
diff --git a/gcc/alias.c b/gcc/alias.c
index d85830e..5d2d333 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -1880,7 +1880,7 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,
 }
 
 /* Return TRUE if EXPR refers to a VALUE whose uid is greater than
-   that of V.  */
+   (or equal to) that of V.  */
 
 static bool
 refs_newer_value_p (const_rtx expr, rtx v)
@@ -1888,14 +1888,14 @@ refs_newer_value_p (const_rtx expr, rtx v)
   int minuid = CSELIB_VAL_PTR (v)->uid;
   subrtx_iterator::array_type array;
   FOR_EACH_SUBRTX (iter, array, expr, NONCONST)
-    if (GET_CODE (*iter) == VALUE && CSELIB_VAL_PTR (*iter)->uid > minuid)
+    if (GET_CODE (*iter) == VALUE && CSELIB_VAL_PTR (*iter)->uid >= minuid)
       return true;
   return false;
 }
 
 /* Convert the address X into something we can use.  This is done by returning
-   it unchanged unless it is a value; in the latter case we call cselib to get
-   a more useful rtx.  */
+   it unchanged unless it is a VALUE or VALUE +/- constant; for VALUE
+   we call cselib to get a more useful rtx.  */
 
 rtx
 get_addr (rtx x)
@@ -1904,7 +1904,23 @@ get_addr (rtx x)
   struct elt_loc_list *l;
 
   if (GET_CODE (x) != VALUE)
-    return x;
+    {
+      if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)
+	  && GET_CODE (XEXP (x, 0)) == VALUE
+	  && CONST_SCALAR_INT_P (XEXP (x, 1)))
+	{
+	  rtx op0 = get_addr (XEXP (x, 0));
+	  if (op0 != XEXP (x, 0))
+	    {
+	      if (GET_CODE (x) == PLUS
+		  && GET_CODE (XEXP (x, 1)) == CONST_INT)
+		return plus_constant (GET_MODE (x), op0, INTVAL (XEXP (x, 1)));
+	      return simplify_gen_binary (GET_CODE (x), GET_MODE (x),
+					  op0, XEXP (x, 1));
+	    }
+	}
+      return x;
+    }
   v = CSELIB_VAL_PTR (x);
   if (v)
     {
diff --git a/gcc/bb-reorder.c b/gcc/bb-reorder.c
index c2a3be3..7d5073b 100644
--- a/gcc/bb-reorder.c
+++ b/gcc/bb-reorder.c
@@ -187,6 +187,10 @@ typedef struct bbro_basic_block_data_def
   /* Which trace was this bb visited in?  */
   int visited;
 
+  /* Cached maximum frequency of interesting incoming edges.
+     Minus one means not yet computed.  */
+  int priority;
+
   /* Which heap is BB in (if any)?  */
   bb_heap_t *heap;
 
@@ -805,7 +809,15 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,
       while (best_edge);
       trace->last = bb;
       bbd[trace->first->index].start_of_trace = *n_traces - 1;
-      bbd[trace->last->index].end_of_trace = *n_traces - 1;
+      if (bbd[trace->last->index].end_of_trace != *n_traces - 1)
+	{
+	  bbd[trace->last->index].end_of_trace = *n_traces - 1;
+	  /* Update the cached maximum frequency for interesting predecessor
+	     edges for successors of the new trace end.  */
+	  FOR_EACH_EDGE (e, ei, trace->last->succs)
+	    if (EDGE_FREQUENCY (e) > bbd[e->dest->index].priority)
+	      bbd[e->dest->index].priority = EDGE_FREQUENCY (e);
+	}
 
       /* The trace is terminated so we have to recount the keys in heap
 	 (some block can have a lower key because now one of its predecessors
@@ -875,6 +887,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)
 	  bbd[i].end_of_trace = -1;
 	  bbd[i].in_trace = -1;
 	  bbd[i].visited = 0;
+	  bbd[i].priority = -1;
 	  bbd[i].heap = NULL;
 	  bbd[i].node = NULL;
 	}
@@ -905,7 +918,6 @@ bb_to_key (basic_block bb)
 {
   edge e;
   edge_iterator ei;
-  int priority = 0;
 
   /* Use index as key to align with its original order.  */
   if (optimize_function_for_size_p (cfun))
@@ -919,17 +931,23 @@ bb_to_key (basic_block bb)
 
   /* Prefer blocks whose predecessor is an end of some trace
      or whose predecessor edge is EDGE_DFS_BACK.  */
-  FOR_EACH_EDGE (e, ei, bb->preds)
+  int priority = bbd[bb->index].priority;
+  if (priority == -1)
     {
-      if ((e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)
-	   && bbd[e->src->index].end_of_trace >= 0)
-	  || (e->flags & EDGE_DFS_BACK))
+      priority = 0;
+      FOR_EACH_EDGE (e, ei, bb->preds)
 	{
-	  int edge_freq = EDGE_FREQUENCY (e);
+	  if ((e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)
+	       && bbd[e->src->index].end_of_trace >= 0)
+	      || (e->flags & EDGE_DFS_BACK))
+	    {
+	      int edge_freq = EDGE_FREQUENCY (e);
 
-	  if (edge_freq > priority)
-	    priority = edge_freq;
+	      if (edge_freq > priority)
+		priority = edge_freq;
+	    }
 	}
+      bbd[bb->index].priority = priority;
     }
 
   if (priority)
@@ -2283,6 +2301,7 @@ reorder_basic_blocks (void)
       bbd[i].end_of_trace = -1;
       bbd[i].in_trace = -1;
       bbd[i].visited = 0;
+      bbd[i].priority = -1;
       bbd[i].heap = NULL;
       bbd[i].node = NULL;
     }
diff --git a/gcc/builtins.c b/gcc/builtins.c
index 1370015..e7fc956 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -497,6 +497,10 @@ get_pointer_alignment_1 (tree exp, unsigned int *alignp,
 	{
 	  *bitposp = ptr_misalign * BITS_PER_UNIT;
 	  *alignp = ptr_align * BITS_PER_UNIT;
+	  /* Make sure to return a sensible alignment when the multiplication
+	     by BITS_PER_UNIT overflowed.  */
+	  if (*alignp == 0)
+	    *alignp = 1u << (HOST_BITS_PER_INT - 1);
 	  /* We cannot really tell whether this result is an approximation.  */
 	  return true;
 	}
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 2b39509..8c6a7a7 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,27 @@
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/57580
+	* c-ppoutput.c (print): Change printed field to bool.
+	Move src_file last for smaller padding.
+	(init_pp_output): Set print.printed to false instead of 0.
+	(scan_translation_unit): Fix up formatting.  Set print.printed
+	to true after printing something other than newline.
+	(scan_translation_unit_trad): Set print.printed to true instead of 1.
+	(maybe_print_line_1): Set print.printed to false instead of 0.
+	(print_line_1): Likewise.
+	(do_line_change): Set print.printed to true instead of 1.
+	(cb_define, dump_queued_macros, cb_include, cb_def_pragma,
+	dump_macro): Set print.printed to false after printing newline.
+
+2015-12-16  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/68162
+	* c-common.h (c_build_qualified_type): Add extra default
+	arguments.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index cabf452..fdb227f 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -850,7 +850,7 @@ extern tree pointer_int_sum (location_t, enum tree_code, tree, tree,
 			     bool = true);
 
 /* Add qualifiers to a type, in the fashion for C.  */
-extern tree c_build_qualified_type (tree, int);
+extern tree c_build_qualified_type (tree, int, tree = NULL_TREE, size_t = 0);
 
 /* Build tree nodes and builtin functions common to both C and C++ language
    frontends.  */
diff --git a/gcc/c-family/c-ppoutput.c b/gcc/c-family/c-ppoutput.c
index 9b9cba0..f8a8da1 100644
--- a/gcc/c-family/c-ppoutput.c
+++ b/gcc/c-family/c-ppoutput.c
@@ -43,11 +43,11 @@ static struct
   const cpp_token *prev;	/* Previous token.  */
   const cpp_token *source;	/* Source token for spacing.  */
   int src_line;			/* Line number currently being written.  */
-  unsigned char printed;	/* Nonzero if something output at line.  */
+  bool printed;			/* True if something output at line.  */
   bool first_time;		/* pp_file_change hasn't been called yet.  */
-  const char *src_file;		/* Current source file.  */
   bool prev_was_system_token;	/* True if the previous token was a
 				   system token.*/
+  const char *src_file;		/* Current source file.  */
 } print;
 
 /* Defined and undefined macros being queued for output with -dU at
@@ -165,7 +165,7 @@ init_pp_output (FILE *out_stream)
 
   /* Initialize the print structure.  */
   print.src_line = 1;
-  print.printed = 0;
+  print.printed = false;
   print.prev = 0;
   print.outf = out_stream;
   print.first_time = 1;
@@ -218,12 +218,16 @@ scan_translation_unit (cpp_reader *pfile)
 	    {
 	      line_marker_emitted = do_line_change (pfile, token, loc, false);
 	      putc (' ', print.outf);
+	      print.printed = true;
 	    }
 	  else if (print.source->flags & PREV_WHITE
 		   || (print.prev
 		       && cpp_avoid_paste (pfile, print.prev, token))
 		   || (print.prev == NULL && token->type == CPP_HASH))
-	    putc (' ', print.outf);
+	    {
+	      putc (' ', print.outf);
+	      print.printed = true;
+	    }
 	}
       else if (token->flags & PREV_WHITE)
 	{
@@ -234,6 +238,7 @@ scan_translation_unit (cpp_reader *pfile)
 	      && !in_pragma)
 	    line_marker_emitted = do_line_change (pfile, token, loc, false);
 	  putc (' ', print.outf);
+	  print.printed = true;
 	}
 
       avoid_paste = false;
@@ -251,7 +256,7 @@ scan_translation_unit (cpp_reader *pfile)
 	    fprintf (print.outf, "%s %s", space, name);
 	  else
 	    fprintf (print.outf, "%s", name);
-	  print.printed = 1;
+	  print.printed = true;
 	  in_pragma = true;
 	}
       else if (token->type == CPP_PRAGMA_EOL)
@@ -262,23 +267,23 @@ scan_translation_unit (cpp_reader *pfile)
       else
 	{
 	  if (cpp_get_options (parse_in)->debug)
-	      linemap_dump_location (line_table, token->src_loc,
-				     print.outf);
+	    linemap_dump_location (line_table, token->src_loc, print.outf);
 
 	  if (do_line_adjustments
 	      && !in_pragma
 	      && !line_marker_emitted
-	      && print.prev_was_system_token != !!in_system_header_at(loc)
+	      && print.prev_was_system_token != !!in_system_header_at (loc)
 	      && !is_location_from_builtin_token (loc))
 	    /* The system-ness of this token is different from the one
 	       of the previous token.  Let's emit a line change to
 	       mark the new system-ness before we emit the token.  */
 	    {
 	      do_line_change (pfile, token, loc, false);
-	      print.prev_was_system_token = !!in_system_header_at(loc);
+	      print.prev_was_system_token = !!in_system_header_at (loc);
 	    }
 	  cpp_output_token (token, print.outf);
 	  line_marker_emitted = false;
+	  print.printed = true;
 	}
 
       /* CPP_COMMENT tokens and raw-string literal tokens can
@@ -328,7 +333,7 @@ scan_translation_unit_trad (cpp_reader *pfile)
       size_t len = pfile->out.cur - pfile->out.base;
       maybe_print_line (pfile->out.first_line);
       fwrite (pfile->out.base, 1, len, print.outf);
-      print.printed = 1;
+      print.printed = true;
       if (!CPP_OPTION (pfile, discard_comments))
 	account_for_newlines (pfile->out.base, len);
     }
@@ -351,7 +356,7 @@ maybe_print_line_1 (source_location src_loc, FILE *stream)
     {
       putc ('\n', stream);
       print.src_line++;
-      print.printed = 0;
+      print.printed = false;
     }
 
   if (!flag_no_line_commands
@@ -397,7 +402,7 @@ print_line_1 (source_location src_loc, const char *special_flags, FILE *stream)
   /* End any previous line of text.  */
   if (print.printed)
     putc ('\n', stream);
-  print.printed = 0;
+  print.printed = false;
 
   if (!flag_no_line_commands)
     {
@@ -472,7 +477,7 @@ do_line_change (cpp_reader *pfile, const cpp_token *token,
   if (!CPP_OPTION (pfile, traditional))
     {
       int spaces = LOCATION_COLUMN (src_loc) - 2;
-      print.printed = 1;
+      print.printed = true;
 
       while (-- spaces >= 0)
 	putc (' ', print.outf);
@@ -515,6 +520,7 @@ cb_define (cpp_reader *pfile, source_location line, cpp_hashnode *node)
     fputs ((const char *) NODE_NAME (node), print.outf);
 
   putc ('\n', print.outf);
+  print.printed = false;
   linemap_resolve_location (line_table, line,
 			    LRK_MACRO_DEFINITION_LOCATION,
 			    &map);
@@ -566,7 +572,7 @@ dump_queued_macros (cpp_reader *pfile ATTRIBUTE_UNUSED)
     {
       putc ('\n', print.outf);
       print.src_line++;
-      print.printed = 0;
+      print.printed = false;
     }
 
   for (q = define_queue; q;)
@@ -575,6 +581,7 @@ dump_queued_macros (cpp_reader *pfile ATTRIBUTE_UNUSED)
       fputs ("#define ", print.outf);
       fputs (q->macro, print.outf);
       putc ('\n', print.outf);
+      print.printed = false;
       print.src_line++;
       oq = q;
       q = q->next;
@@ -618,6 +625,7 @@ cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,
     }
 
   putc ('\n', print.outf);
+  print.printed = false;
   print.src_line++;
 }
 
@@ -683,6 +691,7 @@ cb_def_pragma (cpp_reader *pfile, source_location line)
   maybe_print_line (line);
   fputs ("#pragma ", print.outf);
   cpp_output_line (pfile, print.outf);
+  print.printed = false;
   print.src_line++;
 }
 
@@ -696,6 +705,7 @@ dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)
       fputs ((const char *) cpp_macro_definition (pfile, node),
 	     print.outf);
       putc ('\n', print.outf);
+      print.printed = false;
       print.src_line++;
     }
 
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 336a560..be0286d 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,62 @@
+2016-02-17  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR c/69522
+	* c-parser.c (c_parser_braced_init): New arg outer_obstack.  All
+	callers changed.  If nested_p is true, use it to call
+	finish_implicit_inits.
+	* c-tree.h (finish_implicit_inits): Declare.
+	* c-typeck.c (finish_implicit_inits): New function.  Move code
+	from ...
+	(push_init_level): ... here.
+	(set_designator, process_init_element): Call finish_implicit_inits.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/69669
+	* c-decl.c (finish_enum): When honoring mode attribute,
+	make sure to use proper TYPE_MIN_VALUE and TYPE_MAX_VALUE.
+
+2016-01-28  Marek Polacek  <polacek@redhat.com>
+
+	* c-typeck.c (build_binary_op) [GE_EXPR]: Move the duplicated hunk of
+	code...
+	(build_binary_op) [EQ_EXPR]: ... here.
+
+2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68062
+	* c-typeck.c (build_binary_op) [EQ_EXPR, GE_EXPR]: Promote operand
+	to unsigned, if needed.  Add -Wsign-compare warning.
+
+2015-12-30  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/69037
+	Backport from mainline:
+
+	2015-12-07  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68668
+	* c-decl.c (grokdeclarator): If ORIG_QUAL_INDIRECT is indirect, use
+	TREE_TYPE of ORIG_QUAL_TYPE, otherwise decrement ORIG_QUAL_INDIRECT.
+
+2015-12-16  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/68162
+	* c-decl.c (grokdeclarator): Set first_non_attr_kind before
+	following link from declarator to next declarator.  Track original
+	qualified type and pass it to c_build_qualified_type.
+	* c-typeck.c (c_build_qualified_type): Add arguments
+	orig_qual_type and orig_qual_indirect.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index ad704bf..933ba3b 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -5366,6 +5366,8 @@ grokdeclarator (const struct c_declarator *declarator,
   tree returned_attrs = NULL_TREE;
   bool bitfield = width != NULL;
   tree element_type;
+  tree orig_qual_type = NULL;
+  size_t orig_qual_indirect = 0;
   struct c_arg_info *arg_info = 0;
   addr_space_t as1, as2, address_space;
   location_t loc = UNKNOWN_LOCATION;
@@ -5404,9 +5406,9 @@ grokdeclarator (const struct c_declarator *declarator,
 	case cdk_function:
 	case cdk_pointer:
 	  funcdef_syntax = (decl->kind == cdk_function);
-	  decl = decl->declarator;
 	  if (first_non_attr_kind == cdk_attrs)
 	    first_non_attr_kind = decl->kind;
+	  decl = decl->declarator;
 	  break;
 
 	case cdk_attrs:
@@ -5528,12 +5530,17 @@ grokdeclarator (const struct c_declarator *declarator,
   if ((TREE_CODE (type) == ARRAY_TYPE
        || first_non_attr_kind == cdk_array)
       && TYPE_QUALS (element_type))
-    type = TYPE_MAIN_VARIANT (type);
+    {
+      orig_qual_type = type;
+      type = TYPE_MAIN_VARIANT (type);
+    }
   type_quals = ((constp ? TYPE_QUAL_CONST : 0)
 		| (restrictp ? TYPE_QUAL_RESTRICT : 0)
 		| (volatilep ? TYPE_QUAL_VOLATILE : 0)
 		| (atomicp ? TYPE_QUAL_ATOMIC : 0)
 		| ENCODE_QUAL_ADDR_SPACE (address_space));
+  if (type_quals != TYPE_QUALS (element_type))
+    orig_qual_type = NULL_TREE;
 
   /* Applying the _Atomic qualifier to an array type (through the use
      of typedefs or typeof) must be detected here.  If the qualifier
@@ -6024,6 +6031,7 @@ grokdeclarator (const struct c_declarator *declarator,
 		array_ptr_attrs = NULL_TREE;
 		array_parm_static = 0;
 	      }
+	    orig_qual_indirect++;
 	    break;
 	  }
 	case cdk_function:
@@ -6033,6 +6041,7 @@ grokdeclarator (const struct c_declarator *declarator,
 	       attributes.  */
 	    bool really_funcdef = false;
 	    tree arg_types;
+	    orig_qual_type = NULL_TREE;
 	    if (funcdef_flag)
 	      {
 		const struct c_declarator *t = declarator->declarator;
@@ -6133,7 +6142,9 @@ grokdeclarator (const struct c_declarator *declarator,
 	      pedwarn (loc, OPT_Wpedantic,
 		       "ISO C forbids qualified function types");
 	    if (type_quals)
-	      type = c_build_qualified_type (type, type_quals);
+	      type = c_build_qualified_type (type, type_quals, orig_qual_type,
+					     orig_qual_indirect);
+	    orig_qual_type = NULL_TREE;
 	    size_varies = false;
 
 	    /* When the pointed-to type involves components of variable size,
@@ -6331,7 +6342,8 @@ grokdeclarator (const struct c_declarator *declarator,
 	pedwarn (loc, OPT_Wpedantic,
 		 "ISO C forbids qualified function types");
       if (type_quals)
-	type = c_build_qualified_type (type, type_quals);
+	type = c_build_qualified_type (type, type_quals, orig_qual_type,
+				       orig_qual_indirect);
       decl = build_decl (declarator->id_loc,
 			 TYPE_DECL, declarator->u.id, type);
       if (declspecs->explicit_signed_p)
@@ -6384,7 +6396,8 @@ grokdeclarator (const struct c_declarator *declarator,
 	pedwarn (loc, OPT_Wpedantic,
 		 "ISO C forbids const or volatile function types");
       if (type_quals)
-	type = c_build_qualified_type (type, type_quals);
+	type = c_build_qualified_type (type, type_quals, orig_qual_type,
+				       orig_qual_indirect);
       return type;
     }
 
@@ -6431,8 +6444,16 @@ grokdeclarator (const struct c_declarator *declarator,
 	  {
 	    /* Transfer const-ness of array into that of type pointed to.  */
 	    type = TREE_TYPE (type);
+	    if (orig_qual_type != NULL_TREE)
+	      {
+		if (orig_qual_indirect == 0)
+		  orig_qual_type = TREE_TYPE (orig_qual_type);
+		else
+		  orig_qual_indirect--;
+	      }
 	    if (type_quals)
-	      type = c_build_qualified_type (type, type_quals);
+	      type = c_build_qualified_type (type, type_quals, orig_qual_type,
+					     orig_qual_indirect);
 	    type = c_build_pointer_type (type);
 	    type_quals = array_ptr_quals;
 	    if (type_quals)
@@ -6523,7 +6544,8 @@ grokdeclarator (const struct c_declarator *declarator,
 	    TYPE_DOMAIN (type) = build_range_type (sizetype, size_zero_node,
 						   NULL_TREE);
 	  }
-	type = c_build_qualified_type (type, type_quals);
+	type = c_build_qualified_type (type, type_quals, orig_qual_type,
+				       orig_qual_indirect);
 	decl = build_decl (declarator->id_loc,
 			   FIELD_DECL, declarator->u.id, type);
 	DECL_NONADDRESSABLE_P (decl) = bitfield;
@@ -6635,7 +6657,8 @@ grokdeclarator (const struct c_declarator *declarator,
 	/* An uninitialized decl with `extern' is a reference.  */
 	int extern_ref = !initialized && storage_class == csc_extern;
 
-	type = c_build_qualified_type (type, type_quals);
+	type = c_build_qualified_type (type, type_quals, orig_qual_type,
+				       orig_qual_indirect);
 
 	/* C99 6.2.2p7: It is invalid (compile-time undefined
 	   behavior) to create an 'extern' declaration for a
@@ -7996,7 +8019,22 @@ finish_enum (tree enumtype, tree values, tree attributes)
   precision = MAX (tree_int_cst_min_precision (minnode, sign),
 		   tree_int_cst_min_precision (maxnode, sign));
 
-  if (TYPE_PACKED (enumtype) || precision > TYPE_PRECISION (integer_type_node))
+  /* If the precision of the type was specified with an attribute and it
+     was too small, give an error.  Otherwise, use it.  */
+  if (TYPE_PRECISION (enumtype))
+    {
+      if (precision > TYPE_PRECISION (enumtype))
+	{
+	  TYPE_PRECISION (enumtype) = 0;
+	  error ("specified mode too small for enumeral values");
+	}
+      else
+	precision = TYPE_PRECISION (enumtype);
+    }
+
+  if (TYPE_PACKED (enumtype)
+      || precision > TYPE_PRECISION (integer_type_node)
+      || TYPE_PRECISION (enumtype))
     {
       tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);
       if (tem == NULL)
@@ -8012,16 +8050,7 @@ finish_enum (tree enumtype, tree values, tree attributes)
   TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);
   TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);
   TYPE_SIZE (enumtype) = 0;
-
-  /* If the precision of the type was specific with an attribute and it
-     was too small, give an error.  Otherwise, use it.  */
-  if (TYPE_PRECISION (enumtype))
-    {
-      if (precision > TYPE_PRECISION (enumtype))
-	error ("specified mode too small for enumeral values");
-    }
-  else
-    TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);
+  TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);
 
   layout_type (enumtype);
 
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 86cbc40..c5378fe 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -1206,7 +1206,8 @@ static tree c_parser_simple_asm_expr (c_parser *);
 static tree c_parser_attributes (c_parser *);
 static struct c_type_name *c_parser_type_name (c_parser *);
 static struct c_expr c_parser_initializer (c_parser *);
-static struct c_expr c_parser_braced_init (c_parser *, tree, bool);
+static struct c_expr c_parser_braced_init (c_parser *, tree, bool,
+					   struct obstack *);
 static void c_parser_initelt (c_parser *, struct obstack *);
 static void c_parser_initval (c_parser *, struct c_expr *,
 			      struct obstack *);
@@ -4159,7 +4160,7 @@ static struct c_expr
 c_parser_initializer (c_parser *parser)
 {
   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
-    return c_parser_braced_init (parser, NULL_TREE, false);
+    return c_parser_braced_init (parser, NULL_TREE, false, NULL);
   else
     {
       struct c_expr ret;
@@ -4179,7 +4180,8 @@ c_parser_initializer (c_parser *parser)
    top-level initializer in a declaration.  */
 
 static struct c_expr
-c_parser_braced_init (c_parser *parser, tree type, bool nested_p)
+c_parser_braced_init (c_parser *parser, tree type, bool nested_p,
+		      struct obstack *outer_obstack)
 {
   struct c_expr ret;
   struct obstack braced_init_obstack;
@@ -4188,7 +4190,10 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)
   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));
   c_parser_consume_token (parser);
   if (nested_p)
-    push_init_level (brace_loc, 0, &braced_init_obstack);
+    {
+      finish_implicit_inits (brace_loc, outer_obstack);
+      push_init_level (brace_loc, 0, &braced_init_obstack);
+    }
   else
     really_start_incremental_init (type);
   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
@@ -4443,7 +4448,8 @@ c_parser_initval (c_parser *parser, struct c_expr *after,
   location_t loc = c_parser_peek_token (parser)->location;
 
   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) && !after)
-    init = c_parser_braced_init (parser, NULL_TREE, true);
+    init = c_parser_braced_init (parser, NULL_TREE, true,
+				 braced_init_obstack);
   else
     {
       init = c_parser_expr_no_commas (parser, after);
@@ -7746,7 +7752,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,
       error_at (type_loc, "compound literal has variable size");
       type = error_mark_node;
     }
-  init = c_parser_braced_init (parser, type, false);
+  init = c_parser_braced_init (parser, type, false, NULL);
   finish_init ();
   maybe_warn_string_init (type_loc, type, init);
 
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index 7a72665..885bfd6 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -614,6 +614,7 @@ extern void maybe_warn_string_init (location_t, tree, struct c_expr);
 extern void start_init (tree, tree, int);
 extern void finish_init (void);
 extern void really_start_incremental_init (tree);
+extern void finish_implicit_inits (location_t, struct obstack *);
 extern void push_init_level (location_t, int, struct obstack *);
 extern struct c_expr pop_init_level (location_t, int, struct obstack *);
 extern void set_init_index (location_t, tree, tree, struct obstack *);
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index ffba66b..be4967f 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -7312,6 +7312,31 @@ really_start_incremental_init (tree type)
     }
 }
 
+/* Called when we see an open brace for a nested initializer.  Finish
+   off any pending levels with implicit braces.  */
+void
+finish_implicit_inits (location_t loc, struct obstack *braced_init_obstack)
+{
+  while (constructor_stack->implicit)
+    {
+      if ((TREE_CODE (constructor_type) == RECORD_TYPE
+	   || TREE_CODE (constructor_type) == UNION_TYPE)
+	  && constructor_fields == 0)
+	process_init_element (input_location,
+			      pop_init_level (loc, 1, braced_init_obstack),
+			      true, braced_init_obstack);
+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE
+	       && constructor_max_index
+	       && tree_int_cst_lt (constructor_max_index,
+				   constructor_index))
+	process_init_element (input_location,
+			      pop_init_level (loc, 1, braced_init_obstack),
+			      true, braced_init_obstack);
+      else
+	break;
+    }
+}
+
 /* Push down into a subobject, for initialization.
    If this is for an explicit set of braces, IMPLICIT is 0.
    If it is because the next element belongs at a lower level,
@@ -7324,34 +7349,6 @@ push_init_level (location_t loc, int implicit,
   struct constructor_stack *p;
   tree value = NULL_TREE;
 
-  /* If we've exhausted any levels that didn't have braces,
-     pop them now.  If implicit == 1, this will have been done in
-     process_init_element; do not repeat it here because in the case
-     of excess initializers for an empty aggregate this leads to an
-     infinite cycle of popping a level and immediately recreating
-     it.  */
-  if (implicit != 1)
-    {
-      while (constructor_stack->implicit)
-	{
-	  if ((TREE_CODE (constructor_type) == RECORD_TYPE
-	       || TREE_CODE (constructor_type) == UNION_TYPE)
-	      && constructor_fields == 0)
-	    process_init_element (input_location,
-				  pop_init_level (loc, 1, braced_init_obstack),
-				  true, braced_init_obstack);
-	  else if (TREE_CODE (constructor_type) == ARRAY_TYPE
-		   && constructor_max_index
-		   && tree_int_cst_lt (constructor_max_index,
-				       constructor_index))
-	    process_init_element (input_location,
-				  pop_init_level (loc, 1, braced_init_obstack),
-				  true, braced_init_obstack);
-	  else
-	    break;
-	}
-    }
-
   /* Unless this is an explicit brace, we need to preserve previous
      content if any.  */
   if (implicit)
@@ -7783,6 +7780,7 @@ set_designator (location_t loc, int array,
     }
 
   constructor_designated = 1;
+  finish_implicit_inits (loc, braced_init_obstack);
   push_init_level (loc, 2, braced_init_obstack);
   return 0;
 }
@@ -9168,6 +9166,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,
 	      p = p->next;
 	      if (!p)
 		break;
+	      finish_implicit_inits (loc, braced_init_obstack);
 	      push_init_level (loc, 2, braced_init_obstack);
 	      p->stack = constructor_stack;
 	      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))
@@ -10754,6 +10753,20 @@ build_binary_op (location_t location, enum tree_code code,
               return error_mark_node;
             }
 
+	  /* It's not precisely specified how the usual arithmetic
+	     conversions apply to the vector types.  Here, we use
+	     the unsigned type if one of the operands is signed and
+	     the other one is unsigned.  */
+	  if (TYPE_UNSIGNED (type0) != TYPE_UNSIGNED (type1))
+	    {
+	      if (!TYPE_UNSIGNED (type0))
+		op0 = build1 (VIEW_CONVERT_EXPR, type1, op0);
+	      else
+		op1 = build1 (VIEW_CONVERT_EXPR, type0, op1);
+	      warning_at (location, OPT_Wsign_compare, "comparison between "
+			  "types %qT and %qT", type0, type1);
+	    }
+
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
@@ -10896,6 +10909,20 @@ build_binary_op (location_t location, enum tree_code code,
               return error_mark_node;
             }
 
+	  /* It's not precisely specified how the usual arithmetic
+	     conversions apply to the vector types.  Here, we use
+	     the unsigned type if one of the operands is signed and
+	     the other one is unsigned.  */
+	  if (TYPE_UNSIGNED (type0) != TYPE_UNSIGNED (type1))
+	    {
+	      if (!TYPE_UNSIGNED (type0))
+		op0 = build1 (VIEW_CONVERT_EXPR, type1, op0);
+	      else
+		op1 = build1 (VIEW_CONVERT_EXPR, type0, op1);
+	      warning_at (location, OPT_Wsign_compare, "comparison between "
+			  "types %qT and %qT", type0, type1);
+	    }
+
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
@@ -12578,10 +12605,15 @@ c_finish_transaction (location_t loc, tree block, int flags)
 }
 
 /* Make a variant type in the proper way for C/C++, propagating qualifiers
-   down to the element type of an array.  */
+   down to the element type of an array.  If ORIG_QUAL_TYPE is not
+   NULL, then it should be used as the qualified type
+   ORIG_QUAL_INDIRECT levels down in array type derivation (to
+   preserve information about the typedef name from which an array
+   type was derived).  */
 
 tree
-c_build_qualified_type (tree type, int type_quals)
+c_build_qualified_type (tree type, int type_quals, tree orig_qual_type,
+			size_t orig_qual_indirect)
 {
   if (type == error_mark_node)
     return type;
@@ -12590,18 +12622,22 @@ c_build_qualified_type (tree type, int type_quals)
     {
       tree t;
       tree element_type = c_build_qualified_type (TREE_TYPE (type),
-						  type_quals);
+						  type_quals, orig_qual_type,
+						  orig_qual_indirect - 1);
 
       /* See if we already have an identically qualified type.  */
-      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
-	{
-	  if (TYPE_QUALS (strip_array_types (t)) == type_quals
-	      && TYPE_NAME (t) == TYPE_NAME (type)
-	      && TYPE_CONTEXT (t) == TYPE_CONTEXT (type)
-	      && attribute_list_equal (TYPE_ATTRIBUTES (t),
-				       TYPE_ATTRIBUTES (type)))
-	    break;
-	}
+      if (orig_qual_type && orig_qual_indirect == 0)
+	t = orig_qual_type;
+      else
+	for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
+	  {
+	    if (TYPE_QUALS (strip_array_types (t)) == type_quals
+		&& TYPE_NAME (t) == TYPE_NAME (type)
+		&& TYPE_CONTEXT (t) == TYPE_CONTEXT (type)
+		&& attribute_list_equal (TYPE_ATTRIBUTES (t),
+					 TYPE_ATTRIBUTES (type)))
+	      break;
+	  }
       if (!t)
 	{
           tree domain = TYPE_DOMAIN (type);
@@ -12639,7 +12675,10 @@ c_build_qualified_type (tree type, int type_quals)
       type_quals &= ~TYPE_QUAL_RESTRICT;
     }
 
-  return build_qualified_type (type, type_quals);
+  tree var_type = (orig_qual_type && orig_qual_indirect == 0
+		   ? orig_qual_type
+		   : build_qualified_type (type, type_quals));
+  return var_type;
 }
 
 /* Build a VA_ARG_EXPR for the C parser.  */
diff --git a/gcc/calls.c b/gcc/calls.c
index ee8ea5f..29b4ed1 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -576,12 +576,9 @@ special_function_p (const_tree fndecl, int flags)
       /* We assume that alloca will always be called by name.  It
 	 makes no sense to pass it as a pointer-to-function to
 	 anything that does not understand its behavior.  */
-      if (((IDENTIFIER_LENGTH (name_decl) == 6
-	    && name[0] == 'a'
-	    && ! strcmp (name, "alloca"))
-	   || (IDENTIFIER_LENGTH (name_decl) == 16
-	       && name[0] == '_'
-	       && ! strcmp (name, "__builtin_alloca"))))
+      if (IDENTIFIER_LENGTH (name_decl) == 6
+	  && name[0] == 'a'
+	  && ! strcmp (name, "alloca"))
 	flags |= ECF_MAY_BE_ALLOCA;
 
       /* Disregard prefix _, __, __x or __builtin_.  */
@@ -627,6 +624,17 @@ special_function_p (const_tree fndecl, int flags)
 	flags |= ECF_NORETURN;
     }
 
+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)
+    switch (DECL_FUNCTION_CODE (fndecl))
+      {
+      case BUILT_IN_ALLOCA:
+      case BUILT_IN_ALLOCA_WITH_ALIGN:
+	flags |= ECF_MAY_BE_ALLOCA;
+	break;
+      default:
+	break;
+      }
+
   return flags;
 }
 
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 3293ea6..ffa120a 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -3367,6 +3367,12 @@ expand_gimple_stmt_1 (gimple stmt)
 	  {
 	    tree result = DECL_RESULT (current_function_decl);
 
+	    /* Mark we have return statement with missing bounds.  */
+	    if (!bnd
+		&& chkp_function_instrumented_p (cfun->decl)
+		&& !DECL_P (op0))
+	      bnd = error_mark_node;
+
 	    /* If we are not returning the current function's RESULT_DECL,
 	       build an assignment to it.  */
 	    if (op0 != result)
@@ -3383,9 +3389,6 @@ expand_gimple_stmt_1 (gimple stmt)
 		op0 = build2 (MODIFY_EXPR, TREE_TYPE (result),
 			      result, op0);
 	      }
-	    /* Mark we have return statement with missing bounds.  */
-	    if (!bnd && chkp_function_instrumented_p (cfun->decl))
-	      bnd = error_mark_node;
 	  }
 
 	if (!op0)
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index 852960a..22ae812 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -2609,7 +2609,8 @@ collect_callers_of_node_1 (cgraph_node *node, void *data)
 
   if (avail > AVAIL_INTERPOSABLE)
     for (cs = node->callers; cs != NULL; cs = cs->next_caller)
-      if (!cs->indirect_inlining_edge)
+      if (!cs->indirect_inlining_edge
+	  && !cs->caller->thunk.thunk_p)
         redirect_callers->safe_push (cs);
   return false;
 }
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index cf8c7b6..e368996 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -1028,7 +1028,7 @@ public:
   cgraph_edge *get_edge (gimple call_stmt);
 
   /* Collect all callers of cgraph_node and its aliases that are known to lead
-     to NODE (i.e. are not overwritable).  */
+     to NODE (i.e. are not overwritable) and that are not thunks.  */
   vec<cgraph_edge *> collect_callers (void);
 
   /* Remove all callers from the node.  */
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
index b587ff2..546cac8 100644
--- a/gcc/cgraphclones.c
+++ b/gcc/cgraphclones.c
@@ -367,6 +367,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)
   new_thunk = cgraph_node::create (new_decl);
   set_new_clone_decl_and_node_flags (new_thunk);
   new_thunk->definition = true;
+  new_thunk->local.can_change_signature = node->local.can_change_signature;
   new_thunk->thunk = thunk->thunk;
   new_thunk->unique_name = in_lto_p;
   new_thunk->former_clone_of = thunk->decl;
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 78b2b59..d4db126 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -585,6 +585,7 @@ cgraph_node::analyze (void)
       cgraph_node *t = cgraph_node::get (thunk.alias);
 
       create_edge (t, NULL, 0, CGRAPH_FREQ_BASE);
+      callees->can_throw_external = !TREE_NOTHROW (t->decl);
       /* Target code in expand_thunk may need the thunk's target
 	 to be analyzed, so recurse here.  */
       if (!t->analyzed)
diff --git a/gcc/combine.c b/gcc/combine.c
index ea47b32..fd0ea00 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7227,6 +7227,10 @@ expand_field_assignment (const_rtx x)
       if (len >= HOST_BITS_PER_WIDE_INT)
 	break;
 
+      /* Don't try to compute in too wide unsupported modes.  */
+      if (!targetm.scalar_mode_supported_p (compute_mode))
+	break;
+
       /* Now compute the equivalent expression.  Make a copy of INNER
 	 for the SET_DEST in case it is a MEM into which we will substitute;
 	 we don't want shared RTL in that case.  */
@@ -13781,10 +13785,10 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,
 		break;
 	      tem_insn = i3;
 	      /* If the new I2 sets the same register that is marked dead
-		 in the note, the note now should not be put on I2, as the
-		 note refers to a previous incarnation of the reg.  */
+		 in the note, we do not know where to put the note.
+		 Give up.  */
 	      if (i2 != 0 && reg_set_p (XEXP (note, 0), PATTERN (i2)))
-		tem_insn = i2;
+		break;
 	    }
 
 	  if (place == 0)
diff --git a/gcc/common.opt b/gcc/common.opt
index 1218a71..429811e 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -1845,7 +1845,7 @@ Common Var(common_deferred_options) Defer
 
 frandom-seed=
 Common Joined RejectNegative Var(common_deferred_options) Defer
--frandom-seed=<number>	Make compile reproducible using <number>
+-frandom-seed=<string>	Make compile reproducible using <string>
 
 ; This switch causes the command line that was used to create an
 ; object file to be recorded into the object file.  The exact format
diff --git a/gcc/config/aarch64/aarch64-modes.def b/gcc/config/aarch64/aarch64-modes.def
index b17b90d..c8e9455 100644
--- a/gcc/config/aarch64/aarch64-modes.def
+++ b/gcc/config/aarch64/aarch64-modes.def
@@ -25,6 +25,7 @@ CC_MODE (CC_ZESWP); /* zero-extend LHS (but swap to make it RHS).  */
 CC_MODE (CC_SESWP); /* sign-extend LHS (but swap to make it RHS).  */
 CC_MODE (CC_NZ);    /* Only N and Z bits of condition flags are valid.  */
 CC_MODE (CC_Z);     /* Only Z bit of condition flags is valid.  */
+CC_MODE (CC_C);     /* Only C bit of condition flags is valid.  */
 CC_MODE (CC_DNE);
 CC_MODE (CC_DEQ);
 CC_MODE (CC_DLE);
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index 59c5824..d89bf62 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -184,6 +184,9 @@ int aarch64_get_condition_code (rtx);
 bool aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode);
 enum aarch64_symbol_type
 aarch64_classify_symbolic_expression (rtx, enum aarch64_symbol_context);
+bool aarch64_cannot_change_mode_class (machine_mode,
+				       machine_mode,
+				       enum reg_class);
 bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);
 bool aarch64_constant_address_p (rtx);
 bool aarch64_expand_movmem (rtx *);
@@ -197,6 +200,7 @@ bool aarch64_label_mentioned_p (rtx);
 bool aarch64_legitimate_pic_operand_p (rtx);
 bool aarch64_modes_tieable_p (machine_mode mode1,
 			      machine_mode mode2);
+bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);
 bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);
 bool aarch64_mov_operand_p (rtx, enum aarch64_symbol_context,
 			    machine_mode);
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index efa54a3..5c7291e 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -1115,6 +1115,16 @@ aarch64_split_simd_move (rtx dst, rtx src)
     }
 }
 
+bool
+aarch64_zero_extend_const_eq (machine_mode xmode, rtx x,
+			      machine_mode ymode, rtx y)
+{
+  rtx r = simplify_const_unary_operation (ZERO_EXTEND, xmode, y, ymode);
+  gcc_assert (r != NULL);
+  return rtx_equal_p (x, r);
+}
+			      
+
 static rtx
 aarch64_force_temporary (machine_mode mode, rtx x, rtx value)
 {
@@ -3751,6 +3761,13 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)
     return ((code == GT || code == GE || code == LE || code == LT)
 	    ? CC_SESWPmode : CC_ZESWPmode);
 
+  /* A test for unsigned overflow.  */
+  if ((GET_MODE (x) == DImode || GET_MODE (x) == TImode)
+      && code == NE
+      && GET_CODE (x) == PLUS
+      && GET_CODE (y) == ZERO_EXTEND)
+    return CC_Cmode;
+
   /* For everything else, return CCmode.  */
   return CCmode;
 }
@@ -3901,6 +3918,15 @@ aarch64_get_condition_code_1 (enum machine_mode mode, enum rtx_code comp_code)
 	}
       break;
 
+    case CC_Cmode:
+      switch (comp_code)
+	{
+	case NE: return AARCH64_CS;
+	case EQ: return AARCH64_CC;
+	default: return -1;
+	}
+      break;
+
     default:
       return -1;
       break;
@@ -10183,6 +10209,24 @@ aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,
   return ret;
 }
 
+/* Implement target hook CANNOT_CHANGE_MODE_CLASS.  */
+bool
+aarch64_cannot_change_mode_class (machine_mode from,
+				  machine_mode to,
+				  enum reg_class rclass)
+{
+  /* We cannot allow word_mode subregs of full vector modes.
+     Otherwise the middle-end will assume it's ok to store to
+     (subreg:DI (reg:TI 100) 0) in order to modify only the low 64 bits
+     of the 128-bit register.  However, after reload the subreg will
+     be dropped leaving a plain DImode store.  See PR67609 for a more
+     detailed dicussion.  In all other cases, we want to be permissive
+     and return false.  */
+  return (reg_classes_intersect_p (FP_REGS, rclass)
+	  && GET_MODE_SIZE (to) == UNITS_PER_WORD
+	  && GET_MODE_SIZE (from) > UNITS_PER_WORD);
+}
+
 rtx
 aarch64_reverse_mask (enum machine_mode mode)
 {
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index b49e456..a2ed7b1 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -881,6 +881,9 @@ do {									     \
   extern void  __aarch64_sync_cache_range (void *, void *);	\
   __aarch64_sync_cache_range (beg, end)
 
+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)	\
+  aarch64_cannot_change_mode_class (FROM, TO, CLASS)
+
 #define SHIFT_COUNT_TRUNCATED !TARGET_SIMD
 
 /* Choose appropriate mode for caller saves, so we do the minimum
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 4665279..116fd89 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1484,7 +1484,7 @@
   ""
 {
   rtx low = gen_reg_rtx (DImode);
-  emit_insn (gen_adddi3_compare0 (low, gen_lowpart (DImode, operands[1]),
+  emit_insn (gen_adddi3_compareC (low, gen_lowpart (DImode, operands[1]),
 				  gen_lowpart (DImode, operands[2])));
 
   rtx high = gen_reg_rtx (DImode);
@@ -1529,6 +1529,71 @@
   [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
+(define_insn "*add<mode>3_compareC_cconly_imm"
+  [(set (reg:CC_C CC_REGNUM)
+	(ne:CC_C
+	  (plus:<DWI>
+	    (zero_extend:<DWI> (match_operand:GPI 0 "register_operand" "r,r"))
+	    (match_operand:<DWI> 2 "const_scalar_int_operand" ""))
+	  (zero_extend:<DWI>
+	    (plus:GPI
+	      (match_dup 0)
+	      (match_operand:GPI 1 "aarch64_plus_immediate" "I,J")))))]
+  "aarch64_zero_extend_const_eq (<DWI>mode, operands[2],
+				 <MODE>mode, operands[1])"
+  "@
+  cmn\\t%<w>0, %<w>1
+  cmp\\t%<w>0, #%n1"
+  [(set_attr "type" "alus_imm")]
+)
+
+(define_insn "*add<mode>3_compareC_cconly"
+  [(set (reg:CC_C CC_REGNUM)
+	(ne:CC_C
+	  (plus:<DWI>
+	    (zero_extend:<DWI> (match_operand:GPI 0 "register_operand" "r"))
+	    (zero_extend:<DWI> (match_operand:GPI 1 "register_operand" "r")))
+	  (zero_extend:<DWI> (plus:GPI (match_dup 0) (match_dup 1)))))]
+  ""
+  "cmn\\t%<w>0, %<w>1"
+  [(set_attr "type" "alus_sreg")]
+)
+
+(define_insn "*add<mode>3_compareC_imm"
+  [(set (reg:CC_C CC_REGNUM)
+	(ne:CC_C
+	  (plus:<DWI>
+	    (zero_extend:<DWI> (match_operand:GPI 1 "register_operand" "r,r"))
+	    (match_operand:<DWI> 3 "const_scalar_int_operand" ""))
+	  (zero_extend:<DWI>
+	    (plus:GPI
+	      (match_dup 1)
+	      (match_operand:GPI 2 "aarch64_plus_immediate" "I,J")))))
+   (set (match_operand:GPI 0 "register_operand" "=r,r")
+	(plus:GPI (match_dup 1) (match_dup 2)))]
+  "aarch64_zero_extend_const_eq (<DWI>mode, operands[3],
+                                 <MODE>mode, operands[2])"
+  "@
+  adds\\t%<w>0, %<w>1, %<w>2
+  subs\\t%<w>0, %<w>1, #%n2"
+  [(set_attr "type" "alus_imm")]
+)
+ 
+(define_insn "add<mode>3_compareC"
+  [(set (reg:CC_C CC_REGNUM)
+	(ne:CC_C
+	  (plus:<DWI>
+	    (zero_extend:<DWI> (match_operand:GPI 1 "register_operand" "r"))
+	    (zero_extend:<DWI> (match_operand:GPI 2 "register_operand" "r")))
+	  (zero_extend:<DWI>
+	    (plus:GPI (match_dup 1) (match_dup 2)))))
+   (set (match_operand:GPI 0 "register_operand" "=r")
+	(plus:GPI (match_dup 1) (match_dup 2)))]
+  ""
+  "adds\\t%<w>0, %<w>1, %<w>2"
+  [(set_attr "type" "alus_sreg")]
+)
+
 (define_insn "*adds_mul_imm_<mode>"
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ
@@ -1780,105 +1845,41 @@
   [(set_attr "type" "alu_ext")]
 )
 
-(define_insn "add<mode>3_carryin"
-  [(set
-    (match_operand:GPI 0 "register_operand" "=r")
-    (plus:GPI (geu:GPI (reg:CC CC_REGNUM) (const_int 0))
-	      (plus:GPI
-		(match_operand:GPI 1 "register_operand" "r")
-		(match_operand:GPI 2 "register_operand" "r"))))]
-   ""
-   "adc\\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "type" "adc_reg")]
-)
-
-;; zero_extend version of above
-(define_insn "*addsi3_carryin_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand" "=r")
-    (zero_extend:DI
-     (plus:SI (geu:SI (reg:CC CC_REGNUM) (const_int 0))
-	      (plus:SI
-	       (match_operand:SI 1 "register_operand" "r")
-	       (match_operand:SI 2 "register_operand" "r")))))]
-   ""
-   "adc\\t%w0, %w1, %w2"
-  [(set_attr "type" "adc_reg")]
-)
-
-(define_insn "*add<mode>3_carryin_alt1"
-  [(set
-    (match_operand:GPI 0 "register_operand" "=r")
-    (plus:GPI (plus:GPI
-		(match_operand:GPI 1 "register_operand" "r")
-		(match_operand:GPI 2 "register_operand" "r"))
-              (geu:GPI (reg:CC CC_REGNUM) (const_int 0))))]
+(define_expand "add<mode>3_carryin"
+  [(set (match_operand:GPI 0 "register_operand")
+	(plus:GPI
+	  (plus:GPI
+	    (ne:GPI (reg:CC_C CC_REGNUM) (const_int 0))
+	    (match_operand:GPI 1 "aarch64_reg_or_zero"))
+	  (match_operand:GPI 2 "aarch64_reg_or_zero")))]
    ""
-   "adc\\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "type" "adc_reg")]
-)
-
-;; zero_extend version of above
-(define_insn "*addsi3_carryin_alt1_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand" "=r")
-    (zero_extend:DI
-     (plus:SI (plus:SI
-	       (match_operand:SI 1 "register_operand" "r")
-	       (match_operand:SI 2 "register_operand" "r"))
-              (geu:SI (reg:CC CC_REGNUM) (const_int 0)))))]
    ""
-   "adc\\t%w0, %w1, %w2"
-  [(set_attr "type" "adc_reg")]
 )
 
-(define_insn "*add<mode>3_carryin_alt2"
-  [(set
-    (match_operand:GPI 0 "register_operand" "=r")
-    (plus:GPI (plus:GPI
-                (geu:GPI (reg:CC CC_REGNUM) (const_int 0))
-		(match_operand:GPI 1 "register_operand" "r"))
-	      (match_operand:GPI 2 "register_operand" "r")))]
-   ""
-   "adc\\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "type" "adc_reg")]
-)
+;; Note that add with carry with two zero inputs is matched by cset,
+;; and that add with carry with one zero input is matched by cinc.
 
-;; zero_extend version of above
-(define_insn "*addsi3_carryin_alt2_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand" "=r")
-    (zero_extend:DI
-     (plus:SI (plus:SI
-               (geu:SI (reg:CC CC_REGNUM) (const_int 0))
-	       (match_operand:SI 1 "register_operand" "r"))
-	      (match_operand:SI 2 "register_operand" "r"))))]
-   ""
-   "adc\\t%w0, %w1, %w2"
-  [(set_attr "type" "adc_reg")]
-)
-
-(define_insn "*add<mode>3_carryin_alt3"
-  [(set
-    (match_operand:GPI 0 "register_operand" "=r")
-    (plus:GPI (plus:GPI
-                (geu:GPI (reg:CC CC_REGNUM) (const_int 0))
-		(match_operand:GPI 2 "register_operand" "r"))
-	      (match_operand:GPI 1 "register_operand" "r")))]
+(define_insn "*add<mode>3_carryin"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(plus:GPI
+	  (plus:GPI
+	    (match_operand:GPI 3 "aarch64_carry_operation" "")
+	    (match_operand:GPI 1 "register_operand" "r"))
+	  (match_operand:GPI 2 "register_operand" "r")))]
    ""
    "adc\\t%<w>0, %<w>1, %<w>2"
   [(set_attr "type" "adc_reg")]
 )
 
 ;; zero_extend version of above
-(define_insn "*addsi3_carryin_alt3_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand" "=r")
-    (zero_extend:DI
-     (plus:SI (plus:SI
-               (geu:SI (reg:CC CC_REGNUM) (const_int 0))
-	       (match_operand:SI 2 "register_operand" "r"))
-	      (match_operand:SI 1 "register_operand" "r"))))]
+(define_insn "*addsi3_carryin_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (plus:SI
+	    (plus:SI
+	      (match_operand:SI 3 "aarch64_carry_operation" "")
+	      (match_operand:SI 1 "register_operand" "r"))
+	    (match_operand:SI 2 "register_operand" "r"))))]
    ""
    "adc\\t%w0, %w1, %w2"
   [(set_attr "type" "adc_reg")]
@@ -1955,7 +1956,7 @@
   ""
 {
   rtx low = gen_reg_rtx (DImode);
-  emit_insn (gen_subdi3_compare0 (low, gen_lowpart (DImode, operands[1]),
+  emit_insn (gen_subdi3_compare1 (low, gen_lowpart (DImode, operands[1]),
 				  gen_lowpart (DImode, operands[2])));
 
   rtx high = gen_reg_rtx (DImode);
@@ -1967,7 +1968,7 @@
   DONE;
 })
 
-(define_insn "sub<mode>3_compare0"
+(define_insn "*sub<mode>3_compare0"
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ (minus:GPI (match_operand:GPI 1 "register_operand" "r")
 				  (match_operand:GPI 2 "register_operand" "r"))
@@ -1992,6 +1993,18 @@
   [(set_attr "type" "alus_sreg")]
 )
 
+(define_insn "sub<mode>3_compare1"
+  [(set (reg:CC CC_REGNUM)
+	(compare:CC
+	  (match_operand:GPI 1 "aarch64_reg_or_zero" "rZ")
+	  (match_operand:GPI 2 "aarch64_reg_or_zero" "rZ")))
+   (set (match_operand:GPI 0 "register_operand" "=r")
+	(minus:GPI (match_dup 1) (match_dup 2)))]
+  ""
+  "subs\\t%<w>0, %<w>1, %<w>2"
+  [(set_attr "type" "alus_sreg")]
+)
+
 (define_insn "*sub_<shift>_<mode>"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	(minus:GPI (match_operand:GPI 3 "register_operand" "r")
@@ -2114,13 +2127,53 @@
   [(set_attr "type" "alu_ext")]
 )
 
-(define_insn "sub<mode>3_carryin"
-  [(set
-    (match_operand:GPI 0 "register_operand" "=r")
-    (minus:GPI (minus:GPI
-		(match_operand:GPI 1 "register_operand" "r")
-		(ltu:GPI (reg:CC CC_REGNUM) (const_int 0)))
-	       (match_operand:GPI 2 "register_operand" "r")))]
+;; The hardware description is op1 + ~op2 + C.
+;;                           = op1 + (-op2 + 1) + (1 - !C)
+;;                           = op1 - op2 - 1 + 1 - !C
+;;                           = op1 - op2 - !C.
+;; We describe the latter.
+
+(define_insn "*sub<mode>3_carryin0"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(minus:GPI
+	  (match_operand:GPI 1 "aarch64_reg_or_zero" "rZ")
+	  (match_operand:GPI 2 "aarch64_borrow_operation" "")))]
+   ""
+   "sbc\\t%<w>0, %<w>1, <w>zr"
+  [(set_attr "type" "adc_reg")]
+)
+
+;; zero_extend version of the above
+(define_insn "*subsi3_carryin_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (match_operand:SI 1 "aarch64_reg_or_zero" "rZ")
+	    (match_operand:SI 2 "aarch64_borrow_operation" ""))))]
+   ""
+   "sbc\\t%w0, %w1, wzr"
+  [(set_attr "type" "adc_reg")]
+)
+
+(define_expand "sub<mode>3_carryin"
+  [(set (match_operand:GPI 0 "register_operand")
+	(minus:GPI
+	  (minus:GPI
+	    (match_operand:GPI 1 "aarch64_reg_or_zero")
+	    (match_operand:GPI 2 "register_operand"))
+	  (ltu:GPI (reg:CC CC_REGNUM) (const_int 0))))]
+   ""
+   ""
+)
+
+(define_insn "*sub<mode>3_carryin"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(minus:GPI
+	  (minus:GPI
+	    (match_operand:GPI 1 "aarch64_reg_or_zero" "rZ")
+	    (match_operand:GPI 2 "register_operand" "r"))
+	  (match_operand:GPI 3 "aarch64_borrow_operation" "")))]
+
    ""
    "sbc\\t%<w>0, %<w>1, %<w>2"
   [(set_attr "type" "adc_reg")]
@@ -2128,13 +2181,40 @@
 
 ;; zero_extend version of the above
 (define_insn "*subsi3_carryin_uxtw"
-  [(set
-    (match_operand:DI 0 "register_operand" "=r")
-    (zero_extend:DI
-     (minus:SI (minus:SI
-		(match_operand:SI 1 "register_operand" "r")
-		(ltu:SI (reg:CC CC_REGNUM) (const_int 0)))
-	       (match_operand:SI 2 "register_operand" "r"))))]
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (minus:SI
+	      (match_operand:SI 1 "aarch64_reg_or_zero" "rZ")
+	      (match_operand:SI 2 "register_operand" "r"))
+	    (match_operand:SI 3 "aarch64_borrow_operation" ""))))]
+
+   ""
+   "sbc\\t%w0, %w1, %w2"
+  [(set_attr "type" "adc_reg")]
+)
+
+(define_insn "*sub<mode>3_carryin_alt"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(minus:GPI
+	  (minus:GPI
+	    (match_operand:GPI 1 "aarch64_reg_or_zero" "rZ")
+	    (match_operand:GPI 3 "aarch64_borrow_operation" ""))
+	  (match_operand:GPI 2 "register_operand" "r")))]
+   ""
+   "sbc\\t%<w>0, %<w>1, %<w>2"
+  [(set_attr "type" "adc_reg")]
+)
+
+;; zero_extend version of the above
+(define_insn "*subsi3_carryin_alt_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (minus:SI
+	      (match_operand:SI 1 "aarch64_reg_or_zero" "rZ")
+	      (match_operand:SI 3 "aarch64_borrow_operation" ""))
+	    (match_operand:SI 2 "register_operand" "r"))))]
    ""
    "sbc\\t%w0, %w1, %w2"
   [(set_attr "type" "adc_reg")]
@@ -2225,8 +2305,9 @@
 
 (define_insn "*ngc<mode>"
   [(set (match_operand:GPI 0 "register_operand" "=r")
-	(minus:GPI (neg:GPI (ltu:GPI (reg:CC CC_REGNUM) (const_int 0)))
-		   (match_operand:GPI 1 "register_operand" "r")))]
+	(minus:GPI
+	  (neg:GPI (match_operand:GPI 2 "aarch64_borrow_operation" ""))
+	  (match_operand:GPI 1 "register_operand" "r")))]
   ""
   "ngc\\t%<w>0, %<w>1"
   [(set_attr "type" "adc_reg")]
@@ -2235,8 +2316,9 @@
 (define_insn "*ngcsi_uxtw"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	 (minus:SI (neg:SI (ltu:SI (reg:CC CC_REGNUM) (const_int 0)))
-		   (match_operand:SI 1 "register_operand" "r"))))]
+	  (minus:SI
+	    (neg:SI (match_operand:SI 2 "aarch64_borrow_operation" ""))
+	    (match_operand:SI 1 "register_operand" "r"))))]
   ""
   "ngc\\t%w0, %w1"
   [(set_attr "type" "adc_reg")]
@@ -4068,7 +4150,8 @@
 
 (define_insn "aarch64_movdi_<mode>low"
   [(set (match_operand:DI 0 "register_operand" "=r")
-        (truncate:DI (match_operand:TX 1 "register_operand" "w")))]
+	(zero_extract:DI (match_operand:TX 1 "register_operand" "w")
+			 (const_int 64) (const_int 0)))]
   "TARGET_FLOAT && (reload_completed || reload_in_progress)"
   "fmov\\t%x0, %d1"
   [(set_attr "type" "f_mrc")
@@ -4077,9 +4160,8 @@
 
 (define_insn "aarch64_movdi_<mode>high"
   [(set (match_operand:DI 0 "register_operand" "=r")
-        (truncate:DI
-	  (lshiftrt:TX (match_operand:TX 1 "register_operand" "w")
-		       (const_int 64))))]
+	(zero_extract:DI (match_operand:TX 1 "register_operand" "w")
+			 (const_int 64) (const_int 64)))]
   "TARGET_FLOAT && (reload_completed || reload_in_progress)"
   "fmov\\t%x0, %1.d[1]"
   [(set_attr "type" "f_mrc")
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 7c8bbfa..2efbfab 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -296,6 +296,9 @@
 ;; For constraints used in scalar immediate vector moves
 (define_mode_attr hq [(HI "h") (QI "q")])
 
+;; For doubling width of an integer mode
+(define_mode_attr DWI [(QI "HI") (HI "SI") (SI "DI") (DI "TI")])
+
 ;; For scalar usage of vector/FP registers
 (define_mode_attr v [(QI "b") (HI "h") (SI "s") (DI "d")
 		    (SF "s") (DF "d")
diff --git a/gcc/config/aarch64/predicates.md b/gcc/config/aarch64/predicates.md
index 8e07a17..6308b21 100644
--- a/gcc/config/aarch64/predicates.md
+++ b/gcc/config/aarch64/predicates.md
@@ -243,6 +243,25 @@
   return aarch64_get_condition_code (op) >= 0;
 })
 
+(define_special_predicate "aarch64_carry_operation"
+  (match_code "ne,geu")
+{
+  if (XEXP (op, 1) != const0_rtx)
+    return false;
+  machine_mode ccmode = (GET_CODE (op) == NE ? CC_Cmode : CCmode);
+  rtx op0 = XEXP (op, 0);
+  return REG_P (op0) && REGNO (op0) == CC_REGNUM && GET_MODE (op0) == ccmode;
+})
+
+(define_special_predicate "aarch64_borrow_operation"
+  (match_code "eq,ltu")
+{
+  if (XEXP (op, 1) != const0_rtx)
+    return false;
+  machine_mode ccmode = (GET_CODE (op) == EQ ? CC_Cmode : CCmode);
+  rtx op0 = XEXP (op, 0);
+  return REG_P (op0) && REGNO (op0) == CC_REGNUM && GET_MODE (op0) == ccmode;
+})
 
 ;; True if the operand is memory reference suitable for a load/store exclusive.
 (define_predicate "aarch64_sync_memory_operand"
diff --git a/gcc/config/arm/arm-builtins.c b/gcc/config/arm/arm-builtins.c
index 7a45113..6f4fd9b 100644
--- a/gcc/config/arm/arm-builtins.c
+++ b/gcc/config/arm/arm-builtins.c
@@ -2077,7 +2077,8 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,
 	      if (!(*insn_data[icode].operand[opno].predicate)
                    (op[argc], mode[argc]))
 		op[argc] = (replace_equiv_address
-			    (op[argc], force_reg (Pmode, XEXP (op[argc], 0))));
+			    (op[argc],
+			     copy_to_mode_reg (Pmode, XEXP (op[argc], 0))));
               break;
 
 	    case NEON_ARG_STOP:
@@ -2160,7 +2161,7 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)
   neon_builtin_datum *d =
 		&neon_builtin_data[fcode - ARM_BUILTIN_NEON_BASE];
   enum insn_code icode = d->code;
-  builtin_arg args[SIMD_MAX_BUILTIN_ARGS];
+  builtin_arg args[SIMD_MAX_BUILTIN_ARGS + 1];
   int num_args = insn_data[d->code].n_operands;
   int is_void = 0;
   int k;
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index bfa58c3..303897f 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -10306,8 +10306,10 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
 	      /* SMUL[TB][TB].  */
 	      if (speed_p)
 		*cost += extra_cost->mult[0].extend;
-	      *cost += (rtx_cost (XEXP (x, 0), SIGN_EXTEND, 0, speed_p)
-			+ rtx_cost (XEXP (x, 1), SIGN_EXTEND, 0, speed_p));
+	      *cost += rtx_cost (XEXP (XEXP (x, 0), 0),
+				 SIGN_EXTEND, 0, speed_p);
+	      *cost += rtx_cost (XEXP (XEXP (x, 1), 0),
+				 SIGN_EXTEND, 1, speed_p);
 	      return true;
 	    }
 	  if (speed_p)
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 8c10ea3..928d18f 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -628,16 +628,10 @@ extern int arm_arch_crc;
    type, but kept valid in the wider mode.  The signedness of the
    extension may differ from that of the type.  */
 
-/* It is far faster to zero extend chars than to sign extend them */
-
 #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)	\
   if (GET_MODE_CLASS (MODE) == MODE_INT		\
       && GET_MODE_SIZE (MODE) < 4)      	\
     {						\
-      if (MODE == QImode)			\
-	UNSIGNEDP = 1;				\
-      else if (MODE == HImode)			\
-	UNSIGNEDP = 1;				\
       (MODE) = SImode;				\
     }
 
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index f4c9dea..32e015d 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -3148,8 +3148,22 @@
   "#"   ; "orr%?\\t%0, %1, %2\;bic%?\\t%0, %0, %3"
   "&& reload_completed"
   [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 0)))]
-  ""
+   (set (match_dup 0) (and:SI (match_dup 4) (match_dup 5)))]
+  {
+     /* If operands[3] is a constant make sure to fold the NOT into it
+	to avoid creating a NOT of a CONST_INT.  */
+    rtx not_rtx = simplify_gen_unary (NOT, SImode, operands[3], SImode);
+    if (CONST_INT_P (not_rtx))
+      {
+	operands[4] = operands[0];
+	operands[5] = not_rtx;
+      }
+    else
+      {
+	operands[5] = operands[0];
+	operands[4] = not_rtx;
+      }
+  }
   [(set_attr "length" "8")
    (set_attr "ce_count" "2")
    (set_attr "predicable" "yes")
diff --git a/gcc/config/arm/thumb2.md b/gcc/config/arm/thumb2.md
index 1f68147..52de5d0 100644
--- a/gcc/config/arm/thumb2.md
+++ b/gcc/config/arm/thumb2.md
@@ -653,15 +653,27 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn "*thumb2_ior_scc_strict_it"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
+(define_insn_and_split "*thumb2_ior_scc_strict_it"
+  [(set (match_operand:SI 0 "s_register_operand" "=&r")
 	(ior:SI (match_operator:SI 2 "arm_comparison_operator"
 		 [(match_operand 3 "cc_register" "") (const_int 0)])
-		(match_operand:SI 1 "s_register_operand" "0,?l")))]
+		(match_operand:SI 1 "s_register_operand" "r")))]
   "TARGET_THUMB2 && arm_restrict_it"
-  "@
-   it\\t%d2\;mov%d2\\t%0, #1\;it\\t%d2\;orr%d2\\t%0, %1
-   mov\\t%0, #1\;orr\\t%0, %1\;it\\t%D2\;mov%D2\\t%0, %1"
+  "#" ; orr\\t%0, %1, #1\;it\\t%D2\;mov%D2\\t%0, %1
+  "&& reload_completed"
+  [(set (match_dup 0) (ior:SI (match_dup 1) (const_int 1)))
+   (cond_exec (match_dup 4)
+     (set (match_dup 0) (match_dup 1)))]
+  {
+    machine_mode mode = GET_MODE (operands[3]);
+    rtx_code rc = GET_CODE (operands[2]);
+
+    if (mode == CCFPmode || mode == CCFPEmode)
+      rc = reverse_condition_maybe_unordered (rc);
+    else
+      rc = reverse_condition (rc);
+    operands[4] = gen_rtx_fmt_ee (rc, VOIDmode, operands[3], const0_rtx);
+  }
   [(set_attr "conds" "use")
    (set_attr "length" "8")
    (set_attr "type" "multiple")]
diff --git a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
index c297ed9..83b251f 100644
--- a/gcc/config/arm/vfp.md
+++ b/gcc/config/arm/vfp.md
@@ -1336,8 +1336,9 @@
                         [(match_operand:SDF 1
                            "register_operand" "<F_constraint>")] VCVT)))]
   "TARGET_HARD_FLOAT && TARGET_FPU_ARMV8 <vfp_double_cond>"
-  "vcvt<vrint_variant>%?.<su>32.<V_if_elem>\\t%0, %<V_reg>1"
+  "vcvt<vrint_variant>.<su>32.<V_if_elem>\\t%0, %<V_reg>1"
   [(set_attr "predicable" "no")
+   (set_attr "conds" "unconditional")
    (set_attr "type" "f_cvtf2i")]
 )
 
diff --git a/gcc/config/i386/constraints.md b/gcc/config/i386/constraints.md
index 2271bd1..00a84a0 100644
--- a/gcc/config/i386/constraints.md
+++ b/gcc/config/i386/constraints.md
@@ -149,6 +149,7 @@
 ;;  s  Sibcall memory operand, not valid for TARGET_X32
 ;;  w  Call memory operand, not valid for TARGET_X32
 ;;  z  Constant call address operand.
+;;  C  SSE constant operand.
 
 (define_constraint "Bs"
   "@internal Sibcall memory operand."
@@ -164,6 +165,10 @@
   "@internal Constant call address operand."
   (match_operand 0 "constant_call_address_operand"))
 
+(define_constraint "BC"
+  "@internal SSE constant operand."
+  (match_test "standard_sse_constant_p (op)"))
+
 ;; Integer constant constraints.
 (define_constraint "I"
   "Integer constant in the range 0 @dots{} 31, for 32-bit shifts."
@@ -214,8 +219,8 @@
 
 ;; This can theoretically be any mode's CONST0_RTX.
 (define_constraint "C"
-  "Standard SSE floating point constant."
-  (match_test "standard_sse_constant_p (op)"))
+  "SSE constant zero operand."
+  (match_test "standard_sse_constant_p (op) == 1"))
 
 ;; Constant-or-symbol-reference constraints.
 
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 3b19caa..17971b3 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -115,6 +115,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-iterator.h"
 #include "tree-chkp.h"
 #include "rtl-chkp.h"
+#include "dojump.h"
 
 static rtx legitimize_dllimport_symbol (rtx, bool);
 static rtx legitimize_pe_coff_extern_decl (rtx, bool);
@@ -562,17 +563,17 @@ struct processor_costs geode_cost = {
   {4, 6, 6},				/* cost of storing fp registers
 					   in SFmode, DFmode and XFmode */
 
-  1,					/* cost of moving MMX register */
-  {1, 1},				/* cost of loading MMX registers
+  2,					/* cost of moving MMX register */
+  {2, 2},				/* cost of loading MMX registers
 					   in SImode and DImode */
-  {1, 1},				/* cost of storing MMX registers
+  {2, 2},				/* cost of storing MMX registers
 					   in SImode and DImode */
-  1,					/* cost of moving SSE register */
-  {1, 1, 1},				/* cost of loading SSE registers
+  2,					/* cost of moving SSE register */
+  {2, 2, 8},				/* cost of loading SSE registers
 					   in SImode, DImode and TImode */
-  {1, 1, 1},				/* cost of storing SSE registers
+  {2, 2, 8},				/* cost of storing SSE registers
 					   in SImode, DImode and TImode */
-  1,					/* MMX or SSE register to integer */
+  3,					/* MMX or SSE register to integer */
   64,					/* size of l1 cache.  */
   128,					/* size of l2 cache.  */
   32,					/* size of prefetch block */
@@ -4150,6 +4151,17 @@ ix86_option_override_internal (bool main_args_p,
       opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
     }
 
+  /* Stack realignment without -maccumulate-outgoing-args requires %ebp,
+     so enable -maccumulate-outgoing-args when %ebp is fixed.  */
+  if (fixed_regs[BP_REG]
+      && !(opts->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))
+    {
+      if (opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)
+	warning (0, "fixed ebp register requires %saccumulate-outgoing-args%s",
+		 prefix, suffix);
+      opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
+    }
+
   /* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
   {
     char *p;
@@ -4982,12 +4994,14 @@ ix86_valid_target_attribute_tree (tree args,
       /* If we are using the default tune= or arch=, undo the string assigned,
 	 and use the default.  */
       if (option_strings[IX86_FUNCTION_SPECIFIC_ARCH])
-	opts->x_ix86_arch_string = option_strings[IX86_FUNCTION_SPECIFIC_ARCH];
+	opts->x_ix86_arch_string
+	  = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_ARCH]);
       else if (!orig_arch_specified)
 	opts->x_ix86_arch_string = NULL;
 
       if (option_strings[IX86_FUNCTION_SPECIFIC_TUNE])
-	opts->x_ix86_tune_string = option_strings[IX86_FUNCTION_SPECIFIC_TUNE];
+	opts->x_ix86_tune_string
+	  = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_TUNE]);
       else if (orig_tune_defaulted)
 	opts->x_ix86_tune_string = NULL;
 
@@ -9677,6 +9691,10 @@ ix86_frame_pointer_required (void)
   if (TARGET_64BIT_MS_ABI && get_frame_size () > SEH_MAX_FRAME_SIZE)
     return true;
 
+  /* SSE saves require frame-pointer when stack is misaligned.  */
+  if (TARGET_64BIT_MS_ABI && ix86_incoming_stack_boundary < 128)
+    return true;
+  
   /* In ix86_option_override_internal, TARGET_OMIT_LEAF_FRAME_POINTER
      turns off the frame pointer by default.  Turn it back on now if
      we've not got a leaf function.  */
@@ -10114,18 +10132,6 @@ ix86_compute_frame_layout (struct ix86_frame *frame)
       crtl->preferred_stack_boundary = 128;
       crtl->stack_alignment_needed = 128;
     }
-  /* preferred_stack_boundary is never updated for call
-     expanded from tls descriptor. Update it here. We don't update it in
-     expand stage because according to the comments before
-     ix86_current_function_calls_tls_descriptor, tls calls may be optimized
-     away.  */
-  else if (ix86_current_function_calls_tls_descriptor
-	   && crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)
-    {
-      crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;
-      if (crtl->stack_alignment_needed < PREFERRED_STACK_BOUNDARY)
-	crtl->stack_alignment_needed = PREFERRED_STACK_BOUNDARY;
-    }
 
   stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;
   preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;
@@ -10799,6 +10805,11 @@ ix86_update_stack_boundary (void)
       && cfun->stdarg
       && crtl->stack_alignment_estimated < 128)
     crtl->stack_alignment_estimated = 128;
+
+  /* __tls_get_addr needs to be called with 16-byte aligned stack.  */
+  if (ix86_tls_descriptor_calls_expanded_in_cfun
+      && crtl->preferred_stack_boundary < 128)
+    crtl->preferred_stack_boundary = 128;
 }
 
 /* Handle the TARGET_GET_DRAP_RTX hook.  Return NULL if no DRAP is
@@ -11258,10 +11269,11 @@ ix86_finalize_stack_realign_flags (void)
   unsigned int incoming_stack_boundary
     = (crtl->parm_stack_boundary > ix86_incoming_stack_boundary
        ? crtl->parm_stack_boundary : ix86_incoming_stack_boundary);
-  unsigned int stack_realign = (incoming_stack_boundary
-				< (crtl->is_leaf
-				   ? crtl->max_used_stack_slot_alignment
-				   : crtl->stack_alignment_needed));
+  unsigned int stack_realign
+    = (incoming_stack_boundary
+       < (crtl->is_leaf && !ix86_current_function_calls_tls_descriptor
+	  ? crtl->max_used_stack_slot_alignment
+	  : crtl->stack_alignment_needed));
 
   if (crtl->stack_realign_finalized)
     {
@@ -24365,7 +24377,7 @@ expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,
        if (DYNAMIC_CHECK)
 	 Round COUNT down to multiple of SIZE
        << optional caller supplied zero size guard is here >>
-       << optional caller suppplied dynamic check is here >>
+       << optional caller supplied dynamic check is here >>
        << caller supplied main copy loop is here >>
      }
    done_label:
@@ -24539,8 +24551,8 @@ expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx src
       else
 	*min_size = 0;
 
-      /* Our loops always round down the bock size, but for dispatch to library
-	 we need precise value.  */
+      /* Our loops always round down the block size, but for dispatch to
+         library we need precise value.  */
       if (dynamic_check)
 	*count = expand_simple_binop (GET_MODE (*count), AND, *count,
 				      GEN_INT (-size), *count, 1, OPTAB_DIRECT);
@@ -25118,6 +25130,13 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,
   size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;
   epilogue_size_needed = size_needed;
 
+  /* If we are going to call any library calls conditionally, make sure any
+     pending stack adjustment happen before the first conditional branch,
+     otherwise they will be emitted before the library call only and won't
+     happen from the other branches.  */
+  if (dynamic_check != -1)
+    do_pending_stack_adjust ();
+
   desired_align = decide_alignment (align, alg, expected_size, move_mode);
   if (!TARGET_ALIGN_STRINGOPS || noalign)
     align = desired_align;
@@ -38246,7 +38265,11 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,
       memory = 0;
       break;
     case VOID_FTYPE_PV8DF_V8DF_QI:
+    case VOID_FTYPE_PV4DF_V4DF_QI:
+    case VOID_FTYPE_PV2DF_V2DF_QI:
     case VOID_FTYPE_PV16SF_V16SF_HI:
+    case VOID_FTYPE_PV8SF_V8SF_QI:
+    case VOID_FTYPE_PV4SF_V4SF_QI:
     case VOID_FTYPE_PV8DI_V8DI_QI:
     case VOID_FTYPE_PV4DI_V4DI_QI:
     case VOID_FTYPE_PV2DI_V2DI_QI:
@@ -38306,10 +38329,6 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,
     case VOID_FTYPE_PV16QI_V16QI_HI:
     case VOID_FTYPE_PV32QI_V32QI_SI:
     case VOID_FTYPE_PV64QI_V64QI_DI:
-    case VOID_FTYPE_PV4DF_V4DF_QI:
-    case VOID_FTYPE_PV2DF_V2DF_QI:
-    case VOID_FTYPE_PV8SF_V8SF_QI:
-    case VOID_FTYPE_PV4SF_V4SF_QI:
       nargs = 2;
       klass = store;
       /* Reserve memory operand for target.  */
@@ -40246,13 +40265,12 @@ rdseed_step:
 
       op0 = fixup_modeless_constant (op0, mode0);
 
-      if (GET_MODE (op0) == mode0
-	  || (GET_MODE (op0) == VOIDmode && op0 != constm1_rtx))
+      if (GET_MODE (op0) == mode0 || GET_MODE (op0) == VOIDmode)
 	{
 	  if (!insn_data[icode].operand[0].predicate (op0, mode0))
 	    op0 = copy_to_mode_reg (mode0, op0);
 	}
-      else if (op0 != constm1_rtx)
+      else
 	{
 	  op0 = copy_to_reg (op0);
 	  op0 = simplify_gen_subreg (mode0, op0, GET_MODE (op0), 0);
@@ -45078,6 +45096,7 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)
 	{
 	  /* For SSE1, we have to reuse the V4SF code.  */
 	  rtx t = gen_reg_rtx (V4SFmode);
+	  emit_move_insn (t, gen_lowpart (V4SFmode, target));
 	  ix86_expand_vector_set (false, t, gen_lowpart (SFmode, val), elt);
 	  emit_move_insn (target, gen_lowpart (mode, t));
 	}
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index dc7f6a7..48fa3f0 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -804,7 +804,7 @@
 
 (define_insn "*mov<mode>_internal"
   [(set (match_operand:VMOVE 0 "nonimmediate_operand"               "=v,v ,m")
-	(match_operand:VMOVE 1 "nonimmediate_or_sse_const_operand"  "C ,vm,v"))]
+	(match_operand:VMOVE 1 "nonimmediate_or_sse_const_operand"  "BC,vm,v"))]
   "TARGET_SSE
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
@@ -1022,7 +1022,7 @@
       sse_suffix = "<ssescalarsize>";
     }
 
-  if (misaligned_operand (operands[1], <MODE>mode))
+  if (misaligned_operand (operands[0], <MODE>mode))
     align = "u";
   else
     align = "a";
@@ -2605,7 +2605,7 @@
 	(match_operator:<avx512fmaskmode> 3 "sse_comparison_operator"
 	  [(match_operand:VF 1 "register_operand" "v")
 	   (match_operand:VF 2 "nonimmediate_operand" "vm")]))]
-  "TARGET_SSE"
+  "TARGET_AVX512F"
   "vcmp%D3<ssemodesuffix>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecmp")
    (set_attr "length_immediate" "1")
@@ -3855,7 +3855,7 @@
   "@
    cvtsi2ss\t{%2, %0|%0, %2}
    cvtsi2ss\t{%2, %0|%0, %2}
-   vcvtsi2ss\t{<round_op3>%2, %1, %0|%0, %1, %2<round_op3>}"
+   vcvtsi2ss\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "isa" "noavx,noavx,avx")
    (set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "vector,double,*")
@@ -3876,7 +3876,7 @@
   "@
    cvtsi2ssq\t{%2, %0|%0, %2}
    cvtsi2ssq\t{%2, %0|%0, %2}
-   vcvtsi2ssq\t{<round_op3>%2, %1, %0|%0, %1, %2<round_op3>}"
+   vcvtsi2ssq\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "isa" "noavx,noavx,avx")
    (set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "vector,double,*")
@@ -3989,7 +3989,7 @@
 	  (match_operand:VF_128 1 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512F && <round_modev4sf_condition>"
-  "vcvtusi2<ssescalarmodesuffix>\t{<round_op3>%2, %1, %0|%0, %1, %2<round_op3>}"
+  "vcvtusi2<ssescalarmodesuffix>\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<ssescalarmode>")])
@@ -4003,7 +4003,7 @@
 	  (match_operand:VF_128 1 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512F && TARGET_64BIT"
-  "vcvtusi2<ssescalarmodesuffix>\t{<round_op3>%2, %1, %0|%0, %1, %2<round_op3>}"
+  "vcvtusi2<ssescalarmodesuffix>\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<ssescalarmode>")])
@@ -4268,7 +4268,7 @@
   "@
    cvtsi2sdq\t{%2, %0|%0, %2}
    cvtsi2sdq\t{%2, %0|%0, %2}
-   vcvtsi2sdq\t{<round_op3>%2, %1, %0|%0, %1, %2<round_op3>}"
+   vcvtsi2sdq\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "isa" "noavx,noavx,avx")
    (set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,direct,*")
@@ -7018,28 +7018,50 @@
   DONE;
 })
 
-(define_insn "vec_extract_hi_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=v,<store_mask_constraint>")
+(define_insn "vec_extract_hi_<mode>_maskm"
+  [(set (match_operand:<ssehalfvecmode> 0 "memory_operand" "=m")
+	(vec_merge:<ssehalfvecmode>
+	  (vec_select:<ssehalfvecmode>
+	    (match_operand:VI8F_256 1 "register_operand" "v")
+	    (parallel [(const_int 2) (const_int 3)]))
+	  (match_operand:<ssehalfvecmode> 2 "memory_operand" "0")
+	  (match_operand:<ssehalfvecmode> 3 "register_operand" "k")))]
+  "TARGET_AVX512DQ && TARGET_AVX512VL
+   && rtx_equal_p (operands[2], operands[0])"
+  "vextract<shuffletype>64x2\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}"
+  [(set_attr "type" "sselog1")
+   (set_attr "length_immediate" "1")
+   (set_attr "prefix" "evex")
+   (set_attr "mode" "<sseinsnmode>")])
+
+(define_insn "vec_extract_hi_<mode>_mask"
+  [(set (match_operand:<ssehalfvecmode> 0 "register_operand" "=v")
+	(vec_merge:<ssehalfvecmode>
+	  (vec_select:<ssehalfvecmode>
+	    (match_operand:VI8F_256 1 "register_operand" "v")
+	    (parallel [(const_int 2) (const_int 3)]))
+	  (match_operand:<ssehalfvecmode> 2 "vector_move_operand" "0C")
+	  (match_operand:<avx512fmaskmode> 3 "register_operand" "Yk")))]
+  "TARGET_AVX512VL && TARGET_AVX512DQ"
+  "vextract<shuffletype>64x2\t{$0x1, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x1}"
+  [(set_attr "type" "sselog1")
+   (set_attr "length_immediate" "1")
+   (set_attr "prefix" "evex")
+   (set_attr "mode" "<sseinsnmode>")])
+
+(define_insn "vec_extract_hi_<mode>"
+  [(set (match_operand:<ssehalfvecmode> 0 "nonimmediate_operand" "=xm, vm")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:VI8F_256 1 "register_operand" "v,v")
+	  (match_operand:VI8F_256 1 "register_operand" "x, v")
 	  (parallel [(const_int 2) (const_int 3)])))]
-  "TARGET_AVX && <mask_avx512vl_condition> && <mask_avx512dq_condition>"
-{
-  if (TARGET_AVX512VL)
-  {
-    if (TARGET_AVX512DQ)
-      return "vextract<shuffletype>64x2\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}";
-    else
-      return "vextract<shuffletype>32x4\t{$0x1, %1, %0|%0, %1, 0x1}";
-  }
-  else
-    return "vextract<i128>\t{$0x1, %1, %0|%0, %1, 0x1}";
-}
-  [(set_attr "type" "sselog")
-   (set_attr "prefix_extra" "1")
+  "TARGET_AVX"
+  "@
+    vextract<i128>\t{$0x1, %1, %0|%0, %1, 0x1}
+    vextract<shuffletype>64x2\t{$0x1, %1, %0|%0, %1, 0x1}"
+  [(set_attr "isa" "*, avx512dq")
+   (set_attr "prefix" "vex, evex")
+   (set_attr "type" "sselog1")
    (set_attr "length_immediate" "1")
-   (set_attr "memory" "none,store")
-   (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_split
@@ -11834,13 +11856,13 @@
 {
   int mask = INTVAL (operands[3]);
   if (mask == 0)
-    emit_insn (gen_vec_set_lo_<mode>_mask
-      (operands[0], operands[1], operands[2],
-       operands[4], operands[5]));
+    emit_insn (gen_vec_set_lo_<mode>_mask (operands[0], operands[1],
+					   operands[2], operands[4],
+					   operands[5]));
   else
-    emit_insn (gen_vec_set_hi_<mode>_mask
-      (operands[0], operands[1], operands[2],
-       operands[4], operands[5]));
+    emit_insn (gen_vec_set_hi_<mode>_mask (operands[0], operands[1],
+					   operands[2], operands[4],
+					   operands[5]));
   DONE;
 })
 
@@ -11851,9 +11873,9 @@
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V16FI 1 "register_operand" "v")
 	    (parallel [(const_int 8) (const_int 9)
-	      (const_int 10) (const_int 11)
-	      (const_int 12) (const_int 13)
-              (const_int 14) (const_int 15)]))))]
+		       (const_int 10) (const_int 11)
+		       (const_int 12) (const_int 13)
+		       (const_int 14) (const_int 15)]))))]
   "TARGET_AVX512DQ"
   "vinsert<shuffletype>32x8\t{$0x0, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x0}"
   [(set_attr "type" "sselog")
@@ -11864,13 +11886,13 @@
 (define_insn "vec_set_hi_<mode><mask_name>"
   [(set (match_operand:V16FI 0 "register_operand" "=v")
 	(vec_concat:V16FI
-	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V16FI 1 "register_operand" "v")
 	    (parallel [(const_int 0) (const_int 1)
-	      (const_int 2) (const_int 3)
-	      (const_int 4) (const_int 5)
-              (const_int 6) (const_int 7)]))))]
+		       (const_int 2) (const_int 3)
+		       (const_int 4) (const_int 5)
+		       (const_int 6) (const_int 7)]))
+	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")))]
   "TARGET_AVX512DQ"
   "vinsert<shuffletype>32x8\t{$0x1, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x1}"
   [(set_attr "type" "sselog")
@@ -11885,7 +11907,7 @@
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V8FI 1 "register_operand" "v")
 	    (parallel [(const_int 4) (const_int 5)
-              (const_int 6) (const_int 7)]))))]
+		       (const_int 6) (const_int 7)]))))]
   "TARGET_AVX512F"
   "vinsert<shuffletype>64x4\t{$0x0, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x0}"
   [(set_attr "type" "sselog")
@@ -11896,11 +11918,11 @@
 (define_insn "vec_set_hi_<mode><mask_name>"
   [(set (match_operand:V8FI 0 "register_operand" "=v")
 	(vec_concat:V8FI
-	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V8FI 1 "register_operand" "v")
 	    (parallel [(const_int 0) (const_int 1)
-              (const_int 2) (const_int 3)]))))]
+		       (const_int 2) (const_int 3)]))
+	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")))]
   "TARGET_AVX512F"
   "vinsert<shuffletype>64x4\t{$0x1, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x1}"
   [(set_attr "type" "sselog")
@@ -15188,7 +15210,7 @@
 
 (define_expand "avx512pf_gatherpf<mode>sf"
   [(unspec
-     [(match_operand:<avx512fmaskmode> 0 "register_or_constm1_operand")
+     [(match_operand:<avx512fmaskmode> 0 "register_operand")
       (mem:<GATHER_SCATTER_SF_MEM_MODE>
 	(match_par_dup 5
 	  [(match_operand 2 "vsib_address_operand")
@@ -15230,37 +15252,10 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "XI")])
 
-(define_insn "*avx512pf_gatherpf<mode>sf"
-  [(unspec
-     [(const_int -1)
-      (match_operator:<GATHER_SCATTER_SF_MEM_MODE> 4 "vsib_mem_operator"
-	[(unspec:P
-	   [(match_operand:P 1 "vsib_address_operand" "Tv")
-	    (match_operand:VI48_512 0 "register_operand" "v")
-	    (match_operand:SI 2 "const1248_operand" "n")]
-	   UNSPEC_VSIBADDR)])
-      (match_operand:SI 3 "const_2_to_3_operand" "n")]
-     UNSPEC_GATHER_PREFETCH)]
-  "TARGET_AVX512PF"
-{
-  switch (INTVAL (operands[3]))
-    {
-    case 3:
-      return "vgatherpf0<ssemodesuffix>ps\t{%4|%4}";
-    case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%4|%4}";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "type" "sse")
-   (set_attr "prefix" "evex")
-   (set_attr "mode" "XI")])
-
 ;; Packed double variants
 (define_expand "avx512pf_gatherpf<mode>df"
   [(unspec
-     [(match_operand:<avx512fmaskmode> 0 "register_or_constm1_operand")
+     [(match_operand:<avx512fmaskmode> 0 "register_operand")
       (mem:V8DF
 	(match_par_dup 5
 	  [(match_operand 2 "vsib_address_operand")
@@ -15302,37 +15297,10 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "XI")])
 
-(define_insn "*avx512pf_gatherpf<mode>df"
-  [(unspec
-     [(const_int -1)
-      (match_operator:V8DF 4 "vsib_mem_operator"
-	[(unspec:P
-	   [(match_operand:P 1 "vsib_address_operand" "Tv")
-	    (match_operand:VI4_256_8_512 0 "register_operand" "v")
-	    (match_operand:SI 2 "const1248_operand" "n")]
-	   UNSPEC_VSIBADDR)])
-      (match_operand:SI 3 "const_2_to_3_operand" "n")]
-     UNSPEC_GATHER_PREFETCH)]
-  "TARGET_AVX512PF"
-{
-  switch (INTVAL (operands[3]))
-    {
-    case 3:
-      return "vgatherpf0<ssemodesuffix>pd\t{%4|%4}";
-    case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%4|%4}";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "type" "sse")
-   (set_attr "prefix" "evex")
-   (set_attr "mode" "XI")])
-
 ;; Packed float variants
 (define_expand "avx512pf_scatterpf<mode>sf"
   [(unspec
-     [(match_operand:<avx512fmaskmode> 0 "register_or_constm1_operand")
+     [(match_operand:<avx512fmaskmode> 0 "register_operand")
       (mem:<GATHER_SCATTER_SF_MEM_MODE>
 	(match_par_dup 5
 	  [(match_operand 2 "vsib_address_operand")
@@ -15376,39 +15344,10 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "XI")])
 
-(define_insn "*avx512pf_scatterpf<mode>sf"
-  [(unspec
-     [(const_int -1)
-      (match_operator:<GATHER_SCATTER_SF_MEM_MODE> 4 "vsib_mem_operator"
-	[(unspec:P
-	   [(match_operand:P 1 "vsib_address_operand" "Tv")
-	    (match_operand:VI48_512 0 "register_operand" "v")
-	    (match_operand:SI 2 "const1248_operand" "n")]
-	   UNSPEC_VSIBADDR)])
-      (match_operand:SI 3 "const2367_operand" "n")]
-     UNSPEC_SCATTER_PREFETCH)]
-  "TARGET_AVX512PF"
-{
-  switch (INTVAL (operands[3]))
-    {
-    case 3:
-    case 7:
-      return "vscatterpf0<ssemodesuffix>ps\t{%4|%4}";
-    case 2:
-    case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%4|%4}";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "type" "sse")
-   (set_attr "prefix" "evex")
-   (set_attr "mode" "XI")])
-
 ;; Packed double variants
 (define_expand "avx512pf_scatterpf<mode>df"
   [(unspec
-     [(match_operand:<avx512fmaskmode> 0 "register_or_constm1_operand")
+     [(match_operand:<avx512fmaskmode> 0 "register_operand")
       (mem:V8DF
 	(match_par_dup 5
 	  [(match_operand 2 "vsib_address_operand")
@@ -15452,35 +15391,6 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "XI")])
 
-(define_insn "*avx512pf_scatterpf<mode>df"
-  [(unspec
-     [(const_int -1)
-      (match_operator:V8DF 4 "vsib_mem_operator"
-	[(unspec:P
-	   [(match_operand:P 1 "vsib_address_operand" "Tv")
-	    (match_operand:VI4_256_8_512 0 "register_operand" "v")
-	    (match_operand:SI 2 "const1248_operand" "n")]
-	   UNSPEC_VSIBADDR)])
-      (match_operand:SI 3 "const2367_operand" "n")]
-     UNSPEC_SCATTER_PREFETCH)]
-  "TARGET_AVX512PF"
-{
-  switch (INTVAL (operands[3]))
-    {
-    case 3:
-    case 7:
-      return "vscatterpf0<ssemodesuffix>pd\t{%4|%4}";
-    case 2:
-    case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%4|%4}";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "type" "sse")
-   (set_attr "prefix" "evex")
-   (set_attr "mode" "XI")])
-
 (define_insn "avx512er_exp2<mode><mask_name><round_saeonly_name>"
   [(set (match_operand:VF_512 0 "register_operand" "=v")
 	(unspec:VF_512
@@ -16907,20 +16817,21 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "vec_dup<mode>"
-  [(set (match_operand:AVX_VEC_DUP_MODE 0 "register_operand" "=x,x,v,x")
+  [(set (match_operand:AVX_VEC_DUP_MODE 0 "register_operand" "=x,x,x,v,x")
 	(vec_duplicate:AVX_VEC_DUP_MODE
-	  (match_operand:<ssescalarmode> 1 "nonimmediate_operand" "m,m,v,?x")))]
+	  (match_operand:<ssescalarmode> 1 "nonimmediate_operand" "m,m,x,v,?x")))]
   "TARGET_AVX"
   "@
    v<sseintprefix>broadcast<bcstscalarsuff>\t{%1, %0|%0, %1}
    vbroadcast<ssescalarmodesuffix>\t{%1, %0|%0, %1}
    v<sseintprefix>broadcast<bcstscalarsuff>\t{%x1, %0|%0, %x1}
+   v<sseintprefix>broadcast<bcstscalarsuff>\t{%x1, %g0|%g0, %x1}
    #"
   [(set_attr "type" "ssemov")
    (set_attr "prefix_extra" "1")
    (set_attr "prefix" "maybe_evex")
-   (set_attr "isa" "avx2,noavx2,avx2,noavx2")
-   (set_attr "mode" "<sseinsnmode>,V8SF,<sseinsnmode>,V8SF")])
+   (set_attr "isa" "avx2,noavx2,avx2,avx512f,noavx2")
+   (set_attr "mode" "<sseinsnmode>,V8SF,<sseinsnmode>,<sseinsnmode>,V8SF")])
 
 (define_split
   [(set (match_operand:AVX2_VEC_DUP_MODE 0 "register_operand")
@@ -18524,7 +18435,7 @@
 	   (match_operand:SI 3 "const_0_to_15_operand")]
 	  UNSPEC_RANGE))]
   "TARGET_AVX512DQ && <round_saeonly_mode512bit_condition>"
-  "vrange<ssemodesuffix>\t{<round_saeonly_mask_op4>%3, %2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2, %3<round_saeonly_mask_op4>}"
+  "vrange<ssemodesuffix>\t{%3, <round_saeonly_mask_op4>%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2<round_saeonly_mask_op4>, %3}"
   [(set_attr "type" "sse")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<MODE>")])
@@ -18540,7 +18451,7 @@
 	  (match_dup 1)
 	  (const_int 1)))]
   "TARGET_AVX512DQ"
-  "vrange<ssescalarmodesuffix>\t{<round_saeonly_op4>%3, %2, %1, %0|%0, %1, %2, %3<round_saeonly_op4>}"
+  "vrange<ssescalarmodesuffix>\t{%3, <round_saeonly_op4>%2, %1, %0|%0, %1, %2<round_saeonly_op4>, %3}"
   [(set_attr "type" "sse")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<MODE>")])
diff --git a/gcc/config/ia64/ia64.c b/gcc/config/ia64/ia64.c
index 21da9e2..f6eae19 100644
--- a/gcc/config/ia64/ia64.c
+++ b/gcc/config/ia64/ia64.c
@@ -1146,6 +1146,15 @@ ia64_expand_load_address (rtx dest, rtx src)
     emit_insn (gen_load_fptr (dest, src));
   else if (sdata_symbolic_operand (src, VOIDmode))
     emit_insn (gen_load_gprel (dest, src));
+  else if (local_symbolic_operand64 (src, VOIDmode))
+    {
+      /* We want to use @gprel rather than @ltoff relocations for local
+	 symbols:
+	  - @gprel does not require dynamic linker
+	  - and does not use .sdata section
+	 https://gcc.gnu.org/bugzilla/60465 */
+      emit_insn (gen_load_gprel64 (dest, src));
+    }
   else
     {
       HOST_WIDE_INT addend = 0;
@@ -1944,7 +1953,7 @@ ia64_expand_vecint_compare (enum rtx_code code, machine_mode mode,
 
 	    /* Subtract (-(INT MAX) - 1) from both operands to make
 	       them signed.  */
-	    mask = GEN_INT (0x80000000);
+	    mask = gen_int_mode (0x80000000, SImode);
 	    mask = gen_rtx_CONST_VECTOR (V2SImode, gen_rtvec (2, mask, mask));
 	    mask = force_reg (mode, mask);
 	    t1 = gen_reg_rtx (mode);
diff --git a/gcc/config/ia64/predicates.md b/gcc/config/ia64/predicates.md
index 2aa7a78..2e148f2e 100644
--- a/gcc/config/ia64/predicates.md
+++ b/gcc/config/ia64/predicates.md
@@ -97,6 +97,32 @@
     }
 })
 
+;; True if OP refers to a local symbol [+any offset].
+;; To be encoded as:
+;;   movl % = @gprel(symbol+offset)
+;;   add  % = %, gp
+(define_predicate "local_symbolic_operand64"
+  (match_code "symbol_ref,const")
+{
+  switch (GET_CODE (op))
+    {
+    case CONST:
+      op = XEXP (op, 0);
+      if (GET_CODE (op) != PLUS
+	  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF
+	  || GET_CODE (XEXP (op, 1)) != CONST_INT)
+	return false;
+      op = XEXP (op, 0);
+      /* FALLTHRU */
+
+    case SYMBOL_REF:
+	return SYMBOL_REF_LOCAL_P (op);
+
+    default:
+      gcc_unreachable ();
+    }
+})
+
 ;; True if OP refers to a symbol in the small address area.
 (define_predicate "small_addr_symbolic_operand" 
   (match_code "symbol_ref,const")
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 219560c..3c69889 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -1667,78 +1667,114 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 
   /* Handle secondary reloads for loads/stores of FP registers from
      REG+D addresses where D does not fit in 5 or 14 bits, including
-     (subreg (mem (addr))) cases.  */
+     (subreg (mem (addr))) cases, and reloads for other unsupported
+     memory operands.  */
   if (scratch_reg
-      && fp_reg_operand (operand0, mode)
+      && FP_REG_P (operand0)
       && (MEM_P (operand1)
 	  || (GET_CODE (operand1) == SUBREG
-	      && MEM_P (XEXP (operand1, 0))))
-      && !floating_point_store_memory_operand (operand1, mode))
+	      && MEM_P (XEXP (operand1, 0)))))
     {
-      if (GET_CODE (operand1) == SUBREG)
-	operand1 = XEXP (operand1, 0);
+      rtx op1 = operand1;
 
-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want
-	 it in WORD_MODE regardless of what mode it was originally given
-	 to us.  */
-      scratch_reg = force_mode (word_mode, scratch_reg);
+      if (GET_CODE (op1) == SUBREG)
+	op1 = XEXP (op1, 0);
 
-      /* D might not fit in 14 bits either; for such cases load D into
-	 scratch reg.  */
-      if (reg_plus_base_memory_operand (operand1, mode)
-	  && !(TARGET_PA_20
-	       && !TARGET_ELF32
-	       && INT_14_BITS (XEXP (XEXP (operand1, 0), 1))))
+      if (reg_plus_base_memory_operand (op1, GET_MODE (op1)))
 	{
-	  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));
-	  emit_move_insn (scratch_reg,
-			  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),
-					  Pmode,
-					  XEXP (XEXP (operand1, 0), 0),
-					  scratch_reg));
+	  if (!(TARGET_PA_20
+		&& !TARGET_ELF32
+		&& INT_14_BITS (XEXP (XEXP (op1, 0), 1)))
+	      && !INT_5_BITS (XEXP (XEXP (op1, 0), 1)))
+	    {
+	      /* SCRATCH_REG will hold an address and maybe the actual data.
+		 We want it in WORD_MODE regardless of what mode it was
+		 originally given to us.  */
+	      scratch_reg = force_mode (word_mode, scratch_reg);
+
+	      /* D might not fit in 14 bits either; for such cases load D
+		 into scratch reg.  */
+	      if (!INT_14_BITS (XEXP (XEXP (op1, 0), 1)))
+		{
+		  emit_move_insn (scratch_reg, XEXP (XEXP (op1, 0), 1));
+		  emit_move_insn (scratch_reg,
+				  gen_rtx_fmt_ee (GET_CODE (XEXP (op1, 0)),
+						  Pmode,
+						  XEXP (XEXP (op1, 0), 0),
+						  scratch_reg));
+		}
+	      else
+		emit_move_insn (scratch_reg, XEXP (op1, 0));
+	      emit_insn (gen_rtx_SET (VOIDmode, operand0,
+				  replace_equiv_address (op1, scratch_reg)));
+	      return 1;
+	    }
+	}
+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))
+	       || IS_LO_SUM_DLT_ADDR_P (XEXP (op1, 0))
+	       || IS_INDEX_ADDR_P (XEXP (op1, 0)))
+	{
+	  /* Load memory address into SCRATCH_REG.  */
+	  scratch_reg = force_mode (word_mode, scratch_reg);
+	  emit_move_insn (scratch_reg, XEXP (op1, 0));
+	  emit_insn (gen_rtx_SET (VOIDmode, operand0,
+				  replace_equiv_address (op1, scratch_reg)));
+	  return 1;
 	}
-      else
-	emit_move_insn (scratch_reg, XEXP (operand1, 0));
-      emit_insn (gen_rtx_SET (VOIDmode, operand0,
-			      replace_equiv_address (operand1, scratch_reg)));
-      return 1;
     }
   else if (scratch_reg
-	   && fp_reg_operand (operand1, mode)
+	   && FP_REG_P (operand1)
 	   && (MEM_P (operand0)
 	       || (GET_CODE (operand0) == SUBREG
-		   && MEM_P (XEXP (operand0, 0))))
-	   && !floating_point_store_memory_operand (operand0, mode))
+		   && MEM_P (XEXP (operand0, 0)))))
     {
-      if (GET_CODE (operand0) == SUBREG)
-	operand0 = XEXP (operand0, 0);
+      rtx op0 = operand0;
 
-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want
-	 it in WORD_MODE regardless of what mode it was originally given
-	 to us.  */
-      scratch_reg = force_mode (word_mode, scratch_reg);
+      if (GET_CODE (op0) == SUBREG)
+	op0 = XEXP (op0, 0);
 
-      /* D might not fit in 14 bits either; for such cases load D into
-	 scratch reg.  */
-      if (reg_plus_base_memory_operand (operand0, mode)
-	  && !(TARGET_PA_20
-	       && !TARGET_ELF32
-	       && INT_14_BITS (XEXP (XEXP (operand0, 0), 1))))
-	{
-	  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));
-	  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,
-								        0)),
-						       Pmode,
-						       XEXP (XEXP (operand0, 0),
-								   0),
-						       scratch_reg));
+      if (reg_plus_base_memory_operand (op0, GET_MODE (op0)))
+	{
+	  if (!(TARGET_PA_20
+		&& !TARGET_ELF32
+		&& INT_14_BITS (XEXP (XEXP (op0, 0), 1)))
+	      && !INT_5_BITS (XEXP (XEXP (op0, 0), 1)))
+	    {
+	      /* SCRATCH_REG will hold an address and maybe the actual data.
+		 We want it in WORD_MODE regardless of what mode it was
+		 originally given to us.  */
+	      scratch_reg = force_mode (word_mode, scratch_reg);
+
+	      /* D might not fit in 14 bits either; for such cases load D
+		 into scratch reg.  */
+	      if (!INT_14_BITS (XEXP (XEXP (op0, 0), 1)))
+		{
+		  emit_move_insn (scratch_reg, XEXP (XEXP (op0, 0), 1));
+		  emit_move_insn (scratch_reg,
+				  gen_rtx_fmt_ee (GET_CODE (XEXP (op0, 0)),
+						  Pmode,
+						  XEXP (XEXP (op0, 0), 0),
+						  scratch_reg));
+		}
+	      else
+		emit_move_insn (scratch_reg, XEXP (op0, 0));
+	      emit_insn (gen_rtx_SET (VOIDmode,
+				      replace_equiv_address (op0, scratch_reg),
+				      operand1));
+	      return 1;
+	    }
+	}
+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))
+	       || IS_LO_SUM_DLT_ADDR_P (XEXP (op0, 0))
+	       || IS_INDEX_ADDR_P (XEXP (op0, 0)))
+	{
+	  /* Load memory address into SCRATCH_REG.  */
+	  emit_move_insn (scratch_reg, XEXP (op0, 0));
+	  emit_insn (gen_rtx_SET (VOIDmode,
+				  replace_equiv_address (op0, scratch_reg),
+				  operand1));
+	  return 1;
 	}
-      else
-	emit_move_insn (scratch_reg, XEXP (operand0, 0));
-      emit_insn (gen_rtx_SET (VOIDmode,
-			      replace_equiv_address (operand0, scratch_reg),
-			      operand1));
-      return 1;
     }
   /* Handle secondary reloads for loads of FP registers from constant
      expressions by forcing the constant into memory.  For the most part,
@@ -1747,7 +1783,7 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
      Use scratch_reg to hold the address of the memory location.  */
   else if (scratch_reg
 	   && CONSTANT_P (operand1)
-	   && fp_reg_operand (operand0, mode))
+	   && FP_REG_P (operand0))
     {
       rtx const_mem, xoperands[2];
 
@@ -1792,12 +1828,11 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 
 	  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));
-	  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,
-								        0)),
-						       Pmode,
-						       XEXP (XEXP (operand1, 0),
-						       0),
-						       scratch_reg));
+	  emit_move_insn (scratch_reg,
+			  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),
+					  Pmode,
+					  XEXP (XEXP (operand1, 0), 0),
+					  scratch_reg));
 
 	  /* Now we are going to load the scratch register from memory,
 	     we want to load it in the same width as the original MEM,
@@ -1823,8 +1858,9 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
       emit_move_insn (operand0, scratch_reg);
       return 1;
     }
+
   /* Handle the most common case: storing into a register.  */
-  else if (register_operand (operand0, mode))
+  if (register_operand (operand0, mode))
     {
       /* Legitimize TLS symbol references.  This happens for references
 	 that aren't a legitimate constant.  */
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 271a72e..fde81bf 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -692,237 +692,6 @@
 (include "predicates.md")
 (include "constraints.md")
 
-;; Atomic instructions
-
-;; All memory loads and stores access storage atomically except
-;; for one exception.  The STORE BYTES, STORE DOUBLE BYTES, and
-;; doubleword loads and stores are not guaranteed to be atomic
-;; when referencing the I/O address space.
-
-;; The kernel cmpxchg operation on linux is not atomic with respect to
-;; memory stores on SMP machines, so we must do stores using a cmpxchg
-;; operation.
-
-;; Implement atomic QImode store using exchange.
-
-(define_expand "atomic_storeqi"
-  [(match_operand:QI 0 "memory_operand")                ;; memory
-   (match_operand:QI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic HImode stores using exchange.
-
-(define_expand "atomic_storehi"
-  [(match_operand:HI 0 "memory_operand")                ;; memory
-   (match_operand:HI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic SImode store using exchange.
-
-(define_expand "atomic_storesi"
-  [(match_operand:SI 0 "memory_operand")                ;; memory
-   (match_operand:SI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic SFmode store using exchange.
-
-(define_expand "atomic_storesf"
-  [(match_operand:SF 0 "memory_operand")                ;; memory
-   (match_operand:SF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic DImode load using 64-bit floating point load.
-
-(define_expand "atomic_loaddi"
-  [(match_operand:DI 0 "register_operand")              ;; val out
-   (match_operand:DI 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  enum memmodel model;
-
-  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=f,r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DI 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DImode store.
-
-(define_expand "atomic_storedi"
-  [(match_operand:DI 0 "memory_operand")                ;; memory
-   (match_operand:DI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  enum memmodel model;
-
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
-  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedi_1"
-  [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DI 1 "register_operand" "f,r"))
-   (clobber (match_scratch:DI 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
-  "@
-   {fstds|fstd} %1,0(%0)
-   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DFmode load using 64-bit floating point load.
-
-(define_expand "atomic_loaddf"
-  [(match_operand:DF 0 "register_operand")              ;; val out
-   (match_operand:DF 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  enum memmodel model;
-
-  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_loaddf_1"
-  [(set (match_operand:DF 0 "register_operand" "=f,r")
-        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DFmode store using 64-bit floating point store.
-
-(define_expand "atomic_storedf"
-  [(match_operand:DF 0 "memory_operand")                ;; memory
-   (match_operand:DF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  enum memmodel model;
-
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
-  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedf_1"
-  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DF 1 "register_operand" "f,r"))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "@
-   {fstds|fstd} %1,0(%0)
-   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
 ;; Compare instructions.
 ;; This controls RTL generation and register allocation.
 
@@ -1410,6 +1179,22 @@
 [(set_attr "type" "multi,multi")
  (set_attr "length" "8,8")])
 
+(define_insn "absqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(abs:QI (match_operand:QI 1 "register_operand" "r")))]
+  ""
+  "{extrs|extrw,s},>= %1,31,8,%0\;subi 0,%0,%0"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "abshi2"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(abs:HI (match_operand:HI 1 "register_operand" "r")))]
+  ""
+  "{extrs|extrw,s},>= %1,31,16,%0\;subi 0,%0,%0"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
 (define_insn "abssi2"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(abs:SI (match_operand:SI 1 "register_operand" "r")))]
@@ -1426,6 +1211,30 @@
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
 
+(define_insn "bswaphi2"
+  [(set (match_operand:HI 0 "register_operand" "=&r")
+	(bswap:HI (match_operand:HI 1 "register_operand" "r")))]
+  ""
+  "{extru|extrw,u} %1,23,8,%0\;{dep|depw} %1,23,8,%0"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "bswapsi2"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "{shd|shrpw} %1,%1,16,%0\;{dep|depw} %0,15,8,%0\;{shd|shrpw} %1,%0,8,%0"
+  [(set_attr "type" "multi")
+   (set_attr "length" "12")])
+
+(define_insn "bswapdi2"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(bswap:DI (match_operand:DI 1 "register_operand" "+r")))]
+  "TARGET_64BIT"
+  "permh,3210 %1,%1\;hshl %1,8,%0\;hshr,u %1,8,%1\;or %0,%1,%0"
+  [(set_attr "type" "multi")
+   (set_attr "length" "16")])
+
 ;;; Experimental conditional move patterns
 
 (define_expand "movsicc"
@@ -10006,3 +9815,238 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "addil LR'%1-$tls_leoff$,%2\;ldo RR'%1-$tls_leoff$(%%r1),%0"
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
+
+;; Atomic instructions
+
+;; All memory loads and stores access storage atomically except
+;; for one exception.  The STORE BYTES, STORE DOUBLE BYTES, and
+;; doubleword loads and stores are not guaranteed to be atomic
+;; when referencing the I/O address space.
+
+;; The kernel cmpxchg operation on linux is not atomic with respect to
+;; memory stores on SMP machines, so we must do stores using a cmpxchg
+;; operation.
+
+;; These patterns are at the bottom so the non atomic versions are preferred.
+
+;; Implement atomic QImode store using exchange.
+
+(define_expand "atomic_storeqi"
+  [(match_operand:QI 0 "memory_operand")                ;; memory
+   (match_operand:QI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic HImode stores using exchange.
+
+(define_expand "atomic_storehi"
+  [(match_operand:HI 0 "memory_operand")                ;; memory
+   (match_operand:HI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic SImode store using exchange.
+
+(define_expand "atomic_storesi"
+  [(match_operand:SI 0 "memory_operand")                ;; memory
+   (match_operand:SI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic SFmode store using exchange.
+
+(define_expand "atomic_storesf"
+  [(match_operand:SF 0 "memory_operand")                ;; memory
+   (match_operand:SF 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic DImode load using 64-bit floating point load.
+
+(define_expand "atomic_loaddi"
+  [(match_operand:DI 0 "register_operand")              ;; val out
+   (match_operand:DI 1 "memory_operand")                ;; memory
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_loaddi_1"
+  [(set (match_operand:DI 0 "register_operand" "=f,r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
+   (clobber (match_scratch:DI 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
+  "@
+   {fldds|fldd} 0(%1),%0
+   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
+
+;; Implement atomic DImode store.
+
+(define_expand "atomic_storedi"
+  [(match_operand:DI 0 "memory_operand")                ;; memory
+   (match_operand:DI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_storedi_1"
+  [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
+        (match_operand:DI 1 "register_operand" "f,r"))
+   (clobber (match_scratch:DI 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
+   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "@
+   {fstds|fstd} %1,0(%0)
+   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
+
+;; Implement atomic DFmode load using 64-bit floating point load.
+
+(define_expand "atomic_loaddf"
+  [(match_operand:DF 0 "register_operand")              ;; val out
+   (match_operand:DF 1 "memory_operand")                ;; memory
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_loaddf_1"
+  [(set (match_operand:DF 0 "register_operand" "=f,r")
+        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
+   (clobber (match_scratch:DF 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
+  "@
+   {fldds|fldd} 0(%1),%0
+   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
+
+;; Implement atomic DFmode store using 64-bit floating point store.
+
+(define_expand "atomic_storedf"
+  [(match_operand:DF 0 "memory_operand")                ;; memory
+   (match_operand:DF 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_storedf_1"
+  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
+        (match_operand:DF 1 "register_operand" "f,r"))
+   (clobber (match_scratch:DF 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
+   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "@
+   {fstds|fstd} %1,0(%0)
+   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index f768402..9bd3359 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -2438,7 +2438,7 @@
 	  (match_operand:VM2 1 "memory_operand" "Z"))
      (unspec [(const_int 0)] UNSPEC_SET_VSCR)])]
   "TARGET_ALTIVEC"
-  "lvx %0,%y1"
+  "lvxl %0,%y1"
   [(set_attr "type" "vecload")])
 
 (define_expand "altivec_lvx_<mode>"
diff --git a/gcc/config/rs6000/freebsd64.h b/gcc/config/rs6000/freebsd64.h
index 9fc929d..cddb9f7 100644
--- a/gcc/config/rs6000/freebsd64.h
+++ b/gcc/config/rs6000/freebsd64.h
@@ -65,6 +65,13 @@ extern int dot_symbols;
 #define INVALID_64BIT "-m%s not supported in this configuration"
 #define INVALID_32BIT INVALID_64BIT
 
+/* Use LINUX64 instead of FREEBSD64 for compat with e.g. sysv4le.h */
+#ifdef LINUX64_DEFAULT_ABI_ELFv2
+#define ELFv2_ABI_CHECK (rs6000_elf_abi != 1)
+#else
+#define ELFv2_ABI_CHECK (rs6000_elf_abi == 2)
+#endif
+
 #undef  SUBSUBTARGET_OVERRIDE_OPTIONS
 #define SUBSUBTARGET_OVERRIDE_OPTIONS				\
   do								\
@@ -84,6 +91,12 @@ extern int dot_symbols;
 	      rs6000_isa_flags &= ~OPTION_MASK_RELOCATABLE;	\
 	      error (INVALID_64BIT, "relocatable");		\
 	    }							\
+	  if (ELFv2_ABI_CHECK)					\
+	    {							\
+	      rs6000_current_abi = ABI_ELFv2;			\
+	      if (dot_symbols)					\
+		error ("-mcall-aixdesc incompatible with -mabi=elfv2"); \
+	    }							\
 	  if (rs6000_isa_flags & OPTION_MASK_EABI)		\
 	    {							\
 	      rs6000_isa_flags &= ~OPTION_MASK_EABI;		\
@@ -154,10 +167,7 @@ extern int dot_symbols;
   { "link_os_freebsd_spec32",	LINK_OS_FREEBSD_SPEC32 },     		\
   { "link_os_freebsd_spec64",	LINK_OS_FREEBSD_SPEC64 },
 
-#define FREEBSD_DYNAMIC_LINKER32 "/libexec/ld-elf32.so.1"
-#define FREEBSD_DYNAMIC_LINKER64 "/libexec/ld-elf.so.1"
-
-#define LINK_OS_FREEBSD_SPEC_DEF32 "\
+#define LINK_OS_FREEBSD_SPEC_DEF "\
   %{p:%nconsider using `-pg' instead of `-p' with gprof(1)} \
   %{v:-V} \
   %{assert*} %{R*} %{rpath*} %{defsym*} \
@@ -165,25 +175,13 @@ extern int dot_symbols;
   %{!shared: \
     %{!static: \
       %{rdynamic: -export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker " FREEBSD_DYNAMIC_LINKER32 "}} \
+      %{!dynamic-linker:-dynamic-linker " FBSD_DYNAMIC_LINKER "}} \
     %{static:-Bstatic}} \
   %{symbolic:-Bsymbolic}"
 
-#define LINK_OS_FREEBSD_SPEC_DEF64 "\
-  %{p:%nconsider using `-pg' instead of `-p' with gprof(1)} \
-  %{v:-V} \
-  %{assert*} %{R*} %{rpath*} %{defsym*} \
-  %{shared:-Bshareable %{h*} %{soname*}} \
-  %{!shared: \
-    %{!static: \
-      %{rdynamic: -export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker " FREEBSD_DYNAMIC_LINKER64 "}} \
-    %{static:-Bstatic}} \
-  %{symbolic:-Bsymbolic}"
-
-#define LINK_OS_FREEBSD_SPEC32 "-melf32ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF32
+#define LINK_OS_FREEBSD_SPEC32 "-melf32ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
   
-#define LINK_OS_FREEBSD_SPEC64 "-melf64ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF64
+#define LINK_OS_FREEBSD_SPEC64 "-melf64ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
 
 #undef	MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS { "m64" }
@@ -304,7 +302,7 @@ extern int dot_symbols;
 
 /* rs6000.h gets this wrong for FreeBSD.  We use the GCC defaults instead.  */
 #undef WCHAR_TYPE
-#define	WCHAR_TYPE      (TARGET_64BIT ? "int" : "long int")
+
 #undef  WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index 3a23dfe..2a52c9c 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -278,20 +278,19 @@
 
 ;; Return 1 if op is a general purpose register that is an even register
 ;; which suitable for a load/store quad operation
+;; Subregs are not allowed here because when they are combine can
+;; create (subreg:PTI (reg:TI pseudo)) which will cause reload to
+;; think the innermost reg needs reloading, in TImode instead of
+;; PTImode.  So reload will choose a reg in TImode which has no
+;; requirement that the reg be even.
 (define_predicate "quad_int_reg_operand"
-  (match_operand 0 "register_operand")
+  (match_code "reg")
 {
   HOST_WIDE_INT r;
 
   if (!TARGET_QUAD_MEMORY && !TARGET_QUAD_MEMORY_ATOMIC)
     return 0;
 
-  if (GET_CODE (op) == SUBREG)
-    op = SUBREG_REG (op);
-
-  if (!REG_P (op))
-    return 0;
-
   r = REGNO (op);
   if (r >= FIRST_PSEUDO_REGISTER)
     return 1;
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index f5c2d42..b870c23 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -20737,6 +20737,12 @@ rs6000_expand_atomic_compare_and_swap (rtx operands[])
   else if (reg_overlap_mentioned_p (retval, oldval))
     oldval = copy_to_reg (oldval);
 
+  if (mode != TImode && !reg_or_short_operand (oldval, mode))
+    oldval = copy_to_mode_reg (mode, oldval);
+
+  if (reg_overlap_mentioned_p (retval, newval))
+    newval = copy_to_reg (newval);
+
   mem = rs6000_pre_atomic_barrier (mem, mod_s);
 
   label1 = NULL_RTX;
@@ -20751,10 +20757,8 @@ rs6000_expand_atomic_compare_and_swap (rtx operands[])
 
   x = retval;
   if (mask)
-    {
-      x = expand_simple_binop (SImode, AND, retval, mask,
-			       NULL_RTX, 1, OPTAB_LIB_WIDEN);
-    }
+    x = expand_simple_binop (SImode, AND, retval, mask,
+			     NULL_RTX, 1, OPTAB_LIB_WIDEN);
 
   cond = gen_reg_rtx (CCmode);
   /* If we have TImode, synthesize a comparison.  */
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index 653c2c9..62029ef 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -121,6 +121,7 @@
 %{mcpu=power8: %(asm_cpu_power8)} \
 %{mcpu=a2: -ma2} \
 %{mcpu=powerpc: -mppc} \
+%{mcpu=powerpc64le: %(asm_cpu_power8)} \
 %{mcpu=rs64a: -mppc64} \
 %{mcpu=401: -mppc} \
 %{mcpu=403: -m403} \
diff --git a/gcc/config/s390/2827.md b/gcc/config/s390/2827.md
index f292046..cd4be14 100644
--- a/gcc/config/s390/2827.md
+++ b/gcc/config/s390/2827.md
@@ -18,20 +18,19 @@
 ;; along with GCC; see the file COPYING3.  If not see
 ;; <http://www.gnu.org/licenses/>.
 
-
-(define_attr "ooo_cracked" ""
+(define_attr "zEC12_cracked" ""
   (cond [(eq_attr "mnemonic" "cgdbr,clfxtr,cdgtr,celfbr,cxgtr,clfebr,clc,lngfr,cs,cfxbr,xc,clfdbr,basr,ex,cxlgtr,clfdtr,srdl,lpgfr,cdlgbr,cgxtr,cxlftr,nc,cxftr,cdfbr,clfxbr,cdftr,clgxbr,cgdtr,cxlgbr,mvc,clgdtr,cegbr,cfebr,cdlftr,sldl,cdlgtr,csg,chhsi,clgebr,cxgbr,cxfbr,cdlfbr,cgebr,lzxr,oc,cdgbr,brasl,cgxbr,cxlfbr,clgxtr,exrl,cfdbr,celgbr,clgdbr,lxr,cpsdr,lcgfr,bras,srda,cefbr") (const_int 1)]
         (const_int 0)))
 
-(define_attr "ooo_expanded" ""
+(define_attr "zEC12_expanded" ""
   (cond [(eq_attr "mnemonic" "dlr,dsgr,d,dsgf,stam,dsgfr,dlgr,dsg,cds,dr,stm,mvc,dl,cdsg,stmy,dlg,stmg,lam") (const_int 1)]
         (const_int 0)))
 
-(define_attr "ooo_endgroup" ""
+(define_attr "zEC12_endgroup" ""
   (cond [(eq_attr "mnemonic" "ipm") (const_int 1)]
         (const_int 0)))
 
-(define_attr "ooo_groupalone" ""
+(define_attr "zEC12_groupalone" ""
   (cond [(eq_attr "mnemonic" "lnxbr,madb,ltxtr,clc,axtr,msebr,slbgr,xc,alcr,lpxbr,slbr,maebr,mlg,mfy,lxdtr,maeb,lxeb,nc,mxtr,sxtr,dxbr,alc,msdbr,ltxbr,lxdb,madbr,lxdbr,lxebr,mvc,m,mseb,mlr,mlgr,slb,tcxb,msdb,sqxbr,alcgr,oc,flogr,alcg,mxbr,dxtr,axbr,mr,sxbr,slbg,ml,lcxbr,bcr_flush") (const_int 1)]
         (const_int 0)))
 
diff --git a/gcc/config/s390/2964.md b/gcc/config/s390/2964.md
new file mode 100644
index 0000000..32102bb
--- /dev/null
+++ b/gcc/config/s390/2964.md
@@ -0,0 +1,231 @@
+;; Scheduling description for z13.
+;;   Copyright (C) 2016 Free Software Foundation, Inc.
+;;   Contributed by Andreas Krebbel (Andreas.Krebbel@de.ibm.com)
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it under
+;; the terms of the GNU General Public License as published by the Free
+;; Software Foundation; either version 3, or (at your option) any later
+;; version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+;; for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+
+; generator options: vector_ecycs=12 cracked_ecycs=6 scale_ecycs=5
+
+(define_attr "z13_cracked" ""
+  (cond [(eq_attr "mnemonic" "celgbr,vscef,vsceg,exrl,clfebr,cefbr,chhsi,\
+vgef,vgeg,cdlftr,lcgfr,cfdbr,cgdbr,lzxr,cfxbr,rnsbg,cgdtr,cegbr,rxsbg,ex,\
+cgxtr,clfxtr,cdlgtr,brasl,efpc,cfebr,tbeginc,celfbr,clgxbr,vsteb,vsteh,\
+clfdtr,cdfbr,lngfr,clgebr,stpq,cs,lpgfr,cdlgbr,lpq,cdgtr,d,cgxbr,cdftr,\
+rosbg,clgdbr,cdgbr,bras,tbegin,clfdbr,cdlfbr,cgebr,clfxbr,lxr,csy,csg,clgdtr,\
+clgxtr") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_expanded" ""
+  (cond [(eq_attr "mnemonic" "cxlftr,cdsg,cdsy,stam,lam,dsgf,lmg,cxlgtr,\
+dl,cxftr,sldl,dsg,cxlfbr,cxgtr,stmg,stmy,stm,lm,cds,lmy,cxfbr,cxlgbr,srda,\
+srdl,cxgbr,dlg") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_groupalone" ""
+  (cond [(eq_attr "mnemonic" "mvc,dxbr,lxebr,axtr,cxtr,alcr,lxdb,lxeb,mxtr,\
+mfy,cxbr,dsgr,lcxbr,slb,mr,dr,alc,slbr,maebr,mlgr,dsgfr,sxtr,tdcxt,tabort,\
+msebr,lxdtr,ltxtr,slbg,ml,mxbr,maeb,oc,dxtr,msdb,sqxbr,mseb,xc,m,clc,mlg,\
+mlr,fixbra,alcgr,nc,sfpc,dlgr,fixbr,slbgr,fixtr,lpxbr,axbr,lxdbr,ltxbr,\
+tcxb,dlr,lnxbr,sxbr,flogr,alcg,tend,madb,bcr_flush") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_endgroup" ""
+  (cond [(eq_attr "mnemonic" "ipm") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_unit_lsu" ""
+  (cond [(eq_attr "mnemonic" "vlbb,mvc,llgc,llc,llhrl,vl,llghrl,vlrepf,\
+vlrepg,vlreph,lde,ldy,tabort,l,llh,ld,lg,ly,vlrepb,vllezb,vllezf,vllezg,\
+vllezh,oc,xc,clc,lrl,ear,nc,lgrl,sfpc,llgf,llgfrl,llgh,llgt,lcbb,vll,sar") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_unit_fxu" ""
+  (cond [(eq_attr "mnemonic" "s,lcgr,x,nop,oiy,ppa,ng,msy,sgrk,vstl,aghik,\
+msgf,ipm,mvi,stocg,rll,srlg,cghsi,clgit,srlk,alrk,sg,sh,sl,st,sy,vst,ark,\
+xgr,agsi,tm,nrk,shy,llhr,agf,alcr,slgfr,sr,clgrt,laa,lder,sgf,lan,llilf,\
+llilh,ag,llill,lay,al,n,laxg,ar,ahi,sgr,ntstg,ay,stcy,nopr,mfy,ngrk,lbr,\
+br,dsgr,stdy,ork,ldgr,lcr,cg,ch,lgfrl,cl,stoc,cr,agfr,stgrl,cy,alfi,xg,\
+cgfi,xi,clfhsi,cgfr,xr,slb,mghi,clfi,slg,clhhsi,agfi,clfit,sly,mr,ldr,nihf,\
+nihh,algfi,dr,nihl,algf,algfr,algr,clgf,clgr,clgt,aghi,alc,alg,locg,alr,\
+locr,cghi,aly,alghsik,slbr,clgfrl,mhy,cit,nr,ny,xiy,mlgr,sthy,cly,dsgfr,\
+rllg,cgit,lgb,lgf,clgrl,lgh,lrvgr,cliy,cgrl,lgr,slrk,clrt,icy,laog,og,agr,\
+mvhi,lhrl,or,lhr,vlvgp,lhy,nilf,oy,nilh,nill,lcdfr,mviy,tmhh,tmhl,sthrl,\
+ltgf,ltgr,srk,clghrl,ahy,vstef,vsteg,ah,vlgvb,llgcr,tmh,tml,clmy,slr,cfi,\
+stc,std,ste,stg,sth,locgr,slbg,sty,tmlh,la,lb,mvghi,lh,risbgn,lrvg,lr,asi,\
+lt,ahik,lrvr,cgf,cgh,cgr,clhrl,lzdr,tmll,mh,ml,vlvgb,ms,lrv,vlvgf,xgrk,\
+vlvgg,llgfr,vlvgh,slfi,chi,chy,mhi,lzer,alhsik,ni,ltgfr,loc,icm,oi,cgfrl,\
+agrk,lgat,oilh,llghr,lghrl,oill,xihf,lpgr,cgrt,clrl,sgfr,lpr,lgbr,strl,\
+algrk,alsi,srak,slgf,a,b,c,slgr,m,o,algsi,icmh,srag,iilf,ogrk,clg,icmy,\
+cli,clm,clr,clt,slgrk,mlg,lao,mlr,risbg,mvhhi,lat,etnd,lax,iihf,sra,alcgr,\
+msgr,clghsi,stey,ngr,xilf,laag,oihf,oihh,oihl,ltg,ltr,niy,lgfi,dlgr,lgfr,\
+slgfi,llcr,slbgr,chrl,lgdr,pfpo,lang,basr,sllg,sllk,lghi,lghr,vlgvf,vlgvg,\
+vlgvh,vlr,chsi,lngr,cghrl,srl,lhi,oilf,crl,crt,afi,xrk,llgtr,llihf,llihh,\
+llihl,dlr,msgfi,msgfr,msg,flogr,xy,msr,clgfi,clgfr,ogr,popcnt,alcg,lndfr,\
+larl,sll,tmy,msfi,ic,lpdfr,tend,lnr") (const_int 1)]
+        (const_int 0)))
+
+(define_attr "z13_unit_vfu" ""
+  (cond [(eq_attr "mnemonic" "seb,vcksm,vfadb,vleib,vchgs,vleif,vleig,vleih,\
+vgbm,verimb,vone,verimf,verimg,verimh,dxbr,verllvb,lpebr,verllvf,verllvg,\
+verllvh,vfeneb,wcdgb,vfenef,vfeneh,vchhs,vctzb,vctzf,vctzg,vctzh,vlcb,aeb,\
+vlcf,vlcg,vlch,vfmsdb,vgfmab,ltebr,vgfmaf,vgfmag,vgfmah,vmaeh,vsb,vsf,vsg,\
+vsh,vsl,vsq,lxebr,cdtr,fiebr,vupllb,vupllf,vupllh,vmrhb,madbr,vtm,vmrhf,\
+vmrhg,vmrhh,axtr,fiebra,vleb,cxtr,vlef,vleg,vleh,vpkf,vpkg,vpkh,vmlob,vmlof,\
+vmloh,lxdb,ldeb,mdtr,vceqfs,adb,wflndb,lxeb,vn,vo,vchlb,vx,mxtr,vchlf,vchlg,\
+vchlh,vfcedbs,vfcedb,vceqgs,cxbr,msdbr,vcdgb,debr,vceqhs,meeb,lcxbr,vavglb,\
+vavglf,vavglg,vavglh,wfcedbs,vmrlb,vmrlf,vmrlg,vmrlh,wfchedbs,vmxb,tcdb,\
+vmahh,vsrlb,wcgdb,lcdbr,vistrbs,vrepb,wfmdb,vrepf,vrepg,vreph,ler,wcdlgb,\
+ley,vistrb,vistrf,vistrh,tceb,wfsqdb,sqeb,vsumqf,vsumqg,vesrlb,vfeezbs,\
+maebr,vesrlf,vesrlg,vesrlh,vmeb,vmef,vmeh,meebr,vflcdb,wfmadb,vperm,sxtr,\
+vclzf,vgm,vgmb,vgmf,vgmg,vgmh,tdcxt,vzero,msebr,veslb,veslf,veslg,vfenezb,\
+vfenezf,vfenezh,vistrfs,vchf,vchg,vchh,vmhb,vmhf,vmhh,cdb,veslvb,ledbr,\
+veslvf,veslvg,veslvh,wclgdb,vfmdb,vmnlb,vmnlf,vmnlg,vmnlh,vclzb,vfeezfs,\
+vclzg,vclzh,mdb,vmxlb,vmxlf,vmxlg,vmxlh,ltdtr,vsbcbiq,ceb,wfddb,sebr,vistrhs,\
+lxdtr,lcebr,vab,vaf,vag,vah,ltxtr,vlpf,vlpg,vsegb,vaq,vsegf,vsegh,wfchdbs,\
+sdtr,cdbr,vfeezhs,le,wldeb,vfmadb,vchlbs,vacccq,vmaleb,vsel,vmalef,vmaleh,\
+vflndb,mdbr,vmlb,wflpdb,ldetr,vpksfs,vpksf,vpksg,vpksh,sqdb,mxbr,sqdbr,\
+vmaeb,veslh,vmaef,vpklsf,vpklsg,vpklsh,verllb,vchb,ddtr,verllf,verllg,verllh,\
+wfsdb,maeb,vclgdb,vftcidb,vpksgs,vmxf,vmxg,vmxh,fidbra,vmnb,vmnf,vmng,vfchedbs,\
+lnebr,vfidb,dxtr,ddb,msdb,vmalhb,vfddb,vmalhf,vmalhh,vpkshs,vfsdb,sqxbr,\
+vmalhw,ltdbr,vmob,vmof,vmoh,deb,vchlfs,mseb,vcdlgb,vlpb,wfmsdb,vlph,vmahb,\
+vldeb,vmahf,vgfmb,fidbr,vfsqdb,aebr,wledb,vchlgs,vesravb,vfchdbs,cebr,vesravf,\
+vesravg,vesravh,vcgdb,fixbra,vrepib,vrepif,vrepig,vrepih,tdcdt,vchlhs,vceqb,\
+vscbib,vceqf,vceqg,vscbif,vscbig,vscbih,vmlhw,vscbiq,vuphb,vuphf,vuphh,\
+vfchedb,tdcet,vslb,vpklsfs,adbr,sqebr,vfchdb,fixbr,vpklsgs,vsldb,vmleb,\
+vmlef,vmleh,cpsdr,vmalb,vmalf,vavgb,vmlf,vavgf,vavgg,vavgh,vgfmf,vgfmg,\
+vgfmh,fidtr,vpklshs,lndbr,vno,lpdbr,vacq,vledb,vchbs,vfeeb,vfeef,vfeeh,\
+fixtr,vaccb,wfadb,vaccf,vaccg,vacch,vnot,vmalob,vaccq,vmalof,vmaloh,lpxbr,\
+ledtr,vuplb,vuplf,axbr,lxdbr,ltxbr,vpopct,vpdi,vmlhb,vmlhf,vmlhh,sdbr,vnc,\
+vsumb,vsrab,vsumh,vmaob,vmaof,vmaoh,vesrlvb,vesrlvf,vesrlvg,vesrlvh,tcxb,\
+vceqbs,vceqh,lnxbr,sxbr,vesrab,wflcdb,vesraf,vesrag,vesrah,vflpdb,vmnh,\
+vsbiq,adtr,vsra,vsrl,vuplhb,sdb,vuplhf,vuplhh,vsumgf,vsumgh,ldebr,vuplhw,\
+vchfs,madb,ddbr") (const_int 1)]
+        (const_int 0)))
+
+(define_insn_reservation "z13_0" 0
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "s,lcgr,x,nop,oiy,vlbb,ppa,ng,sgrk,vstl,aghik,\
+mvc,ipm,llgc,mvi,stocg,rll,jg,srlg,cghsi,clgit,srlk,alrk,sg,sh,sl,st,sy,\
+vst,ark,xgr,agsi,tm,nrk,shy,llhr,agf,alcr,slgfr,sr,clgrt,llc,laa,lder,sgf,\
+lan,llhrl,llilf,llilh,ag,llill,lay,al,n,laxg,ar,ahi,sgr,ntstg,ay,stcy,vl,\
+nopr,ngrk,lbr,br,stdy,ork,ldgr,lcr,cg,ch,llghrl,lgfrl,cl,stoc,cr,agfr,stgrl,\
+cy,alfi,xg,cgfi,xi,vlrepf,vlrepg,vlreph,clfhsi,cgfr,xr,slb,mghi,clfi,slg,\
+lde,clhhsi,agfi,clfit,sly,ldr,ldy,nihf,nihh,algfi,nihl,algf,algfr,algr,\
+clgf,clgr,clgt,aghi,alc,alg,locg,alr,locr,cghi,aly,alghsik,slbr,clgfrl,\
+mhy,cit,nr,ny,xiy,sthy,cly,rllg,cgit,lgb,lgf,clgrl,lgh,lrvgr,cliy,cgrl,\
+lgr,slrk,clrt,icy,laog,og,agr,mvhi,lhrl,or,lhr,vlvgp,lhy,nilf,oy,nilh,tabort,\
+nill,lcdfr,mviy,tmhh,tmhl,sthrl,ltgf,ltgr,srk,clghrl,ahy,vstef,vsteg,ah,\
+vlgvb,llgcr,tmh,tml,clmy,slr,cfi,stc,std,ste,stg,sth,l,locgr,llh,slbg,sty,\
+tmlh,la,lb,ld,mvghi,lg,lh,risbgn,lrvg,lr,asi,lt,ahik,ly,lrvr,vlrepb,vllezb,\
+cgf,cgh,vllezf,vllezg,vllezh,cgr,clhrl,lzdr,tmll,mh,vlvgb,lrv,vlvgf,xgrk,\
+vlvgg,llgfr,vlvgh,slfi,chi,chy,mhi,lzer,alhsik,ni,ltgfr,loc,icm,oc,oi,cgfrl,\
+agrk,lgat,oilh,llghr,lghrl,oill,xihf,lpgr,cgrt,clrl,sgfr,lpr,lgbr,strl,\
+algrk,alsi,srak,brcl,slgf,xc,a,b,c,slgr,j,o,algsi,icmh,srag,iilf,ogrk,clc,\
+clg,icmy,cli,clm,clr,clt,slgrk,lrl,lao,risbg,mvhhi,lat,etnd,lax,iihf,sra,\
+alcgr,clghsi,ear,nc,lgrl,stey,ngr,xilf,laag,oihf,oihh,oihl,ltg,ltr,niy,\
+lgfi,sfpc,lgfr,slgfi,llcr,llgf,llgfrl,llgh,slbgr,llgt,chrl,lgdr,pfpo,lang,\
+basr,lcbb,sllg,sllk,lghi,vll,lghr,vlgvf,vlgvg,vlgvh,vlr,chsi,lngr,cghrl,\
+srl,sar,lhi,oilf,crl,crt,afi,xrk,llgtr,llihf,llihh,llihl,xy,clgfi,clgfr,\
+ogr,popcnt,alcg,lndfr,larl,sll,tmy,ic,lpdfr,tend,lnr,bcr_flush")) "nothing")
+
+(define_insn_reservation "z13_1" 1
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "celgbr,vscef,vsceg,msy,msgf,cxlftr,cdsg,cdsy,\
+exrl,clfebr,cefbr,chhsi,stam,vgef,vgeg,cdlftr,lam,mfy,lcgfr,cfdbr,dsgf,\
+cgdbr,lzxr,lmg,cfxbr,rnsbg,cxlgtr,mr,dl,cxftr,sldl,cgdtr,cegbr,rxsbg,ex,\
+cgxtr,clfxtr,mlgr,cdlgtr,brasl,dsg,efpc,cfebr,tbeginc,celfbr,clgxbr,vsteb,\
+vsteh,cxlfbr,clfdtr,cxgtr,stmg,stmy,stm,lm,cds,cdfbr,ml,ms,lngfr,clgebr,\
+stpq,lmy,cs,lpgfr,cdlgbr,lpq,cxfbr,cxlgbr,cdgtr,d,m,mlg,mlr,cgxbr,cdftr,\
+msgr,rosbg,clgdbr,cdgbr,srda,bras,srdl,tbegin,clfdbr,cdlfbr,cxgbr,cgebr,\
+dlg,clfxbr,lxr,csy,msgfi,msgfr,msg,flogr,msr,csg,msfi,clgdtr,clgxtr")) "nothing")
+
+(define_insn_reservation "z13_2" 2
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "seb,vcksm,vfadb,vleib,vchgs,vleif,vleig,vleih,\
+vgbm,verimb,vone,verimf,verimg,verimh,verllvb,lpebr,verllvf,verllvg,verllvh,\
+vfeneb,wcdgb,vfenef,vfeneh,vchhs,vctzb,vctzf,vctzg,vctzh,vlcb,aeb,vlcf,\
+vlcg,vlch,vfmsdb,vgfmab,ltebr,vgfmaf,vgfmag,vgfmah,vmaeh,vsb,vsf,vsg,vsh,\
+vsl,vsq,lxebr,cdtr,fiebr,vupllb,vupllf,vupllh,vmrhb,madbr,vtm,vmrhf,vmrhg,\
+vmrhh,axtr,fiebra,vleb,cxtr,vlef,vleg,vleh,vpkf,vpkg,vpkh,vmlob,vmlof,vmloh,\
+lxdb,ldeb,vceqfs,adb,wflndb,lxeb,vn,vo,vchlb,vx,vchlf,vchlg,vchlh,vfcedbs,\
+vfcedb,vceqgs,cxbr,msdbr,vcdgb,vceqhs,meeb,lcxbr,vavglb,vavglf,vavglg,vavglh,\
+wfcedbs,vmrlb,vmrlf,vmrlg,vmrlh,wfchedbs,vmxb,tcdb,vmahh,vsrlb,wcgdb,lcdbr,\
+vistrbs,vrepb,wfmdb,vrepf,vrepg,vreph,ler,wcdlgb,ley,vistrb,vistrf,vistrh,\
+tceb,vsumqf,vsumqg,vesrlb,vfeezbs,maebr,vesrlf,vesrlg,vesrlh,vmeb,vmef,\
+vmeh,meebr,vflcdb,wfmadb,vperm,sxtr,vclzf,vgm,vgmb,vgmf,vgmg,vgmh,tdcxt,\
+vzero,msebr,veslb,veslf,veslg,vfenezb,vfenezf,vfenezh,vistrfs,vchf,vchg,\
+vchh,vmhb,vmhf,vmhh,cdb,veslvb,ledbr,veslvf,veslvg,veslvh,wclgdb,vfmdb,\
+vmnlb,vmnlf,vmnlg,vmnlh,vclzb,vfeezfs,vclzg,vclzh,mdb,vmxlb,vmxlf,vmxlg,\
+vmxlh,ltdtr,vsbcbiq,ceb,sebr,vistrhs,lxdtr,lcebr,vab,vaf,vag,vah,ltxtr,\
+vlpf,vlpg,vsegb,vaq,vsegf,vsegh,wfchdbs,sdtr,cdbr,vfeezhs,le,wldeb,vfmadb,\
+vchlbs,vacccq,vmaleb,vsel,vmalef,vmaleh,vflndb,mdbr,vmlb,wflpdb,ldetr,vpksfs,\
+vpksf,vpksg,vpksh,vmaeb,veslh,vmaef,vpklsf,vpklsg,vpklsh,verllb,vchb,verllf,\
+verllg,verllh,wfsdb,maeb,vclgdb,vftcidb,vpksgs,vmxf,vmxg,vmxh,fidbra,vmnb,\
+vmnf,vmng,vfchedbs,lnebr,vfidb,msdb,vmalhb,vmalhf,vmalhh,vpkshs,vfsdb,vmalhw,\
+ltdbr,vmob,vmof,vmoh,vchlfs,mseb,vcdlgb,vlpb,wfmsdb,vlph,vmahb,vldeb,vmahf,\
+vgfmb,fidbr,aebr,wledb,vchlgs,vesravb,vfchdbs,cebr,vesravf,vesravg,vesravh,\
+vcgdb,fixbra,vrepib,vrepif,vrepig,vrepih,tdcdt,vchlhs,vceqb,vscbib,vceqf,\
+vceqg,vscbif,vscbig,vscbih,vmlhw,vscbiq,vuphb,vuphf,vuphh,vfchedb,tdcet,\
+vslb,vpklsfs,adbr,vfchdb,fixbr,vpklsgs,vsldb,vmleb,vmlef,vmleh,cpsdr,vmalb,\
+vmalf,vavgb,vmlf,vavgf,vavgg,vavgh,vgfmf,vgfmg,vgfmh,fidtr,vpklshs,lndbr,\
+vno,lpdbr,vacq,vledb,vchbs,vfeeb,vfeef,vfeeh,fixtr,vaccb,wfadb,vaccf,vaccg,\
+vacch,vnot,vmalob,vaccq,vmalof,vmaloh,lpxbr,vuplb,vuplf,axbr,lxdbr,ltxbr,\
+vpopct,vpdi,vmlhb,vmlhf,vmlhh,sdbr,vnc,vsumb,vsrab,vsumh,vmaob,vmaof,vmaoh,\
+vesrlvb,vesrlvf,vesrlvg,vesrlvh,tcxb,vceqbs,vceqh,lnxbr,sxbr,vesrab,wflcdb,\
+vesraf,vesrag,vesrah,vflpdb,vmnh,vsbiq,adtr,vsra,vsrl,vuplhb,sdb,vuplhf,\
+vuplhh,vsumgf,vsumgh,ldebr,vuplhw,vchfs,madb")) "nothing")
+
+(define_insn_reservation "z13_3" 3
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "ledtr")) "nothing")
+
+(define_insn_reservation "z13_4" 4
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "dr,mxbr,dlr")) "nothing")
+
+(define_insn_reservation "z13_6" 6
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "debr,sqeb,deb,sqebr")) "nothing")
+
+(define_insn_reservation "z13_7" 7
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "mdtr")) "nothing")
+
+(define_insn_reservation "z13_8" 8
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "wfddb,ddb,vfddb,ddbr")) "nothing")
+
+(define_insn_reservation "z13_9" 9
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "dsgr,wfsqdb,dsgfr,sqdb,sqdbr,vfsqdb")) "nothing")
+
+(define_insn_reservation "z13_13" 13
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "mxtr,ddtr")) "nothing")
+
+(define_insn_reservation "z13_16" 16
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "sqxbr")) "nothing")
+
+(define_insn_reservation "z13_17" 17
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "dxtr")) "nothing")
+
+(define_insn_reservation "z13_20" 20
+  (and (eq_attr "cpu" "z13")
+       (eq_attr "mnemonic" "dxbr,dlgr")) "nothing")
diff --git a/gcc/config/s390/constraints.md b/gcc/config/s390/constraints.md
index 66d4ace..8b95206 100644
--- a/gcc/config/s390/constraints.md
+++ b/gcc/config/s390/constraints.md
@@ -34,6 +34,8 @@
 ;;         jm1: constant scalar or vector with all bits set
 ;;         jxx: contiguous bitmask of 0 or 1 in all vector elements
 ;;         jyy: constant consisting of byte chunks being either 0 or 0xff
+;;         jKK: constant vector with all elements having the same value and
+;;              matching K constraint
 ;;    t -- Access registers 36 and 37.
 ;;    v -- Vector registers v0-v31.
 ;;    C -- A signed 8-bit constant (-128..127)
@@ -108,23 +110,6 @@
   "FP_REGS"
   "Floating point registers")
 
-(define_constraint "j00"
-  "Zero scalar or vector constant"
-  (match_test "op == CONST0_RTX (GET_MODE (op))"))
-
-(define_constraint "jm1"
-  "All one bit scalar or vector constant"
-  (match_test "op == CONSTM1_RTX (GET_MODE (op))"))
-
-(define_constraint "jxx"
-  "@internal"
-  (and (match_code "const_vector")
-       (match_test "s390_contiguous_bitmask_vector_p (op, NULL, NULL)")))
-
-(define_constraint "jyy"
-  "@internal"
-  (and (match_code "const_vector")
-       (match_test "s390_bytemask_vector_p (op, NULL)")))
 
 (define_register_constraint "t"
   "ACCESS_REGS"
@@ -402,6 +387,33 @@
        (match_test "s390_O_constraint_str ('n', ival)")))
 
 
+;;
+;; Vector constraints follow.
+;;
+
+(define_constraint "j00"
+  "Zero scalar or vector constant"
+  (match_test "op == CONST0_RTX (GET_MODE (op))"))
+
+(define_constraint "jm1"
+  "All one bit scalar or vector constant"
+  (match_test "op == CONSTM1_RTX (GET_MODE (op))"))
+
+(define_constraint "jxx"
+  "@internal"
+  (and (match_code "const_vector")
+       (match_test "s390_contiguous_bitmask_vector_p (op, NULL, NULL)")))
+
+(define_constraint "jyy"
+  "@internal"
+  (and (match_code "const_vector")
+       (match_test "s390_bytemask_vector_p (op, NULL)")))
+
+(define_constraint "jKK"
+  "@internal"
+  (and (and (match_code "const_vector")
+	    (match_test "s390_const_vec_duplicate_p (op)"))
+       (match_test "satisfies_constraint_K (XVECEXP (op, 0, 0))")))
 
 
 ;;
diff --git a/gcc/config/s390/predicates.md b/gcc/config/s390/predicates.md
index 46619b9..8dc351e 100644
--- a/gcc/config/s390/predicates.md
+++ b/gcc/config/s390/predicates.md
@@ -29,11 +29,17 @@
   (and (match_code "const_int,const_double,const_vector")
        (match_test "op == CONST0_RTX (mode)")))
 
-;; Return true if OP an all ones operand (int/float/vector).
-(define_predicate "constm1_operand"
-  (and (match_code "const_int, const_double,const_vector")
+;; Return true if OP an all ones operand (int/vector).
+(define_predicate "all_ones_operand"
+  (and (match_code "const_int, const_double, const_vector")
+       (match_test "INTEGRAL_MODE_P (GET_MODE (op))")
        (match_test "op == CONSTM1_RTX (mode)")))
 
+;; Return true if OP is a 4 bit mask operand
+(define_predicate "const_mask_operand"
+  (and (match_code "const_int")
+       (match_test "UINTVAL (op) < 16")))
+
 ;; Return true if OP is constant.
 
 (define_special_predicate "consttable_operand"
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
index 245d538..bd3d534 100644
--- a/gcc/config/s390/s390-builtin-types.def
+++ b/gcc/config/s390/s390-builtin-types.def
@@ -58,695 +58,698 @@
 	       s390_builtin_types[T4],				\
 	       s390_builtin_types[T5],				\
 	       s390_builtin_types[T6])
-DEF_TYPE (BT_DBL, B_VX, double_type_node, 0)
-DEF_TYPE (BT_DBLCONST, B_VX, double_type_node, 1)
-DEF_TYPE (BT_FLT, B_VX, float_type_node, 0)
+DEF_TYPE (BT_INT, B_HTM | B_VX, integer_type_node, 0)
+DEF_TYPE (BT_VOID, 0, void_type_node, 0)
 DEF_TYPE (BT_FLTCONST, B_VX, float_type_node, 1)
+DEF_TYPE (BT_UINT64, B_HTM, c_uint64_type_node, 0)
+DEF_TYPE (BT_FLT, B_VX, float_type_node, 0)
+DEF_TYPE (BT_UINT, 0, unsigned_type_node, 0)
+DEF_TYPE (BT_VOIDCONST, B_VX, void_type_node, 1)
+DEF_TYPE (BT_ULONG, B_VX, long_unsigned_type_node, 0)
+DEF_TYPE (BT_USHORTCONST, B_VX, short_unsigned_type_node, 1)
+DEF_TYPE (BT_SHORTCONST, B_VX, short_integer_type_node, 1)
 DEF_TYPE (BT_INTCONST, B_VX, integer_type_node, 1)
-DEF_TYPE (BT_INT, B_HTM | B_VX, integer_type_node, 0)
-DEF_TYPE (BT_LONGLONGCONST, B_VX, long_long_integer_type_node, 1)
-DEF_TYPE (BT_LONGLONG, B_VX, long_long_integer_type_node, 0)
-DEF_TYPE (BT_LONG, B_VX, long_integer_type_node, 0)
+DEF_TYPE (BT_UCHARCONST, B_VX, unsigned_char_type_node, 1)
 DEF_TYPE (BT_UCHAR, B_VX, unsigned_char_type_node, 0)
-DEF_TYPE (BT_SCHAR, B_VX, signed_char_type_node, 0)
 DEF_TYPE (BT_SCHARCONST, B_VX, signed_char_type_node, 1)
-DEF_TYPE (BT_SHORTCONST, B_VX, short_integer_type_node, 1)
 DEF_TYPE (BT_SHORT, B_VX, short_integer_type_node, 0)
-DEF_TYPE (BT_UINT, 0, unsigned_type_node, 0)
-DEF_TYPE (BT_UINT64, B_HTM, c_uint64_type_node, 0)
-DEF_TYPE (BT_UCHARCONST, B_VX, unsigned_char_type_node, 1)
-DEF_TYPE (BT_UINTCONST, B_VX, unsigned_type_node, 1)
+DEF_TYPE (BT_LONG, B_VX, long_integer_type_node, 0)
+DEF_TYPE (BT_SCHAR, B_VX, signed_char_type_node, 0)
 DEF_TYPE (BT_ULONGLONGCONST, B_VX, long_long_unsigned_type_node, 1)
-DEF_TYPE (BT_USHORTCONST, B_VX, short_unsigned_type_node, 1)
-DEF_TYPE (BT_VOIDCONST, B_VX, void_type_node, 1)
-DEF_TYPE (BT_VOID, 0, void_type_node, 0)
-DEF_TYPE (BT_ULONG, B_VX, long_unsigned_type_node, 0)
-DEF_TYPE (BT_ULONGLONG, B_VX, long_long_unsigned_type_node, 0)
 DEF_TYPE (BT_USHORT, B_VX, short_unsigned_type_node, 0)
-DEF_DISTINCT_TYPE (BT_BCHAR, B_VX, BT_UCHAR)
-DEF_DISTINCT_TYPE (BT_BINT, B_VX, BT_UINT)
-DEF_DISTINCT_TYPE (BT_BLONGLONG, B_VX, BT_ULONGLONG)
-DEF_DISTINCT_TYPE (BT_BSHORT, B_VX, BT_USHORT)
-DEF_POINTER_TYPE (BT_DBLPTR, B_VX, BT_DBL)
+DEF_TYPE (BT_LONGLONG, B_VX, long_long_integer_type_node, 0)
+DEF_TYPE (BT_DBLCONST, B_VX, double_type_node, 1)
+DEF_TYPE (BT_ULONGLONG, B_VX, long_long_unsigned_type_node, 0)
+DEF_TYPE (BT_DBL, B_VX, double_type_node, 0)
+DEF_TYPE (BT_LONGLONGCONST, B_VX, long_long_integer_type_node, 1)
+DEF_TYPE (BT_UINTCONST, B_VX, unsigned_type_node, 1)
+DEF_VECTOR_TYPE (BT_UV2DI, B_VX, BT_ULONGLONG, 2)
+DEF_VECTOR_TYPE (BT_V4SI, B_VX, BT_INT, 4)
+DEF_VECTOR_TYPE (BT_V8HI, B_VX, BT_SHORT, 8)
+DEF_VECTOR_TYPE (BT_UV4SI, B_VX, BT_UINT, 4)
+DEF_VECTOR_TYPE (BT_V16QI, B_VX, BT_SCHAR, 16)
+DEF_VECTOR_TYPE (BT_V2DF, B_VX, BT_DBL, 2)
+DEF_VECTOR_TYPE (BT_V2DI, B_VX, BT_LONGLONG, 2)
+DEF_VECTOR_TYPE (BT_UV8HI, B_VX, BT_USHORT, 8)
+DEF_VECTOR_TYPE (BT_UV16QI, B_VX, BT_UCHAR, 16)
+DEF_POINTER_TYPE (BT_UCHARPTR, B_VX, BT_UCHAR)
 DEF_POINTER_TYPE (BT_DBLCONSTPTR, B_VX, BT_DBLCONST)
+DEF_POINTER_TYPE (BT_VOIDPTR, B_HTM | B_VX, BT_VOID)
 DEF_POINTER_TYPE (BT_FLTPTR, B_VX, BT_FLT)
-DEF_POINTER_TYPE (BT_FLTCONSTPTR, B_VX, BT_FLTCONST)
-DEF_POINTER_TYPE (BT_INTCONSTPTR, B_VX, BT_INTCONST)
-DEF_POINTER_TYPE (BT_INTPTR, B_VX, BT_INT)
-DEF_POINTER_TYPE (BT_LONGLONGCONSTPTR, B_VX, BT_LONGLONGCONST)
-DEF_POINTER_TYPE (BT_LONGLONGPTR, B_VX, BT_LONGLONG)
-DEF_POINTER_TYPE (BT_SCHARCONSTPTR, B_VX, BT_SCHARCONST)
+DEF_POINTER_TYPE (BT_UINT64PTR, B_HTM, BT_UINT64)
 DEF_POINTER_TYPE (BT_SCHARPTR, B_VX, BT_SCHAR)
-DEF_POINTER_TYPE (BT_SHORTCONSTPTR, B_VX, BT_SHORTCONST)
-DEF_POINTER_TYPE (BT_SHORTPTR, B_VX, BT_SHORT)
-DEF_POINTER_TYPE (BT_UCHARCONSTPTR, B_VX, BT_UCHARCONST)
-DEF_POINTER_TYPE (BT_UCHARPTR, B_VX, BT_UCHAR)
-DEF_POINTER_TYPE (BT_UINTPTR, B_VX, BT_UINT)
 DEF_POINTER_TYPE (BT_UINTCONSTPTR, B_VX, BT_UINTCONST)
-DEF_POINTER_TYPE (BT_UINT64PTR, B_HTM, BT_UINT64)
 DEF_POINTER_TYPE (BT_ULONGLONGCONSTPTR, B_VX, BT_ULONGLONGCONST)
-DEF_POINTER_TYPE (BT_ULONGLONGPTR, B_VX, BT_ULONGLONG)
+DEF_POINTER_TYPE (BT_LONGLONGCONSTPTR, B_VX, BT_LONGLONGCONST)
+DEF_POINTER_TYPE (BT_SHORTPTR, B_VX, BT_SHORT)
 DEF_POINTER_TYPE (BT_USHORTPTR, B_VX, BT_USHORT)
-DEF_POINTER_TYPE (BT_USHORTCONSTPTR, B_VX, BT_USHORTCONST)
-DEF_POINTER_TYPE (BT_VOIDPTR, B_HTM | B_VX, BT_VOID)
+DEF_POINTER_TYPE (BT_INTPTR, B_VX, BT_INT)
+DEF_POINTER_TYPE (BT_INTCONSTPTR, B_VX, BT_INTCONST)
+DEF_POINTER_TYPE (BT_LONGLONGPTR, B_VX, BT_LONGLONG)
+DEF_POINTER_TYPE (BT_ULONGLONGPTR, B_VX, BT_ULONGLONG)
+DEF_POINTER_TYPE (BT_DBLPTR, B_VX, BT_DBL)
 DEF_POINTER_TYPE (BT_VOIDCONSTPTR, B_VX, BT_VOIDCONST)
-DEF_VECTOR_TYPE (BT_V16QI, B_VX, BT_SCHAR, 16)
-DEF_VECTOR_TYPE (BT_V2DI, B_VX, BT_LONGLONG, 2)
-DEF_VECTOR_TYPE (BT_V2DF, B_VX, BT_DBL, 2)
-DEF_VECTOR_TYPE (BT_V4SI, B_VX, BT_INT, 4)
-DEF_VECTOR_TYPE (BT_V8HI, B_VX, BT_SHORT, 8)
-DEF_VECTOR_TYPE (BT_UV16QI, B_VX, BT_UCHAR, 16)
-DEF_VECTOR_TYPE (BT_UV2DI, B_VX, BT_ULONGLONG, 2)
-DEF_VECTOR_TYPE (BT_UV4SI, B_VX, BT_UINT, 4)
-DEF_VECTOR_TYPE (BT_UV8HI, B_VX, BT_USHORT, 8)
+DEF_POINTER_TYPE (BT_USHORTCONSTPTR, B_VX, BT_USHORTCONST)
+DEF_POINTER_TYPE (BT_SHORTCONSTPTR, B_VX, BT_SHORTCONST)
+DEF_POINTER_TYPE (BT_UCHARCONSTPTR, B_VX, BT_UCHARCONST)
+DEF_POINTER_TYPE (BT_FLTCONSTPTR, B_VX, BT_FLTCONST)
+DEF_POINTER_TYPE (BT_SCHARCONSTPTR, B_VX, BT_SCHARCONST)
+DEF_POINTER_TYPE (BT_UINTPTR, B_VX, BT_UINT)
+DEF_DISTINCT_TYPE (BT_BLONGLONG, B_VX, BT_ULONGLONG)
+DEF_DISTINCT_TYPE (BT_BINT, B_VX, BT_UINT)
+DEF_DISTINCT_TYPE (BT_BSHORT, B_VX, BT_USHORT)
+DEF_DISTINCT_TYPE (BT_BCHAR, B_VX, BT_UCHAR)
 DEF_OPAQUE_VECTOR_TYPE (BT_OV2DI, B_VX, BT_LONGLONG, 2)
+DEF_OPAQUE_VECTOR_TYPE (BT_BV16QI, B_VX, BT_BCHAR, 16)
 DEF_OPAQUE_VECTOR_TYPE (BT_OV4SI, B_VX, BT_INT, 4)
 DEF_OPAQUE_VECTOR_TYPE (BT_OUV4SI, B_VX, BT_UINT, 4)
-DEF_OPAQUE_VECTOR_TYPE (BT_BV16QI, B_VX, BT_BCHAR, 16)
-DEF_OPAQUE_VECTOR_TYPE (BT_BV2DI, B_VX, BT_BLONGLONG, 2)
 DEF_OPAQUE_VECTOR_TYPE (BT_BV4SI, B_VX, BT_BINT, 4)
+DEF_OPAQUE_VECTOR_TYPE (BT_BV2DI, B_VX, BT_BLONGLONG, 2)
 DEF_OPAQUE_VECTOR_TYPE (BT_BV8HI, B_VX, BT_BSHORT, 8)
-DEF_FN_TYPE_1 (BT_FN_UINT, 0, BT_UINT)
 DEF_FN_TYPE_1 (BT_FN_INT, B_HTM, BT_INT)
-DEF_FN_TYPE_2 (BT_FN_VOID_UINT, 0, BT_VOID, BT_UINT)
-DEF_FN_TYPE_2 (BT_FN_VOID_INT, B_HTM, BT_VOID, BT_INT)
+DEF_FN_TYPE_1 (BT_FN_UINT, 0, BT_UINT)
 DEF_FN_TYPE_2 (BT_FN_INT_INT, B_VX, BT_INT, BT_INT)
 DEF_FN_TYPE_2 (BT_FN_INT_VOIDPTR, B_HTM, BT_INT, BT_VOIDPTR)
+DEF_FN_TYPE_2 (BT_FN_OV4SI_INT, B_VX, BT_OV4SI, BT_INT)
+DEF_FN_TYPE_2 (BT_FN_OV4SI_INTCONSTPTR, B_VX, BT_OV4SI, BT_INTCONSTPTR)
+DEF_FN_TYPE_2 (BT_FN_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI)
+DEF_FN_TYPE_2 (BT_FN_UV16QI_UCHAR, B_VX, BT_UV16QI, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_UV16QI_UCHARCONSTPTR, B_VX, BT_UV16QI, BT_UCHARCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_UV16QI_USHORT, B_VX, BT_UV16QI, BT_USHORT)
-DEF_FN_TYPE_2 (BT_FN_UV16QI_UCHAR, B_VX, BT_UV16QI, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_UV16QI_UV16QI, B_VX, BT_UV16QI, BT_UV16QI)
 DEF_FN_TYPE_2 (BT_FN_UV2DI_ULONGLONG, B_VX, BT_UV2DI, BT_ULONGLONG)
 DEF_FN_TYPE_2 (BT_FN_UV2DI_ULONGLONGCONSTPTR, B_VX, BT_UV2DI, BT_ULONGLONGCONSTPTR)
+DEF_FN_TYPE_2 (BT_FN_UV2DI_USHORT, B_VX, BT_UV2DI, BT_USHORT)
 DEF_FN_TYPE_2 (BT_FN_UV2DI_UV2DI, B_VX, BT_UV2DI, BT_UV2DI)
 DEF_FN_TYPE_2 (BT_FN_UV2DI_UV4SI, B_VX, BT_UV2DI, BT_UV4SI)
-DEF_FN_TYPE_2 (BT_FN_OV4SI_INTCONSTPTR, B_VX, BT_OV4SI, BT_INTCONSTPTR)
-DEF_FN_TYPE_2 (BT_FN_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_2 (BT_FN_OV4SI_INT, B_VX, BT_OV4SI, BT_INT)
-DEF_FN_TYPE_2 (BT_FN_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI)
+DEF_FN_TYPE_2 (BT_FN_UV4SI_UINT, B_VX, BT_UV4SI, BT_UINT)
 DEF_FN_TYPE_2 (BT_FN_UV4SI_UINTCONSTPTR, B_VX, BT_UV4SI, BT_UINTCONSTPTR)
+DEF_FN_TYPE_2 (BT_FN_UV4SI_USHORT, B_VX, BT_UV4SI, BT_USHORT)
+DEF_FN_TYPE_2 (BT_FN_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_2 (BT_FN_UV4SI_UV8HI, B_VX, BT_UV4SI, BT_UV8HI)
-DEF_FN_TYPE_2 (BT_FN_UV4SI_UINT, B_VX, BT_UV4SI, BT_UINT)
 DEF_FN_TYPE_2 (BT_FN_UV8HI_USHORT, B_VX, BT_UV8HI, BT_USHORT)
+DEF_FN_TYPE_2 (BT_FN_UV8HI_USHORTCONSTPTR, B_VX, BT_UV8HI, BT_USHORTCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_UV8HI_UV16QI, B_VX, BT_UV8HI, BT_UV16QI)
 DEF_FN_TYPE_2 (BT_FN_UV8HI_UV8HI, B_VX, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_2 (BT_FN_UV8HI_USHORTCONSTPTR, B_VX, BT_UV8HI, BT_USHORTCONSTPTR)
+DEF_FN_TYPE_2 (BT_FN_V16QI_SCHAR, B_VX, BT_V16QI, BT_SCHAR)
 DEF_FN_TYPE_2 (BT_FN_V16QI_UCHAR, B_VX, BT_V16QI, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_V16QI_V16QI, B_VX, BT_V16QI, BT_V16QI)
+DEF_FN_TYPE_2 (BT_FN_V2DF_DBL, B_VX, BT_V2DF, BT_DBL)
+DEF_FN_TYPE_2 (BT_FN_V2DF_FLTCONSTPTR, B_VX, BT_V2DF, BT_FLTCONSTPTR)
+DEF_FN_TYPE_2 (BT_FN_V2DF_V2DF, B_VX, BT_V2DF, BT_V2DF)
+DEF_FN_TYPE_2 (BT_FN_V2DI_SHORT, B_VX, BT_V2DI, BT_SHORT)
 DEF_FN_TYPE_2 (BT_FN_V2DI_V16QI, B_VX, BT_V2DI, BT_V16QI)
 DEF_FN_TYPE_2 (BT_FN_V2DI_V2DI, B_VX, BT_V2DI, BT_V2DI)
-DEF_FN_TYPE_2 (BT_FN_V2DI_SHORT, B_VX, BT_V2DI, BT_SHORT)
-DEF_FN_TYPE_2 (BT_FN_V2DF_V2DF, B_VX, BT_V2DF, BT_V2DF)
-DEF_FN_TYPE_2 (BT_FN_V2DI_V8HI, B_VX, BT_V2DI, BT_V8HI)
-DEF_FN_TYPE_2 (BT_FN_V2DF_FLTCONSTPTR, B_VX, BT_V2DF, BT_FLTCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_V2DI_V4SI, B_VX, BT_V2DI, BT_V4SI)
-DEF_FN_TYPE_2 (BT_FN_V2DF_DBL, B_VX, BT_V2DF, BT_DBL)
-DEF_FN_TYPE_2 (BT_FN_V4SI_V8HI, B_VX, BT_V4SI, BT_V8HI)
-DEF_FN_TYPE_2 (BT_FN_V4SI_V4SI, B_VX, BT_V4SI, BT_V4SI)
+DEF_FN_TYPE_2 (BT_FN_V2DI_V8HI, B_VX, BT_V2DI, BT_V8HI)
 DEF_FN_TYPE_2 (BT_FN_V4SI_SHORT, B_VX, BT_V4SI, BT_SHORT)
+DEF_FN_TYPE_2 (BT_FN_V4SI_V4SI, B_VX, BT_V4SI, BT_V4SI)
+DEF_FN_TYPE_2 (BT_FN_V4SI_V8HI, B_VX, BT_V4SI, BT_V8HI)
+DEF_FN_TYPE_2 (BT_FN_V8HI_SHORT, B_VX, BT_V8HI, BT_SHORT)
 DEF_FN_TYPE_2 (BT_FN_V8HI_V16QI, B_VX, BT_V8HI, BT_V16QI)
 DEF_FN_TYPE_2 (BT_FN_V8HI_V8HI, B_VX, BT_V8HI, BT_V8HI)
-DEF_FN_TYPE_2 (BT_FN_V8HI_SHORT, B_VX, BT_V8HI, BT_SHORT)
-DEF_FN_TYPE_3 (BT_FN_INT_V2DI_V2DI, B_VX, BT_INT, BT_V2DI, BT_V2DI)
+DEF_FN_TYPE_2 (BT_FN_VOID_INT, B_HTM, BT_VOID, BT_INT)
+DEF_FN_TYPE_2 (BT_FN_VOID_UINT, 0, BT_VOID, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_DBL_V2DF_INT, B_VX, BT_DBL, BT_V2DF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_INT_OV4SI_INT, B_VX, BT_INT, BT_OV4SI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_INT_OV4SI_OV4SI, B_VX, BT_INT, BT_OV4SI, BT_OV4SI)
-DEF_FN_TYPE_3 (BT_FN_INT_V2DF_V2DF, B_VX, BT_INT, BT_V2DF, BT_V2DF)
-DEF_FN_TYPE_3 (BT_FN_USHORT_UV8HI_INT, B_VX, BT_USHORT, BT_UV8HI, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_INT_UV16QI_UV16QI, B_VX, BT_INT, BT_UV16QI, BT_UV16QI)
 DEF_FN_TYPE_3 (BT_FN_INT_UV2DI_UV2DI, B_VX, BT_INT, BT_UV2DI, BT_UV2DI)
-DEF_FN_TYPE_3 (BT_FN_ULONGLONG_UV2DI_INT, B_VX, BT_ULONGLONG, BT_UV2DI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_INT_UV4SI_UV4SI, B_VX, BT_INT, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_UCHAR_UV16QI_INT, B_VX, BT_UCHAR, BT_UV16QI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_INT_UV8HI_UV8HI, B_VX, BT_INT, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_3 (BT_FN_INT_V4SI_V4SI, B_VX, BT_INT, BT_V4SI, BT_V4SI)
-DEF_FN_TYPE_3 (BT_FN_INT_UV16QI_UV16QI, B_VX, BT_INT, BT_UV16QI, BT_UV16QI)
 DEF_FN_TYPE_3 (BT_FN_INT_V16QI_V16QI, B_VX, BT_INT, BT_V16QI, BT_V16QI)
-DEF_FN_TYPE_3 (BT_FN_INT_VOIDPTR_INT, B_HTM, BT_INT, BT_VOIDPTR, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_DBL_V2DF_INT, B_VX, BT_DBL, BT_V2DF, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_VOID_UINT64PTR_UINT64, B_HTM, BT_VOID, BT_UINT64PTR, BT_UINT64)
+DEF_FN_TYPE_3 (BT_FN_INT_V2DF_V2DF, B_VX, BT_INT, BT_V2DF, BT_V2DF)
+DEF_FN_TYPE_3 (BT_FN_INT_V2DI_V2DI, B_VX, BT_INT, BT_V2DI, BT_V2DI)
+DEF_FN_TYPE_3 (BT_FN_INT_V4SI_V4SI, B_VX, BT_INT, BT_V4SI, BT_V4SI)
 DEF_FN_TYPE_3 (BT_FN_INT_V8HI_V8HI, B_VX, BT_INT, BT_V8HI, BT_V8HI)
-DEF_FN_TYPE_3 (BT_FN_UINT_VOIDCONSTPTR_INT, B_VX, BT_UINT, BT_VOIDCONSTPTR, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_INT_OV4SI_INT, B_VX, BT_INT, BT_OV4SI, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_VOID_V2DF_FLTPTR, B_VX, BT_VOID, BT_V2DF, BT_FLTPTR)
+DEF_FN_TYPE_3 (BT_FN_INT_VOIDPTR_INT, B_HTM, BT_INT, BT_VOIDPTR, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_OV2DI_LONGLONG_LONGLONG, B_VX, BT_OV2DI, BT_LONGLONG, BT_LONGLONG)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_INTCONSTPTR_INT, B_VX, BT_OV4SI, BT_INTCONSTPTR, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_INTCONSTPTR_UINT, B_VX, BT_OV4SI, BT_INTCONSTPTR, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_INT_INT, B_VX, BT_OV4SI, BT_INT, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_INTPTR)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_UCHAR)
+DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_ULONG, B_VX, BT_OV4SI, BT_OV4SI, BT_ULONG)
+DEF_FN_TYPE_3 (BT_FN_UCHAR_UV16QI_INT, B_VX, BT_UCHAR, BT_UV16QI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_UINT_UV4SI_INT, B_VX, BT_UINT, BT_UV4SI, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV8HI_UV8HI, B_VX, BT_UV16QI, BT_UV8HI, BT_UV8HI)
+DEF_FN_TYPE_3 (BT_FN_UINT_VOIDCONSTPTR_INT, B_VX, BT_UINT, BT_VOIDCONSTPTR, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_ULONGLONG_UV2DI_INT, B_VX, BT_ULONGLONG, BT_UV2DI, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_USHORT_UV8HI_INT, B_VX, BT_USHORT, BT_UV8HI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_UV16QI_UCHARCONSTPTR_USHORT, B_VX, BT_UV16QI, BT_UCHARCONSTPTR, BT_USHORT)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UV16QI, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UCHAR, B_VX, BT_UV16QI, BT_UV16QI, BT_UCHAR)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV4SI_UV4SI, B_VX, BT_UV16QI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UCHAR_UCHAR, B_VX, BT_UV16QI, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV16QI_UCHAR_INT, B_VX, BT_UV16QI, BT_UCHAR, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV2DI_UV2DI, B_VX, BT_UV16QI, BT_UV2DI, BT_UV2DI)
-DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UINT, B_VX, BT_UV16QI, BT_UV16QI, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UCHAR_UCHAR, B_VX, BT_UV16QI, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_INTPTR, B_VX, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_FN_TYPE_3 (BT_FN_UV2DI_V2DF_INT, B_VX, BT_UV2DI, BT_V2DF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UCHAR, B_VX, BT_UV16QI, BT_UV16QI, BT_UCHAR)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UINT, B_VX, BT_UV16QI, BT_UV16QI, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV16QI_UV16QI, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV2DI_UV2DI, B_VX, BT_UV16QI, BT_UV2DI, BT_UV2DI)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV4SI_UV4SI, B_VX, BT_UV16QI, BT_UV4SI, BT_UV4SI)
+DEF_FN_TYPE_3 (BT_FN_UV16QI_UV8HI_UV8HI, B_VX, BT_UV16QI, BT_UV8HI, BT_UV8HI)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_UCHAR_UCHAR, B_VX, BT_UV2DI, BT_UCHAR, BT_UCHAR)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_ULONGLONG_INT, B_VX, BT_UV2DI, BT_ULONGLONG, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UCHAR, B_VX, BT_UV2DI, BT_UV2DI, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UINT, B_VX, BT_UV2DI, BT_UV2DI, BT_UINT)
-DEF_FN_TYPE_3 (BT_FN_OV2DI_LONGLONG_LONGLONG, B_VX, BT_OV2DI, BT_LONGLONG, BT_LONGLONG)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UV2DI, B_VX, BT_UV2DI, BT_UV2DI, BT_UV2DI)
-DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UCHAR, B_VX, BT_UV2DI, BT_UV2DI, BT_UCHAR)
-DEF_FN_TYPE_3 (BT_FN_UV2DI_ULONGLONG_INT, B_VX, BT_UV2DI, BT_ULONGLONG, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_UV2DI_UV8HI_UV8HI, B_VX, BT_UV2DI, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_3 (BT_FN_UV2DI_UCHAR_UCHAR, B_VX, BT_UV2DI, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV4SI_UV4SI, B_VX, BT_UV2DI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_INT_INT, B_VX, BT_OV4SI, BT_INT, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_UV8HI_UV8HI, B_VX, BT_UV2DI, BT_UV8HI, BT_UV8HI)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_V2DF_INT, B_VX, BT_UV2DI, BT_V2DF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV4SI_UCHAR_UCHAR, B_VX, BT_UV4SI, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UINT_INT, B_VX, BT_UV4SI, BT_UINT, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UCHAR, B_VX, BT_UV4SI, BT_UV4SI, BT_UCHAR)
-DEF_FN_TYPE_3 (BT_FN_UV4SI_UV8HI_UV8HI, B_VX, BT_UV4SI, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_UCHAR)
-DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UINT, B_VX, BT_UV4SI, BT_UV4SI, BT_UINT)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UV16QI_UV16QI, B_VX, BT_UV4SI, BT_UV16QI, BT_UV16QI)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_INTCONSTPTR_INT, B_VX, BT_OV4SI, BT_INTCONSTPTR, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_INTPTR)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UV2DI_UV2DI, B_VX, BT_UV4SI, BT_UV2DI, BT_UV2DI)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_INTCONSTPTR_UINT, B_VX, BT_OV4SI, BT_INTCONSTPTR, BT_UINT)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_ULONG, B_VX, BT_OV4SI, BT_OV4SI, BT_ULONG)
-DEF_FN_TYPE_3 (BT_FN_OV4SI_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI)
-DEF_FN_TYPE_3 (BT_FN_UV4SI_UCHAR_UCHAR, B_VX, BT_UV4SI, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_INTPTR, B_VX, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_FN_TYPE_3 (BT_FN_UV8HI_UV4SI_UV4SI, B_VX, BT_UV8HI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_UV8HI_UV16QI_UV16QI, B_VX, BT_UV8HI, BT_UV16QI, BT_UV16QI)
+DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UCHAR, B_VX, BT_UV4SI, BT_UV4SI, BT_UCHAR)
+DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UINT, B_VX, BT_UV4SI, BT_UV4SI, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI)
+DEF_FN_TYPE_3 (BT_FN_UV4SI_UV8HI_UV8HI, B_VX, BT_UV4SI, BT_UV8HI, BT_UV8HI)
 DEF_FN_TYPE_3 (BT_FN_UV8HI_UCHAR_UCHAR, B_VX, BT_UV8HI, BT_UCHAR, BT_UCHAR)
-DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_UV8HI, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_UCHAR, B_VX, BT_UV8HI, BT_UV8HI, BT_UCHAR)
+DEF_FN_TYPE_3 (BT_FN_UV8HI_USHORT_INT, B_VX, BT_UV8HI, BT_USHORT, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV8HI_UV16QI_UV16QI, B_VX, BT_UV8HI, BT_UV16QI, BT_UV16QI)
+DEF_FN_TYPE_3 (BT_FN_UV8HI_UV4SI_UV4SI, B_VX, BT_UV8HI, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_INTPTR, B_VX, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_UCHAR, B_VX, BT_UV8HI, BT_UV8HI, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_UINT, B_VX, BT_UV8HI, BT_UV8HI, BT_UINT)
-DEF_FN_TYPE_3 (BT_FN_UV8HI_USHORT_INT, B_VX, BT_UV8HI, BT_USHORT, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_V16QI_UV16QI_UV16QI, B_VX, BT_V16QI, BT_UV16QI, BT_UV16QI)
-DEF_FN_TYPE_3 (BT_FN_V16QI_UINT_VOIDCONSTPTR, B_VX, BT_V16QI, BT_UINT, BT_VOIDCONSTPTR)
-DEF_FN_TYPE_3 (BT_FN_V16QI_V8HI_V8HI, B_VX, BT_V16QI, BT_V8HI, BT_V8HI)
+DEF_FN_TYPE_3 (BT_FN_UV8HI_UV8HI_UV8HI, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI)
 DEF_FN_TYPE_3 (BT_FN_V16QI_BV16QI_V16QI, B_VX, BT_V16QI, BT_BV16QI, BT_V16QI)
+DEF_FN_TYPE_3 (BT_FN_V16QI_UINT_VOIDCONSTPTR, B_VX, BT_V16QI, BT_UINT, BT_VOIDCONSTPTR)
+DEF_FN_TYPE_3 (BT_FN_V16QI_UV16QI_UV16QI, B_VX, BT_V16QI, BT_UV16QI, BT_UV16QI)
 DEF_FN_TYPE_3 (BT_FN_V16QI_V16QI_V16QI, B_VX, BT_V16QI, BT_V16QI, BT_V16QI)
-DEF_FN_TYPE_3 (BT_FN_V2DI_V2DF_INT, B_VX, BT_V2DI, BT_V2DF, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_V2DI_V2DF_V2DF, B_VX, BT_V2DI, BT_V2DF, BT_V2DF)
-DEF_FN_TYPE_3 (BT_FN_V2DI_V4SI_V4SI, B_VX, BT_V2DI, BT_V4SI, BT_V4SI)
-DEF_FN_TYPE_3 (BT_FN_V2DI_UV2DI_UV2DI, B_VX, BT_V2DI, BT_UV2DI, BT_UV2DI)
-DEF_FN_TYPE_3 (BT_FN_V2DI_V2DI_V2DI, B_VX, BT_V2DI, BT_V2DI, BT_V2DI)
-DEF_FN_TYPE_3 (BT_FN_V2DF_V2DI_INT, B_VX, BT_V2DF, BT_V2DI, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V16QI_V8HI_V8HI, B_VX, BT_V16QI, BT_V8HI, BT_V8HI)
+DEF_FN_TYPE_3 (BT_FN_V2DF_DBL_INT, B_VX, BT_V2DF, BT_DBL, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V2DF_UV2DI_INT, B_VX, BT_V2DF, BT_UV2DI, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V2DF_UV4SI_INT, B_VX, BT_V2DF, BT_UV4SI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_V2DF, B_VX, BT_V2DF, BT_V2DF, BT_V2DF)
-DEF_FN_TYPE_3 (BT_FN_V2DF_DBL_INT, B_VX, BT_V2DF, BT_DBL, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V2DF_V2DI_INT, B_VX, BT_V2DF, BT_V2DI, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V2DI_BV2DI_V2DI, B_VX, BT_V2DI, BT_BV2DI, BT_V2DI)
-DEF_FN_TYPE_3 (BT_FN_V2DF_UV4SI_INT, B_VX, BT_V2DF, BT_UV4SI, BT_INT)
-DEF_FN_TYPE_3 (BT_FN_V4SI_V4SI_V4SI, B_VX, BT_V4SI, BT_V4SI, BT_V4SI)
-DEF_FN_TYPE_3 (BT_FN_V4SI_V8HI_V8HI, B_VX, BT_V4SI, BT_V8HI, BT_V8HI)
+DEF_FN_TYPE_3 (BT_FN_V2DI_UV2DI_UV2DI, B_VX, BT_V2DI, BT_UV2DI, BT_UV2DI)
+DEF_FN_TYPE_3 (BT_FN_V2DI_V2DF_INT, B_VX, BT_V2DI, BT_V2DF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V2DI_V2DF_V2DF, B_VX, BT_V2DI, BT_V2DF, BT_V2DF)
+DEF_FN_TYPE_3 (BT_FN_V2DI_V2DI_V2DI, B_VX, BT_V2DI, BT_V2DI, BT_V2DI)
+DEF_FN_TYPE_3 (BT_FN_V2DI_V4SI_V4SI, B_VX, BT_V2DI, BT_V4SI, BT_V4SI)
+DEF_FN_TYPE_3 (BT_FN_V4SI_BV4SI_V4SI, B_VX, BT_V4SI, BT_BV4SI, BT_V4SI)
 DEF_FN_TYPE_3 (BT_FN_V4SI_INT_VOIDPTR, B_VX, BT_V4SI, BT_INT, BT_VOIDPTR)
-DEF_FN_TYPE_3 (BT_FN_V4SI_V2DI_V2DI, B_VX, BT_V4SI, BT_V2DI, BT_V2DI)
 DEF_FN_TYPE_3 (BT_FN_V4SI_UV4SI_UV4SI, B_VX, BT_V4SI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_3 (BT_FN_V4SI_BV4SI_V4SI, B_VX, BT_V4SI, BT_BV4SI, BT_V4SI)
+DEF_FN_TYPE_3 (BT_FN_V4SI_V2DI_V2DI, B_VX, BT_V4SI, BT_V2DI, BT_V2DI)
+DEF_FN_TYPE_3 (BT_FN_V4SI_V4SI_V4SI, B_VX, BT_V4SI, BT_V4SI, BT_V4SI)
+DEF_FN_TYPE_3 (BT_FN_V4SI_V8HI_V8HI, B_VX, BT_V4SI, BT_V8HI, BT_V8HI)
 DEF_FN_TYPE_3 (BT_FN_V8HI_BV8HI_V8HI, B_VX, BT_V8HI, BT_BV8HI, BT_V8HI)
+DEF_FN_TYPE_3 (BT_FN_V8HI_UV8HI_UV8HI, B_VX, BT_V8HI, BT_UV8HI, BT_UV8HI)
 DEF_FN_TYPE_3 (BT_FN_V8HI_V16QI_V16QI, B_VX, BT_V8HI, BT_V16QI, BT_V16QI)
 DEF_FN_TYPE_3 (BT_FN_V8HI_V4SI_V4SI, B_VX, BT_V8HI, BT_V4SI, BT_V4SI)
-DEF_FN_TYPE_3 (BT_FN_V8HI_UV8HI_UV8HI, B_VX, BT_V8HI, BT_UV8HI, BT_UV8HI)
 DEF_FN_TYPE_3 (BT_FN_V8HI_V8HI_V8HI, B_VX, BT_V8HI, BT_V8HI, BT_V8HI)
-DEF_FN_TYPE_4 (BT_FN_VOID_OV4SI_VOIDPTR_UINT, B_VX, BT_VOID, BT_OV4SI, BT_VOIDPTR, BT_UINT)
+DEF_FN_TYPE_3 (BT_FN_VOID_UINT64PTR_UINT64, B_HTM, BT_VOID, BT_UINT64PTR, BT_UINT64)
+DEF_FN_TYPE_3 (BT_FN_VOID_V2DF_FLTPTR, B_VX, BT_VOID, BT_V2DF, BT_FLTPTR)
 DEF_FN_TYPE_4 (BT_FN_INT_OV4SI_OV4SI_INTPTR, B_VX, BT_INT, BT_OV4SI, BT_OV4SI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_VOID_V16QI_UINT_VOIDPTR, B_VX, BT_VOID, BT_V16QI, BT_UINT, BT_VOIDPTR)
-DEF_FN_TYPE_4 (BT_FN_VOID_OV4SI_INT_VOIDPTR, B_VX, BT_VOID, BT_OV4SI, BT_INT, BT_VOIDPTR)
-DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UV16QI_INTPTR, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UV16QI_INT, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_INT_OV4SI_INT, B_VX, BT_OV4SI, BT_INT, BT_OV4SI, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_INT, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_OV4SI)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_UCHAR)
+DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_ULONGLONG, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_ULONGLONG)
 DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UCHAR_INT, B_VX, BT_UV16QI, BT_UV16QI, BT_UCHAR, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UV16QI_INT, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UV16QI_INTPTR, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_UV16QI_UV16QI_UV16QI_UV16QI, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
-DEF_FN_TYPE_4 (BT_FN_UV16QI_UV8HI_UV8HI_INTPTR, B_VX, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_UV16QI_UV2DI_UV2DI_UV16QI, B_VX, BT_UV16QI, BT_UV2DI, BT_UV2DI, BT_UV16QI)
+DEF_FN_TYPE_4 (BT_FN_UV16QI_UV8HI_UV8HI_INTPTR, B_VX, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_UV2DI_UV2DI_ULONGLONG_INT, B_VX, BT_UV2DI, BT_UV2DI, BT_ULONGLONG, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_UV2DI_UV2DI_UV2DI_INT, B_VX, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_UV2DI_UV4SI_UV4SI_UV2DI, B_VX, BT_UV2DI, BT_UV4SI, BT_UV4SI, BT_UV2DI)
-DEF_FN_TYPE_4 (BT_FN_UV2DI_UV2DI_ULONGLONG_INT, B_VX, BT_UV2DI, BT_UV2DI, BT_ULONGLONG, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_UV4SI_UV2DI_UV2DI_INTPTR, B_VX, BT_UV4SI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_INT, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INT)
-DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UV4SI_INTPTR, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_INT_OV4SI_INT, B_VX, BT_OV4SI, BT_INT, BT_OV4SI, BT_INT)
+DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UINT_INT, B_VX, BT_UV4SI, BT_UV4SI, BT_UINT, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UV4SI_INT, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_ULONGLONG, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_ULONGLONG)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_OV4SI, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_OV4SI)
+DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UV4SI_INTPTR, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UV4SI_UV4SI, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_4 (BT_FN_UV4SI_UV8HI_UV8HI_UV4SI, B_VX, BT_UV4SI, BT_UV8HI, BT_UV8HI, BT_UV4SI)
-DEF_FN_TYPE_4 (BT_FN_UV4SI_UV4SI_UINT_INT, B_VX, BT_UV4SI, BT_UV4SI, BT_UINT, BT_INT)
-DEF_FN_TYPE_4 (BT_FN_OV4SI_OV4SI_OV4SI_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_UCHAR)
+DEF_FN_TYPE_4 (BT_FN_UV8HI_UV16QI_UV16QI_UV8HI, B_VX, BT_UV8HI, BT_UV16QI, BT_UV16QI, BT_UV8HI)
 DEF_FN_TYPE_4 (BT_FN_UV8HI_UV4SI_UV4SI_INTPTR, B_VX, BT_UV8HI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_USHORT_INT, B_VX, BT_UV8HI, BT_UV8HI, BT_USHORT, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_UV8HI_INT, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT)
-DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_UV8HI_UV8HI, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
-DEF_FN_TYPE_4 (BT_FN_UV8HI_UV16QI_UV16QI_UV8HI, B_VX, BT_UV8HI, BT_UV16QI, BT_UV16QI, BT_UV8HI)
 DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_UV8HI_INTPTR, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_USHORT_INT, B_VX, BT_UV8HI, BT_UV8HI, BT_USHORT, BT_INT)
-DEF_FN_TYPE_4 (BT_FN_V16QI_V8HI_V8HI_INTPTR, B_VX, BT_V16QI, BT_V8HI, BT_V8HI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_V16QI_V16QI_V16QI_INTPTR, B_VX, BT_V16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_UV8HI_UV8HI_UV8HI_UV8HI, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
 DEF_FN_TYPE_4 (BT_FN_V16QI_UV16QI_UV16QI_INTPTR, B_VX, BT_V16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V16QI_V16QI_V16QI_INTPTR, B_VX, BT_V16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V16QI_V16QI_V16QI_V16QI, B_VX, BT_V16QI, BT_V16QI, BT_V16QI, BT_V16QI)
-DEF_FN_TYPE_4 (BT_FN_V2DI_V2DF_INT_INTPTR, B_VX, BT_V2DI, BT_V2DF, BT_INT, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_V2DI_V2DI_V2DI_INTPTR, B_VX, BT_V2DI, BT_V2DI, BT_V2DI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V16QI_V8HI_V8HI_INTPTR, B_VX, BT_V16QI, BT_V8HI, BT_V8HI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V2DF_V2DF_DBL_INT, B_VX, BT_V2DF, BT_V2DF, BT_DBL, BT_INT)
 DEF_FN_TYPE_4 (BT_FN_V2DF_V2DF_UCHAR_UCHAR, B_VX, BT_V2DF, BT_V2DF, BT_UCHAR, BT_UCHAR)
-DEF_FN_TYPE_4 (BT_FN_V2DI_V2DF_V2DF_INTPTR, B_VX, BT_V2DI, BT_V2DF, BT_V2DF, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_V2DI_V4SI_V4SI_V2DI, B_VX, BT_V2DI, BT_V4SI, BT_V4SI, BT_V2DI)
 DEF_FN_TYPE_4 (BT_FN_V2DF_V2DF_V2DF_V2DF, B_VX, BT_V2DF, BT_V2DF, BT_V2DF, BT_V2DF)
 DEF_FN_TYPE_4 (BT_FN_V2DI_UV2DI_UV2DI_INTPTR, B_VX, BT_V2DI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
-DEF_FN_TYPE_4 (BT_FN_V4SI_V8HI_V8HI_V4SI, B_VX, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
+DEF_FN_TYPE_4 (BT_FN_V2DI_V2DF_INT_INTPTR, B_VX, BT_V2DI, BT_V2DF, BT_INT, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V2DI_V2DF_V2DF_INTPTR, B_VX, BT_V2DI, BT_V2DF, BT_V2DF, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V2DI_V2DI_V2DI_INTPTR, B_VX, BT_V2DI, BT_V2DI, BT_V2DI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V2DI_V4SI_V4SI_V2DI, B_VX, BT_V2DI, BT_V4SI, BT_V4SI, BT_V2DI)
 DEF_FN_TYPE_4 (BT_FN_V4SI_UV4SI_UV4SI_INTPTR, B_VX, BT_V4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V4SI_V2DI_V2DI_INTPTR, B_VX, BT_V4SI, BT_V2DI, BT_V2DI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V4SI_V4SI_V4SI_INTPTR, B_VX, BT_V4SI, BT_V4SI, BT_V4SI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V4SI_V4SI_V4SI_V4SI, B_VX, BT_V4SI, BT_V4SI, BT_V4SI, BT_V4SI)
-DEF_FN_TYPE_4 (BT_FN_V8HI_V8HI_V8HI_V8HI, B_VX, BT_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
+DEF_FN_TYPE_4 (BT_FN_V4SI_V8HI_V8HI_V4SI, B_VX, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
 DEF_FN_TYPE_4 (BT_FN_V8HI_UV8HI_UV8HI_INTPTR, B_VX, BT_V8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V8HI_V16QI_V16QI_V8HI, B_VX, BT_V8HI, BT_V16QI, BT_V16QI, BT_V8HI)
-DEF_FN_TYPE_4 (BT_FN_V8HI_V8HI_V8HI_INTPTR, B_VX, BT_V8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
 DEF_FN_TYPE_4 (BT_FN_V8HI_V4SI_V4SI_INTPTR, B_VX, BT_V8HI, BT_V4SI, BT_V4SI, BT_INTPTR)
-DEF_FN_TYPE_5 (BT_FN_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, B_VX, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
-DEF_FN_TYPE_5 (BT_FN_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, B_VX, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
-DEF_FN_TYPE_5 (BT_FN_VOID_V4SI_V4SI_INTPTR_ULONGLONG, B_VX, BT_VOID, BT_V4SI, BT_V4SI, BT_INTPTR, BT_ULONGLONG)
+DEF_FN_TYPE_4 (BT_FN_V8HI_V8HI_V8HI_INTPTR, B_VX, BT_V8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
+DEF_FN_TYPE_4 (BT_FN_V8HI_V8HI_V8HI_V8HI, B_VX, BT_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
+DEF_FN_TYPE_4 (BT_FN_VOID_OV4SI_INT_VOIDPTR, B_VX, BT_VOID, BT_OV4SI, BT_INT, BT_VOIDPTR)
+DEF_FN_TYPE_4 (BT_FN_VOID_OV4SI_VOIDPTR_UINT, B_VX, BT_VOID, BT_OV4SI, BT_VOIDPTR, BT_UINT)
+DEF_FN_TYPE_4 (BT_FN_VOID_V16QI_UINT_VOIDPTR, B_VX, BT_VOID, BT_V16QI, BT_UINT, BT_VOIDPTR)
+DEF_FN_TYPE_5 (BT_FN_OV4SI_OV4SI_OUV4SI_INTCONSTPTR_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_OUV4SI, BT_INTCONSTPTR, BT_UCHAR)
+DEF_FN_TYPE_5 (BT_FN_OV4SI_OV4SI_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INTPTR)
 DEF_FN_TYPE_5 (BT_FN_UV16QI_UV16QI_UV16QI_INT_INTPTR, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT, BT_INTPTR)
 DEF_FN_TYPE_5 (BT_FN_UV16QI_UV16QI_UV16QI_UV16QI_INT, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT)
-DEF_FN_TYPE_5 (BT_FN_UV2DI_UV2DI_UV2DI_UV2DI_INT, B_VX, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
 DEF_FN_TYPE_5 (BT_FN_UV2DI_UV2DI_UV2DI_ULONGLONGCONSTPTR_UCHAR, B_VX, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UCHAR)
-DEF_FN_TYPE_5 (BT_FN_UV4SI_UV4SI_UV4SI_UV4SI_INT, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT)
+DEF_FN_TYPE_5 (BT_FN_UV2DI_UV2DI_UV2DI_UV2DI_INT, B_VX, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
 DEF_FN_TYPE_5 (BT_FN_UV4SI_UV4SI_UV4SI_INT_INTPTR, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT, BT_INTPTR)
-DEF_FN_TYPE_5 (BT_FN_OV4SI_OV4SI_OV4SI_OV4SI_INTPTR, B_VX, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_OV4SI, BT_INTPTR)
-DEF_FN_TYPE_5 (BT_FN_OV4SI_OV4SI_OUV4SI_INTCONSTPTR_UCHAR, B_VX, BT_OV4SI, BT_OV4SI, BT_OUV4SI, BT_INTCONSTPTR, BT_UCHAR)
 DEF_FN_TYPE_5 (BT_FN_UV4SI_UV4SI_UV4SI_UINTCONSTPTR_UCHAR, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UINTCONSTPTR, BT_UCHAR)
-DEF_FN_TYPE_5 (BT_FN_UV8HI_UV8HI_UV8HI_UV8HI_INT, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT)
+DEF_FN_TYPE_5 (BT_FN_UV4SI_UV4SI_UV4SI_UV4SI_INT, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT)
 DEF_FN_TYPE_5 (BT_FN_UV8HI_UV8HI_UV8HI_INT_INTPTR, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT, BT_INTPTR)
+DEF_FN_TYPE_5 (BT_FN_UV8HI_UV8HI_UV8HI_UV8HI_INT, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT)
+DEF_FN_TYPE_5 (BT_FN_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, B_VX, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_FN_TYPE_5 (BT_FN_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, B_VX, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
+DEF_FN_TYPE_5 (BT_FN_VOID_V4SI_V4SI_INTPTR_ULONGLONG, B_VX, BT_VOID, BT_V4SI, BT_V4SI, BT_INTPTR, BT_ULONGLONG)
 DEF_FN_TYPE_6 (BT_FN_UV16QI_UV16QI_UV16QI_UV16QI_INT_INTPTR, B_VX, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT, BT_INTPTR)
 DEF_FN_TYPE_6 (BT_FN_UV4SI_UV4SI_UV4SI_UV4SI_INT_INTPTR, B_VX, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT, BT_INTPTR)
 DEF_FN_TYPE_6 (BT_FN_UV8HI_UV8HI_UV8HI_UV8HI_INT_INTPTR, B_VX, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_BV16QI_BV16QI, BT_BV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHAR, BT_UV16QI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_UV16QI_V16QI, BT_UV16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR, BT_UV16QI, BT_UCHARCONSTPTR)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_INTPTR, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_UV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_INTPTR, BT_BV16QI, BT_BV16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UCHAR, BT_BV16QI, BT_BV16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV16QI, BT_BV16QI, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV4SI, BT_BV16QI, BT_BV16QI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV8HI, BT_BV16QI, BT_BV16QI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV16QI_BV8HI_BV8HI, BT_BV16QI, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI, BT_BV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_INTPTR, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_UV16QI, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_UV16QI_INTPTR, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV16QI_V16QI_V16QI, BT_BV16QI, BT_V16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_BV16QI_V16QI_V16QI_INTPTR, BT_BV16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_INT, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_UV16QI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_UV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UCHAR, BT_BV2DI, BT_BV2DI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV16QI, BT_BV2DI, BT_BV2DI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV2DI_ULONGLONGCONSTPTR_UCHAR, BT_BV2DI, BT_BV2DI, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV4SI, BT_BV2DI, BT_BV2DI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV8HI, BT_BV2DI, BT_BV2DI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_BV2DI_BV4SI, BT_BV2DI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_UV2DI_V2DI, BT_UV2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV4SI, BT_UV2DI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG, BT_UV2DI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR, BT_UV2DI, BT_ULONGLONGCONSTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_V4SI, BT_UV4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV8HI, BT_BV4SI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR, BT_UV4SI, BT_UINTCONSTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UINT, BT_UV4SI, BT_UINT)
+DEF_OV_TYPE (BT_OV_BV2DI_UV2DI_UV2DI, BT_BV2DI, BT_UV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_BV2DI_V2DF_V2DF, BT_BV2DI, BT_V2DF, BT_V2DF)
+DEF_OV_TYPE (BT_OV_BV2DI_V2DI_V2DI, BT_BV2DI, BT_V2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV2DI_BV2DI, BT_BV4SI, BT_BV2DI, BT_BV2DI)
 DEF_OV_TYPE (BT_OV_BV4SI_BV4SI, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV8HI, BT_UV4SI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR, BT_UV8HI, BT_USHORTCONSTPTR)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_INTPTR, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_UV16QI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_UV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_INTPTR, BT_BV4SI, BT_BV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UCHAR, BT_BV4SI, BT_BV4SI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV16QI, BT_BV4SI, BT_BV4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV4SI, BT_BV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV4SI_UINTCONSTPTR_UCHAR, BT_BV4SI, BT_BV4SI, BT_UV4SI, BT_UINTCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV8HI, BT_BV4SI, BT_BV4SI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV4SI_BV8HI, BT_BV4SI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI, BT_BV4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_INTPTR, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_UV4SI, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_UV4SI_INTPTR, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV4SI_V4SI_V4SI, BT_BV4SI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_BV4SI_V4SI_V4SI_INTPTR, BT_BV4SI, BT_V4SI, BT_V4SI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_BV8HI_BV16QI, BT_BV8HI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_UV8HI_USHORT, BT_UV8HI, BT_USHORT)
-DEF_OV_TYPE (BT_OV_UV8HI_V8HI, BT_UV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV4SI_BV4SI, BT_BV8HI, BT_BV4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_BV8HI_BV8HI, BT_BV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV16QI, BT_UV8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V16QI_SCHAR, BT_V16QI, BT_SCHAR)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR, BT_V16QI, BT_SCHARCONSTPTR)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONG, BT_V2DI, BT_LONGLONG)
-DEF_OV_TYPE (BT_OV_V2DI_V8HI, BT_V2DI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V2DI_V16QI, BT_V2DI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR, BT_V2DI, BT_LONGLONGCONSTPTR)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V2DI_V4SI, BT_V2DI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V2DF_DBL, BT_V2DF, BT_DBL)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF, BT_V2DF, BT_V2DF)
-DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR, BT_V2DF, BT_DBLCONSTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR, BT_V4SI, BT_INTCONSTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_INT, BT_V4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SI_V8HI, BT_V4SI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V8HI_V16QI, BT_V8HI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR, BT_V8HI, BT_SHORTCONSTPTR)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V8HI_SHORT, BT_V8HI, BT_SHORT)
-DEF_OV_TYPE (BT_OV_INT_UV2DI_BV2DI, BT_INT, BT_UV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_INTPTR, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_UV16QI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_UV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_INTPTR, BT_BV8HI, BT_BV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UCHAR, BT_BV8HI, BT_BV8HI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV16QI, BT_BV8HI, BT_BV8HI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV4SI, BT_BV8HI, BT_BV8HI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV8HI, BT_BV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI, BT_BV8HI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_INTPTR, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_UV8HI, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_UV8HI_INTPTR, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_BV8HI_V8HI_V8HI, BT_BV8HI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_BV8HI_V8HI_V8HI_INTPTR, BT_BV8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_DBL_V2DF_INT, BT_DBL, BT_V2DF, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_V8HI_UV8HI, BT_INT, BT_V8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_INT_BV8HI_BV8HI, BT_INT, BT_BV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_INT_V4SI_UV4SI, BT_INT, BT_V4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UCHAR_UV16QI_INT, BT_UCHAR, BT_UV16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_V2DI_UV2DI, BT_INT, BT_V2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_SHORT_V8HI_INT, BT_SHORT, BT_V8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_BV8HI_V8HI, BT_INT, BT_BV8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_USHORT_BV8HI_INT, BT_USHORT, BT_BV8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_BV8HI_UV8HI, BT_INT, BT_BV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UINT_UV4SI_INT, BT_UINT, BT_UV4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_UV8HI_UV8HI, BT_INT, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_LONGLONG_V2DI_INT, BT_LONGLONG, BT_V2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_UV8HI_BV8HI, BT_INT, BT_UV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_ULONGLONG_BV2DI_INT, BT_ULONGLONG, BT_BV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_V4SI_V4SI, BT_INT, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_INT_V8HI_BV8HI, BT_INT, BT_V8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_INT_V4SI_BV4SI, BT_INT, BT_V4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_INT_UV16QI_BV16QI, BT_INT, BT_UV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_INT_V2DF_UV2DI, BT_INT, BT_V2DF, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_INT_BV16QI_BV16QI, BT_INT, BT_BV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_INT_BV16QI_UV16QI, BT_INT, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_INT_BV16QI_V16QI, BT_INT, BT_BV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_INT_BV2DI_BV2DI, BT_INT, BT_BV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_INT_BV2DI_UV2DI, BT_INT, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_INT_BV2DI_V2DI, BT_INT, BT_BV2DI, BT_V2DI)
 DEF_OV_TYPE (BT_OV_INT_BV4SI_BV4SI, BT_INT, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_INT_BV16QI_BV16QI, BT_INT, BT_BV16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_INT_BV4SI_UV4SI, BT_INT, BT_BV4SI, BT_UV4SI)
 DEF_OV_TYPE (BT_OV_INT_BV4SI_V4SI, BT_INT, BT_BV4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_INT_BV8HI_BV8HI, BT_INT, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_INT_BV8HI_UV8HI, BT_INT, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_INT_BV8HI_V8HI, BT_INT, BT_BV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_INT_UV16QI_BV16QI, BT_INT, BT_UV16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_INT_UV16QI_UV16QI, BT_INT, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_INT_UV2DI_BV2DI, BT_INT, BT_UV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_INT_UV2DI_UV2DI, BT_INT, BT_UV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_INT_UV4SI_BV4SI, BT_INT, BT_UV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_INT_UV4SI_UV4SI, BT_INT, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_INT_UV8HI_BV8HI, BT_INT, BT_UV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_INT_UV8HI_UV8HI, BT_INT, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_INT_V16QI_BV16QI, BT_INT, BT_V16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_INT_V16QI_UV16QI, BT_INT, BT_V16QI, BT_UV16QI)
 DEF_OV_TYPE (BT_OV_INT_V16QI_V16QI, BT_INT, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_UCHAR_BV16QI_INT, BT_UCHAR, BT_BV16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_BV4SI_UV4SI, BT_INT, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_INT_V2DF_UV2DI, BT_INT, BT_V2DF, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_INT_V2DF_V2DF, BT_INT, BT_V2DF, BT_V2DF)
+DEF_OV_TYPE (BT_OV_INT_V2DI_BV2DI, BT_INT, BT_V2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_INT_V2DI_UV2DI, BT_INT, BT_V2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_INT_V2DI_V2DI, BT_INT, BT_V2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_INT_V4SI_BV4SI, BT_INT, BT_V4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_INT_V4SI_INT, BT_INT, BT_V4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_UV4SI_UV4SI, BT_INT, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_ULONGLONG_UV2DI_INT, BT_ULONGLONG, BT_UV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_UV4SI_BV4SI, BT_INT, BT_UV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_INT_V4SI_UV4SI, BT_INT, BT_V4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_INT_V4SI_V4SI, BT_INT, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_INT_V8HI_BV8HI, BT_INT, BT_V8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_INT_V8HI_UV8HI, BT_INT, BT_V8HI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_INT_V8HI_V8HI, BT_INT, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_INT_V2DI_V2DI, BT_INT, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_INT_BV16QI_V16QI, BT_INT, BT_BV16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_INT_V2DI_BV2DI, BT_INT, BT_V2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_LONGLONG_V2DI_INT, BT_LONGLONG, BT_V2DI, BT_INT)
 DEF_OV_TYPE (BT_OV_SCHAR_V16QI_INT, BT_SCHAR, BT_V16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_BV2DI_BV2DI, BT_INT, BT_BV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_SHORT_V8HI_INT, BT_SHORT, BT_V8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_UCHAR_BV16QI_INT, BT_UCHAR, BT_BV16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_UCHAR_UV16QI_INT, BT_UCHAR, BT_UV16QI, BT_INT)
 DEF_OV_TYPE (BT_OV_UINT_BV4SI_INT, BT_UINT, BT_BV4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_BV2DI_V2DI, BT_INT, BT_BV2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_INT_UV16QI_UV16QI, BT_INT, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_INT_BV2DI_UV2DI, BT_INT, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UINT_UV4SI_INT, BT_UINT, BT_UV4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_ULONGLONG_BV2DI_INT, BT_ULONGLONG, BT_BV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_ULONGLONG_UV2DI_INT, BT_ULONGLONG, BT_UV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_USHORT_BV8HI_INT, BT_USHORT, BT_BV8HI, BT_INT)
 DEF_OV_TYPE (BT_OV_USHORT_UV8HI_INT, BT_USHORT, BT_UV8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_INT_V2DF_V2DF, BT_INT, BT_V2DF, BT_V2DF)
-DEF_OV_TYPE (BT_OV_INT_V16QI_BV16QI, BT_INT, BT_V16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_INT_UV2DI_UV2DI, BT_INT, BT_UV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_ULONG, BT_UV16QI, BT_UV16QI, BT_ULONG)
-DEF_OV_TYPE (BT_OV_BV16QI_BV8HI_BV8HI, BT_BV16QI, BT_BV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV2DI_UV2DI, BT_UV16QI, BT_UV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI, BT_UV16QI, BT_BV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_V16QI_V16QI, BT_BV16QI, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_BV16QI, BT_UV16QI, BT_UV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR_UINT, BT_UV16QI, BT_UCHARCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI_INTPTR, BT_UV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_UV16QI, BT_UV16QI, BT_BV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR_USHORT, BT_UV16QI, BT_UCHARCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARPTR, BT_UV16QI, BT_LONG, BT_UCHARPTR)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_INT, BT_UV16QI, BT_UCHAR, BT_INT)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV4SI, BT_BV16QI, BT_BV16QI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV8HI_UV8HI, BT_UV16QI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV8HI, BT_BV16QI, BT_BV16QI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UCHAR, BT_BV16QI, BT_BV16QI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_UV16QI, BT_BV16QI, BT_BV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI, BT_BV16QI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_INTPTR, BT_BV16QI, BT_BV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_V16QI, BT_UV16QI, BT_UV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHAR, BT_UV16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR, BT_UV16QI, BT_UCHARCONSTPTR)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR_UINT, BT_UV16QI, BT_UCHARCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR_USHORT, BT_UV16QI, BT_UCHARCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_BV16QI_INT, BT_UV16QI, BT_UCHAR, BT_BV16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_INT, BT_UV16QI, BT_UCHAR, BT_INT)
+DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_UV16QI_INT, BT_UV16QI, BT_UCHAR, BT_UV16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_BV16QI, BT_UV16QI, BT_UV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_INTPTR, BT_UV16QI, BT_UV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UCHAR, BT_UV16QI, BT_UV16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_ULONG, BT_UV16QI, BT_UV16QI, BT_ULONG)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_INT, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_INTPTR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UCHAR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_ULONGLONG, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UV16QI_INTPTR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV4SI, BT_UV16QI, BT_UV16QI, BT_UV4SI)
 DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV8HI, BT_UV16QI, BT_UV16QI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV16QI_V8HI_V8HI, BT_UV16QI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_V16QI, BT_UV16QI, BT_UV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV2DI_UV2DI, BT_UV16QI, BT_UV2DI, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_UV16QI_UV4SI_UV4SI, BT_UV16QI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV16QI, BT_UV2DI, BT_UV2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV4SI_UV4SI, BT_UV2DI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR_USHORT, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_UV16QI_UV8HI_UV8HI, BT_UV16QI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV16QI_UV8HI_UV8HI_INTPTR, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV16QI_V16QI, BT_UV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_V8HI_V8HI, BT_UV16QI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_UV2DI_BV2DI_UV2DI, BT_UV2DI, BT_BV2DI, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV8HI, BT_UV2DI, BT_UV2DI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_BV2DI, BT_UV2DI, BT_UV2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_ULONGLONG, BT_UV2DI, BT_ULONGLONG, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_V2DI, BT_UV2DI, BT_UV2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG, BT_UV2DI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR, BT_UV2DI, BT_ULONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR_UINT, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV4SI, BT_BV2DI, BT_BV2DI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_BV2DI_V2DI_V2DI, BT_BV2DI, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV16QI, BT_BV2DI, BT_BV2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV2DI_UV2DI_UV2DI, BT_BV2DI, BT_UV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR_USHORT, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_BV2DI_INT, BT_UV2DI, BT_ULONGLONG, BT_BV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_INT, BT_UV2DI, BT_ULONGLONG, BT_INT)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_ULONGLONG, BT_UV2DI, BT_ULONGLONG, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_UV2DI_INT, BT_UV2DI, BT_ULONGLONG, BT_UV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_BV2DI, BT_UV2DI, BT_UV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UCHAR, BT_UV2DI, BT_UV2DI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_ULONG, BT_UV2DI, BT_UV2DI, BT_ULONG)
-DEF_OV_TYPE (BT_OV_BV2DI_V2DF_V2DF, BT_BV2DI, BT_V2DF, BT_V2DF)
-DEF_OV_TYPE (BT_OV_UV2DI_UV8HI_UV8HI, BT_UV2DI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV16QI, BT_UV2DI, BT_UV2DI, BT_UV16QI)
 DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV8HI, BT_BV2DI, BT_BV2DI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UCHAR, BT_UV2DI, BT_UV2DI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_UV2DI_BV2DI_UV2DI, BT_UV2DI, BT_BV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UCHAR, BT_BV2DI, BT_BV2DI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_BV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_INT, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UCHAR, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_ULONGLONG, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_ULONGLONGCONSTPTR_UCHAR, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UV16QI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV4SI, BT_UV2DI, BT_UV2DI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_INT, BT_UV2DI, BT_ULONGLONG, BT_INT)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV8HI, BT_UV4SI, BT_UV4SI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV4SI_V2DI_V2DI, BT_UV4SI, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV8HI, BT_BV4SI, BT_BV4SI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_V4SI, BT_UV4SI, BT_UV4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UCHAR, BT_UV4SI, BT_UV4SI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV8HI, BT_UV2DI, BT_UV2DI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_V2DI, BT_UV2DI, BT_UV2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV4SI, BT_UV2DI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV4SI_UV4SI, BT_UV2DI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV4SI_UV4SI_UV2DI, BT_UV2DI, BT_UV4SI, BT_UV4SI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_UV8HI_UV8HI, BT_UV2DI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV2DI_V2DI, BT_UV2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI, BT_UV4SI, BT_BV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI_INTPTR, BT_UV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_UV4SI, BT_UV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTPTR, BT_UV4SI, BT_LONG, BT_UINTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_UINT, BT_UV4SI, BT_UINT)
+DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR, BT_UV4SI, BT_UINTCONSTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR_UINT, BT_UV4SI, BT_UINTCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR_USHORT, BT_UV4SI, BT_UINTCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_UV4SI_UINT_BV4SI_INT, BT_UV4SI, BT_UINT, BT_BV4SI, BT_INT)
 DEF_OV_TYPE (BT_OV_UV4SI_UINT_INT, BT_UV4SI, BT_UINT, BT_INT)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_INTPTR, BT_BV4SI, BT_BV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_ULONG, BT_UV4SI, BT_UV4SI, BT_ULONG)
-DEF_OV_TYPE (BT_OV_BV4SI_BV2DI_BV2DI, BT_BV4SI, BT_BV2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV4SI, BT_BV4SI, BT_BV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_BV4SI, BT_UV4SI, BT_UV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UINT_UV4SI_INT, BT_UV4SI, BT_UINT, BT_UV4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV4SI_UV16QI_UV16QI, BT_UV4SI, BT_UV16QI, BT_UV16QI)
 DEF_OV_TYPE (BT_OV_UV4SI_UV2DI_UV2DI, BT_UV4SI, BT_UV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI, BT_BV4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV16QI, BT_UV4SI, BT_UV4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV2DI_UV2DI_INTPTR, BT_UV4SI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_BV4SI, BT_UV4SI, BT_UV4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_INTPTR, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR_USHORT, BT_UV4SI, BT_UINTCONSTPTR, BT_USHORT)
-DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI, BT_UV4SI, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UCHAR, BT_BV4SI, BT_BV4SI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV16QI_UV16QI, BT_UV4SI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UCHAR, BT_UV4SI, BT_UV4SI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_ULONG, BT_UV4SI, BT_UV4SI, BT_ULONG)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV16QI, BT_UV4SI, BT_UV4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_INT, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_INTPTR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UCHAR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UINTCONSTPTR_UCHAR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UINTCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_ULONGLONG, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV16QI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV4SI_INTPTR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV8HI, BT_UV4SI, BT_UV4SI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_V4SI, BT_UV4SI, BT_UV4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV8HI, BT_UV4SI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_UV4SI_UV8HI_UV8HI, BT_UV4SI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTPTR, BT_UV4SI, BT_LONG, BT_UINTPTR)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV16QI, BT_BV4SI, BT_BV4SI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV4SI_V4SI_V4SI, BT_BV4SI, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR_UINT, BT_UV4SI, BT_UINTCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_UV4SI, BT_UV4SI, BT_BV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_V4SI_V4SI, BT_UV8HI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_UV8HI_UV8HI_UV4SI, BT_UV4SI, BT_UV8HI, BT_UV8HI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_V2DI_V2DI, BT_UV4SI, BT_V2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_UV4SI_V4SI, BT_UV4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI, BT_UV8HI, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI_INTPTR, BT_UV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_UV8HI, BT_UV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTPTR, BT_UV8HI, BT_LONG, BT_USHORTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_USHORT, BT_UV8HI, BT_USHORT)
+DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR, BT_UV8HI, BT_USHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR_UINT, BT_UV8HI, BT_USHORTCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV4SI, BT_UV8HI, BT_UV8HI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_BV8HI_V8HI_V8HI, BT_BV8HI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_BV8HI_BV4SI_BV4SI, BT_BV8HI, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_V8HI, BT_UV8HI, BT_UV8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV4SI_UV4SI, BT_UV8HI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV8HI_USHORT_INT, BT_UV8HI, BT_USHORT, BT_INT)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV16QI, BT_BV8HI, BT_BV8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI, BT_BV8HI, BT_UV8HI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR_USHORT, BT_UV8HI, BT_USHORTCONSTPTR, BT_USHORT)
-DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTPTR, BT_UV8HI, BT_LONG, BT_USHORTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UCHAR, BT_UV8HI, BT_UV8HI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UCHAR, BT_BV8HI, BT_BV8HI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_INTPTR, BT_BV8HI, BT_BV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV8HI, BT_BV8HI, BT_BV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV16QI, BT_UV8HI, BT_UV8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_BV8HI, BT_UV8HI, BT_UV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_UV4SI, BT_BV8HI, BT_BV8HI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI, BT_UV8HI, BT_BV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_USHORT_BV8HI_INT, BT_UV8HI, BT_USHORT, BT_BV8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV8HI_USHORT_INT, BT_UV8HI, BT_USHORT, BT_INT)
+DEF_OV_TYPE (BT_OV_UV8HI_USHORT_UV8HI_INT, BT_UV8HI, BT_USHORT, BT_UV8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV8HI_UV16QI, BT_UV8HI, BT_UV16QI)
 DEF_OV_TYPE (BT_OV_UV8HI_UV16QI_UV16QI, BT_UV8HI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_UV8HI, BT_UV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV16QI_UV16QI_UV8HI, BT_UV8HI, BT_UV16QI, BT_UV16QI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV4SI_UV4SI, BT_UV8HI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV4SI_UV4SI_INTPTR, BT_UV8HI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_BV8HI, BT_UV8HI, BT_UV8HI, BT_BV8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_INTPTR, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UCHAR, BT_UV8HI, BT_UV8HI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_ULONG, BT_UV8HI, BT_UV8HI, BT_ULONG)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV16QI, BT_UV8HI, BT_UV8HI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV4SI, BT_UV8HI, BT_UV8HI, BT_UV4SI)
 DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_INT, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_INTPTR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UCHAR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_ULONGLONG, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV16QI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV8HI_INTPTR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_V8HI, BT_UV8HI, BT_UV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_V4SI_V4SI, BT_UV8HI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_UV8HI_V8HI, BT_UV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V16QI_BV16QI_V16QI, BT_V16QI, BT_BV16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UCHAR, BT_V16QI, BT_V16QI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_INTPTR, BT_V16QI, BT_V16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_BV16QI, BT_V16QI, BT_V16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARPTR, BT_V16QI, BT_LONG, BT_SCHARPTR)
+DEF_OV_TYPE (BT_OV_V16QI_SCHAR, BT_V16QI, BT_SCHAR)
+DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR, BT_V16QI, BT_SCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR_UINT, BT_V16QI, BT_SCHARCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV8HI, BT_V16QI, BT_V16QI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI, BT_V16QI, BT_V16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV4SI, BT_V16QI, BT_V16QI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_ULONG, BT_V16QI, BT_V16QI, BT_ULONG)
 DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR_USHORT, BT_V16QI, BT_SCHARCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V16QI_SCHAR_INT, BT_V16QI, BT_SCHAR, BT_INT)
+DEF_OV_TYPE (BT_OV_V16QI_SCHAR_V16QI_INT, BT_V16QI, BT_SCHAR, BT_V16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_V16QI_UV16QI_V16QI_V16QI, BT_V16QI, BT_UV16QI, BT_V16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI, BT_V16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_BV16QI, BT_V16QI, BT_V16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_INTPTR, BT_V16QI, BT_V16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UCHAR, BT_V16QI, BT_V16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_ULONG, BT_V16QI, BT_V16QI, BT_ULONG)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI, BT_V16QI, BT_V16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI_UCHAR, BT_V16QI, BT_V16QI, BT_UV16QI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI_UV16QI, BT_V16QI, BT_V16QI, BT_UV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV4SI, BT_V16QI, BT_V16QI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV8HI, BT_V16QI, BT_V16QI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI, BT_V16QI, BT_V16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_BV16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_BV16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_INT, BT_V16QI, BT_V16QI, BT_V16QI, BT_INT)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_INTPTR, BT_V16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_ULONGLONG, BT_V16QI, BT_V16QI, BT_V16QI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_UV16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_V16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_V16QI_V8HI_V8HI, BT_V16QI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V2DF_UV2DI_INT, BT_V2DF, BT_UV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UCHAR, BT_V2DI, BT_V2DI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV16QI, BT_V2DI, BT_V2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_USHORT, BT_V2DF, BT_DBLCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_V16QI_V8HI_V8HI_INTPTR, BT_V16QI, BT_V8HI, BT_V8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V2DF_BV2DI_V2DF, BT_V2DF, BT_BV2DI, BT_V2DF)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_UCHAR, BT_V2DF, BT_V2DF, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_BV2DI, BT_V2DF, BT_V2DF, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV8HI, BT_V2DI, BT_V2DI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_V2DF_DBL, BT_V2DF, BT_DBL)
+DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR, BT_V2DF, BT_DBLCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_UINT, BT_V2DF, BT_DBLCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_USHORT, BT_V2DF, BT_DBLCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_INT, BT_V2DF, BT_DBL, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_DBL_V2DF_INT, BT_V2DF, BT_DBL, BT_V2DF, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLPTR, BT_V2DF, BT_LONG, BT_DBLPTR)
+DEF_OV_TYPE (BT_OV_V2DF_UV2DI_INT, BT_V2DF, BT_UV2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF, BT_V2DF, BT_V2DF)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_BV2DI, BT_V2DF, BT_V2DF, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_UCHAR, BT_V2DF, BT_V2DF, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_V2DF_V2DF_UV2DI, BT_V2DF, BT_V2DF, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV4SI, BT_V2DI, BT_V2DI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_UV2DI_DBLCONSTPTR_UCHAR, BT_V2DF, BT_V2DF, BT_UV2DI, BT_DBLCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF, BT_V2DF, BT_V2DF, BT_V2DF)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_BV2DI, BT_V2DF, BT_V2DF, BT_V2DF, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_INT, BT_V2DF, BT_V2DF, BT_V2DF, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_ULONGLONG, BT_V2DF, BT_V2DF, BT_V2DF, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_UV16QI, BT_V2DF, BT_V2DF, BT_V2DF, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_UV2DI, BT_V2DF, BT_V2DF, BT_V2DF, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DI, BT_V2DF, BT_V2DF, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V2DI_BV2DI_V2DI, BT_V2DI, BT_BV2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGPTR, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI, BT_V2DI, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V2DI_V4SI_V4SI, BT_V2DI, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI, BT_V2DI, BT_V2DI, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_V2DF_V2DI_INT, BT_V2DF, BT_V2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_INT, BT_V2DI, BT_LONGLONG, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_BV2DI_V2DI, BT_V2DI, BT_BV2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONG, BT_V2DI, BT_LONGLONG)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR, BT_V2DI, BT_LONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR_UINT, BT_V2DI, BT_LONGLONGCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR_USHORT, BT_V2DI, BT_LONGLONGCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_INT, BT_V2DI, BT_LONGLONG, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_LONGLONG, BT_V2DI, BT_LONGLONG, BT_LONGLONG)
+DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_V2DI_INT, BT_V2DI, BT_LONGLONG, BT_V2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGPTR, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
+DEF_OV_TYPE (BT_OV_V2DI_V16QI, BT_V2DI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI, BT_V2DI, BT_V2DI)
 DEF_OV_TYPE (BT_OV_V2DI_V2DI_BV2DI, BT_V2DI, BT_V2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLPTR, BT_V2DF, BT_LONG, BT_DBLPTR)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UCHAR, BT_V2DI, BT_V2DI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_V2DI_V2DI_ULONG, BT_V2DI, BT_V2DI, BT_ULONG)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_LONGLONG, BT_V2DI, BT_LONGLONG, BT_LONGLONG)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR_USHORT, BT_V2DI, BT_LONGLONGCONSTPTR, BT_USHORT)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF, BT_V2DF, BT_V2DF, BT_V2DF)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV16QI, BT_V2DI, BT_V2DI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI, BT_V2DI, BT_V2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI_LONGLONGCONSTPTR_UCHAR, BT_V2DI, BT_V2DI, BT_UV2DI, BT_LONGLONGCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI_UCHAR, BT_V2DI, BT_V2DI, BT_UV2DI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV4SI, BT_V2DI, BT_V2DI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV8HI, BT_V2DI, BT_V2DI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI, BT_V2DI, BT_V2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_BV2DI, BT_V2DI, BT_V2DI, BT_V2DI, BT_BV2DI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_INT, BT_V2DI, BT_V2DI, BT_V2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_ULONGLONG, BT_V2DI, BT_V2DI, BT_V2DI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_UV16QI, BT_V2DI, BT_V2DI, BT_V2DI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_UV2DI, BT_V2DI, BT_V2DI, BT_V2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_V2DI_V4SI, BT_V2DI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V2DI_V4SI_V4SI, BT_V2DI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V2DI_V4SI_V4SI_V2DI, BT_V2DI, BT_V4SI, BT_V4SI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_V2DI_V8HI, BT_V2DI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V4SI_BV4SI_V4SI, BT_V4SI, BT_BV4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V4SI_INT, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR, BT_V4SI, BT_INTCONSTPTR)
+DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_UINT, BT_V4SI, BT_INTCONSTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_USHORT, BT_V4SI, BT_INTCONSTPTR, BT_USHORT)
-DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI, BT_V4SI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V4SI_INT_INT, BT_V4SI, BT_INT, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_INT_V4SI_INT, BT_V4SI, BT_INT, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_LONG_INTPTR, BT_V4SI, BT_LONG, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V4SI_UV4SI_V4SI_V4SI, BT_V4SI, BT_UV4SI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
+DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI_INTPTR, BT_V4SI, BT_V2DI, BT_V2DI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V4SI_V4SI_BV4SI, BT_V4SI, BT_V4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_UINT, BT_V4SI, BT_INTCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_V4SI_BV4SI_V4SI, BT_V4SI, BT_BV4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV8HI, BT_V4SI, BT_V4SI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_V4SI_V4SI_INTPTR, BT_V4SI, BT_V4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI, BT_V4SI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UCHAR, BT_V4SI, BT_V4SI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_V4SI_V4SI_ULONG, BT_V4SI, BT_V4SI, BT_ULONG)
-DEF_OV_TYPE (BT_OV_V4SI_INT_INT, BT_V4SI, BT_INT, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI, BT_V4SI, BT_V4SI, BT_UV4SI)
 DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV16QI, BT_V4SI, BT_V4SI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V4SI_LONG_INTPTR, BT_V4SI, BT_LONG, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UCHAR, BT_V4SI, BT_V4SI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV8HI, BT_V8HI, BT_V8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_ULONG, BT_V8HI, BT_V8HI, BT_ULONG)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI, BT_V4SI, BT_V4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_INTCONSTPTR_UCHAR, BT_V4SI, BT_V4SI, BT_UV4SI, BT_INTCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_UCHAR, BT_V4SI, BT_V4SI, BT_UV4SI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_UV4SI, BT_V4SI, BT_V4SI, BT_UV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV8HI, BT_V4SI, BT_V4SI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI, BT_V4SI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_BV4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_BV4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_INT, BT_V4SI, BT_V4SI, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_INTPTR, BT_V4SI, BT_V4SI, BT_V4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_ULONGLONG, BT_V4SI, BT_V4SI, BT_V4SI, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_UV16QI, BT_V4SI, BT_V4SI, BT_V4SI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_UV4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_V4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V4SI_V8HI, BT_V4SI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI, BT_V4SI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI_V4SI, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V8HI_BV8HI_V8HI, BT_V8HI, BT_BV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTPTR, BT_V8HI, BT_LONG, BT_SHORTPTR)
+DEF_OV_TYPE (BT_OV_V8HI_SHORT, BT_V8HI, BT_SHORT)
+DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR, BT_V8HI, BT_SHORTCONSTPTR)
+DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR_UINT, BT_V8HI, BT_SHORTCONSTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR_USHORT, BT_V8HI, BT_SHORTCONSTPTR, BT_USHORT)
+DEF_OV_TYPE (BT_OV_V8HI_SHORT_INT, BT_V8HI, BT_SHORT, BT_INT)
+DEF_OV_TYPE (BT_OV_V8HI_SHORT_V8HI_INT, BT_V8HI, BT_SHORT, BT_V8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_V8HI_UV8HI_V8HI_V8HI, BT_V8HI, BT_UV8HI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_V16QI, BT_V8HI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V8HI_V16QI_V16QI, BT_V8HI, BT_V16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V8HI_V16QI_V16QI_V8HI, BT_V8HI, BT_V16QI, BT_V16QI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V8HI_V4SI_V4SI, BT_V8HI, BT_V4SI, BT_V4SI)
+DEF_OV_TYPE (BT_OV_V8HI_V4SI_V4SI_INTPTR, BT_V8HI, BT_V4SI, BT_V4SI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_BV8HI, BT_V8HI, BT_V8HI, BT_BV8HI)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_INTPTR, BT_V8HI, BT_V8HI, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_UCHAR, BT_V8HI, BT_V8HI, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_ULONG, BT_V8HI, BT_V8HI, BT_ULONG)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV16QI, BT_V8HI, BT_V8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V8HI_BV8HI_V8HI, BT_V8HI, BT_BV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV4SI, BT_V8HI, BT_V8HI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_BV8HI, BT_V8HI, BT_V8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR_UINT, BT_V8HI, BT_SHORTCONSTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_V8HI_SHORT_INT, BT_V8HI, BT_SHORT, BT_INT)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_UCHAR, BT_V8HI, BT_V8HI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR_USHORT, BT_V8HI, BT_SHORTCONSTPTR, BT_USHORT)
-DEF_OV_TYPE (BT_OV_V8HI_V16QI_V16QI, BT_V8HI, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_VOID_V2DF_DBLPTR_UINT, BT_VOID, BT_V2DF, BT_DBLPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_UV16QI_UCHARPTR_UINT, BT_VOID, BT_UV16QI, BT_UCHARPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_V4SI_INTPTR_UINT, BT_VOID, BT_V4SI, BT_INTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_UINTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_UINTPTR)
-DEF_OV_TYPE (BT_OV_VOID_V4SI_LONG_INTPTR, BT_VOID, BT_V4SI, BT_LONG, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_VOID_V2DI_LONG_LONGLONGPTR, BT_VOID, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
-DEF_OV_TYPE (BT_OV_VOID_V8HI_SHORTPTR_UINT, BT_VOID, BT_V8HI, BT_SHORTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_V2DF_LONG_DBLPTR, BT_VOID, BT_V2DF, BT_LONG, BT_DBLPTR)
-DEF_OV_TYPE (BT_OV_VOID_UV8HI_USHORTPTR_UINT, BT_VOID, BT_UV8HI, BT_USHORTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_UV2DI_ULONGLONGPTR_UINT, BT_VOID, BT_UV2DI, BT_ULONGLONGPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_UV16QI_LONG_UCHARPTR, BT_VOID, BT_UV16QI, BT_LONG, BT_UCHARPTR)
-DEF_OV_TYPE (BT_OV_VOID_UV8HI_LONG_USHORTPTR, BT_VOID, BT_UV8HI, BT_LONG, BT_USHORTPTR)
-DEF_OV_TYPE (BT_OV_VOID_UV4SI_UINTPTR_UINT, BT_VOID, BT_UV4SI, BT_UINTPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_V16QI_SCHARPTR_UINT, BT_VOID, BT_V16QI, BT_SCHARPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_VOID_V16QI_LONG_SCHARPTR, BT_VOID, BT_V16QI, BT_LONG, BT_SCHARPTR)
-DEF_OV_TYPE (BT_OV_VOID_V8HI_LONG_SHORTPTR, BT_VOID, BT_V8HI, BT_LONG, BT_SHORTPTR)
-DEF_OV_TYPE (BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR, BT_VOID, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
-DEF_OV_TYPE (BT_OV_VOID_V2DI_LONGLONGPTR_UINT, BT_VOID, BT_V2DI, BT_LONGLONGPTR, BT_UINT)
-DEF_OV_TYPE (BT_OV_UV16QI_UV8HI_UV8HI_INTPTR, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UCHAR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_ULONGLONG, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_INT, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_UV16QI, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_UV16QI_INT, BT_UV16QI, BT_UCHAR, BT_UV16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_UV16QI, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI_INTPTR, BT_UV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_BV16QI_BV16QI_BV16QI_INTPTR, BT_BV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_INTPTR, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV16QI_V16QI_V16QI_INTPTR, BT_BV16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV16QI_UCHAR_BV16QI_INT, BT_UV16QI, BT_UCHAR, BT_BV16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_INTPTR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_ULONGLONG, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_UV2DI_INT, BT_UV2DI, BT_ULONGLONG, BT_UV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_INT, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_INT, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UCHAR, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV4SI_UV4SI_UV2DI, BT_UV2DI, BT_UV4SI, BT_UV4SI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_BV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_UV16QI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_UV2DI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_BV2DI_UV16QI, BT_BV2DI, BT_BV2DI, BT_BV2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG_BV2DI_INT, BT_UV2DI, BT_ULONGLONG, BT_BV2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV8HI_UV8HI_UV4SI, BT_UV4SI, BT_UV8HI, BT_UV8HI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_BV4SI_V4SI_V4SI_INTPTR, BT_BV4SI, BT_V4SI, BT_V4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UCHAR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_INTPTR, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UINT_UV4SI_INT, BT_UV4SI, BT_UINT, BT_UV4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_INTPTR, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV2DI_UV2DI_INTPTR, BT_UV4SI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI_INTPTR, BT_UV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV16QI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_UV4SI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_UV4SI, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UINT_BV4SI_INT, BT_UV4SI, BT_UINT, BT_BV4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_INT, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_INTPTR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_BV4SI_UV16QI, BT_BV4SI, BT_BV4SI, BT_BV4SI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_ULONGLONG, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_UV8HI, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_INTPTR, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_UV4SI_UV4SI_INTPTR, BT_UV8HI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_UV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_INTPTR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV16QI_UV16QI_UV8HI, BT_UV8HI, BT_UV16QI, BT_UV16QI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV16QI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_BV8HI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_ULONGLONG, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV8HI_USHORT_BV8HI_INT, BT_UV8HI, BT_USHORT, BT_BV8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV8HI_V8HI_V8HI_INTPTR, BT_BV8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_INT, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_BV8HI_BV8HI_BV8HI_UV16QI, BT_BV8HI, BT_BV8HI, BT_BV8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UCHAR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_INTPTR, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI_INTPTR, BT_UV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_USHORT_UV8HI_INT, BT_UV8HI, BT_USHORT, BT_UV8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_V16QI_SCHAR_V16QI_INT, BT_V16QI, BT_SCHAR, BT_V16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_BV16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_BV16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_V16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_INTPTR, BT_V16QI, BT_V16QI, BT_V16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V16QI_UV16QI_V16QI_V16QI, BT_V16QI, BT_UV16QI, BT_V16QI, BT_V16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_ULONGLONG, BT_V16QI, BT_V16QI, BT_V16QI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_V16QI_V8HI_V8HI_INTPTR, BT_V16QI, BT_V8HI, BT_V8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI_UCHAR, BT_V16QI, BT_V16QI, BT_UV16QI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_UV16QI_UV16QI, BT_V16QI, BT_V16QI, BT_UV16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_INT, BT_V16QI, BT_V16QI, BT_V16QI, BT_INT)
-DEF_OV_TYPE (BT_OV_V16QI_V16QI_V16QI_UV16QI, BT_V16QI, BT_V16QI, BT_V16QI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI_UCHAR, BT_V2DI, BT_V2DI, BT_UV2DI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_INT, BT_V2DI, BT_V2DI, BT_V2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_ULONGLONG, BT_V2DF, BT_V2DF, BT_V2DF, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_UV16QI, BT_V2DI, BT_V2DI, BT_V2DI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_INT, BT_V2DF, BT_V2DF, BT_V2DF, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_UV2DI, BT_V2DI, BT_V2DI, BT_V2DI, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_UV16QI, BT_V2DF, BT_V2DF, BT_V2DF, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_ULONGLONG, BT_V2DI, BT_V2DI, BT_V2DI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_V2DF_DBL_V2DF_INT, BT_V2DF, BT_DBL, BT_V2DF, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DI_V4SI_V4SI_V2DI, BT_V2DI, BT_V4SI, BT_V4SI, BT_V2DI)
-DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_V2DI_INT, BT_V2DI, BT_LONGLONG, BT_V2DI, BT_INT)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_V2DI_BV2DI, BT_V2DI, BT_V2DI, BT_V2DI, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_UV2DI, BT_V2DF, BT_V2DF, BT_V2DF, BT_UV2DI)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_V2DF_BV2DI, BT_V2DF, BT_V2DF, BT_V2DF, BT_BV2DI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_BV4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_BV4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_UV16QI, BT_V4SI, BT_V4SI, BT_V4SI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_INT, BT_V4SI, BT_V4SI, BT_V4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_UV4SI, BT_V4SI, BT_V4SI, BT_UV4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_ULONGLONG, BT_V4SI, BT_V4SI, BT_V4SI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_UCHAR, BT_V4SI, BT_V4SI, BT_UV4SI, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI_V4SI, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V4SI_UV4SI_V4SI_V4SI, BT_V4SI, BT_UV4SI, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_V4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_V4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI_INTPTR, BT_V4SI, BT_V2DI, BT_V2DI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_UV4SI, BT_V4SI, BT_V4SI, BT_V4SI, BT_UV4SI)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_V4SI_INTPTR, BT_V4SI, BT_V4SI, BT_V4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V4SI_INT_V4SI_INT, BT_V4SI, BT_INT, BT_V4SI, BT_INT)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_INT, BT_V8HI, BT_V8HI, BT_V8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV8HI, BT_V8HI, BT_V8HI, BT_UV8HI)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV8HI_UCHAR, BT_V8HI, BT_V8HI, BT_UV8HI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_UV8HI_UV8HI, BT_V8HI, BT_V8HI, BT_UV8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_UV8HI, BT_V8HI, BT_V8HI, BT_V8HI, BT_UV8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_INTPTR, BT_V8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V8HI_UV8HI_V8HI_V8HI, BT_V8HI, BT_UV8HI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V16QI_V16QI_V8HI, BT_V8HI, BT_V16QI, BT_V16QI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_BV8HI, BT_V8HI, BT_V8HI, BT_V8HI, BT_BV8HI)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_INT, BT_V8HI, BT_V8HI, BT_V8HI, BT_INT)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_INTPTR, BT_V8HI, BT_V8HI, BT_V8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_ULONGLONG, BT_V8HI, BT_V8HI, BT_V8HI, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_V8HI_SHORT_V8HI_INT, BT_V8HI, BT_SHORT, BT_V8HI, BT_INT)
-DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_V8HI, BT_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
-DEF_OV_TYPE (BT_OV_V8HI_V4SI_V4SI_INTPTR, BT_V8HI, BT_V4SI, BT_V4SI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_UV16QI, BT_V8HI, BT_V8HI, BT_V8HI, BT_UV16QI)
-DEF_OV_TYPE (BT_OV_VOID_V2DF_UV2DI_DBLPTR_ULONGLONG, BT_VOID, BT_V2DF, BT_UV2DI, BT_DBLPTR, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_VOID_V4SI_UV4SI_INTPTR_ULONGLONG, BT_VOID, BT_V4SI, BT_UV4SI, BT_INTPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_UV8HI, BT_V8HI, BT_V8HI, BT_V8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_V8HI_V8HI_V8HI_V8HI, BT_V8HI, BT_V8HI, BT_V8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_VOID_BV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_BV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_BV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_BV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV16QI_LONG_UCHARPTR, BT_VOID, BT_UV16QI, BT_LONG, BT_UCHARPTR)
+DEF_OV_TYPE (BT_OV_VOID_UV16QI_UCHARPTR_UINT, BT_VOID, BT_UV16QI, BT_UCHARPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR, BT_VOID, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
+DEF_OV_TYPE (BT_OV_VOID_UV2DI_ULONGLONGPTR_UINT, BT_VOID, BT_UV2DI, BT_ULONGLONGPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_UINTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_UINTPTR)
+DEF_OV_TYPE (BT_OV_VOID_UV4SI_UINTPTR_UINT, BT_VOID, BT_UV4SI, BT_UINTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_VOID_BV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_BV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV8HI_LONG_USHORTPTR, BT_VOID, BT_UV8HI, BT_LONG, BT_USHORTPTR)
+DEF_OV_TYPE (BT_OV_VOID_UV8HI_USHORTPTR_UINT, BT_VOID, BT_UV8HI, BT_USHORTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_V16QI_LONG_SCHARPTR, BT_VOID, BT_V16QI, BT_LONG, BT_SCHARPTR)
+DEF_OV_TYPE (BT_OV_VOID_V16QI_SCHARPTR_UINT, BT_VOID, BT_V16QI, BT_SCHARPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_V2DF_DBLPTR_UINT, BT_VOID, BT_V2DF, BT_DBLPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_V2DF_LONG_DBLPTR, BT_VOID, BT_V2DF, BT_LONG, BT_DBLPTR)
+DEF_OV_TYPE (BT_OV_VOID_V2DF_UV2DI_DBLPTR_ULONGLONG, BT_VOID, BT_V2DF, BT_UV2DI, BT_DBLPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_V2DI_LONGLONGPTR_UINT, BT_VOID, BT_V2DI, BT_LONGLONGPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_V2DI_LONG_LONGLONGPTR, BT_VOID, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
 DEF_OV_TYPE (BT_OV_VOID_V2DI_UV2DI_LONGLONGPTR_ULONGLONG, BT_VOID, BT_V2DI, BT_UV2DI, BT_LONGLONGPTR, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_VOID_BV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_BV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
-DEF_OV_TYPE (BT_OV_UV16QI_UV16QI_UV16QI_UV16QI_INTPTR, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV16QI_UV16QI_UV16QI_UV16QI_INTPTR, BT_BV16QI, BT_UV16QI, BT_UV16QI, BT_UV16QI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_BV2DI_BV2DI_UV2DI_ULONGLONGCONSTPTR_UCHAR, BT_BV2DI, BT_BV2DI, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_UV2DI_UV2DI_UV2DI_ULONGLONGCONSTPTR_UCHAR, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_ULONGLONGCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV4SI_BV4SI_UV4SI_UINTCONSTPTR_UCHAR, BT_BV4SI, BT_BV4SI, BT_UV4SI, BT_UINTCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV4SI_UV4SI_UV4SI_UV4SI_INTPTR, BT_BV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UV4SI_INTPTR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV4SI_UV4SI_UV4SI_UINTCONSTPTR_UCHAR, BT_UV4SI, BT_UV4SI, BT_UV4SI, BT_UINTCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_BV8HI_UV8HI_UV8HI_UV8HI_INTPTR, BT_BV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_UV8HI_UV8HI_INTPTR, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
-DEF_OV_TYPE (BT_OV_V2DI_V2DI_UV2DI_LONGLONGCONSTPTR_UCHAR, BT_V2DI, BT_V2DI, BT_UV2DI, BT_LONGLONGCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V2DF_V2DF_UV2DI_DBLCONSTPTR_UCHAR, BT_V2DF, BT_V2DF, BT_UV2DI, BT_DBLCONSTPTR, BT_UCHAR)
-DEF_OV_TYPE (BT_OV_V4SI_V4SI_UV4SI_INTCONSTPTR_UCHAR, BT_V4SI, BT_V4SI, BT_UV4SI, BT_INTCONSTPTR, BT_UCHAR)
+DEF_OV_TYPE (BT_OV_VOID_V4SI_INTPTR_UINT, BT_VOID, BT_V4SI, BT_INTPTR, BT_UINT)
+DEF_OV_TYPE (BT_OV_VOID_V4SI_LONG_INTPTR, BT_VOID, BT_V4SI, BT_LONG, BT_INTPTR)
+DEF_OV_TYPE (BT_OV_VOID_V4SI_UV4SI_INTPTR_ULONGLONG, BT_VOID, BT_V4SI, BT_UV4SI, BT_INTPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_V8HI_LONG_SHORTPTR, BT_VOID, BT_V8HI, BT_LONG, BT_SHORTPTR)
+DEF_OV_TYPE (BT_OV_VOID_V8HI_SHORTPTR_UINT, BT_VOID, BT_V8HI, BT_SHORTPTR, BT_UINT)
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index b267b04..b0a86e9 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -362,6 +362,15 @@ B_DEF      (s390_vrepih,                vec_splatsv8hi,     0,
 B_DEF      (s390_vrepif,                vec_splatsv4si,     0,                  B_VX,               O1_S16,             BT_FN_V4SI_SHORT)
 B_DEF      (s390_vrepig,                vec_splatsv2di,     0,                  B_VX,               O1_S16,             BT_FN_V2DI_SHORT)
 
+B_DEF      (s390_vec_splat_u8,          vec_splatsv16qi,    0,                  B_VX,               O1_U8,              BT_FN_UV16QI_UCHAR)
+B_DEF      (s390_vec_splat_s8,          vec_splatsv16qi,    0,                  B_VX,               O1_S8,              BT_FN_V16QI_SCHAR)
+B_DEF      (s390_vec_splat_u16,         vec_splatsv8hi,     0,                  B_VX,               O1_U16,             BT_FN_UV8HI_USHORT)
+B_DEF      (s390_vec_splat_s16,         vec_splatsv8hi,     0,                  B_VX,               O1_S16,             BT_FN_V8HI_SHORT)
+B_DEF      (s390_vec_splat_u32,         vec_splatsv4si,     0,                  B_VX,               O1_U16,             BT_FN_UV4SI_USHORT)
+B_DEF      (s390_vec_splat_s32,         vec_splatsv4si,     0,                  B_VX,               O1_S16,             BT_FN_V4SI_SHORT)
+B_DEF      (s390_vec_splat_u64,         vec_splatsv2di,     0,                  B_VX,               O1_U16,             BT_FN_UV2DI_USHORT)
+B_DEF      (s390_vec_splat_s64,         vec_splatsv2di,     0,                  B_VX,               O1_S16,             BT_FN_V2DI_SHORT)
+
 OB_DEF     (s390_vec_insert,            s390_vec_insert_s8, s390_vec_insert_dbl,B_VX,               BT_FN_OV4SI_INT_OV4SI_INT)
 OB_DEF_VAR (s390_vec_insert_s8,         s390_vlvgb,         O3_ELEM,            BT_OV_V16QI_SCHAR_V16QI_INT)
 OB_DEF_VAR (s390_vec_insert_u8,         s390_vlvgb,         O3_ELEM,            BT_OV_UV16QI_UCHAR_UV16QI_INT)
@@ -2461,15 +2470,15 @@ OB_DEF     (s390_vec_ctd,               s390_vec_ctd_s64,   s390_vec_ctd_u64,
 OB_DEF_VAR (s390_vec_ctd_s64,           s390_vec_ctd_s64,   O2_U5,              BT_OV_V2DF_V2DI_INT)                     /* vcdgb */
 OB_DEF_VAR (s390_vec_ctd_u64,           s390_vec_ctd_u64,   O2_U5,              BT_OV_V2DF_UV2DI_INT)                    /* vcdlgb */
 
-B_DEF      (s390_vec_ctd_s64,           vec_ctd_s64,        0,                  B_VX,               O2_U5,              BT_FN_V2DF_V2DI_INT)                     /* vcdgb */
-B_DEF      (s390_vec_ctd_u64,           vec_ctd_u64,        0,                  B_VX,               O2_U5,              BT_FN_V2DF_UV2DI_INT)                    /* vcdlgb */
-B_DEF      (s390_vcdgb,                 vec_di_to_df_s64,   0,                  B_VX,               O2_U5,              BT_FN_V2DF_V2DI_INT)
-B_DEF      (s390_vcdlgb,                vec_di_to_df_u64,   0,                  B_VX,               O2_U5,              BT_FN_V2DF_UV2DI_INT)
-B_DEF      (s390_vec_ctsl,              vec_ctsl,           0,                  B_VX,               O2_U5,              BT_FN_V2DI_V2DF_INT)                     /* vcgdb */
-B_DEF      (s390_vec_ctul,              vec_ctul,           0,                  B_VX,               O2_U5,              BT_FN_UV2DI_V2DF_INT)                    /* vclgdb */
-B_DEF      (s390_vcgdb,                 vec_df_to_di_s64,   0,                  B_VX,               O2_U5,              BT_FN_V2DI_V2DF_INT)
-B_DEF      (s390_vclgdb,                vec_df_to_di_u64,   0,                  B_VX,               O2_U5,              BT_FN_UV2DI_V2DF_INT)
-B_DEF      (s390_vfidb,                 vfidb,              0,                  B_VX,               O2_U4 | O3_U4,      BT_FN_V2DF_V2DF_UCHAR_UCHAR)
+B_DEF      (s390_vec_ctd_s64,           vec_ctd_s64,        0,                  B_VX,               O2_U3,              BT_FN_V2DF_V2DI_INT)                     /* vcdgb */
+B_DEF      (s390_vec_ctd_u64,           vec_ctd_u64,        0,                  B_VX,               O2_U3,              BT_FN_V2DF_UV2DI_INT)                    /* vcdlgb */
+B_DEF      (s390_vcdgb,                 vec_di_to_df_s64,   0,                  B_VX,               O2_U3,              BT_FN_V2DF_V2DI_INT)                     /* vcdgb */
+B_DEF      (s390_vcdlgb,                vec_di_to_df_u64,   0,                  B_VX,               O2_U3,              BT_FN_V2DF_UV2DI_INT)                    /* vcdlgb */
+B_DEF      (s390_vec_ctsl,              vec_ctsl,           0,                  B_VX,               O2_U3,              BT_FN_V2DI_V2DF_INT)                     /* vcgdb */
+B_DEF      (s390_vec_ctul,              vec_ctul,           0,                  B_VX,               O2_U3,              BT_FN_UV2DI_V2DF_INT)                    /* vclgdb */
+B_DEF      (s390_vcgdb,                 vec_df_to_di_s64,   0,                  B_VX,               O2_U3,              BT_FN_V2DI_V2DF_INT)                     /* vcgdb */
+B_DEF      (s390_vclgdb,                vec_df_to_di_u64,   0,                  B_VX,               O2_U3,              BT_FN_UV2DI_V2DF_INT)                    /* vclgdb */
+B_DEF      (s390_vfidb,                 vfidb,              0,                  B_VX,               O2_U4 | O3_U3,      BT_FN_V2DF_V2DF_UCHAR_UCHAR)
 B_DEF      (s390_vec_ld2f,              vec_ld2f,           0,                  B_VX,               0,                  BT_FN_V2DF_FLTCONSTPTR)                  /* vldeb */
 B_DEF      (s390_vec_st2f,              vec_st2f,           0,                  B_VX,               0,                  BT_FN_VOID_V2DF_FLTPTR)                  /* vledb */
 B_DEF      (s390_vfmadb,                fmav2df4,           0,                  B_VX,               0,                  BT_FN_V2DF_V2DF_V2DF_V2DF)
diff --git a/gcc/config/s390/s390-c.c b/gcc/config/s390/s390-c.c
index a55ac95..e37e321 100644
--- a/gcc/config/s390/s390-c.c
+++ b/gcc/config/s390/s390-c.c
@@ -427,22 +427,14 @@ s390_get_vstring_flags (int ob_fcode)
   switch (ob_fcode)
     {
 
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq_or_0_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne_or_0_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq_or_0_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne_or_0_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg_or_0_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg_or_0_idx:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg_or_0_idx_cc:
-    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg_or_0_idx_cc:
+    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq:
+    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne:
+    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_eq_cc:
+    case S390_OVERLOADED_BUILTIN_s390_vec_find_any_ne_cc:
+    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg:
+    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg:
+    case S390_OVERLOADED_BUILTIN_s390_vec_cmprg_cc:
+    case S390_OVERLOADED_BUILTIN_s390_vec_cmpnrg_cc:
       flags |= __VSTRING_FLAG_RT;
       break;
     default:
@@ -828,13 +820,14 @@ s390_resolve_overloaded_builtin (location_t loc,
 
   if (last_match_type == INT_MAX)
     {
-      error_at (loc, "invalid parameter combination for intrinsic");
+      error_at (loc, "invalid parameter combination for intrinsic %qs",
+		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
       return error_mark_node;
     }
   else if (num_matches > 1)
     {
-      error_at (loc, "ambiguous overload for intrinsic: %s\n",
-	     IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
+      error_at (loc, "ambiguous overload for intrinsic %qs",
+		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
       return error_mark_node;
     }
 
diff --git a/gcc/config/s390/s390-protos.h b/gcc/config/s390/s390-protos.h
index a8b8854..9190d8a 100644
--- a/gcc/config/s390/s390-protos.h
+++ b/gcc/config/s390/s390-protos.h
@@ -89,6 +89,7 @@ extern bool s390_expand_movmem (rtx, rtx, rtx);
 extern void s390_expand_setmem (rtx, rtx, rtx);
 extern bool s390_expand_cmpmem (rtx, rtx, rtx, rtx);
 extern void s390_expand_vec_strlen (rtx, rtx, rtx);
+extern void s390_expand_vec_movstr (rtx, rtx, rtx);
 extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
 extern bool s390_expand_insv (rtx, rtx, rtx, rtx);
 extern void s390_expand_cs_hqi (machine_mode, rtx, rtx, rtx,
@@ -124,6 +125,8 @@ extern int s390_compare_and_branch_condition_mask (rtx);
 extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);
 extern void s390_asm_output_function_label (FILE *, const char *, tree);
 
+extern bool s390_const_vec_duplicate_p (rtx);
+
 #endif /* RTX_CODE */
 
 /* s390-c.c routines */
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index ba2a151..64407bb 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -101,6 +101,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "plugin-api.h"
 #include "ipa-ref.h"
 #include "cgraph.h"
+#include "tm-constrs.h"
 
 /* Define the specific costs for a given cpu.  */
 
@@ -337,6 +338,19 @@ extern int reload_completed;
 
 /* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */
 static rtx_insn *last_scheduled_insn;
+#define MAX_SCHED_UNITS 3
+static int last_scheduled_unit_distance[MAX_SCHED_UNITS];
+
+/* The maximum score added for an instruction whose unit hasn't been
+   in use for MAX_SCHED_MIX_DISTANCE steps.  Increase this value to
+   give instruction mix scheduling more priority over instruction
+   grouping.  */
+#define MAX_SCHED_MIX_SCORE      8
+
+/* The maximum distance up to which individual scores will be
+   calculated.  Everything beyond this gives MAX_SCHED_MIX_SCORE.
+   Increase this with the OOO windows size of the machine.  */
+#define MAX_SCHED_MIX_DISTANCE 100
 
 /* Structure used to hold the components of a S/390 memory
    address.  A legitimate address on S/390 is of the general
@@ -377,6 +391,8 @@ struct GTY (()) s390_frame_layout
      be saved to.
       0 - does not need to be saved at all
      -1 - stack slot  */
+#define SAVE_SLOT_NONE   0
+#define SAVE_SLOT_STACK -1
   signed char gpr_save_slots[16];
 
   /* Number of first and last gpr to be saved, restored.  */
@@ -858,6 +874,15 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
       insn_op = &insn_data[icode].operand[arity + nonvoid];
       op[arity] = expand_expr (arg, NULL_RTX, insn_op->mode, EXPAND_NORMAL);
 
+      /* expand_expr truncates constants to the target mode only if it
+	 is "convenient".  However, our checks below rely on this
+	 being done.  */
+      if (CONST_INT_P (op[arity])
+	  && SCALAR_INT_MODE_P (insn_op->mode)
+	  && GET_MODE (op[arity]) != insn_op->mode)
+	op[arity] = GEN_INT (trunc_int_for_mode (INTVAL (op[arity]),
+						 insn_op->mode));
+
       /* Wrap the expanded RTX for pointer types into a MEM expr with
 	 the proper mode.  This allows us to use e.g. (match_operand
 	 "memory_operand"..) in the insn patterns instead of (mem
@@ -2266,6 +2291,24 @@ s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT in, int size,
   return true;
 }
 
+bool
+s390_const_vec_duplicate_p (rtx op)
+{
+ if (!VECTOR_MODE_P (GET_MODE (op))
+      || GET_CODE (op) != CONST_VECTOR
+      || !CONST_INT_P (XVECEXP (op, 0, 0)))
+    return false;
+
+  if (GET_MODE_NUNITS (GET_MODE (op)) > 1)
+    {
+      int i;
+
+      for (i = 1; i < GET_MODE_NUNITS (GET_MODE (op)); ++i)
+	if (!rtx_equal_p (XVECEXP (op, 0, i), XVECEXP (op, 0, 0)))
+	  return false;
+    }
+  return true;
+}
 /* Return true if OP contains the same contiguous bitfield in *all*
    its elements.  START and END can be used to obtain the start and
    end position of the bitfield.
@@ -2281,20 +2324,9 @@ s390_contiguous_bitmask_vector_p (rtx op, int *start, int *end)
   unsigned HOST_WIDE_INT mask;
   int length, size;
 
-  if (!VECTOR_MODE_P (GET_MODE (op))
-      || GET_CODE (op) != CONST_VECTOR
-      || !CONST_INT_P (XVECEXP (op, 0, 0)))
+  if (!s390_const_vec_duplicate_p (op))
     return false;
 
-  if (GET_MODE_NUNITS (GET_MODE (op)) > 1)
-    {
-      int i;
-
-      for (i = 1; i < GET_MODE_NUNITS (GET_MODE (op)); ++i)
-	if (!rtx_equal_p (XVECEXP (op, 0, i), XVECEXP (op, 0, 0)))
-	  return false;
-    }
-
   size = GET_MODE_UNIT_BITSIZE (GET_MODE (op));
   mask = UINTVAL (XVECEXP (op, 0, 0));
   if (s390_contiguous_bitmask_p (mask, size, start,
@@ -3657,9 +3689,11 @@ s390_legitimate_constant_p (machine_mode mode, rtx op)
       if (GET_MODE_SIZE (mode) != 16)
 	return 0;
 
-      if (!const0_operand (op, mode)
-	  && !s390_contiguous_bitmask_vector_p (op, NULL, NULL)
-	  && !s390_bytemask_vector_p (op, NULL))
+      if (!satisfies_constraint_j00 (op)
+	  && !satisfies_constraint_jm1 (op)
+	  && !satisfies_constraint_jKK (op)
+	  && !satisfies_constraint_jxx (op)
+	  && !satisfies_constraint_jyy (op))
 	return 0;
     }
 
@@ -3840,14 +3874,12 @@ legitimate_reload_fp_constant_p (rtx op)
 static bool
 legitimate_reload_vector_constant_p (rtx op)
 {
-  /* FIXME: Support constant vectors with all the same 16 bit unsigned
-     operands.  These can be loaded with vrepi.  */
-
   if (TARGET_VX && GET_MODE_SIZE (GET_MODE (op)) == 16
-      && (const0_operand (op, GET_MODE (op))
-	  || constm1_operand (op, GET_MODE (op))
-	  || s390_contiguous_bitmask_vector_p (op, NULL, NULL)
-	  || s390_bytemask_vector_p (op, NULL)))
+      && (satisfies_constraint_j00 (op)
+	  || satisfies_constraint_jm1 (op)
+	  || satisfies_constraint_jKK (op)
+	  || satisfies_constraint_jxx (op)
+	  || satisfies_constraint_jyy (op)))
     return true;
 
   return false;
@@ -5545,6 +5577,124 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)
     emit_move_insn (target, temp);
 }
 
+void
+s390_expand_vec_movstr (rtx result, rtx dst, rtx src)
+{
+  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;
+  rtx temp = gen_reg_rtx (Pmode);
+  rtx src_addr = XEXP (src, 0);
+  rtx dst_addr = XEXP (dst, 0);
+  rtx src_addr_reg = gen_reg_rtx (Pmode);
+  rtx dst_addr_reg = gen_reg_rtx (Pmode);
+  rtx offset = gen_reg_rtx (Pmode);
+  rtx vsrc = gen_reg_rtx (V16QImode);
+  rtx vpos = gen_reg_rtx (V16QImode);
+  rtx loadlen = gen_reg_rtx (SImode);
+  rtx gpos_qi = gen_reg_rtx(QImode);
+  rtx gpos = gen_reg_rtx (SImode);
+  rtx done_label = gen_label_rtx ();
+  rtx loop_label = gen_label_rtx ();
+  rtx exit_label = gen_label_rtx ();
+  rtx full_label = gen_label_rtx ();
+
+  /* Perform a quick check for string ending on the first up to 16
+     bytes and exit early if successful.  */
+
+  emit_insn (gen_vlbb (vsrc, src, GEN_INT (6)));
+  emit_insn (gen_lcbb (loadlen, src_addr, GEN_INT (6)));
+  emit_insn (gen_vfenezv16qi (vpos, vsrc, vsrc));
+  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));
+  emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));
+  /* gpos is the byte index if a zero was found and 16 otherwise.
+     So if it is lower than the loaded bytes we have a hit.  */
+  emit_cmp_and_jump_insns (gpos, loadlen, GE, NULL_RTX, SImode, 1,
+			   full_label);
+  emit_insn (gen_vstlv16qi (vsrc, gpos, dst));
+
+  force_expand_binop (Pmode, add_optab, dst_addr, gpos, result,
+		      1, OPTAB_DIRECT);
+  emit_jump (exit_label);
+  emit_barrier ();
+
+  emit_label (full_label);
+  LABEL_NUSES (full_label) = 1;
+
+  /* Calculate `offset' so that src + offset points to the last byte
+     before 16 byte alignment.  */
+
+  /* temp = src_addr & 0xf */
+  force_expand_binop (Pmode, and_optab, src_addr, GEN_INT (15), temp,
+		      1, OPTAB_DIRECT);
+
+  /* offset = 0xf - temp */
+  emit_move_insn (offset, GEN_INT (15));
+  force_expand_binop (Pmode, sub_optab, offset, temp, offset,
+		      1, OPTAB_DIRECT);
+
+  /* Store `offset' bytes in the dstination string.  The quick check
+     has loaded at least `offset' bytes into vsrc.  */
+
+  emit_insn (gen_vstlv16qi (vsrc, gen_lowpart (SImode, offset), dst));
+
+  /* Advance to the next byte to be loaded.  */
+  force_expand_binop (Pmode, add_optab, offset, const1_rtx, offset,
+		      1, OPTAB_DIRECT);
+
+  /* Make sure the addresses are single regs which can be used as a
+     base.  */
+  emit_move_insn (src_addr_reg, src_addr);
+  emit_move_insn (dst_addr_reg, dst_addr);
+
+  /* MAIN LOOP */
+
+  emit_label (loop_label);
+  LABEL_NUSES (loop_label) = 1;
+
+  emit_move_insn (vsrc,
+		  gen_rtx_MEM (V16QImode,
+			       gen_rtx_PLUS (Pmode, src_addr_reg, offset)));
+
+  emit_insn (gen_vec_vfenesv16qi (vpos, vsrc, vsrc,
+				  GEN_INT (VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));
+  add_int_reg_note (s390_emit_ccraw_jump (8, EQ, done_label),
+		    REG_BR_PROB, very_unlikely);
+
+  emit_move_insn (gen_rtx_MEM (V16QImode,
+			       gen_rtx_PLUS (Pmode, dst_addr_reg, offset)),
+		  vsrc);
+  /* offset += 16 */
+  force_expand_binop (Pmode, add_optab, offset, GEN_INT (16),
+		      offset,  1, OPTAB_DIRECT);
+
+  emit_jump (loop_label);
+  emit_barrier ();
+
+  /* REGULAR EXIT */
+
+  /* We are done.  Add the offset of the zero character to the dst_addr
+     pointer to get the result.  */
+
+  emit_label (done_label);
+  LABEL_NUSES (done_label) = 1;
+
+  force_expand_binop (Pmode, add_optab, dst_addr_reg, offset, dst_addr_reg,
+		      1, OPTAB_DIRECT);
+
+  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));
+  emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));
+
+  emit_insn (gen_vstlv16qi (vsrc, gpos, gen_rtx_MEM (BLKmode, dst_addr_reg)));
+
+  force_expand_binop (Pmode, add_optab, dst_addr_reg, gpos, result,
+		      1, OPTAB_DIRECT);
+
+  /* EARLY EXIT */
+
+  emit_label (exit_label);
+  LABEL_NUSES (exit_label) = 1;
+}
+
+
 /* Expand conditional increment or decrement using alc/slb instructions.
    Should generate code setting DST to either SRC or SRC + INCREMENT,
    depending on the result of the comparison CMP_OP0 CMP_CODE CMP_OP1.
@@ -6084,17 +6234,17 @@ s390_expand_vcond (rtx target, rtx then, rtx els,
      predicates.  But it appears to be better for scheduling etc. to
      have that in early.  */
   if (!REG_P (cmp_op1))
-    cmp_op1 = force_reg (GET_MODE (target), cmp_op1);
+    cmp_op1 = force_reg (GET_MODE (cmp_op1), cmp_op1);
 
   if (!REG_P (cmp_op2))
-    cmp_op2 = force_reg (GET_MODE (target), cmp_op2);
+    cmp_op2 = force_reg (GET_MODE (cmp_op2), cmp_op2);
 
   s390_expand_vec_compare (result_target, cond,
 			   cmp_op1, cmp_op2);
 
   /* If the results are supposed to be either -1 or 0 we are done
      since this is what our compare instructions generate anyway.  */
-  if (constm1_operand (then, GET_MODE (then))
+  if (all_ones_operand (then, GET_MODE (then))
       && const0_operand (els, GET_MODE (els)))
     {
       emit_move_insn (target, gen_rtx_SUBREG (GET_MODE (target),
@@ -7118,6 +7268,11 @@ print_operand (FILE *file, rtx x, int code)
     case CONST_VECTOR:
       switch (code)
 	{
+	case 'h':
+	  gcc_assert (s390_const_vec_duplicate_p (x));
+	  fprintf (file, HOST_WIDE_INT_PRINT_DEC,
+		   ((INTVAL (XVECEXP (x, 0, 0)) & 0xffff) ^ 0x8000) - 0x8000);
+	  break;
 	case 'e':
 	case 's':
 	  {
@@ -9003,7 +9158,7 @@ s390_register_info_gprtofpr ()
 
   for (i = 15; i >= 6; i--)
     {
-      if (cfun_gpr_save_slot (i) == 0)
+      if (cfun_gpr_save_slot (i) == SAVE_SLOT_NONE)
 	continue;
 
       /* Advance to the next FP register which can be used as a
@@ -9020,7 +9175,7 @@ s390_register_info_gprtofpr ()
 	     case we ran out of FPR save slots.  */
 	  for (j = 6; j <= 15; j++)
 	    if (FP_REGNO_P (cfun_gpr_save_slot (j)))
-	      cfun_gpr_save_slot (j) = -1;
+	      cfun_gpr_save_slot (j) = SAVE_SLOT_STACK;
 	  break;
 	}
       cfun_gpr_save_slot (i) = save_reg_slot++;
@@ -9047,12 +9202,16 @@ s390_register_info_stdarg_fpr ()
     return;
 
   min_fpr = crtl->args.info.fprs;
-  max_fpr = min_fpr + cfun->va_list_fpr_size;
-  if (max_fpr > FP_ARG_NUM_REG)
-    max_fpr = FP_ARG_NUM_REG;
+  max_fpr = min_fpr + cfun->va_list_fpr_size - 1;
+  if (max_fpr >= FP_ARG_NUM_REG)
+    max_fpr = FP_ARG_NUM_REG - 1;
+
+  /* FPR argument regs start at f0.  */
+  min_fpr += FPR0_REGNUM;
+  max_fpr += FPR0_REGNUM;
 
-  for (i = min_fpr; i < max_fpr; i++)
-    cfun_set_fpr_save (i + FPR0_REGNUM);
+  for (i = min_fpr; i <= max_fpr; i++)
+    cfun_set_fpr_save (i);
 }
 
 /* Reserve the GPR save slots for GPRs which need to be saved due to
@@ -9072,12 +9231,61 @@ s390_register_info_stdarg_gpr ()
     return;
 
   min_gpr = crtl->args.info.gprs;
-  max_gpr = min_gpr + cfun->va_list_gpr_size;
-  if (max_gpr > GP_ARG_NUM_REG)
-    max_gpr = GP_ARG_NUM_REG;
+  max_gpr = min_gpr + cfun->va_list_gpr_size - 1;
+  if (max_gpr >= GP_ARG_NUM_REG)
+    max_gpr = GP_ARG_NUM_REG - 1;
+
+  /* GPR argument regs start at r2.  */
+  min_gpr += GPR2_REGNUM;
+  max_gpr += GPR2_REGNUM;
+
+  /* If r6 was supposed to be saved into an FPR and now needs to go to
+     the stack for vararg we have to adjust the restore range to make
+     sure that the restore is done from stack as well.  */
+  if (FP_REGNO_P (cfun_gpr_save_slot (GPR6_REGNUM))
+      && min_gpr <= GPR6_REGNUM
+      && max_gpr >= GPR6_REGNUM)
+    {
+      if (cfun_frame_layout.first_restore_gpr == -1
+	  || cfun_frame_layout.first_restore_gpr > GPR6_REGNUM)
+	cfun_frame_layout.first_restore_gpr = GPR6_REGNUM;
+      if (cfun_frame_layout.last_restore_gpr == -1
+	  || cfun_frame_layout.last_restore_gpr < GPR6_REGNUM)
+	cfun_frame_layout.last_restore_gpr = GPR6_REGNUM;
+    }
+
+  if (cfun_frame_layout.first_save_gpr == -1
+      || cfun_frame_layout.first_save_gpr > min_gpr)
+    cfun_frame_layout.first_save_gpr = min_gpr;
+
+  if (cfun_frame_layout.last_save_gpr == -1
+      || cfun_frame_layout.last_save_gpr < max_gpr)
+    cfun_frame_layout.last_save_gpr = max_gpr;
 
-  for (i = min_gpr; i < max_gpr; i++)
-    cfun_gpr_save_slot (2 + i) = -1;
+  for (i = min_gpr; i <= max_gpr; i++)
+    cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;
+}
+
+/* Calculate the save and restore ranges for stm(g) and lm(g) in the
+   prologue and epilogue.  */
+
+static void
+s390_register_info_set_ranges ()
+{
+  int i, j;
+
+  /* Find the first and the last save slot supposed to use the stack
+     to set the restore range.
+     Vararg regs might be marked as save to stack but only the
+     call-saved regs really need restoring (i.e. r6).  This code
+     assumes that the vararg regs have not yet been recorded in
+     cfun_gpr_save_slot.  */
+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != SAVE_SLOT_STACK; i++);
+  for (j = 15; j > i && cfun_gpr_save_slot (j) != SAVE_SLOT_STACK; j--);
+  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;
+  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;
+  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;
+  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;
 }
 
 /* The GPR and FPR save slots in cfun->machine->frame_layout are set
@@ -9088,7 +9296,7 @@ s390_register_info_stdarg_gpr ()
 static void
 s390_register_info ()
 {
-  int i, j;
+  int i;
   char clobbered_regs[32];
 
   gcc_assert (!epilogue_completed);
@@ -9152,33 +9360,20 @@ s390_register_info ()
 	|| (reload_completed && cfun_frame_layout.frame_size > 0)
 	|| cfun->calls_alloca);
 
-  memset (cfun_frame_layout.gpr_save_slots, 0, 16);
+  memset (cfun_frame_layout.gpr_save_slots, SAVE_SLOT_NONE, 16);
 
   for (i = 6; i < 16; i++)
     if (clobbered_regs[i])
-      cfun_gpr_save_slot (i) = -1;
+      cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;
 
   s390_register_info_stdarg_fpr ();
   s390_register_info_gprtofpr ();
-
-  /* First find the range of GPRs to be restored.  Vararg regs don't
-     need to be restored so we do it before assigning slots to the
-     vararg GPRs.  */
-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);
-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);
-  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;
-  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;
-
+  s390_register_info_set_ranges ();
   /* stdarg functions might need to save GPRs 2 to 6.  This might
-     override the GPR->FPR save decision made above for r6 since
-     vararg regs must go to the stack.  */
+     override the GPR->FPR save decision made by
+     s390_register_info_gprtofpr for r6 since vararg regs must go to
+     the stack.  */
   s390_register_info_stdarg_gpr ();
-
-  /* Now the range of GPRs which need saving.  */
-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);
-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);
-  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;
-  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;
 }
 
 /* This function is called by s390_optimize_prologue in order to get
@@ -9189,7 +9384,7 @@ static void
 s390_optimize_register_info ()
 {
   char clobbered_regs[32];
-  int i, j;
+  int i;
 
   gcc_assert (epilogue_completed);
   gcc_assert (!cfun->machine->split_branches_pending_p);
@@ -9212,23 +9407,14 @@ s390_optimize_register_info ()
 	|| cfun_frame_layout.save_return_addr_p
 	|| crtl->calls_eh_return);
 
-  memset (cfun_frame_layout.gpr_save_slots, 0, 6);
+  memset (cfun_frame_layout.gpr_save_slots, SAVE_SLOT_NONE, 6);
 
   for (i = 6; i < 16; i++)
     if (!clobbered_regs[i])
-      cfun_gpr_save_slot (i) = 0;
-
-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);
-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);
-  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;
-  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;
+      cfun_gpr_save_slot (i) = SAVE_SLOT_NONE;
 
+  s390_register_info_set_ranges ();
   s390_register_info_stdarg_gpr ();
-
-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);
-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);
-  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;
-  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;
 }
 
 /* Fill cfun->machine with info about frame of current function.  */
@@ -9639,7 +9825,7 @@ s390_hard_regno_rename_ok (unsigned int old_reg, unsigned int new_reg)
      regrename manually about it.  */
   if (GENERAL_REGNO_P (new_reg)
       && !call_really_used_regs[new_reg]
-      && cfun_gpr_save_slot (new_reg) == 0)
+      && cfun_gpr_save_slot (new_reg) == SAVE_SLOT_NONE)
     return false;
 
   return true;
@@ -9654,7 +9840,7 @@ s390_hard_regno_scratch_ok (unsigned int regno)
   /* See s390_hard_regno_rename_ok.  */
   if (GENERAL_REGNO_P (regno)
       && !call_really_used_regs[regno]
-      && cfun_gpr_save_slot (regno) == 0)
+      && cfun_gpr_save_slot (regno) == SAVE_SLOT_NONE)
     return false;
 
   return true;
@@ -10127,6 +10313,10 @@ s390_save_gprs_to_fprs (void)
 	    emit_move_insn (gen_rtx_REG (DImode, cfun_gpr_save_slot (i)),
 			    gen_rtx_REG (DImode, i));
 	  RTX_FRAME_RELATED_P (insn) = 1;
+	  /* This prevents dwarf2cfi from interpreting the set.  Doing
+	     so it might emit def_cfa_register infos setting an FPR as
+	     new CFA.  */
+	  add_reg_note (insn, REG_CFA_REGISTER, PATTERN (insn));
 	}
     }
 }
@@ -10666,7 +10856,7 @@ s390_emit_epilogue (bool sibcall)
 	     be in between two GPRs which need saving.)  Otherwise it
 	     would be difficult to take that decision back in
 	     s390_optimize_prologue.  */
-	  if (cfun_gpr_save_slot (RETURN_REGNUM) == -1)
+	  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)
 	    {
 	      int return_regnum = find_unused_clobbered_reg();
 	      if (!return_regnum)
@@ -10760,7 +10950,7 @@ s390_can_use_return_insn (void)
     return false;
 
   for (i = 0; i < 16; i++)
-    if (cfun_gpr_save_slot (i))
+    if (cfun_gpr_save_slot (i) != SAVE_SLOT_NONE)
       return false;
 
   /* For 31 bit this is not covered by the frame_size check below
@@ -12245,7 +12435,7 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,
          replace the symbol itself with the PLT stub.  */
       if (flag_pic && !SYMBOL_REF_LOCAL_P (addr_location))
         {
-	  if (retaddr_reg != NULL_RTX)
+	  if (TARGET_64BIT || retaddr_reg != NULL_RTX)
 	    {
 	      addr_location = gen_rtx_UNSPEC (Pmode,
 					      gen_rtvec (1, addr_location),
@@ -12452,9 +12642,9 @@ s390_optimize_prologue (void)
 
 	  /* It must not happen that what we once saved in an FPR now
 	     needs a stack slot.  */
-	  gcc_assert (cfun_gpr_save_slot (gpr_regno) != -1);
+	  gcc_assert (cfun_gpr_save_slot (gpr_regno) != SAVE_SLOT_STACK);
 
-	  if (cfun_gpr_save_slot (gpr_regno) == 0)
+	  if (cfun_gpr_save_slot (gpr_regno) == SAVE_SLOT_NONE)
 	    {
 	      remove_insn (insn);
 	      continue;
@@ -13100,27 +13290,66 @@ s390_z10_prevent_earlyload_conflicts (rtx_insn **ready, int *nready_p)
 
 static int s390_sched_state;
 
-#define S390_OOO_SCHED_STATE_NORMAL  3
-#define S390_OOO_SCHED_STATE_CRACKED 4
+#define S390_SCHED_STATE_NORMAL  3
+#define S390_SCHED_STATE_CRACKED 4
 
-#define S390_OOO_SCHED_ATTR_MASK_CRACKED    0x1
-#define S390_OOO_SCHED_ATTR_MASK_EXPANDED   0x2
-#define S390_OOO_SCHED_ATTR_MASK_ENDGROUP   0x4
-#define S390_OOO_SCHED_ATTR_MASK_GROUPALONE 0x8
+#define S390_SCHED_ATTR_MASK_CRACKED    0x1
+#define S390_SCHED_ATTR_MASK_EXPANDED   0x2
+#define S390_SCHED_ATTR_MASK_ENDGROUP   0x4
+#define S390_SCHED_ATTR_MASK_GROUPALONE 0x8
 
 static unsigned int
 s390_get_sched_attrmask (rtx_insn *insn)
 {
   unsigned int mask = 0;
 
-  if (get_attr_ooo_cracked (insn))
-    mask |= S390_OOO_SCHED_ATTR_MASK_CRACKED;
-  if (get_attr_ooo_expanded (insn))
-    mask |= S390_OOO_SCHED_ATTR_MASK_EXPANDED;
-  if (get_attr_ooo_endgroup (insn))
-    mask |= S390_OOO_SCHED_ATTR_MASK_ENDGROUP;
-  if (get_attr_ooo_groupalone (insn))
-    mask |= S390_OOO_SCHED_ATTR_MASK_GROUPALONE;
+  switch (s390_tune)
+    {
+    case PROCESSOR_2827_ZEC12:
+      if (get_attr_zEC12_cracked (insn))
+	mask |= S390_SCHED_ATTR_MASK_CRACKED;
+      if (get_attr_zEC12_expanded (insn))
+	mask |= S390_SCHED_ATTR_MASK_EXPANDED;
+      if (get_attr_zEC12_endgroup (insn))
+	mask |= S390_SCHED_ATTR_MASK_ENDGROUP;
+      if (get_attr_zEC12_groupalone (insn))
+	mask |= S390_SCHED_ATTR_MASK_GROUPALONE;
+      break;
+    case PROCESSOR_2964_Z13:
+      if (get_attr_z13_cracked (insn))
+	mask |= S390_SCHED_ATTR_MASK_CRACKED;
+      if (get_attr_z13_expanded (insn))
+	mask |= S390_SCHED_ATTR_MASK_EXPANDED;
+      if (get_attr_z13_endgroup (insn))
+	mask |= S390_SCHED_ATTR_MASK_ENDGROUP;
+      if (get_attr_z13_groupalone (insn))
+	mask |= S390_SCHED_ATTR_MASK_GROUPALONE;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  return mask;
+}
+
+static unsigned int
+s390_get_unit_mask (rtx_insn *insn, int *units)
+{
+  unsigned int mask = 0;
+
+  switch (s390_tune)
+    {
+    case PROCESSOR_2964_Z13:
+      *units = 3;
+      if (get_attr_z13_unit_lsu (insn))
+	mask |= 1 << 0;
+      if (get_attr_z13_unit_fxu (insn))
+	mask |= 1 << 1;
+      if (get_attr_z13_unit_vfu (insn))
+	mask |= 1 << 2;
+      break;
+    default:
+      gcc_unreachable ();
+    }
   return mask;
 }
 
@@ -13138,48 +13367,66 @@ s390_sched_score (rtx_insn *insn)
     case 0:
       /* Try to put insns into the first slot which would otherwise
 	 break a group.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) != 0
-	  || (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) != 0)
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0
+	  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0)
 	score += 5;
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_GROUPALONE) != 0)
+      if ((mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)
 	score += 10;
     case 1:
       /* Prefer not cracked insns while trying to put together a
 	 group.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) == 0
-	  && (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) == 0
-	  && (mask & S390_OOO_SCHED_ATTR_MASK_GROUPALONE) == 0)
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) == 0
+	  && (mask & S390_SCHED_ATTR_MASK_EXPANDED) == 0
+	  && (mask & S390_SCHED_ATTR_MASK_GROUPALONE) == 0)
 	score += 10;
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_ENDGROUP) == 0)
+      if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) == 0)
 	score += 5;
       break;
     case 2:
       /* Prefer not cracked insns while trying to put together a
 	 group.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) == 0
-	  && (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) == 0
-	  && (mask & S390_OOO_SCHED_ATTR_MASK_GROUPALONE) == 0)
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) == 0
+	  && (mask & S390_SCHED_ATTR_MASK_EXPANDED) == 0
+	  && (mask & S390_SCHED_ATTR_MASK_GROUPALONE) == 0)
 	score += 10;
       /* Prefer endgroup insns in the last slot.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_ENDGROUP) != 0)
+      if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) != 0)
 	score += 10;
       break;
-    case S390_OOO_SCHED_STATE_NORMAL:
+    case S390_SCHED_STATE_NORMAL:
       /* Prefer not cracked insns if the last was not cracked.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) == 0
-	  && (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) == 0)
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) == 0
+	  && (mask & S390_SCHED_ATTR_MASK_EXPANDED) == 0)
 	score += 5;
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_GROUPALONE) != 0)
+      if ((mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)
 	score += 10;
       break;
-    case S390_OOO_SCHED_STATE_CRACKED:
+    case S390_SCHED_STATE_CRACKED:
       /* Try to keep cracked insns together to prevent them from
 	 interrupting groups.  */
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) != 0
-	  || (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) != 0)
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0
+	  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0)
 	score += 5;
       break;
     }
+
+  if (s390_tune == PROCESSOR_2964_Z13)
+    {
+      int units, i;
+      unsigned unit_mask, m = 1;
+
+      unit_mask = s390_get_unit_mask (insn, &units);
+      gcc_assert (units <= MAX_SCHED_UNITS);
+
+      /* Add a score in range 0..MAX_SCHED_MIX_SCORE depending on how long
+	 ago the last insn of this unit type got scheduled.  This is
+	 supposed to help providing a proper instruction mix to the
+	 CPU.  */
+      for (i = 0; i < units; i++, m <<= 1)
+	if (m & unit_mask)
+	  score += (last_scheduled_unit_distance[i] * MAX_SCHED_MIX_SCORE /
+		    MAX_SCHED_MIX_DISTANCE);
+    }
   return score;
 }
 
@@ -13235,12 +13482,12 @@ s390_sched_reorder (FILE *file, int verbose,
 
 	      if (verbose > 5)
 		fprintf (file,
-			 "move insn %d to the top of list\n",
+			 ";;\t\tBACKEND: move insn %d to the top of list\n",
 			 INSN_UID (ready[last_index]));
 	    }
 	  else if (verbose > 5)
 	    fprintf (file,
-		     "best insn %d already on top\n",
+		     ";;\t\tBACKEND: best insn %d already on top\n",
 		     INSN_UID (ready[last_index]));
 	}
 
@@ -13251,16 +13498,35 @@ s390_sched_reorder (FILE *file, int verbose,
 
 	  for (i = last_index; i >= 0; i--)
 	    {
-	      if (recog_memoized (ready[i]) < 0)
+	      unsigned int sched_mask;
+	      rtx_insn *insn = ready[i];
+
+	      if (recog_memoized (insn) < 0)
 		continue;
-	      fprintf (file, "insn %d score: %d: ", INSN_UID (ready[i]),
-		       s390_sched_score (ready[i]));
-#define PRINT_OOO_ATTR(ATTR) fprintf (file, "%s ", get_attr_##ATTR (ready[i]) ? #ATTR : "!" #ATTR);
-	      PRINT_OOO_ATTR (ooo_cracked);
-	      PRINT_OOO_ATTR (ooo_expanded);
-	      PRINT_OOO_ATTR (ooo_endgroup);
-	      PRINT_OOO_ATTR (ooo_groupalone);
-#undef PRINT_OOO_ATTR
+
+	      sched_mask = s390_get_sched_attrmask (insn);
+	      fprintf (file, ";;\t\tBACKEND: insn %d score: %d: ",
+		       INSN_UID (insn),
+		       s390_sched_score (insn));
+#define PRINT_SCHED_ATTR(M, ATTR) fprintf (file, "%s ",\
+					   ((M) & sched_mask) ? #ATTR : "");
+	      PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_CRACKED, cracked);
+	      PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_EXPANDED, expanded);
+	      PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_ENDGROUP, endgroup);
+	      PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_GROUPALONE, groupalone);
+#undef PRINT_SCHED_ATTR
+	      if (s390_tune == PROCESSOR_2964_Z13)
+		{
+		  unsigned int unit_mask, m = 1;
+		  int units, j;
+
+		  unit_mask  = s390_get_unit_mask (insn, &units);
+		  fprintf (file, "(units:");
+		  for (j = 0; j < units; j++, m <<= 1)
+		    if (m & unit_mask)
+		      fprintf (file, " u%d", j);
+		  fprintf (file, ")");
+		}
 	      fprintf (file, "\n");
 	    }
 	}
@@ -13286,12 +13552,12 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)
     {
       unsigned int mask = s390_get_sched_attrmask (insn);
 
-      if ((mask & S390_OOO_SCHED_ATTR_MASK_CRACKED) != 0
-	  || (mask & S390_OOO_SCHED_ATTR_MASK_EXPANDED) != 0)
-	s390_sched_state = S390_OOO_SCHED_STATE_CRACKED;
-      else if ((mask & S390_OOO_SCHED_ATTR_MASK_ENDGROUP) != 0
-	       || (mask & S390_OOO_SCHED_ATTR_MASK_GROUPALONE) != 0)
-	s390_sched_state = S390_OOO_SCHED_STATE_NORMAL;
+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0
+	  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0)
+	s390_sched_state = S390_SCHED_STATE_CRACKED;
+      else if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) != 0
+	       || (mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)
+	s390_sched_state = S390_SCHED_STATE_NORMAL;
       else
 	{
 	  /* Only normal insns are left (mask == 0).  */
@@ -13300,30 +13566,73 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)
 	    case 0:
 	    case 1:
 	    case 2:
-	    case S390_OOO_SCHED_STATE_NORMAL:
-	      if (s390_sched_state == S390_OOO_SCHED_STATE_NORMAL)
+	    case S390_SCHED_STATE_NORMAL:
+	      if (s390_sched_state == S390_SCHED_STATE_NORMAL)
 		s390_sched_state = 1;
 	      else
 		s390_sched_state++;
 
 	      break;
-	    case S390_OOO_SCHED_STATE_CRACKED:
-	      s390_sched_state = S390_OOO_SCHED_STATE_NORMAL;
+	    case S390_SCHED_STATE_CRACKED:
+	      s390_sched_state = S390_SCHED_STATE_NORMAL;
 	      break;
 	    }
 	}
+
+      if (s390_tune == PROCESSOR_2964_Z13)
+	{
+	  int units, i;
+	  unsigned unit_mask, m = 1;
+
+	  unit_mask = s390_get_unit_mask (insn, &units);
+	  gcc_assert (units <= MAX_SCHED_UNITS);
+
+	  for (i = 0; i < units; i++, m <<= 1)
+	    if (m & unit_mask)
+	      last_scheduled_unit_distance[i] = 0;
+	    else if (last_scheduled_unit_distance[i] < MAX_SCHED_MIX_DISTANCE)
+	      last_scheduled_unit_distance[i]++;
+	}
+
       if (verbose > 5)
 	{
-	  fprintf (file, "insn %d: ", INSN_UID (insn));
-#define PRINT_OOO_ATTR(ATTR)						\
-	  fprintf (file, "%s ", get_attr_##ATTR (insn) ? #ATTR : "");
-	  PRINT_OOO_ATTR (ooo_cracked);
-	  PRINT_OOO_ATTR (ooo_expanded);
-	  PRINT_OOO_ATTR (ooo_endgroup);
-	  PRINT_OOO_ATTR (ooo_groupalone);
-#undef PRINT_OOO_ATTR
-	  fprintf (file, "\n");
-	  fprintf (file, "sched state: %d\n", s390_sched_state);
+	  unsigned int sched_mask;
+
+	  sched_mask = s390_get_sched_attrmask (insn);
+
+	  fprintf (file, ";;\t\tBACKEND: insn %d: ", INSN_UID (insn));
+#define PRINT_SCHED_ATTR(M, ATTR) fprintf (file, "%s ", ((M) & sched_mask) ? #ATTR : "");
+	  PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_CRACKED, cracked);
+	  PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_EXPANDED, expanded);
+	  PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_ENDGROUP, endgroup);
+	  PRINT_SCHED_ATTR (S390_SCHED_ATTR_MASK_GROUPALONE, groupalone);
+#undef PRINT_SCHED_ATTR
+
+	  if (s390_tune == PROCESSOR_2964_Z13)
+	    {
+	      unsigned int unit_mask, m = 1;
+	      int units, j;
+
+	      unit_mask  = s390_get_unit_mask (insn, &units);
+	      fprintf (file, "(units:");
+	      for (j = 0; j < units; j++, m <<= 1)
+		if (m & unit_mask)
+		  fprintf (file, " %d", j);
+	      fprintf (file, ")");
+	    }
+	  fprintf (file, " sched state: %d\n", s390_sched_state);
+
+	  if (s390_tune == PROCESSOR_2964_Z13)
+	    {
+	      int units, j;
+
+	      s390_get_unit_mask (insn, &units);
+
+	      fprintf (file, ";;\t\tBACKEND: units unused for: ");
+	      for (j = 0; j < units; j++)
+		fprintf (file, "%d:%d ", j, last_scheduled_unit_distance[j]);
+	      fprintf (file, "\n");
+	    }
 	}
     }
 
@@ -13340,6 +13649,7 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,
 		 int max_ready ATTRIBUTE_UNUSED)
 {
   last_scheduled_insn = NULL;
+  memset (last_scheduled_unit_distance, 0, MAX_SCHED_UNITS * sizeof (int));
   s390_sched_state = 0;
 }
 
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 1f4147a..71587d1 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -302,6 +302,8 @@
    ; General purpose registers
    (GPR0_REGNUM                  0)
    (GPR1_REGNUM                  1)
+   (GPR2_REGNUM                  2)
+   (GPR6_REGNUM                  6)
    ; Floating point registers.
    (FPR0_REGNUM                 16)
    (FPR1_REGNUM                 20)
@@ -500,6 +502,9 @@
 ;; Pipeline description for zEC12
 (include "2827.md")
 
+;; Pipeline description for z13
+(include "2964.md")
+
 ;; Predicates
 (include "predicates.md")
 
@@ -2923,8 +2928,16 @@
      (clobber (reg:CC CC_REGNUM))])]
   ""
 {
-  rtx addr1 = gen_reg_rtx (Pmode);
-  rtx addr2 = gen_reg_rtx (Pmode);
+  rtx addr1, addr2;
+
+  if (TARGET_VX && optimize_function_for_speed_p (cfun))
+    {
+      s390_expand_vec_movstr (operands[0], operands[1], operands[2]);
+      DONE;
+    }
+
+  addr1 = gen_reg_rtx (Pmode);
+  addr2 = gen_reg_rtx (Pmode);
 
   emit_move_insn (addr1, force_operand (XEXP (operands[1], 0), NULL_RTX));
   emit_move_insn (addr2, force_operand (XEXP (operands[2], 0), NULL_RTX));
@@ -10742,9 +10755,9 @@
 
 (define_insn "lcbb"
   [(set (match_operand:SI             0 "register_operand"  "=d")
-	(unspec:SI [(match_operand:SI 1 "address_operand" "ZQZR")
+	(unspec:SI [(match_operand    1 "address_operand" "ZQZR")
 		    (match_operand:SI 2 "immediate_operand"  "C")] UNSPEC_LCBB))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_Z13"
-  "lcbb\t%0,%1,%b2"
+  "lcbb\t%0,%a1,%b2"
   [(set_attr "op_type" "VRX")])
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index 2e26e3a..5404f24 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -67,14 +67,14 @@ __lcbb(const void *ptr, int bndry)
 #define vec_genmasks_16 __builtin_s390_vgmh
 #define vec_genmasks_32 __builtin_s390_vgmf
 #define vec_genmasks_64 __builtin_s390_vgmg
-#define vec_splat_u8 __builtin_s390_vlrepb
-#define vec_splat_s8 __builtin_s390_vlrepb
-#define vec_splat_u16 __builtin_s390_vlreph
-#define vec_splat_s16 __builtin_s390_vlreph
-#define vec_splat_u32 __builtin_s390_vlrepf
-#define vec_splat_s32 __builtin_s390_vlrepf
-#define vec_splat_u64 __builtin_s390_vlrepg
-#define vec_splat_s64 __builtin_s390_vlrepg
+#define vec_splat_u8 __builtin_s390_vec_splat_u8
+#define vec_splat_s8 __builtin_s390_vec_splat_s8
+#define vec_splat_u16 __builtin_s390_vec_splat_u16
+#define vec_splat_s16 __builtin_s390_vec_splat_s16
+#define vec_splat_u32 __builtin_s390_vec_splat_u32
+#define vec_splat_s32 __builtin_s390_vec_splat_s32
+#define vec_splat_u64 __builtin_s390_vec_splat_u64
+#define vec_splat_s64 __builtin_s390_vec_splat_s64
 #define vec_add_u128 __builtin_s390_vaq
 #define vec_addc_u128 __builtin_s390_vaccq
 #define vec_adde_u128 __builtin_s390_vacq
@@ -82,6 +82,7 @@ __lcbb(const void *ptr, int bndry)
 #define vec_checksum __builtin_s390_vcksm
 #define vec_gfmsum_128 __builtin_s390_vgfmg
 #define vec_gfmsum_accum_128 __builtin_s390_vgfmag
+#define vec_sub_u128 __builtin_s390_vsq
 #define vec_subc_u128 __builtin_s390_vscbiq
 #define vec_sube_u128 __builtin_s390_vsbiq
 #define vec_subec_u128 __builtin_s390_vsbcbiq
diff --git a/gcc/config/s390/vector.md b/gcc/config/s390/vector.md
index 16276e0..c1127bf 100644
--- a/gcc/config/s390/vector.md
+++ b/gcc/config/s390/vector.md
@@ -43,8 +43,8 @@
 
 ; All integer vector modes supported in a vector register + TImode
 (define_mode_iterator VIT [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI V1DI V2DI V1TI TI])
-(define_mode_iterator VI  [V2QI V4QI V8QI V16QI V2HI V4HI V8HI V2SI V4SI V2DI])
-(define_mode_iterator VI_QHS [V4QI V8QI V16QI V4HI V8HI V4SI])
+(define_mode_iterator VI  [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI V1DI V2DI])
+(define_mode_iterator VI_QHS [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI])
 
 (define_mode_iterator V_8   [V1QI])
 (define_mode_iterator V_16  [V2QI  V1HI])
@@ -100,11 +100,11 @@
 			    (V1TF "V1TI")])
 
 ; Vector with doubled element size.
-(define_mode_attr vec_double [(V2QI "V1HI") (V4QI "V2HI") (V8QI "V4HI") (V16QI "V8HI")
-			      (V2HI "V1SI") (V4HI "V2SI") (V8HI "V4SI")
-			      (V2SI "V1DI") (V4SI "V2DI")
-			      (V2DI "V1TI")
-			      (V2SF "V1DF") (V4SF "V2DF")])
+(define_mode_attr vec_double [(V1QI "V1HI") (V2QI "V1HI") (V4QI "V2HI") (V8QI "V4HI") (V16QI "V8HI")
+			      (V1HI "V1SI") (V2HI "V1SI") (V4HI "V2SI") (V8HI "V4SI")
+			      (V1SI "V1DI") (V2SI "V1DI") (V4SI "V2DI")
+			      (V1DI "V1TI") (V2DI "V1TI")
+			      (V1SF "V1DF") (V2SF "V1DF") (V4SF "V2DF")])
 
 ; Vector with half the element size.
 (define_mode_attr vec_half [(V1HI "V2QI") (V2HI "V4QI") (V4HI "V8QI") (V8HI "V16QI")
@@ -137,8 +137,8 @@
 
 ; Full HW vector size moves
 (define_insn "mov<mode>"
-  [(set (match_operand:V_128 0 "nonimmediate_operand" "=v, v,QR,  v,  v,  v,  v,v,d")
-	(match_operand:V_128 1 "general_operand"      " v,QR, v,j00,jm1,jyy,jxx,d,v"))]
+  [(set (match_operand:V_128 0 "nonimmediate_operand" "=v, v,QR,  v,  v,  v,  v,  v,v,d")
+	(match_operand:V_128 1 "general_operand"      " v,QR, v,j00,jm1,jyy,jxx,jKK,d,v"))]
   "TARGET_VX"
   "@
    vlr\t%v0,%v1
@@ -148,9 +148,10 @@
    vone\t%v0
    vgbm\t%v0,%t1
    vgm<bhfgq>\t%v0,%s1,%e1
+   vrepi<bhfgq>\t%v0,%h1
    vlvgp\t%v0,%1,%N1
    #"
-  [(set_attr "op_type" "VRR,VRX,VRX,VRI,VRI,VRI,VRI,VRR,*")])
+  [(set_attr "op_type" "VRR,VRX,VRX,VRI,VRI,VRI,VRI,VRI,VRR,*")])
 
 (define_split
   [(set (match_operand:V_128 0 "register_operand" "")
@@ -313,7 +314,7 @@
 (define_insn "*vec_set<mode>"
   [(set (match_operand:V                    0 "register_operand"             "=v, v,v")
 	(unspec:V [(match_operand:<non_vec> 1 "general_operand"               "d,QR,K")
-		   (match_operand:DI        2 "shift_count_or_setmem_operand" "Y, I,I")
+		   (match_operand:SI        2 "shift_count_or_setmem_operand" "Y, I,I")
 		   (match_operand:V         3 "register_operand"              "0, 0,0")]
 		  UNSPEC_VEC_SET))]
   "TARGET_VX"
@@ -363,18 +364,18 @@
 	 (vec_select:<non_vec>
 	  (match_operand:V_HW 1 "register_operand"  "v")
 	  (parallel
-	   [(match_operand:QI 2 "immediate_operand" "C")]))))]
-  "TARGET_VX"
+	   [(match_operand:QI 2 "const_mask_operand" "C")]))))]
+  "TARGET_VX && UINTVAL (operands[2]) < GET_MODE_NUNITS (<V_HW:MODE>mode)"
   "vrep<bhfgq>\t%v0,%v1,%2"
   [(set_attr "op_type" "VRI")])
 
 (define_insn "*vec_splats<mode>"
   [(set (match_operand:V_HW                          0 "register_operand" "=v,v,v,v")
-	(vec_duplicate:V_HW (match_operand:<non_vec> 1 "general_operand"  "QR,I,v,d")))]
+	(vec_duplicate:V_HW (match_operand:<non_vec> 1 "general_operand"  "QR,K,v,d")))]
   "TARGET_VX"
   "@
    vlrep<bhfgq>\t%v0,%1
-   vrepi<bhfgq>\t%v0,%1
+   vrepi<bhfgq>\t%v0,%h1
    vrep<bhfgq>\t%v0,%v1,0
    #"
   [(set_attr "op_type" "VRX,VRI,VRI,*")])
@@ -452,8 +453,8 @@
 ; operation into two DImode ADDs.
 (define_insn "<ti*>add<mode>3"
   [(set (match_operand:VIT           0 "nonimmediate_operand" "=v")
-	(plus:VIT (match_operand:VIT 1 "nonimmediate_operand"  "v")
-		  (match_operand:VIT 2 "nonimmediate_operand"  "v")))]
+	(plus:VIT (match_operand:VIT 1 "nonimmediate_operand" "%v")
+		  (match_operand:VIT 2 "general_operand"       "v")))]
   "TARGET_VX"
   "va<bhfgq>\t%v0,%v1,%v2"
   [(set_attr "op_type" "VRR")])
@@ -462,7 +463,7 @@
 (define_insn "<ti*>sub<mode>3"
   [(set (match_operand:VIT            0 "nonimmediate_operand" "=v")
 	(minus:VIT (match_operand:VIT 1 "nonimmediate_operand"  "v")
-		   (match_operand:VIT 2 "nonimmediate_operand"  "v")))]
+		   (match_operand:VIT 2 "general_operand"  "v")))]
   "TARGET_VX"
   "vs<bhfgq>\t%v0,%v1,%v2"
   [(set_attr "op_type" "VRR")])
@@ -470,7 +471,7 @@
 ; vmlb, vmlhw, vmlf
 (define_insn "mul<mode>3"
   [(set (match_operand:VI_QHS              0 "register_operand" "=v")
-	(mult:VI_QHS (match_operand:VI_QHS 1 "register_operand"  "v")
+	(mult:VI_QHS (match_operand:VI_QHS 1 "register_operand" "%v")
 		     (match_operand:VI_QHS 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vml<bhfgq><w>\t%v0,%v1,%v2"
@@ -525,7 +526,7 @@
 
 (define_insn "and<mode>3"
   [(set (match_operand:VT         0 "register_operand" "=v")
-	(and:VT (match_operand:VT 1 "register_operand"  "v")
+	(and:VT (match_operand:VT 1 "register_operand" "%v")
 		(match_operand:VT 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vn\t%v0,%v1,%v2"
@@ -536,7 +537,7 @@
 
 (define_insn "ior<mode>3"
   [(set (match_operand:VT         0 "register_operand" "=v")
-	(ior:VT (match_operand:VT 1 "register_operand"  "v")
+	(ior:VT (match_operand:VT 1 "register_operand" "%v")
 		(match_operand:VT 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vo\t%v0,%v1,%v2"
@@ -547,7 +548,7 @@
 
 (define_insn "xor<mode>3"
   [(set (match_operand:VT         0 "register_operand" "=v")
-	(xor:VT (match_operand:VT 1 "register_operand"  "v")
+	(xor:VT (match_operand:VT 1 "register_operand" "%v")
 		(match_operand:VT 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vx\t%v0,%v1,%v2"
@@ -764,7 +765,7 @@
 ; vmnb, vmnh, vmnf, vmng
 (define_insn "smin<mode>3"
   [(set (match_operand:VI          0 "register_operand" "=v")
-	(smin:VI (match_operand:VI 1 "register_operand"  "v")
+	(smin:VI (match_operand:VI 1 "register_operand" "%v")
 		 (match_operand:VI 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vmn<bhfgq>\t%v0,%v1,%v2"
@@ -773,7 +774,7 @@
 ; vmxb, vmxh, vmxf, vmxg
 (define_insn "smax<mode>3"
   [(set (match_operand:VI          0 "register_operand" "=v")
-	(smax:VI (match_operand:VI 1 "register_operand"  "v")
+	(smax:VI (match_operand:VI 1 "register_operand" "%v")
 		 (match_operand:VI 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vmx<bhfgq>\t%v0,%v1,%v2"
@@ -782,7 +783,7 @@
 ; vmnlb, vmnlh, vmnlf, vmnlg
 (define_insn "umin<mode>3"
   [(set (match_operand:VI          0 "register_operand" "=v")
-	(umin:VI (match_operand:VI 1 "register_operand"  "v")
+	(umin:VI (match_operand:VI 1 "register_operand" "%v")
 		 (match_operand:VI 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vmnl<bhfgq>\t%v0,%v1,%v2"
@@ -791,7 +792,7 @@
 ; vmxlb, vmxlh, vmxlf, vmxlg
 (define_insn "umax<mode>3"
   [(set (match_operand:VI          0 "register_operand" "=v")
-	(umax:VI (match_operand:VI 1 "register_operand"  "v")
+	(umax:VI (match_operand:VI 1 "register_operand" "%v")
 		 (match_operand:VI 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vmxl<bhfgq>\t%v0,%v1,%v2"
@@ -799,8 +800,8 @@
 
 ; vmeb, vmeh, vmef
 (define_insn "vec_widen_smult_even_<mode>"
-  [(set (match_operand:<vec_double>                    0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand"  "v")
+  [(set (match_operand:<vec_double>                 0 "register_operand" "=v")
+	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_QHS 2 "register_operand"  "v")]
 			     UNSPEC_VEC_SMULT_EVEN))]
   "TARGET_VX"
@@ -810,7 +811,7 @@
 ; vmleb, vmleh, vmlef
 (define_insn "vec_widen_umult_even_<mode>"
   [(set (match_operand:<vec_double>                 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand"  "v")
+	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_QHS 2 "register_operand"  "v")]
 			     UNSPEC_VEC_UMULT_EVEN))]
   "TARGET_VX"
@@ -820,7 +821,7 @@
 ; vmob, vmoh, vmof
 (define_insn "vec_widen_smult_odd_<mode>"
   [(set (match_operand:<vec_double>                 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand"  "v")
+	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_QHS 2 "register_operand"  "v")]
 			     UNSPEC_VEC_SMULT_ODD))]
   "TARGET_VX"
@@ -830,7 +831,7 @@
 ; vmlob, vmloh, vmlof
 (define_insn "vec_widen_umult_odd_<mode>"
   [(set (match_operand:<vec_double>                 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand"  "v")
+	(unspec:<vec_double> [(match_operand:VI_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_QHS 2 "register_operand"  "v")]
 			     UNSPEC_VEC_UMULT_ODD))]
   "TARGET_VX"
@@ -853,7 +854,7 @@
 
 (define_insn "addv2df3"
   [(set (match_operand:V2DF            0 "register_operand" "=v")
-	(plus:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(plus:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		   (match_operand:V2DF 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vfadb\t%v0,%v1,%v2"
@@ -861,7 +862,7 @@
 
 (define_insn "subv2df3"
   [(set (match_operand:V2DF             0 "register_operand" "=v")
-	(minus:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(minus:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		    (match_operand:V2DF 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vfsdb\t%v0,%v1,%v2"
@@ -869,7 +870,7 @@
 
 (define_insn "mulv2df3"
   [(set (match_operand:V2DF            0 "register_operand" "=v")
-	(mult:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(mult:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		   (match_operand:V2DF 2 "register_operand"  "v")))]
   "TARGET_VX"
   "vfmdb\t%v0,%v1,%v2"
@@ -892,7 +893,7 @@
 
 (define_insn "fmav2df4"
   [(set (match_operand:V2DF           0 "register_operand" "=v")
-	(fma:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(fma:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		  (match_operand:V2DF 2 "register_operand"  "v")
 		  (match_operand:V2DF 3 "register_operand"  "v")))]
   "TARGET_VX"
@@ -901,7 +902,7 @@
 
 (define_insn "fmsv2df4"
   [(set (match_operand:V2DF                     0 "register_operand" "=v")
-	(fma:V2DF (match_operand:V2DF           1 "register_operand"  "v")
+	(fma:V2DF (match_operand:V2DF           1 "register_operand" "%v")
 		  (match_operand:V2DF           2 "register_operand"  "v")
 		  (neg:V2DF (match_operand:V2DF 3 "register_operand"  "v"))))]
   "TARGET_VX"
@@ -932,7 +933,7 @@
 ; Emulate with compare + select
 (define_insn_and_split "smaxv2df3"
   [(set (match_operand:V2DF            0 "register_operand" "=v")
-	(smax:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(smax:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		   (match_operand:V2DF 2 "register_operand"  "v")))]
   "TARGET_VX"
   "#"
@@ -952,7 +953,7 @@
 ; Emulate with compare + select
 (define_insn_and_split "sminv2df3"
   [(set (match_operand:V2DF            0 "register_operand" "=v")
-	(smin:V2DF (match_operand:V2DF 1 "register_operand"  "v")
+	(smin:V2DF (match_operand:V2DF 1 "register_operand" "%v")
 		   (match_operand:V2DF 2 "register_operand"  "v")))]
   "TARGET_VX"
   "#"
@@ -1072,7 +1073,7 @@
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
 	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:QI 3 "immediate_operand" "C")]
+			   (match_operand:QI 3 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VFENE))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1106,7 +1107,7 @@
 	 (eq (match_operand:<tointvec> 3 "register_operand" "")
 	     (match_operand:V 4 "const0_operand" ""))
 	 (match_operand:V 1 "const0_operand" "")
-	 (match_operand:V 2 "constm1_operand" "")))]
+	 (match_operand:V 2 "all_ones_operand" "")))]
   "TARGET_VX"
   [(set (match_dup 0) (match_dup 3))]
 {
@@ -1119,7 +1120,7 @@
 	(if_then_else:V
 	 (eq (match_operand:<tointvec> 3 "register_operand" "")
 	     (match_operand:V 4 "const0_operand" ""))
-	 (match_operand:V 1 "constm1_operand" "")
+	 (match_operand:V 1 "all_ones_operand" "")
 	 (match_operand:V 2 "const0_operand" "")))]
   "TARGET_VX"
   [(set (match_dup 0) (not:V (match_dup 3)))]
@@ -1133,7 +1134,7 @@
 	(if_then_else:V
 	 (ne (match_operand:<tointvec> 3 "register_operand" "")
 	     (match_operand:V 4 "const0_operand" ""))
-	 (match_operand:V 1 "constm1_operand" "")
+	 (match_operand:V 1 "all_ones_operand" "")
 	 (match_operand:V 2 "const0_operand" "")))]
   "TARGET_VX"
   [(set (match_dup 0) (match_dup 3))]
@@ -1148,7 +1149,7 @@
 	 (ne (match_operand:<tointvec> 3 "register_operand" "")
 	     (match_operand:V 4 "const0_operand" ""))
 	 (match_operand:V 1 "const0_operand" "")
-	 (match_operand:V 2 "constm1_operand" "")))]
+	 (match_operand:V 2 "all_ones_operand" "")))]
   "TARGET_VX"
   [(set (match_dup 0) (not:V (match_dup 3)))]
 {
@@ -1184,7 +1185,7 @@
   [(set (match_operand:V 0 "register_operand" "=v")
 	(if_then_else:V
 	 (eq (match_operand:<tointvec> 3 "register_operand" "v")
-	     (match_operand:<tointvec> 4 "constm1_operand" ""))
+	     (match_operand:<tointvec> 4 "all_ones_operand" ""))
 	 (match_operand:V 1 "register_operand" "v")
 	 (match_operand:V 2 "register_operand" "v")))]
   "TARGET_VX"
@@ -1196,7 +1197,7 @@
   [(set (match_operand:V 0 "register_operand" "=v")
 	(if_then_else:V
 	 (eq (not:<tointvec> (match_operand:<tointvec> 3 "register_operand" "v"))
-	     (match_operand:<tointvec> 4 "constm1_operand" ""))
+	     (match_operand:<tointvec> 4 "all_ones_operand" ""))
 	 (match_operand:V 1 "register_operand" "v")
 	 (match_operand:V 2 "register_operand" "v")))]
   "TARGET_VX"
diff --git a/gcc/config/s390/vx-builtins.md b/gcc/config/s390/vx-builtins.md
index fb76534..9cc13ce 100644
--- a/gcc/config/s390/vx-builtins.md
+++ b/gcc/config/s390/vx-builtins.md
@@ -28,12 +28,12 @@
 
 ; The element type of the vector with floating point modes translated
 ; to int modes of the same size.
-(define_mode_attr non_vec_int[(V2QI "QI") (V4QI "QI") (V8QI "QI") (V16QI "QI")
-			      (V2HI "HI") (V4HI "HI") (V8HI "HI")
-			      (V2SI "SI") (V4SI "SI")
-			      (V2DI "DI")
-			      (V2SF "SI") (V4SF "SI")
-			      (V2DF "DI")])
+(define_mode_attr non_vec_int[(V1QI "QI") (V2QI "QI") (V4QI "QI") (V8QI "QI") (V16QI "QI")
+			      (V1HI "HI") (V2HI "HI") (V4HI "HI") (V8HI "HI")
+			      (V1SI "SI") (V2SI "SI") (V4SI "SI")
+			      (V1DI "DI") (V2DI "DI")
+			      (V1SF "SI") (V2SF "SI") (V4SF "SI")
+			      (V1DF "DI") (V2DF "DI")])
 
 ; Condition code modes generated by int comparisons
 (define_mode_iterator VICMP [CCVEQ CCVH CCVHU])
@@ -67,20 +67,20 @@
 ; Vector gather element
 
 (define_insn "vec_gather_element<mode>"
-  [(set (match_operand:V_HW_32_64                     0 "register_operand" "=v")
-	(unspec:V_HW_32_64 [(match_operand:V_HW_32_64 1 "register_operand"  "0")
-			    (match_operand:<tointvec> 2 "register_operand"  "v")
-			    (match_operand:BLK        3 "memory_operand"   "QR")
-			    (match_operand:QI         4 "immediate_operand" "C")]
+  [(set (match_operand:V_HW_32_64                     0 "register_operand"  "=v")
+	(unspec:V_HW_32_64 [(match_operand:V_HW_32_64 1 "register_operand"   "0")
+			    (match_operand:<tointvec> 2 "register_operand"   "v")
+			    (match_operand:BLK        3 "memory_operand"    "QR")
+			    (match_operand:QI         4 "const_mask_operand" "C")]
 			   UNSPEC_VEC_GATHER))]
-  "TARGET_VX"
+  "TARGET_VX && UINTVAL (operands[4]) < GET_MODE_NUNITS (<V_HW_32_64:MODE>mode)"
   "vge<bhfgq>\t%0,%O3(%v2,%R3),%b4"
   [(set_attr "op_type" "VRV")])
 
 (define_expand "vec_genmask<mode>"
   [(match_operand:VI_HW 0 "register_operand" "=v")
-   (match_operand:QI    1 "immediate_operand" "C")
-   (match_operand:QI    2 "immediate_operand" "C")]
+   (match_operand:QI    1 "const_int_operand" "C")
+   (match_operand:QI    2 "const_int_operand" "C")]
   "TARGET_VX"
 {
   int nunits = GET_MODE_NUNITS (<VI_HW:MODE>mode);
@@ -120,8 +120,8 @@
 
 (define_expand "vec_genbytemaskv16qi"
   [(match_operand:V16QI 0 "register_operand"  "")
-   (match_operand       1 "immediate_operand" "")]
-  "TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'K', \"K\")"
+   (match_operand:HI    1 "const_int_operand" "")]
+  "TARGET_VX"
 {
   int i;
   unsigned mask = 0x8000;
@@ -177,11 +177,11 @@
   [(set_attr "op_type" "VRX")])
 
 (define_insn "vlbb"
-  [(set (match_operand:V16QI              0 "register_operand"  "=v")
-	(unspec:V16QI [(match_operand:BLK 1 "memory_operand"    "QR")
-		       (match_operand:HI  2 "immediate_operand" " K")]
+  [(set (match_operand:V16QI              0 "register_operand"   "=v")
+	(unspec:V16QI [(match_operand:BLK 1 "memory_operand"     "QR")
+		       (match_operand:QI  2 "const_mask_operand"  "C")]
 		      UNSPEC_VEC_LOAD_BNDRY))]
-  "TARGET_VX"
+  "TARGET_VX && UINTVAL (operands[2]) < 7"
   "vlbb\t%v0,%1,%2"
   [(set_attr "op_type" "VRX")])
 
@@ -351,10 +351,10 @@
   [(set_attr "op_type" "VRR")])
 
 (define_expand "vec_permi<mode>"
-  [(set (match_operand:V_HW_64                  0 "register_operand"  "")
-	(unspec:V_HW_64 [(match_operand:V_HW_64 1 "register_operand"  "")
-			 (match_operand:V_HW_64 2 "register_operand"  "")
-			 (match_operand:QI      3 "immediate_operand" "")]
+  [(set (match_operand:V_HW_64                  0 "register_operand"   "")
+	(unspec:V_HW_64 [(match_operand:V_HW_64 1 "register_operand"   "")
+			 (match_operand:V_HW_64 2 "register_operand"   "")
+			 (match_operand:QI      3 "const_mask_operand" "")]
 			UNSPEC_VEC_PERMI))]
   "TARGET_VX"
 {
@@ -363,12 +363,12 @@
 })
 
 (define_insn "*vec_permi<mode>"
-  [(set (match_operand:V_HW_64                  0 "register_operand" "=v")
-	(unspec:V_HW_64 [(match_operand:V_HW_64 1 "register_operand"  "v")
-			 (match_operand:V_HW_64 2 "register_operand"  "v")
-			 (match_operand:QI      3 "immediate_operand" "C")]
+  [(set (match_operand:V_HW_64                  0 "register_operand"  "=v")
+	(unspec:V_HW_64 [(match_operand:V_HW_64 1 "register_operand"   "v")
+			 (match_operand:V_HW_64 2 "register_operand"   "v")
+			 (match_operand:QI      3 "const_mask_operand" "C")]
 			UNSPEC_VEC_PERMI))]
-  "TARGET_VX"
+  "TARGET_VX && (UINTVAL (operands[3]) & 10) == 0"
   "vpdi\t%v0,%v1,%v2,%b3"
   [(set_attr "op_type" "VRR")])
 
@@ -382,7 +382,7 @@
 	(vec_duplicate:V_HW (vec_select:<non_vec>
 			     (match_operand:V_HW 1 "register_operand"  "")
 			     (parallel
-			      [(match_operand:QI 2 "immediate_operand" "")]))))]
+			      [(match_operand:QI 2 "const_mask_operand" "")]))))]
   "TARGET_VX")
 
 ; Vector scatter element
@@ -393,13 +393,13 @@
 (define_insn "vec_scatter_elementv4si_DI"
   [(set (mem:SI
 	 (plus:DI (zero_extend:DI
-		   (unspec:SI [(match_operand:V4SI 1 "register_operand"  "v")
-			       (match_operand:DI   3 "immediate_operand" "I")]
+		   (unspec:SI [(match_operand:V4SI 1 "register_operand"   "v")
+			       (match_operand:QI   3 "const_mask_operand" "C")]
 			      UNSPEC_VEC_EXTRACT))
-		  (match_operand:SI                2 "address_operand"  "ZQ")))
-	(unspec:SI [(match_operand:V4SI            0 "register_operand"  "v")
+		  (match_operand:SI                2 "address_operand"   "ZQ")))
+	(unspec:SI [(match_operand:V4SI            0 "register_operand"   "v")
 		    (match_dup 3)] UNSPEC_VEC_EXTRACT))]
-  "TARGET_VX && TARGET_64BIT"
+  "TARGET_VX && TARGET_64BIT && UINTVAL (operands[3]) < 4"
   "vscef\t%v0,%O2(%v1,%R2),%3"
   [(set_attr "op_type" "VRV")])
 
@@ -407,13 +407,13 @@
 (define_insn "vec_scatter_element<V_HW_64:mode>_SI"
   [(set (mem:<non_vec>
 	 (plus:SI (subreg:SI
-		   (unspec:<non_vec_int> [(match_operand:V_HW_64 1 "register_operand"  "v")
-					  (match_operand:DI      3 "immediate_operand" "I")]
+		   (unspec:<non_vec_int> [(match_operand:V_HW_64 1 "register_operand"   "v")
+					  (match_operand:QI      3 "const_mask_operand" "C")]
 					 UNSPEC_VEC_EXTRACT) 4)
-		  (match_operand:SI                              2 "address_operand"  "ZQ")))
-	(unspec:<non_vec> [(match_operand:V_HW_64                0 "register_operand"  "v")
+		  (match_operand:SI                              2 "address_operand"   "ZQ")))
+	(unspec:<non_vec> [(match_operand:V_HW_64                0 "register_operand"   "v")
 			   (match_dup 3)] UNSPEC_VEC_EXTRACT))]
-  "TARGET_VX && !TARGET_64BIT"
+  "TARGET_VX && !TARGET_64BIT && UINTVAL (operands[3]) < GET_MODE_NUNITS (<V_HW_64:MODE>mode)"
   "vsce<V_HW_64:bhfgq>\t%v0,%O2(%v1,%R2),%3"
   [(set_attr "op_type" "VRV")])
 
@@ -421,13 +421,13 @@
 (define_insn "vec_scatter_element<mode>_<non_vec_int>"
   [(set (mem:<non_vec>
 	 (plus:<non_vec_int> (unspec:<non_vec_int>
-			      [(match_operand:<tointvec> 1 "register_operand"  "v")
-			       (match_operand:DI         3 "immediate_operand" "I")]
+			      [(match_operand:<tointvec> 1 "register_operand"   "v")
+			       (match_operand:QI         3 "const_mask_operand" "C")]
 			      UNSPEC_VEC_EXTRACT)
-			     (match_operand:DI           2 "address_operand"  "ZQ")))
-	(unspec:<non_vec> [(match_operand:V_HW_32_64     0 "register_operand"  "v")
+			     (match_operand:DI           2 "address_operand"   "ZQ")))
+	(unspec:<non_vec> [(match_operand:V_HW_32_64     0 "register_operand"   "v")
 			   (match_dup 3)] UNSPEC_VEC_EXTRACT))]
-  "TARGET_VX"
+  "TARGET_VX && UINTVAL (operands[3]) < GET_MODE_NUNITS (<V_HW_32_64:MODE>mode)"
   "vsce<bhfgq>\t%v0,%O2(%v1,%R2),%3"
   [(set_attr "op_type" "VRV")])
 
@@ -438,7 +438,7 @@
   [(match_operand:V_HW_32_64 0 "register_operand" "")
    (match_operand:<tointvec> 1 "register_operand" "")
    (match_operand 2 "address_operand" "")
-   (match_operand:DI 3 "immediate_operand" "")]
+   (match_operand:QI 3 "const_mask_operand" "")]
   "TARGET_VX"
 {
   if (TARGET_64BIT)
@@ -575,7 +575,7 @@
 
 (define_insn "vec_addc<mode>"
   [(set (match_operand:VI_HW                0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand"  "v")
+	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "%v")
 		       (match_operand:VI_HW 2 "register_operand"  "v")]
 		      UNSPEC_VEC_ADDC))]
   "TARGET_VX"
@@ -584,7 +584,7 @@
 
 (define_insn "vec_addc_u128"
   [(set (match_operand:V16QI                0 "register_operand" "=v")
-	(unspec:V16QI [(match_operand:V16QI 1 "register_operand"  "v")
+	(unspec:V16QI [(match_operand:V16QI 1 "register_operand" "%v")
 		       (match_operand:V16QI 2 "register_operand"  "v")]
 		      UNSPEC_VEC_ADDC_U128))]
   "TARGET_VX"
@@ -596,7 +596,7 @@
 
 (define_insn "vec_adde_u128"
   [(set (match_operand:V16QI                0 "register_operand" "=v")
-	(unspec:V16QI [(match_operand:V16QI 1 "register_operand"  "v")
+	(unspec:V16QI [(match_operand:V16QI 1 "register_operand" "%v")
 		       (match_operand:V16QI 2 "register_operand"  "v")
 		       (match_operand:V16QI 3 "register_operand"  "v")]
 		      UNSPEC_VEC_ADDE_U128))]
@@ -609,7 +609,7 @@
 
 (define_insn "vec_addec_u128"
   [(set (match_operand:V16QI                0 "register_operand" "=v")
-	(unspec:V16QI [(match_operand:V16QI 1 "register_operand"  "v")
+	(unspec:V16QI [(match_operand:V16QI 1 "register_operand" "%v")
 		       (match_operand:V16QI 2 "register_operand"  "v")
 		       (match_operand:V16QI 3 "register_operand"  "v")]
 		      UNSPEC_VEC_ADDEC_U128))]
@@ -672,7 +672,7 @@
 
 (define_insn "vec_avg<mode>"
   [(set (match_operand:VI_HW                0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand"  "v")
+	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "%v")
 		       (match_operand:VI_HW 2 "register_operand"  "v")]
 		      UNSPEC_VEC_AVG))]
   "TARGET_VX"
@@ -683,7 +683,7 @@
 
 (define_insn "vec_avgu<mode>"
   [(set (match_operand:VI_HW                0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand"  "v")
+	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "%v")
 		       (match_operand:VI_HW 2 "register_operand"  "v")]
 		      UNSPEC_VEC_AVGU))]
   "TARGET_VX"
@@ -871,9 +871,9 @@
 ; vmalb, vmalh, vmalf, vmalg
 (define_insn "vec_vmal<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand"  "v")]
 			  UNSPEC_VEC_VMAL))]
   "TARGET_VX"
   "vmal<bhfgq><w>\t%v0,%v1,%v2,%v3"
@@ -884,9 +884,9 @@
 ; vmahb; vmahh, vmahf, vmahg
 (define_insn "vec_vmah<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand"  "v")]
 			  UNSPEC_VEC_VMAH))]
   "TARGET_VX"
   "vmah<bhfgq>\t%v0,%v1,%v2,%v3"
@@ -895,9 +895,9 @@
 ; vmalhb; vmalhh, vmalhf, vmalhg
 (define_insn "vec_vmalh<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand"  "v")]
 			  UNSPEC_VEC_VMALH))]
   "TARGET_VX"
   "vmalh<bhfgq>\t%v0,%v1,%v2,%v3"
@@ -908,8 +908,8 @@
 ; vmaeb; vmaeh, vmaef, vmaeg
 (define_insn "vec_vmae<mode>"
   [(set (match_operand:<vec_double> 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			      (match_operand:VI_HW_QHS 2 "register_operand" "v")
+	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand"   "%v")
+			      (match_operand:VI_HW_QHS 2 "register_operand"    "v")
 			      (match_operand:<vec_double> 3 "register_operand" "v")]
 			     UNSPEC_VEC_VMAE))]
   "TARGET_VX"
@@ -919,7 +919,7 @@
 ; vmaleb; vmaleh, vmalef, vmaleg
 (define_insn "vec_vmale<mode>"
   [(set (match_operand:<vec_double> 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_HW_QHS 2 "register_operand" "v")
 			      (match_operand:<vec_double> 3 "register_operand" "v")]
 			     UNSPEC_VEC_VMALE))]
@@ -932,7 +932,7 @@
 ; vmaob; vmaoh, vmaof, vmaog
 (define_insn "vec_vmao<mode>"
   [(set (match_operand:<vec_double> 0 "register_operand" "=v")
-	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+	(unspec:<vec_double> [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
 			      (match_operand:VI_HW_QHS 2 "register_operand" "v")
 			      (match_operand:<vec_double> 3 "register_operand" "v")]
 			     UNSPEC_VEC_VMAO))]
@@ -959,7 +959,7 @@
 ; vmhb, vmhh, vmhf
 (define_insn "vec_smulh<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "v")]
 			  UNSPEC_VEC_SMULT_HI))]
   "TARGET_VX"
@@ -969,7 +969,7 @@
 ; vmlhb, vmlhh, vmlhf
 (define_insn "vec_umulh<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "%v")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "v")]
 			  UNSPEC_VEC_UMULT_HI))]
   "TARGET_VX"
@@ -987,7 +987,7 @@
 
 (define_insn "vec_nor<mode>3"
   [(set (match_operand:VT_HW 0 "register_operand" "=v")
-	(not:VT_HW (ior:VT_HW (match_operand:VT_HW 1 "register_operand" "v")
+	(not:VT_HW (ior:VT_HW (match_operand:VT_HW 1 "register_operand" "%v")
 			      (match_operand:VT_HW 2 "register_operand" "v"))))]
   "TARGET_VX"
   "vno\t%v0,%v1,%v2"
@@ -1042,7 +1042,7 @@
 	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand"  "0")
 		       (match_operand:VI_HW 2 "register_operand"  "v")
 		       (match_operand:VI_HW 3 "register_operand"  "v")
-		       (match_operand:SI    4 "immediate_operand" "I")]
+		       (match_operand:QI    4 "const_int_operand" "C")]
 		      UNSPEC_VEC_RL_MASK))]
   "TARGET_VX"
   "verim<bhfgq>\t%v0,%v2,%v3,%b4"
@@ -1079,7 +1079,7 @@
   [(set (match_operand:V_HW 0 "register_operand"              "=v")
 	(unspec:V_HW [(match_operand:V_HW 1 "register_operand" "v")
 		      (match_operand:V_HW 2 "register_operand" "v")
-		      (match_operand:DI 3 "immediate_operand" "C")]
+		      (match_operand:QI 3 "const_int_operand"  "C")]
 		     UNSPEC_VEC_SLDB))]
   "TARGET_VX"
   "vsldb\t%v0,%v1,%v2,%b3"
@@ -1089,7 +1089,7 @@
   [(set (match_operand:V_HW 0 "register_operand"               "")
 	(unspec:V_HW [(match_operand:V_HW 1 "register_operand" "")
 		      (match_operand:V_HW 2 "register_operand" "")
-		      (match_operand:DI 3 "immediate_operand"  "")]
+		      (match_operand:QI 3 "const_int_operand"  "")]
 		     UNSPEC_VEC_SLDB))]
   "TARGET_VX"
 {
@@ -1262,7 +1262,7 @@
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
 	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:SI        3 "immediate_operand" "C")]
+			   (match_operand:QI        3 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VFAE))]
   "TARGET_VX"
 {
@@ -1282,9 +1282,9 @@
 ; vfaezbs, vfaezhs, vfaezfs
 (define_insn "*vfaes<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:SI        3 "immediate_operand" "C")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"   "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"   "v")
+			   (match_operand:QI        3 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VFAE))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1307,9 +1307,9 @@
 
 (define_expand "vfaez<mode>"
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:SI        3 "immediate_operand" "C")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"  "")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "")
+			   (match_operand:QI        3 "const_mask_operand" "")]
 			  UNSPEC_VEC_VFAE))]
   "TARGET_VX"
 {
@@ -1319,9 +1319,9 @@
 (define_expand "vfaes<mode>"
   [(parallel
     [(set (match_operand:VI_HW_QHS 0 "register_operand" "")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "")
-			   (match_operand:SI        3 "immediate_operand" "C")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"  "")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "")
+			   (match_operand:QI        3 "const_mask_operand" "")]
 			  UNSPEC_VEC_VFAE))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1338,9 +1338,9 @@
 (define_expand "vfaezs<mode>"
   [(parallel
     [(set (match_operand:VI_HW_QHS 0 "register_operand" "")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "")
-			   (match_operand:SI        3 "immediate_operand" "C")]
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"  "")
+			   (match_operand:VI_HW_QHS 2 "register_operand"  "")
+			   (match_operand:SI        3 "const_mask_operand" "")]
 			  UNSPEC_VEC_VFAE))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1363,7 +1363,7 @@
   [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
 	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:QI 3 "immediate_operand" "C")]
+			   (match_operand:QI 3 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VFEE))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1541,11 +1541,11 @@
 ; vstrcb, vstrch, vstrcf
 ; vstrczb, vstrczh, vstrczf
 (define_insn "vstrc<mode>"
-  [(set (match_operand:VI_HW_QHS                    0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"  "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand"  "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand"  "v")
-			   (match_operand:SI        4 "immediate_operand" "C")]
+  [(set (match_operand:VI_HW_QHS                    0 "register_operand"  "=v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"   "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"   "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand"   "v")
+			   (match_operand:QI        4 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VSTRC))]
   "TARGET_VX"
 {
@@ -1564,11 +1564,11 @@
 ; vstrcbs, vstrchs, vstrcfs
 ; vstrczbs, vstrczhs, vstrczfs
 (define_insn "*vstrcs<mode>"
-  [(set (match_operand:VI_HW_QHS                    0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"  "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand"  "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand"  "v")
-			   (match_operand:SI        4 "immediate_operand" "C")]
+  [(set (match_operand:VI_HW_QHS                    0 "register_operand"  "=v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"   "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand"   "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand"   "v")
+			   (match_operand:QI        4 "const_mask_operand" "C")]
 			  UNSPEC_VEC_VSTRC))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1591,11 +1591,11 @@
   [(set_attr "op_type" "VRR")])
 
 (define_expand "vstrcz<mode>"
-  [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
-	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
-			   (match_operand:VI_HW_QHS 3 "register_operand" "v")
-			   (match_operand:SI        4 "immediate_operand" "C")]
+  [(set (match_operand:VI_HW_QHS 0 "register_operand" "")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand"   "")
+			   (match_operand:VI_HW_QHS 2 "register_operand"   "")
+			   (match_operand:VI_HW_QHS 3 "register_operand"   "")
+			   (match_operand:QI        4 "const_mask_operand" "")]
 			  UNSPEC_VEC_VSTRC))]
   "TARGET_VX"
 {
@@ -1608,7 +1608,7 @@
 	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "")
 			   (match_operand:VI_HW_QHS 3 "register_operand" "")
-			   (match_operand:SI        4 "immediate_operand" "C")]
+			   (match_operand:QI        4 "const_mask_operand" "")]
 			  UNSPEC_VEC_VSTRC))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1629,7 +1629,7 @@
 	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "")
 			   (match_operand:VI_HW_QHS 2 "register_operand" "")
 			   (match_operand:VI_HW_QHS 3 "register_operand" "")
-			   (match_operand:SI        4 "immediate_operand" "C")]
+			   (match_operand:QI        4 "const_mask_operand" "")]
 			  UNSPEC_VEC_VSTRC))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1)
@@ -1647,11 +1647,11 @@
 
 ; Signed V2DI -> V2DF conversion - inexact exception disabled
 (define_insn "vec_di_to_df_s64"
-  [(set (match_operand:V2DF 0 "register_operand"               "=v")
-	(unspec:V2DF [(match_operand:V2DI 1 "register_operand"  "v")
-		      (match_operand:QI   2 "immediate_operand" "C")]
+  [(set (match_operand:V2DF 0 "register_operand"                "=v")
+	(unspec:V2DF [(match_operand:V2DI 1 "register_operand"   "v")
+		      (match_operand:QI   2 "const_mask_operand" "C")]
 		     UNSPEC_VEC_VCDGB))]
-  "TARGET_VX"
+  "TARGET_VX && UINTVAL (operands[2]) != 2 && UINTVAL (operands[2]) <= 7"
   "vcdgb\t%v0,%v1,4,%b2"
   [(set_attr "op_type" "VRR")])
 
@@ -1661,7 +1661,7 @@
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
 		      (const_int 0)] ; According to current BFP rounding mode
 		     UNSPEC_VEC_VCDGB))
-   (use (match_operand:QI 2 "immediate_operand" ""))
+   (use (match_operand:QI 2 "const_int_operand" ""))
    (set (match_dup 0) (mult:V2DF (match_dup 0) (match_dup 3)))]
   "TARGET_VX"
 {
@@ -1679,7 +1679,7 @@
 (define_insn "vec_di_to_df_u64"
   [(set (match_operand:V2DF 0 "register_operand"               "=v")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand"  "v")
-		      (match_operand:QI   2 "immediate_operand" "C")]
+		      (match_operand:QI   2 "const_int_operand" "C")]
 		     UNSPEC_VEC_VCDLGB))]
   "TARGET_VX"
   "vcdlgb\t%v0,%v1,4,%b2"
@@ -1691,7 +1691,7 @@
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
 		      (const_int 0)] ; According to current BFP rounding mode
 		     UNSPEC_VEC_VCDLGB))
-   (use (match_operand:QI 2 "immediate_operand" ""))
+   (use (match_operand:QI 2 "const_int_operand" ""))
    (set (match_dup 0) (mult:V2DF (match_dup 0) (match_dup 3)))]
   "TARGET_VX"
 {
@@ -1710,7 +1710,7 @@
 (define_insn "vec_df_to_di_s64"
   [(set (match_operand:V2DI 0 "register_operand"               "=v")
 	(unspec:V2DI [(match_operand:V2DF 1 "register_operand"  "v")
-		      (match_operand:QI   2 "immediate_operand" "C")]
+		      (match_operand:QI   2 "const_int_operand" "C")]
 		     UNSPEC_VEC_VCGDB))]
   "TARGET_VX"
   "vcgdb\t%v0,%v1,4,%b2"
@@ -1718,7 +1718,7 @@
 
 ; The input needs to be multiplied with 2**op2
 (define_expand "vec_ctsl"
-  [(use (match_operand:QI 2 "immediate_operand" ""))
+  [(use (match_operand:QI 2 "const_int_operand" ""))
    (set (match_dup 4) (mult:V2DF (match_operand:V2DF 1 "register_operand" "")
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
@@ -1741,15 +1741,15 @@
 (define_insn "vec_df_to_di_u64"
   [(set (match_operand:V2DI 0 "register_operand"               "=v")
 	(unspec:V2DI [(match_operand:V2DF 1 "register_operand"  "v")
-		      (match_operand:QI   2 "immediate_operand" "C")]
+		      (match_operand:QI   2 "const_mask_operand" "C")]
 		     UNSPEC_VEC_VCLGDB))]
-  "TARGET_VX"
+  "TARGET_VX && UINTVAL (operands[2]) <= 7"
   "vclgdb\t%v0,%v1,4,%b2"
   [(set_attr "op_type" "VRR")])
 
 ; The input needs to be multiplied with 2**op2
 (define_expand "vec_ctul"
-  [(use (match_operand:QI 2 "immediate_operand" ""))
+  [(use (match_operand:QI 2 "const_int_operand" ""))
    (set (match_dup 4) (mult:V2DF (match_operand:V2DF 1 "register_operand" "")
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
@@ -1770,12 +1770,12 @@
 
 ; Vector load fp integer - IEEE inexact exception is suppressed
 (define_insn "vfidb"
-  [(set (match_operand:V2DI               0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DF 1 "register_operand"  "v")
-		      (match_operand:QI   2 "immediate_operand" "C")
-		      (match_operand:QI   3 "immediate_operand" "C")]
+  [(set (match_operand:V2DI               0 "register_operand"  "=v")
+	(unspec:V2DI [(match_operand:V2DF 1 "register_operand"   "v")
+		      (match_operand:QI   2 "const_mask_operand" "C")
+		      (match_operand:QI   3 "const_mask_operand" "C")]
 		     UNSPEC_VEC_VFIDB))]
-  "TARGET_VX"
+  "TARGET_VX && !(UINTVAL (operands[2]) & 3) && UINTVAL (operands[3]) <= 7"
   "vfidb\t%v0,%v1,%b2,%b3"
   [(set_attr "op_type" "VRR")])
 
@@ -1887,21 +1887,21 @@
 (define_insn "*vftcidb"
   [(set (match_operand:V2DF 0 "register_operand"  "=v")
 	(unspec:V2DF [(match_operand:V2DF 1 "register_operand"  "v")
-		      (match_operand:SI   2 "immediate_operand" "J")]
+		      (match_operand:HI   2 "const_int_operand" "J")]
 		     UNSPEC_VEC_VFTCIDB))
    (set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_dup 1) (match_dup 2)] UNSPEC_VEC_VFTCIDBCC))]
-  "TARGET_VX"
+  "TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \"J\")"
   "vftcidb\t%v0,%v1,%x2"
   [(set_attr "op_type" "VRR")])
 
 (define_insn "*vftcidb_cconly"
   [(set (reg:CCRAW CC_REGNUM)
 	(unspec:CCRAW [(match_operand:V2DF 1 "register_operand"  "v")
-		       (match_operand:SI   2 "immediate_operand" "J")]
+		       (match_operand:HI   2 "const_int_operand" "J")]
 		      UNSPEC_VEC_VFTCIDBCC))
    (clobber (match_scratch:V2DI 0 "=v"))]
-  "TARGET_VX"
+  "TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \"J\")"
   "vftcidb\t%v0,%v1,%x2"
   [(set_attr "op_type" "VRR")])
 
@@ -1909,13 +1909,13 @@
   [(parallel
     [(set (match_operand:V2DF               0 "register_operand"  "")
 	  (unspec:V2DF [(match_operand:V2DF 1 "register_operand"  "")
-			(match_operand:SI   2 "immediate_operand" "")]
+			(match_operand:HI   2 "const_int_operand" "")]
 		       UNSPEC_VEC_VFTCIDB))
      (set (reg:CCRAW CC_REGNUM)
 	  (unspec:CCRAW [(match_dup 1) (match_dup 2)] UNSPEC_VEC_VFTCIDBCC))])
    (set (match_operand:SI 3 "memory_operand" "")
 	(unspec:SI [(reg:CCRAW CC_REGNUM)] UNSPEC_CC_TO_INT))]
-  "TARGET_VX")
+  "TARGET_VX && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'J', \"J\")")
 
 ;;
 ;; Integer compares
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index a3154d6..826e2f3 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -10241,12 +10241,16 @@ label:
 		      (const_string "single") (const_string "double")))
    (set_attr "type" "jump_ind")])
 
+;; sibcall_value_pcrel used to have a =&k clobber for the scratch register
+;; that it needs for the branch address.  This causes troubles when there
+;; is a big overlap of argument and return value registers.  Hence, use a
+;; fixed call clobbered register for the address.  See also PR 67260.
 (define_insn_and_split "sibcall_value_pcrel"
   [(set (match_operand 0 "" "=rf")
 	(call (mem:SI (match_operand:SI 1 "symbol_ref_operand" ""))
 	      (match_operand 2 "" "")))
    (use (reg:SI FPSCR_MODES_REG))
-   (clobber (match_scratch:SI 3 "=&k"))
+   (clobber (reg:SI R1_REG))
    (return)]
   "TARGET_SH2"
   "#"
@@ -10256,6 +10260,8 @@ label:
   rtx lab = PATTERN (gen_call_site ());
   rtx call_insn;
 
+  operands[3] =  gen_rtx_REG (SImode, R1_REG);
+
   emit_insn (gen_sym_label2reg (operands[3], operands[1], lab));
   call_insn = emit_call_insn (gen_sibcall_valuei_pcrel (operands[0],
 							operands[3],
@@ -11368,12 +11374,16 @@ label:
 ;; ??? reload might clobber r0 if we use it explicitly in the RTL before
 ;; reload; using a R0_REGS pseudo reg is likely to give poor code.
 ;; So we keep the use of r0 hidden in a R0_REGS clobber until after reload.
+;;
+;; The use on the T_REG in the casesi_worker* patterns links the bounds
+;; checking insns and the table memory access.  See also PR 69713.
 (define_insn "casesi_worker_0"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	(unspec:SI [(match_operand:SI 1 "register_operand" "0,r")
 		 (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 "=X,1"))
-   (clobber (match_scratch:SI 4 "=&z,z"))]
+   (clobber (match_scratch:SI 4 "=&z,z"))
+   (use (reg:SI T_REG))]
   "TARGET_SH1"
   "#")
 
@@ -11382,7 +11392,8 @@ label:
 	(unspec:SI [(match_operand:SI 1 "register_operand" "")
 		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 ""))
-   (clobber (match_scratch:SI 4 ""))]
+   (clobber (match_scratch:SI 4))
+   (use (reg:SI T_REG))]
   "TARGET_SH1 && ! TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
@@ -11400,7 +11411,8 @@ label:
 	(unspec:SI [(match_operand:SI 1 "register_operand" "")
 		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 ""))
-   (clobber (match_scratch:SI 4 ""))]
+   (clobber (match_scratch:SI 4))
+   (use (reg:SI T_REG))]
   "TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 98ff5c9..5879dd4 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -4693,24 +4693,7 @@
 
 ;; Boolean instructions.
 
-;; We define DImode `and' so with DImode `not' we can get
-;; DImode `andn'.  Other combinations are possible.
-
-(define_expand "anddi3"
-  [(set (match_operand:DI 0 "register_operand" "")
-	(and:DI (match_operand:DI 1 "arith_double_operand" "")
-		(match_operand:DI 2 "arith_double_operand" "")))]
-  ""
-  "")
-
-(define_insn "*anddi3_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(and:DI (match_operand:DI 1 "arith_double_operand" "%r")
-		(match_operand:DI 2 "arith_double_operand" "rHI")))]
-  "! TARGET_ARCH64"
-  "#")
-
-(define_insn "*anddi3_sp64"
+(define_insn "anddi3"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(and:DI (match_operand:DI 1 "arith_operand" "%r")
 		(match_operand:DI 2 "arith_operand" "rI")))]
@@ -4736,28 +4719,6 @@
   operands[4] = GEN_INT (~INTVAL (operands[2]));
 })
 
-(define_insn_and_split "*and_not_di_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(and:DI (not:DI (match_operand:DI 1 "register_operand" "%r"))
-		(match_operand:DI 2 "register_operand" "r")))]
-  "! TARGET_ARCH64"
-  "#"
-  "&& reload_completed
-   && ((GET_CODE (operands[0]) == REG
-        && SPARC_INT_REG_P (REGNO (operands[0])))
-       || (GET_CODE (operands[0]) == SUBREG
-           && GET_CODE (SUBREG_REG (operands[0])) == REG
-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))"
-  [(set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))
-   (set (match_dup 6) (and:SI (not:SI (match_dup 7)) (match_dup 8)))]
-  "operands[3] = gen_highpart (SImode, operands[0]);
-   operands[4] = gen_highpart (SImode, operands[1]);
-   operands[5] = gen_highpart (SImode, operands[2]);
-   operands[6] = gen_lowpart (SImode, operands[0]);
-   operands[7] = gen_lowpart (SImode, operands[1]);
-   operands[8] = gen_lowpart (SImode, operands[2]);"
-  [(set_attr "length" "2")])
-
 (define_insn "*and_not_di_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(and:DI (not:DI (match_operand:DI 1 "register_operand" "%r"))
@@ -4772,22 +4733,7 @@
   ""
   "andn\t%2, %1, %0")
 
-(define_expand "iordi3"
-  [(set (match_operand:DI 0 "register_operand" "")
-	(ior:DI (match_operand:DI 1 "arith_double_operand" "")
-		(match_operand:DI 2 "arith_double_operand" "")))]
-  ""
-  "")
-
-(define_insn "*iordi3_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ior:DI (match_operand:DI 1 "arith_double_operand" "%r")
-		(match_operand:DI 2 "arith_double_operand" "rHI")))]
-  "! TARGET_ARCH64"
-  "#"
-  [(set_attr "length" "2")])
-
-(define_insn "*iordi3_sp64"
+(define_insn "iordi3"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(ior:DI (match_operand:DI 1 "arith_operand" "%r")
 		(match_operand:DI 2 "arith_operand" "rI")))]
@@ -4813,28 +4759,6 @@
   operands[4] = gen_int_mode (~INTVAL (operands[2]), SImode);
 })
 
-(define_insn_and_split "*or_not_di_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(ior:DI (not:DI (match_operand:DI 1 "register_operand" "r"))
-		(match_operand:DI 2 "register_operand" "r")))]
-  "! TARGET_ARCH64"
-  "#"
-  "&& reload_completed
-   && ((GET_CODE (operands[0]) == REG
-        && SPARC_INT_REG_P (REGNO (operands[0])))
-       || (GET_CODE (operands[0]) == SUBREG
-           && GET_CODE (SUBREG_REG (operands[0])) == REG
-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))"
-  [(set (match_dup 3) (ior:SI (not:SI (match_dup 4)) (match_dup 5)))
-   (set (match_dup 6) (ior:SI (not:SI (match_dup 7)) (match_dup 8)))]
-  "operands[3] = gen_highpart (SImode, operands[0]);
-   operands[4] = gen_highpart (SImode, operands[1]);
-   operands[5] = gen_highpart (SImode, operands[2]);
-   operands[6] = gen_lowpart (SImode, operands[0]);
-   operands[7] = gen_lowpart (SImode, operands[1]);
-   operands[8] = gen_lowpart (SImode, operands[2]);"
-  [(set_attr "length" "2")])
-
 (define_insn "*or_not_di_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(ior:DI (not:DI (match_operand:DI 1 "register_operand" "r"))
@@ -4849,22 +4773,7 @@
   ""
   "orn\t%2, %1, %0")
 
-(define_expand "xordi3"
-  [(set (match_operand:DI 0 "register_operand" "")
-	(xor:DI (match_operand:DI 1 "arith_double_operand" "")
-		(match_operand:DI 2 "arith_double_operand" "")))]
-  ""
-  "")
-
-(define_insn "*xordi3_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(xor:DI (match_operand:DI 1 "arith_double_operand" "%r")
-		(match_operand:DI 2 "arith_double_operand" "rHI")))]
-  "! TARGET_ARCH64"
-  "#"
-  [(set_attr "length" "2")])
-
-(define_insn "*xordi3_sp64"
+(define_insn "xordi3"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(xor:DI (match_operand:DI 1 "arith_operand" "%rJ")
 		(match_operand:DI 2 "arith_operand" "rI")))]
@@ -4902,64 +4811,6 @@
   operands[4] = gen_int_mode (~INTVAL (operands[2]), SImode);
 })
 
-;; Split DImode logical operations requiring two instructions.
-(define_split
-  [(set (match_operand:DI 0 "register_operand" "")
-	(match_operator:DI 1 "cc_arith_operator"	; AND, IOR, XOR
-			   [(match_operand:DI 2 "register_operand" "")
-			    (match_operand:DI 3 "arith_double_operand" "")]))]
-  "! TARGET_ARCH64
-   && reload_completed
-   && ((GET_CODE (operands[0]) == REG
-        && SPARC_INT_REG_P (REGNO (operands[0])))
-       || (GET_CODE (operands[0]) == SUBREG
-           && GET_CODE (SUBREG_REG (operands[0])) == REG
-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))"
-  [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))
-   (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]
-{
-  operands[4] = gen_highpart (SImode, operands[0]);
-  operands[5] = gen_lowpart (SImode, operands[0]);
-  operands[6] = gen_highpart (SImode, operands[2]);
-  operands[7] = gen_lowpart (SImode, operands[2]);
-#if HOST_BITS_PER_WIDE_INT == 32
-  if (GET_CODE (operands[3]) == CONST_INT)
-    {
-      if (INTVAL (operands[3]) < 0)
-	operands[8] = constm1_rtx;
-      else
-	operands[8] = const0_rtx;
-    }
-  else
-#endif
-    operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);
-  operands[9] = gen_lowpart (SImode, operands[3]);
-})
-
-;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).
-;; Combine now canonicalizes to the rightmost expression.
-(define_insn_and_split "*xor_not_di_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(not:DI (xor:DI (match_operand:DI 1 "register_operand" "r")
-			(match_operand:DI 2 "register_operand" "r"))))]
-  "! TARGET_ARCH64"
-  "#"
-  "&& reload_completed
-   && ((GET_CODE (operands[0]) == REG
-        && SPARC_INT_REG_P (REGNO (operands[0])))
-       || (GET_CODE (operands[0]) == SUBREG
-           && GET_CODE (SUBREG_REG (operands[0])) == REG
-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))"
-  [(set (match_dup 3) (not:SI (xor:SI (match_dup 4) (match_dup 5))))
-   (set (match_dup 6) (not:SI (xor:SI (match_dup 7) (match_dup 8))))]
-  "operands[3] = gen_highpart (SImode, operands[0]);
-   operands[4] = gen_highpart (SImode, operands[1]);
-   operands[5] = gen_highpart (SImode, operands[2]);
-   operands[6] = gen_lowpart (SImode, operands[0]);
-   operands[7] = gen_lowpart (SImode, operands[1]);
-   operands[8] = gen_lowpart (SImode, operands[2]);"
-  [(set_attr "length" "2")])
-
 (define_insn "*xor_not_di_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(not:DI (xor:DI (match_operand:DI 1 "register_or_zero_operand" "rJ")
@@ -5208,34 +5059,7 @@
   "subcc\t%%g0, %1, %0"
   [(set_attr "type" "compare")])
 
-;; We cannot use the "not" pseudo insn because the Sun assembler
-;; does not know how to make it work for constants.
-(define_expand "one_cmpldi2"
-  [(set (match_operand:DI 0 "register_operand" "")
-	(not:DI (match_operand:DI 1 "register_operand" "")))]
-  ""
-  "")
-
-(define_insn_and_split "*one_cmpldi2_sp32"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(not:DI (match_operand:DI 1 "register_operand" "r")))]
-  "! TARGET_ARCH64"
-  "#"
-  "&& reload_completed
-   && ((GET_CODE (operands[0]) == REG
-        && SPARC_INT_REG_P (REGNO (operands[0])))
-       || (GET_CODE (operands[0]) == SUBREG
-           && GET_CODE (SUBREG_REG (operands[0])) == REG
-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))"
-  [(set (match_dup 2) (not:SI (xor:SI (match_dup 3) (const_int 0))))
-   (set (match_dup 4) (not:SI (xor:SI (match_dup 5) (const_int 0))))]
-  "operands[2] = gen_highpart (SImode, operands[0]);
-   operands[3] = gen_highpart (SImode, operands[1]);
-   operands[4] = gen_lowpart (SImode, operands[0]);
-   operands[5] = gen_lowpart (SImode, operands[1]);"
-  [(set_attr "length" "2")])
-
-(define_insn "*one_cmpldi2_sp64"
+(define_insn "one_cmpldi2"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(not:DI (match_operand:DI 1 "arith_operand" "rI")))]
   "TARGET_ARCH64"
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 3477397..73ea50e 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,239 @@
+2016-03-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67364
+	* constexpr.c (cxx_eval_store_expression): Replace
+	CONSTRUCTOR_ELTS in nested CONSTRUCTORs, too.
+
+2016-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67364
+	* constexpr.c (cxx_eval_component_reference): Further tweak.
+
+	PR c++/70067
+	* tree.c (strip_typedefs): Handle TYPENAME_TYPE lookup finding the
+	same type.
+
+2016-03-03  Jason Merrill  <jason@redhat.com>
+
+	* call.c (build_aggr_conv): Use get_nsdmi.
+
+	PR c++/51406
+	* typeck.c (build_static_cast_1): Avoid folding back to lvalue.
+
+	PR c++/67364
+	* constexpr.c (cxx_eval_component_reference): Just return an empty
+	CONSTRUCTOR for an empty class.
+
+2016-03-01  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* call.c (build_op_delete_call, build_over_call): Check mark_used
+	return value.
+	* class.c (resolve_address_of_overloaded_function): Likewise.
+	* decl.c (cxx_maybe_build_cleanup): Likewise.
+	* pt.c (gen_elem_of_pack_expansion_instantiation, tsubst_baselink,
+	tsubst_qualified_id, tsubst_copy, tsubst_copy_and_build): Likewise.
+	* rtti.c (build_dynamic_cast_1): Likewise.
+	* semantics.c (process_outer_var_ref): Likewise.
+	* typeck.c (build_class_member_access_expr,
+	cp_build_function_call_vec, cp_build_addr_expr_1): Likewise.
+
+2016-03-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69261
+	* constexpr.c (find_array_ctor_elt): Handle splitting RANGE_EXPR.
+
+2016-03-01  Markus Trippelsdorf  <markus@trippelsdorf.de>
+	    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/68087
+	* constexpr.c (cxx_eval_array_reference): Use tree_fits_shwi_p before
+	tree_to_shwi to avoid ICEs.
+
+2016-03-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67104
+	* constexpr.c (array_index_cmp, find_array_ctor_elt): New.
+	(cxx_eval_array_reference, cxx_eval_store_expression): Use them.
+
+	PR c++/51489
+	* constexpr.c (cxx_eval_binary_expression): Don't VERIFY_CONSTANT
+	the operands.
+
+	PR c++/69995
+	* constexpr.c (cxx_eval_call_expression): Unshare arg.
+	(cxx_eval_constant_expression) [DECL_EXPR]: Unshare init.
+	[TARGET_EXPR]: Unshare init.
+
+2016-02-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69995
+	* constexpr.c (cxx_eval_store_expression): Unshare init.
+
+	PR c++/65985
+	* constexpr.c (build_constexpr_constructor_member_initializers):
+	Handle an additional STATEMENT_LIST.
+
+2016-02-25  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backported from mainline
+	2016-02-19  Jakub Jelinek  <jakub@redhat.com>
+		    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* Make-lang.in: Invoke gperf with -L C++.
+	* cfns.gperf: Remove prototypes for hash and libc_name_p
+	inlines.
+	* cfns.h: Regenerated.
+	* except.c (nothrow_libfn_p): Adjust.
+
+2016-02-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67364
+	* constexpr.c (cxx_eval_component_reference): Don't complain about
+	unevaluated empty classes.
+
+	PR c++/68049
+	* tree.c (strip_typedefs): Use DECL_ORIGINAL_TYPE.
+
+2016-02-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69323
+	* pt.c (instantiate_class_template_1): Set
+	processing_template_decl before substituting friend_type.
+
+2016-02-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69743
+	* call.c (remaining_arguments): No longer static.
+	* cp-tree.h: Declare it.
+	* pt.c (more_specialized_fn): Use it.
+
+2016-02-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68585
+	* constexpr.c (cxx_eval_bare_aggregate): Fix 'changed' detection.
+
+	PR c++/68679
+	* decl2.c (reset_type_linkage_2): Look through member templates.
+
+2016-02-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68890
+	* constexpr.c (verify_ctor_sanity): Remove CONSTRUCTOR_NELTS check.
+
+2016-02-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68926
+	* pt.c (resolve_nondeduced_context): Add complain parm.
+	(do_auto_deduction): Pass it.
+	* cvt.c (convert_to_void): Likewise.
+	* decl.c (cp_finish_decl): Likewise.
+	* init.c (build_new): Likewise.
+	* rtti.c (get_tinfo_decl_dynamic): Likewise.
+	* semantics.c (finish_decltype_type): Likewise.
+	* typeck.c (decay_conversion): Likewise.
+	* cp-tree.h: Adjust declaration.
+	* call.c (standard_conversion): Add complain parm, pass it along.
+	(implicit_conversion): Pass it.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/59627
+	* parser.c (cp_parser_omp_declare_reduction): Set assembler name
+	of the DECL_OMP_DECLARE_REDUCTION_P decls.
+
+2016-01-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69009
+	* pt.c (partial_specialization_p, impartial_args): New.
+	(instantiate_decl): Call impartial_args.
+
+2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68062
+	* typeck.c (cp_build_binary_op): Promote operand to unsigned, if
+	needed.  Add -Wsign-compare warning.
+
+2016-01-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68949
+	* optimize.c (maybe_clone_body): Clear DECL_SAVED_TREE of the alias.
+	* semantics.c (expand_or_defer_fn_1): Keep DECL_SAVED_TREE of
+	maybe-in-charge *tor.
+
+	PR c++/69131
+	* method.c (walk_field_subobs): Add dtor_from_ctor parm.
+	(process_subob_fn): Likewise.  Don't consider triviality if true.
+	(synthesize_method_walk): Pass it.
+
+2016-01-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/68965
+	* pt.c (tsubst_copy): Mark elements in expanded vector as used.
+
+2016-01-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/68449
+	* constexpr.c (cxx_eval_constant_expression): Handle NULL initializer.
+
+2016-01-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68983
+	PR c++/67557
+	* call.c (unsafe_copy_elision_p): Look through COMPOUND_EXPR.
+
+2015-12-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/66921
+	* decl.c (cp_complete_array_type): Allow an initializer that
+	already has array type.
+
+	PR c++/67339
+	* parser.c (cp_parser_elaborated_type_specifier): Use CLASS_TYPE_P
+	rather than check for RECORD_TYPE.
+
+2015-12-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67411
+	* decl2.c (decl_maybe_constant_var_p): Use DECL_HAS_VALUE_EXPR_P.
+
+	PR c++/67411
+	* decl2.c (decl_maybe_constant_var_p): A proxy isn't constant.
+
+2015-12-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67550
+	* init.c (constant_value_1): Don't return a CONSTRUCTOR missing
+	non-constant elements.
+
+	PR c++/67576
+	PR c++/25466
+	* rtti.c (build_typeid): Use save_expr, not stabilize_reference.
+
+2015-12-16  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/68162
+	* tree.c (c_build_qualified_type): Add extra arguments.
+
+2015-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63628
+	* pt.c (tsubst_pack_expansion): Also make dummy decls if
+	retrieve_local_specialization fails.
+
+2015-12-04  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	PR c++/67337
+	* mangle.c (write_template_prefix): Guard against context==NULL.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index e98beb1..b09fb02 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -111,7 +111,7 @@ else
 # deleting the $(srcdir)/cp/cfns.h file.
 $(srcdir)/cp/cfns.h:
 endif
-	gperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' -L ANSI-C \
+	gperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' -L C++ \
 		$(srcdir)/cp/cfns.gperf --output-file $(srcdir)/cp/cfns.h
 
 #
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 0df408c..0751b6d 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -213,7 +213,6 @@ static struct z_candidate *add_function_candidate
 	 tree, int, tsubst_flags_t);
 static conversion *implicit_conversion (tree, tree, tree, bool, int,
 					tsubst_flags_t);
-static conversion *standard_conversion (tree, tree, tree, bool, int);
 static conversion *reference_binding (tree, tree, tree, bool, int,
 				      tsubst_flags_t);
 static conversion *build_conv (conversion_kind, tree, conversion *);
@@ -924,6 +923,8 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)
 
       if (i < CONSTRUCTOR_NELTS (ctor))
 	val = CONSTRUCTOR_ELT (ctor, i)->value;
+      else if (DECL_INITIAL (field))
+	val = get_nsdmi (field, /*ctor*/false);
       else if (TREE_CODE (ftype) == REFERENCE_TYPE)
 	/* Value-initialization of reference is ill-formed.  */
 	return NULL;
@@ -1106,7 +1107,7 @@ strip_top_quals (tree t)
 
 static conversion *
 standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
-		     int flags)
+		     int flags, tsubst_flags_t complain)
 {
   enum tree_code fcode, tcode;
   conversion *conv;
@@ -1136,7 +1137,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
       else if (TREE_CODE (to) == BOOLEAN_TYPE)
 	{
 	  /* Necessary for eg, TEMPLATE_ID_EXPRs (c++/50961).  */
-	  expr = resolve_nondeduced_context (expr);
+	  expr = resolve_nondeduced_context (expr, complain);
 	  from = TREE_TYPE (expr);
 	}
     }
@@ -1175,7 +1176,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
 	 the standard conversion sequence to perform componentwise
 	 conversion.  */
       conversion *part_conv = standard_conversion
-	(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, c_cast_p, flags);
+	(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, c_cast_p, flags,
+	 complain);
 
       if (part_conv)
 	{
@@ -1814,7 +1816,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,
   if (TREE_CODE (to) == REFERENCE_TYPE)
     conv = reference_binding (to, from, expr, c_cast_p, flags, complain);
   else
-    conv = standard_conversion (to, from, expr, c_cast_p, flags);
+    conv = standard_conversion (to, from, expr, c_cast_p, flags, complain);
 
   if (conv)
     return conv;
@@ -1920,7 +1922,7 @@ add_candidate (struct z_candidate **candidates,
 /* Return the number of remaining arguments in the parameter list
    beginning with ARG.  */
 
-static int
+int
 remaining_arguments (tree arg)
 {
   int n;
@@ -5980,7 +5982,8 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,
 	  argarray[0] = addr;
 	  for (i = 1; i < nargs; i++)
 	    argarray[i] = CALL_EXPR_ARG (placement, i);
-	  mark_used (fn);
+	  if (!mark_used (fn, complain) && !(complain & tf_error))
+	    return error_mark_node;
 	  return build_cxx_call (fn, nargs, argarray, complain);
 	}
       else
@@ -7031,6 +7034,9 @@ unsafe_copy_elision_p (tree target, tree exp)
       && resolves_to_fixed_type_p (target, NULL))
     return false;
   tree init = TARGET_EXPR_INITIAL (exp);
+  /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */
+  while (TREE_CODE (init) == COMPOUND_EXPR)
+    init = TREE_OPERAND (init, 1);
   return (TREE_CODE (init) == AGGR_INIT_EXPR
 	  && !AGGR_INIT_VIA_CTOR_P (init));
 }
@@ -7435,7 +7441,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
 	 the implementation elided its use.  */
       if (!trivial || DECL_DELETED_FN (fn))
 	{
-	  mark_used (fn);
+	  if (!mark_used (fn, complain) && !(complain & tf_error))
+	    return error_mark_node;
 	  already_used = true;
 	}
 
diff --git a/gcc/cp/cfns.gperf b/gcc/cp/cfns.gperf
index 68acd3d..214ecf6 100644
--- a/gcc/cp/cfns.gperf
+++ b/gcc/cp/cfns.gperf
@@ -1,3 +1,5 @@
+%language=C++
+%define class-name libc_name
 %{
 /* Copyright (C) 2000-2015 Free Software Foundation, Inc.
 
@@ -16,14 +18,6 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
-#ifdef __GNUC__
-__inline
-#endif
-static unsigned int hash (const char *, unsigned int);
-#ifdef __GNUC__
-__inline
-#endif
-const char * libc_name_p (const char *, unsigned int);
 %}
 %%
 # The standard C library functions, for feeding to gperf; the result is used
diff --git a/gcc/cp/cfns.h b/gcc/cp/cfns.h
index 1c6665d..596f413 100644
--- a/gcc/cp/cfns.h
+++ b/gcc/cp/cfns.h
@@ -1,5 +1,5 @@
-/* ANSI-C code produced by gperf version 3.0.3 */
-/* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L ANSI-C cfns.gperf  */
+/* C++ code produced by gperf version 3.0.4 */
+/* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L C++ --output-file cfns.h cfns.gperf  */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
       && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
@@ -28,7 +28,7 @@
 #error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
 #endif
 
-#line 1 "cfns.gperf"
+#line 3 "cfns.gperf"
 
 /* Copyright (C) 2000-2015 Free Software Foundation, Inc.
 
@@ -47,25 +47,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
-#ifdef __GNUC__
-__inline
-#endif
-static unsigned int hash (const char *, unsigned int);
-#ifdef __GNUC__
-__inline
-#endif
-const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
 
-#ifdef __GNUC__
-__inline
-#else
-#ifdef __cplusplus
-inline
-#endif
-#endif
-static unsigned int
-hash (register const char *str, register unsigned int len)
+class libc_name
+{
+private:
+  static inline unsigned int hash (const char *str, unsigned int len);
+public:
+  static const char *libc_name_p (const char *str, unsigned int len);
+};
+
+inline unsigned int
+libc_name::hash (register const char *str, register unsigned int len)
 {
   static const unsigned short asso_values[] =
     {
@@ -122,14 +115,8 @@ hash (register const char *str, register unsigned int len)
   return hval + asso_values[(unsigned char)str[len - 1]];
 }
 
-#ifdef __GNUC__
-__inline
-#ifdef __GNUC_STDC_INLINE__
-__attribute__ ((__gnu_inline__))
-#endif
-#endif
 const char *
-libc_name_p (register const char *str, register unsigned int len)
+libc_name::libc_name_p (register const char *str, register unsigned int len)
 {
   enum
     {
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index f3ec826..9dc15da 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -7784,8 +7784,8 @@ resolve_address_of_overloaded_function (tree target_type,
       /* Make =delete work with SFINAE.  */
       if (DECL_DELETED_FN (fn) && !(flags & tf_error))
 	return error_mark_node;
-      
-      mark_used (fn);
+      if (!mark_used (fn, flags) && !(flags & tf_error))
+	return error_mark_node;
     }
 
   /* We could not check access to member functions when this
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index ba9fd0e..49c869b 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -539,6 +539,7 @@ build_constexpr_constructor_member_initializers (tree type, tree body)
 {
   vec<constructor_elt, va_gc> *vec = NULL;
   bool ok = true;
+ top:
   if (TREE_CODE (body) == MUST_NOT_THROW_EXPR
       || TREE_CODE (body) == EH_SPEC_BLOCK)
     body = TREE_OPERAND (body, 0);
@@ -550,6 +551,8 @@ build_constexpr_constructor_member_initializers (tree type, tree body)
 	  body = tsi_stmt (i);
 	  if (TREE_CODE (body) == BIND_EXPR)
 	    break;
+	  if (TREE_CODE (body) == MUST_NOT_THROW_EXPR)
+	    goto top;
 	}
     }
   if (TREE_CODE (body) == BIND_EXPR)
@@ -1394,6 +1397,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,
 		  tree oparm = TREE_PURPOSE (bound);
 		  tree arg = TREE_VALUE (bound);
 		  gcc_assert (DECL_NAME (remapped) == DECL_NAME (oparm));
+		  /* Don't share a CONSTRUCTOR that might be changed.  */
+		  arg = unshare_expr (arg);
 		  ctx->values->put (remapped, arg);
 		  bound = TREE_CHAIN (bound);
 		  remapped = DECL_CHAIN (remapped);
@@ -1653,15 +1658,14 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,
   tree lhs, rhs;
   lhs = cxx_eval_constant_expression (ctx, orig_lhs, /*lval*/false,
 				      non_constant_p, overflow_p);
-  /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to
-     a local array in a constexpr function.  */
-  bool ptr = POINTER_TYPE_P (TREE_TYPE (lhs));
-  if (!ptr)
-    VERIFY_CONSTANT (lhs);
+  /* Don't VERIFY_CONSTANT here, it's unnecessary and will break pointer
+     subtraction.  */
+  if (*non_constant_p)
+    return t;
   rhs = cxx_eval_constant_expression (ctx, orig_rhs, /*lval*/false,
 				      non_constant_p, overflow_p);
-  if (!ptr)
-    VERIFY_CONSTANT (rhs);
+  if (*non_constant_p)
+    return t;
 
   location_t loc = EXPR_LOCATION (t);
   enum tree_code code = TREE_CODE (t);
@@ -1676,6 +1680,9 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,
     }
   else if (cxx_eval_check_shift_p (loc, ctx, code, type, lhs, rhs))
     *non_constant_p = true;
+  /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to
+     a local array in a constexpr function.  */
+  bool ptr = POINTER_TYPE_P (TREE_TYPE (lhs));
   if (!ptr)
     VERIFY_CONSTANT (r);
   return r;
@@ -1707,6 +1714,133 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,
 				       jump_target);
 }
 
+/* Returns less than, equal to, or greater than zero if KEY is found to be
+   less than, to match, or to be greater than the constructor_elt's INDEX.  */
+
+static int
+array_index_cmp (tree key, tree index)
+{
+  gcc_assert (TREE_CODE (key) == INTEGER_CST);
+
+  switch (TREE_CODE (index))
+    {
+    case INTEGER_CST:
+      return tree_int_cst_compare (key, index);
+    case RANGE_EXPR:
+      {
+	tree lo = TREE_OPERAND (index, 0);
+	tree hi = TREE_OPERAND (index, 1);
+	if (tree_int_cst_lt (key, lo))
+	  return -1;
+	else if (tree_int_cst_lt (hi, key))
+	  return 1;
+	else
+	  return 0;
+      }
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Returns the index of the constructor_elt of ARY which matches DINDEX, or -1
+   if none.  If INSERT is true, insert a matching element rather than fail.  */
+
+static HOST_WIDE_INT
+find_array_ctor_elt (tree ary, tree dindex, bool insert = false)
+{
+  if (tree_int_cst_sgn (dindex) < 0)
+    return -1;
+
+  unsigned HOST_WIDE_INT i = tree_to_uhwi (dindex);
+  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ary);
+  unsigned HOST_WIDE_INT len = vec_safe_length (elts);
+
+  unsigned HOST_WIDE_INT end = len;
+  unsigned HOST_WIDE_INT begin = 0;
+
+  /* If the last element of the CONSTRUCTOR has its own index, we can assume
+     that the same is true of the other elements and index directly.  */
+  if (end > 0)
+    {
+      tree cindex = (*elts)[end-1].index;
+      if (TREE_CODE (cindex) == INTEGER_CST
+	  && compare_tree_int (cindex, end-1) == 0)
+	{
+	  if (i < end)
+	    return i;
+	  else
+	    begin = end;
+	}
+    }
+
+  /* Otherwise, find a matching index by means of a binary search.  */
+  while (begin != end)
+    {
+      unsigned HOST_WIDE_INT middle = (begin + end) / 2;
+      constructor_elt &elt = (*elts)[middle];
+      tree idx = elt.index;
+
+      int cmp = array_index_cmp (dindex, idx);
+      if (cmp < 0)
+	end = middle;
+      else if (cmp > 0)
+	begin = middle + 1;
+      else
+	{
+	  if (insert && TREE_CODE (idx) == RANGE_EXPR)
+	    {
+	      /* We need to split the range.  */
+	      constructor_elt e;
+	      tree lo = TREE_OPERAND (idx, 0);
+	      tree hi = TREE_OPERAND (idx, 1);
+	      if (tree_int_cst_lt (lo, dindex))
+		{
+		  /* There are still some lower elts; shorten the range.  */
+		  tree new_hi = int_const_binop (MINUS_EXPR, dindex,
+						 size_one_node);
+		  if (tree_int_cst_equal (lo, new_hi))
+		    /* Only one element left, no longer a range.  */
+		    elt.index = lo;
+		  else
+		    TREE_OPERAND (idx, 1) = new_hi;
+		  /* Append the element we want to insert.  */
+		  ++middle;
+		  e.index = dindex;
+		  e.value = unshare_expr (elt.value);
+		  vec_safe_insert (CONSTRUCTOR_ELTS (ary), middle, e);
+		}
+	      else
+		/* No lower elts, the range elt is now ours.  */
+		elt.index = dindex;
+
+	      if (tree_int_cst_lt (dindex, hi))
+		{
+		  /* There are still some higher elts; append a range.  */
+		  tree new_lo = int_const_binop (PLUS_EXPR, dindex,
+						 size_one_node);
+		  if (tree_int_cst_equal (new_lo, hi))
+		    e.index = hi;
+		  else
+		    e.index = build2 (RANGE_EXPR, sizetype, new_lo, hi);
+		  e.value = unshare_expr (elt.value);
+		  vec_safe_insert (CONSTRUCTOR_ELTS (ary), middle+1, e);
+		}
+	    }
+	  return middle;
+	}
+    }
+
+  if (insert)
+    {
+      constructor_elt e = { dindex, NULL_TREE };
+      vec_safe_insert (CONSTRUCTOR_ELTS (ary), end, e);
+      return end;
+    }
+
+  return -1;
+}
+
+
 /* Subroutine of cxx_eval_constant_expression.
    Attempt to reduce a reference to an array slot.  */
 
@@ -1751,37 +1885,27 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,
       gcc_unreachable ();
     }
 
-  i = tree_fits_shwi_p (index) ? tree_to_shwi (index) : -1;
-  bool found = true;
-  if (TREE_CODE (ary) == CONSTRUCTOR && len
-      && (TREE_CODE (CONSTRUCTOR_ELT (ary, len-1)->index) == RANGE_EXPR
-	  || compare_tree_int (CONSTRUCTOR_ELT (ary, len-1)->index, len-1)))
+  if (!tree_fits_shwi_p (index)
+      || (i = tree_to_shwi (index)) < 0)
     {
-      /* The last element doesn't match its position in the array; this must be
-	 a sparse array from cxx_eval_store_expression.  So iterate.  */
-      found = false;
-      vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (ary);
-      constructor_elt *e;
-      for (unsigned ix = 0; vec_safe_iterate (v, ix, &e); ++ix)
-	{
-	  if (TREE_CODE (e->index) == RANGE_EXPR)
-	    {
-	      tree lo = TREE_OPERAND (e->index, 0);
-	      tree hi = TREE_OPERAND (e->index, 1);
-	      if (tree_int_cst_le (lo, index) && tree_int_cst_le (index, hi))
-		found = true;
-	    }
-	  else if (tree_int_cst_equal (e->index, index))
-	    found = true;
-	  if (found)
-	    {
-	      i = ix;
-	      break;
-	    }
-	}
+      if (!ctx->quiet)
+	error ("negative array subscript");
+      *non_constant_p = true;
+      return t;
     }
 
-  if (i >= len || !found)
+  bool found;
+  if (TREE_CODE (ary) == CONSTRUCTOR)
+    {
+      HOST_WIDE_INT ix = find_array_ctor_elt (ary, index);
+      found = (ix >= 0);
+      if (found)
+	i = ix;
+    }
+  else
+    found = (i < len);
+
+  if (!found)
     {
       if (tree_int_cst_lt (index, array_type_nelts_top (TREE_TYPE (ary))))
 	{
@@ -1798,13 +1922,6 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,
       *non_constant_p = true;
       return t;
     }
-  else if (i < 0)
-    {
-      if (!ctx->quiet)
-	error ("negative array subscript");
-      *non_constant_p = true;
-      return t;
-    }
 
   if (TREE_CODE (ary) == CONSTRUCTOR)
     return (*CONSTRUCTOR_ELTS (ary))[i].value;
@@ -1880,11 +1997,16 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,
       return t;
     }
 
+  /* We only create a CONSTRUCTOR for a subobject when we modify it, so empty
+     classes never get represented; throw together a value now.  */
+  if (is_really_empty_class (TREE_TYPE (t)))
+    return build_constructor (TREE_TYPE (t), NULL);
+
   if (CONSTRUCTOR_NO_IMPLICIT_ZERO (whole))
     {
       /* 'whole' is part of the aggregate initializer we're currently
 	 building; if there's no initializer for this member yet, that's an
-	 error. */
+	 error.  */
       if (!ctx->quiet)
 	error ("accessing uninitialized member %qD", part);
       *non_constant_p = true;
@@ -2110,7 +2232,8 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)
   gcc_assert (ctx->ctor);
   gcc_assert (same_type_ignoring_top_level_qualifiers_p
 	      (type, TREE_TYPE (ctx->ctor)));
-  gcc_assert (CONSTRUCTOR_NELTS (ctx->ctor) == 0);
+  /* We used to check that ctx->ctor was empty, but that isn't the case when
+     the object is zero-initialized before calling the constructor.  */
   if (ctx->object)
     gcc_assert (same_type_ignoring_top_level_qualifiers_p
 		(type, TREE_TYPE (ctx->object)));
@@ -2138,6 +2261,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
   unsigned i; tree index, value;
   FOR_EACH_CONSTRUCTOR_ELT (v, i, index, value)
     {
+      tree orig_value = value;
       constexpr_ctx new_ctx;
       init_subob_ctx (ctx, new_ctx, index, value);
       if (new_ctx.ctor != ctx->ctor)
@@ -2150,7 +2274,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
       /* Don't VERIFY_CONSTANT here.  */
       if (ctx->quiet && *non_constant_p)
 	break;
-      if (elt != value)
+      if (elt != orig_value)
 	changed = true;
       if (index && TREE_CODE (index) == COMPONENT_REF)
 	{
@@ -2727,21 +2851,33 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
 	  CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp) = true;
 	}
 
-      constructor_elt ce;
+      enum tree_code code = TREE_CODE (type);
       type = refs->pop();
-      ce.index = refs->pop();
-      ce.value = NULL_TREE;
+      tree index = refs->pop();
 
-      unsigned HOST_WIDE_INT idx = 0;
       constructor_elt *cep = NULL;
-      for (idx = 0;
-	   vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);
-	   idx++)
-	/* ??? slow */
-	if (cp_tree_equal (ce.index, cep->index))
-	  break;
-      if (!cep)
-	cep = vec_safe_push (CONSTRUCTOR_ELTS (*valp), ce);
+      if (code == ARRAY_TYPE)
+	{
+	  HOST_WIDE_INT i
+	    = find_array_ctor_elt (*valp, index, /*insert*/true);
+	  gcc_assert (i >= 0);
+	  cep = CONSTRUCTOR_ELT (*valp, i);
+	  gcc_assert (TREE_CODE (cep->index) != RANGE_EXPR);
+	}
+      else
+	{
+	  gcc_assert (TREE_CODE (index) == FIELD_DECL);
+	  for (unsigned HOST_WIDE_INT idx = 0;
+	       vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);
+	       idx++)
+	    if (index == cep->index)
+	      break;
+	  if (!cep)
+	    {
+	      constructor_elt ce = { index, NULL_TREE };
+	      cep = vec_safe_push (CONSTRUCTOR_ELTS (*valp), ce);
+	    }
+	}
       valp = &cep->value;
     }
   release_tree_vector (refs);
@@ -2762,16 +2898,17 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
 
   init = cxx_eval_constant_expression (&new_ctx, init, false,
 				       non_constant_p, overflow_p);
+  /* Don't share a CONSTRUCTOR that might be changed later.  */
+  init = unshare_expr (init);
   if (target == object)
+    /* The hash table might have moved since the get earlier.  */
+    valp = ctx->values->get (object);
+
+  if (TREE_CODE (init) == CONSTRUCTOR)
     {
-      /* The hash table might have moved since the get earlier.  */
-      valp = ctx->values->get (object);
-      if (TREE_CODE (init) == CONSTRUCTOR)
-	/* An outer ctx->ctor might be pointing to *valp, so just replace
-	   its contents.  */
-	CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);
-      else
-	*valp = init;
+      /* An outer ctx->ctor might be pointing to *valp, so just replace
+	 its contents.  */
+      CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);
     }
   else
     *valp = init;
@@ -3114,7 +3251,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	r = TARGET_EXPR_INITIAL (r);
       if (TREE_CODE (r) == VAR_DECL)
 	if (tree *p = ctx->values->get (r))
-	  r = *p;
+	  if (*p != NULL_TREE)
+	    r = *p;
       if (DECL_P (r))
 	{
 	  if (!ctx->quiet)
@@ -3181,6 +3319,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	    init = cxx_eval_constant_expression (ctx, init,
 						 false,
 						 non_constant_p, overflow_p);
+	    /* Don't share a CONSTRUCTOR that might be changed.  */
+	    init = unshare_expr (init);
 	    ctx->values->put (r, init);
 	  }
 	else if (ctx == &new_ctx)
@@ -3225,6 +3365,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
       if (lval)
 	{
 	  tree slot = TARGET_EXPR_SLOT (t);
+	  r = unshare_expr (r);
 	  ctx->values->put (slot, r);
 	  return slot;
 	}
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 6f13b01..cb92704 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -5237,6 +5237,7 @@ extern tree make_temporary_var_for_ref_to_temp	(tree, tree);
 extern bool type_has_extended_temps		(tree);
 extern tree strip_top_quals			(tree);
 extern bool reference_related_p			(tree, tree);
+extern int remaining_arguments			(tree);
 extern tree perform_implicit_conversion		(tree, tree, tsubst_flags_t);
 extern tree perform_implicit_conversion_flags	(tree, tree, tsubst_flags_t, int);
 extern tree build_integral_nontype_arg_conv	(tree, tree, tsubst_flags_t);
@@ -5792,7 +5793,7 @@ extern tree get_template_parms_at_level (tree, int);
 extern tree get_template_innermost_arguments	(const_tree);
 extern tree get_template_argument_pack_elems	(const_tree);
 extern tree get_function_template_decl		(const_tree);
-extern tree resolve_nondeduced_context		(tree);
+extern tree resolve_nondeduced_context		(tree, tsubst_flags_t);
 extern hashval_t iterative_hash_template_arg (tree arg, hashval_t val);
 
 /* in repo.c */
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index 10d50ae..f4fa662 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -1260,7 +1260,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)
 
     default:;
     }
-  expr = resolve_nondeduced_context (expr);
+  expr = resolve_nondeduced_context (expr, complain);
   {
     tree probe = expr;
 
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index c9e98e9..3c0c973 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -6436,7 +6436,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
       if (TREE_CODE (d_init) == TREE_LIST)
 	d_init = build_x_compound_expr_from_list (d_init, ELK_INIT,
 						  tf_warning_or_error);
-      d_init = resolve_nondeduced_context (d_init);
+      d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);
       type = TREE_TYPE (decl) = do_auto_deduction (type, d_init,
 						   auto_node);
       if (type == error_mark_node)
@@ -7360,7 +7360,8 @@ cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)
 
   /* Don't get confused by a CONSTRUCTOR for some other type.  */
   if (initial_value && TREE_CODE (initial_value) == CONSTRUCTOR
-      && !BRACE_ENCLOSED_INITIALIZER_P (initial_value))
+      && !BRACE_ENCLOSED_INITIALIZER_P (initial_value)
+      && TREE_CODE (TREE_TYPE (initial_value)) != ARRAY_TYPE)
     return 1;
 
   if (initial_value)
@@ -14594,7 +14595,8 @@ cxx_maybe_build_cleanup (tree decl, tsubst_flags_t complain)
 	 ordinary FUNCTION_DECL.  */
       fn = lookup_name (id);
       arg = build_address (decl);
-      mark_used (decl);
+      if (!mark_used (decl, complain) && !(complain & tf_error))
+	return error_mark_node;
       cleanup = cp_build_function_call_nary (fn, complain, arg, NULL_TREE);
       if (cleanup == error_mark_node)
 	return error_mark_node;
@@ -14634,10 +14636,11 @@ cxx_maybe_build_cleanup (tree decl, tsubst_flags_t complain)
     SET_EXPR_LOCATION (cleanup, UNKNOWN_LOCATION);
 
   if (cleanup
-      && !lookup_attribute ("warn_unused", TYPE_ATTRIBUTES (TREE_TYPE (decl))))
-    /* Treat objects with destructors as used; the destructor may do
-       something substantive.  */
-    mark_used (decl);
+      && !lookup_attribute ("warn_unused", TYPE_ATTRIBUTES (TREE_TYPE (decl)))
+      /* Treat objects with destructors as used; the destructor may do
+	 something substantive.  */
+      && !mark_used (decl, complain) && !(complain & tf_error))
+    return error_mark_node;
 
   return cleanup;
 }
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 8d895fe..142d493 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -2659,10 +2659,16 @@ reset_type_linkage_2 (tree type)
 	  reset_decl_linkage (ti);
 	}
       for (tree m = TYPE_FIELDS (type); m; m = DECL_CHAIN (m))
-	if (TREE_CODE (m) == VAR_DECL)
-	  reset_decl_linkage (m);
+	{
+	  tree mem = STRIP_TEMPLATE (m);
+	  if (VAR_P (mem))
+	    reset_decl_linkage (mem);
+	}
       for (tree m = TYPE_METHODS (type); m; m = DECL_CHAIN (m))
-	reset_decl_linkage (m);
+	{
+	  tree mem = STRIP_TEMPLATE (m);
+	  reset_decl_linkage (mem);
+	}
       binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),
 			     bt_reset_linkage_2, NULL);
     }
@@ -4197,6 +4203,9 @@ decl_maybe_constant_var_p (tree decl)
     return false;
   if (DECL_DECLARED_CONSTEXPR_P (decl))
     return true;
+  if (DECL_HAS_VALUE_EXPR_P (decl))
+    /* A proxy isn't constant.  */
+    return false;
   return (CP_TYPE_CONST_NON_VOLATILE_P (type)
 	  && INTEGRAL_OR_ENUMERATION_TYPE_P (type));
 }
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
index 3ff1ce6..2f2e396 100644
--- a/gcc/cp/except.c
+++ b/gcc/cp/except.c
@@ -1040,7 +1040,8 @@ nothrow_libfn_p (const_tree fn)
      unless the system headers are playing rename tricks, and if
      they are, we don't want to be confused by them.  */
   id = DECL_NAME (fn);
-  return !!libc_name_p (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));
+  return !!libc_name::libc_name_p (IDENTIFIER_POINTER (id),
+				   IDENTIFIER_LENGTH (id));
 }
 
 /* Returns nonzero if an exception of type FROM will be caught by a
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index ac11224..3d79ba8 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -2079,6 +2079,11 @@ constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p)
 	      && (TREE_CODE (init) == CONSTRUCTOR
 		  || TREE_CODE (init) == STRING_CST)))
 	break;
+      /* Don't return a CONSTRUCTOR for a variable with partial run-time
+	 initialization, since it doesn't represent the entire value.  */
+      if (TREE_CODE (init) == CONSTRUCTOR
+	  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))
+	break;
       decl = unshare_expr (init);
     }
   return decl;
@@ -3026,7 +3031,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,
       if (auto_node)
 	{
 	  tree d_init = (**init)[0];
-	  d_init = resolve_nondeduced_context (d_init);
+	  d_init = resolve_nondeduced_context (d_init, complain);
 	  type = do_auto_deduction (type, d_init, auto_node);
 	}
     }
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index c89643d..4e0ed22 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -1160,7 +1160,7 @@ write_template_prefix (const tree node)
      So, for the example above, `Outer<int>::Inner' is represented as a
      substitution candidate by a TREE_LIST whose purpose is `Outer<int>'
      and whose value is `Outer<T>::Inner<U>'.  */
-  if (TYPE_P (context))
+  if (context && TYPE_P (context))
     substitution = build_tree_list (context, templ);
   else
     substitution = templ;
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index 33e2f3c..11fc20c 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -1118,7 +1118,7 @@ is_trivially_xible (enum tree_code code, tree to, tree from)
 static void
 process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,
 		  bool *deleted_p, bool *constexpr_p,
-		  bool diag, tree arg)
+		  bool diag, tree arg, bool dtor_from_ctor = false)
 {
   if (!fn || fn == error_mark_node)
     goto bad;
@@ -1130,7 +1130,7 @@ process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,
       *spec_p = merge_exception_specifiers (*spec_p, raises);
     }
 
-  if (!trivial_fn_p (fn))
+  if (!trivial_fn_p (fn) && !dtor_from_ctor)
     {
       if (trivial_p)
 	*trivial_p = false;
@@ -1163,14 +1163,17 @@ process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,
 }
 
 /* Subroutine of synthesized_method_walk to allow recursion into anonymous
-   aggregates.  */
+   aggregates.  If DTOR_FROM_CTOR is true, we're walking subobject destructors
+   called from a synthesized constructor, in which case we don't consider
+   the triviality of the subobject destructor.  */
 
 static void
 walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,
 		   int quals, bool copy_arg_p, bool move_p,
 		   bool assign_p, tree *spec_p, bool *trivial_p,
 		   bool *deleted_p, bool *constexpr_p,
-		   bool diag, int flags, tsubst_flags_t complain)
+		   bool diag, int flags, tsubst_flags_t complain,
+		   bool dtor_from_ctor)
 {
   tree field;
   for (field = fields; field; field = DECL_CHAIN (field))
@@ -1287,7 +1290,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,
 	  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,
 			     copy_arg_p, move_p, assign_p, spec_p, trivial_p,
 			     deleted_p, constexpr_p,
-			     diag, flags, complain);
+			     diag, flags, complain, dtor_from_ctor);
 	  continue;
 	}
 
@@ -1304,7 +1307,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,
       rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);
 
       process_subob_fn (rval, spec_p, trivial_p, deleted_p,
-			constexpr_p, diag, field);
+			constexpr_p, diag, field, dtor_from_ctor);
     }
 }
 
@@ -1487,7 +1490,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
 	     dtors would be a double-fault).  */
 	  process_subob_fn (rval, NULL, NULL,
 			    deleted_p, NULL, false,
-			    basetype);
+			    basetype, /*dtor_from_ctor*/true);
 	}
 
       if (check_vdtor && type_has_virtual_destructor (basetype))
@@ -1534,7 +1537,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
 				      NULL_TREE, flags, complain);
 	      process_subob_fn (rval, NULL, NULL,
 				deleted_p, NULL, false,
-				basetype);
+				basetype, /*dtor_from_ctor*/true);
 	    }
 	}
     }
@@ -1543,13 +1546,13 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
   walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,
 		     copy_arg_p, move_p, assign_p, spec_p, trivial_p,
 		     deleted_p, constexpr_p,
-		     diag, flags, complain);
+		     diag, flags, complain, /*dtor_from_ctor*/false);
   if (ctor_p)
     walk_field_subobs (TYPE_FIELDS (ctype), complete_dtor_identifier,
 		       sfk_destructor, TYPE_UNQUALIFIED, false,
 		       false, false, NULL, NULL,
 		       deleted_p, NULL,
-		       false, flags, complain);
+		       false, flags, complain, /*dtor_from_ctor*/true);
 
   pop_scope (scope);
 
diff --git a/gcc/cp/optimize.c b/gcc/cp/optimize.c
index a2dd880..e485a6d 100644
--- a/gcc/cp/optimize.c
+++ b/gcc/cp/optimize.c
@@ -670,6 +670,8 @@ maybe_clone_body (tree fn)
 	{
 	  if (expand_or_defer_fn_1 (clone))
 	    emit_associated_thunks (clone);
+	  /* We didn't generate a body, so remove the empty one.  */
+	  DECL_SAVED_TREE (clone) = NULL_TREE;
 	}
       else
 	expand_or_defer_fn (clone);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index e6def9a..fc5090e 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -15682,7 +15682,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,
     {
       /* Indicate whether this class was declared as a `class' or as a
 	 `struct'.  */
-      if (TREE_CODE (type) == RECORD_TYPE)
+      if (CLASS_TYPE_P (type))
 	CLASSTYPE_DECLARED_CLASS (type) = (tag_type == class_type);
       cp_parser_check_class_key (tag_type, type);
     }
@@ -32359,6 +32359,7 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,
       DECL_DECLARED_INLINE_P (fndecl) = 1;
       DECL_IGNORED_P (fndecl) = 1;
       DECL_OMP_DECLARE_REDUCTION_P (fndecl) = 1;
+      SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier ("<udr>"));
       DECL_ATTRIBUTES (fndecl)
 	= tree_cons (get_identifier ("gnu_inline"), NULL_TREE,
 		     DECL_ATTRIBUTES (fndecl));
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 51cc245..969328c 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -9623,11 +9623,11 @@ instantiate_class_template_1 (tree type)
 		       template <class U> friend class T::C;
 
 		     otherwise.  */
+		  /* Bump processing_template_decl in case this is something like
+		     template <class T> friend struct A<T>::B.  */
+		  ++processing_template_decl;
 		  friend_type = tsubst (friend_type, args,
 					tf_warning_or_error, NULL_TREE);
-		  /* Bump processing_template_decl for correct
-		     dependent_type_p calculation.  */
-		  ++processing_template_decl;
 		  if (dependent_type_p (friend_type))
 		    adjust_processing_template_decl = true;
 		  --processing_template_decl;
@@ -9998,7 +9998,8 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
 	  if (index == 0)
 	    {
 	      aps = make_argument_pack_select (arg_pack, index);
-	      mark_used (parm);
+	      if (!mark_used (parm, complain) && !(complain & tf_error))
+		return error_mark_node;
 	      register_local_specialization (aps, parm);
 	    }
 	  else
@@ -10095,12 +10096,16 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	  if (PACK_EXPANSION_LOCAL_P (t))
 	    arg_pack = retrieve_local_specialization (parm_pack);
 	  else
+	    /* We can't rely on local_specializations for a parameter
+	       name used later in a function declaration (such as in a
+	       late-specified return type).  Even if it exists, it might
+	       have the wrong value for a recursive call.  */
+	    need_local_specializations = true;
+
+	  if (!arg_pack)
 	    {
-	      /* We can't rely on local_specializations for a parameter
-		 name used later in a function declaration (such as in a
-		 late-specified return type).  Even if it exists, it might
-		 have the wrong value for a recursive call.  Just make a
-		 dummy decl, since it's only used for its type.  */
+	      /* This parameter pack was used in an unevaluated context.  Just
+		 make a dummy decl, since it's only used for its type.  */
 	      arg_pack = tsubst_decl (parm_pack, args, complain);
 	      if (arg_pack && DECL_PACK_P (arg_pack))
 		/* Partial instantiation of the parm_pack, we can't build
@@ -10108,7 +10113,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 		arg_pack = NULL_TREE;
 	      else
 		arg_pack = make_fnparm_pack (arg_pack);
-	      need_local_specializations = true;
 	    }
 	}
       else if (TREE_CODE (parm_pack) == FIELD_DECL)
@@ -12783,8 +12787,9 @@ tsubst_baselink (tree baselink, tree object_type,
        point.)  */
     if (BASELINK_P (baselink))
       fns = BASELINK_FUNCTIONS (baselink);
-    if (!template_id_p && !really_overloaded_fn (fns))
-      mark_used (OVL_CURRENT (fns));
+    if (!template_id_p && !really_overloaded_fn (fns)
+	&& !mark_used (OVL_CURRENT (fns), complain) && !(complain & tf_error))
+      return error_mark_node;
 
     /* Add back the template arguments, if present.  */
     if (BASELINK_P (baselink) && template_id_p)
@@ -12899,7 +12904,8 @@ tsubst_qualified_id (tree qualified_id, tree args,
       check_accessibility_of_qualified_id (expr, /*object_type=*/NULL_TREE,
 					   scope);
       /* Remember that there was a reference to this entity.  */
-      mark_used (expr);
+      if (!mark_used (expr, complain) && !(complain & tf_error))
+	return error_mark_node;
     }
 
   if (expr == error_mark_node || TREE_CODE (expr) == TREE_LIST)
@@ -13009,7 +13015,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
       
       if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)
 	r = ARGUMENT_PACK_SELECT_ARG (r);
-      mark_used (r);
+      if (!mark_used (r, complain) && !(complain & tf_error))
+	return error_mark_node;
       return r;
 
     case CONST_DECL:
@@ -13245,7 +13252,12 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	  --c_inhibit_evaluation_warnings;
 
 	  if (TREE_CODE (expanded) == TREE_VEC)
-	    len = TREE_VEC_LENGTH (expanded);
+	    {
+	      len = TREE_VEC_LENGTH (expanded);
+	      /* Set TREE_USED for the benefit of -Wunused.  */
+	      for (int i = 0; i < len; i++)
+		TREE_USED (TREE_VEC_ELT (expanded, i)) = true;
+	    }
 
 	  if (expanded == error_mark_node)
 	    return error_mark_node;
@@ -13531,7 +13543,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	tree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);
 	r = build2 (code, type, op0, op1);
 	PTRMEM_OK_P (r) = PTRMEM_OK_P (t);
-	mark_used (TREE_OPERAND (r, 1));
+	if (!mark_used (TREE_OPERAND (r, 1), complain)
+	    && !(complain & tf_error))
+	  return error_mark_node;
 	return r;
       }
 
@@ -15092,8 +15106,9 @@ tsubst_copy_and_build (tree t,
       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),
 						args, complain, in_decl);
       /* Remember that there was a reference to this entity.  */
-      if (DECL_P (op1))
-	mark_used (op1);
+      if (DECL_P (op1)
+	  && !mark_used (op1, complain) && !(complain & tf_error))
+	RETURN (error_mark_node);
       RETURN (build_x_arrow (input_location, op1, complain));
 
     case NEW_EXPR:
@@ -15344,8 +15359,9 @@ tsubst_copy_and_build (tree t,
 	  }
 
 	/* Remember that there was a reference to this entity.  */
-	if (DECL_P (function))
-	  mark_used (function, complain);
+	if (DECL_P (function)
+	    && !mark_used (function, complain) && !(complain & tf_error))
+	  RETURN (error_mark_node);
 
 	/* Put back tf_decltype for the actual call.  */
 	complain |= decltype_flag;
@@ -15528,8 +15544,9 @@ tsubst_copy_and_build (tree t,
 	object = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),
 						     args, complain, in_decl);
 	/* Remember that there was a reference to this entity.  */
-	if (DECL_P (object))
-	  mark_used (object);
+	if (DECL_P (object)
+	    && !mark_used (object, complain) && !(complain & tf_error))
+	  RETURN (error_mark_node);
 	object_type = TREE_TYPE (object);
 
 	member = TREE_OPERAND (t, 1);
@@ -17344,7 +17361,7 @@ resolve_overloaded_unification (tree tparms,
    lvalue for the function template specialization.  */
 
 tree
-resolve_nondeduced_context (tree orig_expr)
+resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)
 {
   tree expr, offset, baselink;
   bool addr;
@@ -17427,16 +17444,16 @@ resolve_nondeduced_context (tree orig_expr)
 	    {
 	      tree base
 		= TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (offset, 0)));
-	      expr = build_offset_ref (base, expr, addr, tf_warning_or_error);
+	      expr = build_offset_ref (base, expr, addr, complain);
 	    }
 	  if (addr)
-	    expr = cp_build_addr_expr (expr, tf_warning_or_error);
+	    expr = cp_build_addr_expr (expr, complain);
 	  return expr;
 	}
-      else if (good == 0 && badargs)
+      else if (good == 0 && badargs && (complain & tf_error))
 	/* There were no good options and at least one bad one, so let the
 	   user know what the problem is.  */
-	instantiate_template (badfn, badargs, tf_warning_or_error);
+	instantiate_template (badfn, badargs, complain);
     }
   return orig_expr;
 }
@@ -19004,7 +19021,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)
 
       if (TREE_CODE (arg1) == TYPE_PACK_EXPANSION)
         {
-          int i, len2 = list_length (args2);
+          int i, len2 = remaining_arguments (args2);
           tree parmvec = make_tree_vec (1);
           tree argvec = make_tree_vec (len2);
           tree ta = args2;
@@ -19028,7 +19045,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)
         }
       else if (TREE_CODE (arg2) == TYPE_PACK_EXPANSION)
         {
-          int i, len1 = list_length (args1);
+          int i, len1 = remaining_arguments (args1);
           tree parmvec = make_tree_vec (1);
           tree argvec = make_tree_vec (len1);
           tree ta = args1;
@@ -19469,6 +19486,38 @@ most_general_template (tree decl)
   return decl;
 }
 
+/* True iff the TEMPLATE_DECL tmpl is a partial specialization.  */
+
+static bool
+partial_specialization_p (tree tmpl)
+{
+  /* Any specialization has DECL_TEMPLATE_SPECIALIZATION.  */
+  if (!DECL_TEMPLATE_SPECIALIZATION (tmpl))
+    return false;
+  if (!VAR_P (DECL_TEMPLATE_RESULT (tmpl)))
+    return false;
+  tree t = DECL_TI_TEMPLATE (tmpl);
+  /* A specialization that fully specializes one of the containing classes is
+     not a partial specialization.  */
+  return (list_length (DECL_TEMPLATE_PARMS (tmpl))
+	  == list_length (DECL_TEMPLATE_PARMS (t)));
+}
+
+/* If TMPL is a partial specialization, return the arguments for its primary
+   template.  */
+
+static tree
+impartial_args (tree tmpl, tree args)
+{
+  if (!partial_specialization_p (tmpl))
+    return args;
+
+  /* If TMPL is a partial specialization, we need to substitute to get
+     the args for the primary template.  */
+  return tsubst_template_args (DECL_TI_ARGS (tmpl), args,
+			       tf_warning_or_error, tmpl);
+}
+
 /* Return the most specialized of the template partial specializations
    which can produce TARGET, a specialization of some class or variable
    template.  The value returned is actually a TREE_LIST; the TREE_VALUE is
@@ -20283,7 +20332,7 @@ instantiate_decl (tree d, int defer_ok,
     return d;
 
   gen_tmpl = most_general_template (tmpl);
-  gen_args = DECL_TI_ARGS (d);
+  gen_args = impartial_args (tmpl, DECL_TI_ARGS (d));
 
   if (tmpl != gen_tmpl)
     /* We should already have the extra args.  */
@@ -22341,7 +22390,7 @@ do_auto_deduction (tree type, tree init, tree auto_node)
 	}
     }
 
-  init = resolve_nondeduced_context (init);
+  init = resolve_nondeduced_context (init, tf_warning_or_error);
 
   targs = make_tree_vec (1);
   if (AUTO_IS_DECLTYPE (auto_node))
diff --git a/gcc/cp/rtti.c b/gcc/cp/rtti.c
index 3e941b9..3628778 100644
--- a/gcc/cp/rtti.c
+++ b/gcc/cp/rtti.c
@@ -255,7 +255,7 @@ get_tinfo_decl_dynamic (tree exp, tsubst_flags_t complain)
   if (error_operand_p (exp))
     return error_mark_node;
 
-  exp = resolve_nondeduced_context (exp);
+  exp = resolve_nondeduced_context (exp, complain);
 
   /* peel back references, so they match.  */
   type = non_reference (TREE_TYPE (exp));
@@ -345,7 +345,7 @@ build_typeid (tree exp, tsubst_flags_t complain)
       /* So we need to look into the vtable of the type of exp.
          Make sure it isn't a null lvalue.  */
       exp = cp_build_addr_expr (exp, complain);
-      exp = stabilize_reference (exp);
+      exp = save_expr (exp);
       cond = cp_convert (boolean_type_node, exp, complain);
       exp = cp_build_indirect_ref (exp, RO_NULL, complain);
     }
@@ -708,10 +708,12 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)
 	  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));
 	  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));
 	  td2 = get_tinfo_decl (target_type);
-	  mark_used (td2);
+	  if (!mark_used (td2, complain) && !(complain & tf_error))
+	    return error_mark_node;
 	  td2 = cp_build_addr_expr (td2, complain);
 	  td3 = get_tinfo_decl (static_type);
-	  mark_used (td3);
+	  if (!mark_used (td3, complain) && !(complain & tf_error))
+	    return error_mark_node;
 	  td3 = cp_build_addr_expr (td3, complain);
 
 	  /* Determine how T and V are related.  */
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index feba03d..74e40a9 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -3119,7 +3119,8 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)
   tree initializer = convert_from_reference (decl);
 
   /* Mark it as used now even if the use is ill-formed.  */
-  mark_used (decl);
+  if (!mark_used (decl, complain) && !(complain & tf_error))
+    return error_mark_node;
 
   /* Core issue 696: "[At the July 2009 meeting] the CWG expressed
      support for an approach in which a reference to a local
@@ -4104,9 +4105,8 @@ expand_or_defer_fn_1 (tree fn)
       /* We don't want to process FN again, so pretend we've written
 	 it out, even though we haven't.  */
       TREE_ASM_WRITTEN (fn) = 1;
-      /* If this is an instantiation of a constexpr function, keep
-	 DECL_SAVED_TREE for explain_invalid_constexpr_fn.  */
-      if (!is_instantiation_of_constexpr (fn))
+      /* If this is a constexpr function, keep DECL_SAVED_TREE.  */
+      if (!DECL_DECLARED_CONSTEXPR_P (fn))
 	DECL_SAVED_TREE (fn) = NULL_TREE;
       return false;
     }
@@ -7248,7 +7248,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
 
   /* The type denoted by decltype(e) is defined as follows:  */
 
-  expr = resolve_nondeduced_context (expr);
+  expr = resolve_nondeduced_context (expr, complain);
 
   if (invalid_nonstatic_memfn_p (expr, complain))
     return error_mark_node;
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index f0a9589..5f1735a 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -1007,7 +1007,8 @@ move (tree expr)
    the C version of this function does not properly maintain canonical
    types (which are not used in C).  */
 tree
-c_build_qualified_type (tree type, int type_quals)
+c_build_qualified_type (tree type, int type_quals, tree /* orig_qual_type */,
+			size_t /* orig_qual_indirect */)
 {
   return cp_build_qualified_type (type, type_quals);
 }
@@ -1345,6 +1346,9 @@ strip_typedefs (tree t)
 	  }
 	result = make_typename_type (strip_typedefs (TYPE_CONTEXT (t)),
 				     fullname, typename_type, tf_none);
+	/* Handle 'typedef typename A::N N;'  */
+	if (typedef_variant_p (result))
+	  result = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (TYPE_NAME (result)));
       }
       break;
     case DECLTYPE_TYPE:
@@ -1362,7 +1366,15 @@ strip_typedefs (tree t)
     }
 
   if (!result)
-      result = TYPE_MAIN_VARIANT (t);
+    {
+      if (typedef_variant_p (t))
+	/* Explicitly get the underlying type, as TYPE_MAIN_VARIANT doesn't
+	   strip typedefs with attributes.  */
+	result = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (TYPE_NAME (t)));
+      else
+	result = TYPE_MAIN_VARIANT (t);
+    }
+  gcc_assert (!typedef_variant_p (result));
   if (TYPE_USER_ALIGN (t) != TYPE_USER_ALIGN (result)
       || TYPE_ALIGN (t) != TYPE_ALIGN (result))
     {
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 2279255..e79c71e 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -1926,7 +1926,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)
 
   exp = mark_rvalue_use (exp);
 
-  exp = resolve_nondeduced_context (exp);
+  exp = resolve_nondeduced_context (exp, complain);
   if (type_unknown_p (exp))
     {
       if (complain & tf_error)
@@ -2298,7 +2298,8 @@ build_class_member_access_expr (tree object, tree member,
   if (DECL_P (member))
     {
       member_scope = DECL_CLASS_CONTEXT (member);
-      mark_used (member);
+      if (!mark_used (member, complain) && !(complain & tf_error))
+	return error_mark_node;
       if (TREE_DEPRECATED (member))
 	warn_deprecated_use (member, NULL_TREE);
     }
@@ -3468,7 +3469,8 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,
 
   if (TREE_CODE (function) == FUNCTION_DECL)
     {
-      mark_used (function);
+      if (!mark_used (function, complain) && !(complain & tf_error))
+	return error_mark_node;
       fndecl = function;
 
       /* Convert anything with function type to a pointer-to-function.  */
@@ -4672,6 +4674,20 @@ cp_build_binary_op (location_t location,
 	      return error_mark_node;
 	    }
 
+	  /* It's not precisely specified how the usual arithmetic
+	     conversions apply to the vector types.  Here, we use
+	     the unsigned type if one of the operands is signed and
+	     the other one is unsigned.  */
+	  if (TYPE_UNSIGNED (type0) != TYPE_UNSIGNED (type1))
+	    {
+	      if (!TYPE_UNSIGNED (type0))
+		op0 = build1 (VIEW_CONVERT_EXPR, type1, op0);
+	      else
+		op1 = build1 (VIEW_CONVERT_EXPR, type0, op1);
+	      warning_at (location, OPT_Wsign_compare, "comparison between "
+			  "types %qT and %qT", type0, type1);
+	    }
+
 	  /* Always construct signed integer vector type.  */
 	  intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
@@ -5367,7 +5383,8 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)
 	 and the created OFFSET_REF.  */
       tree base = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg, 0)));
       tree fn = get_first_fn (TREE_OPERAND (arg, 1));
-      mark_used (fn);
+      if (!mark_used (fn, complain) && !(complain & tf_error))
+	return error_mark_node;
 
       if (! flag_ms_extensions)
 	{
@@ -5554,7 +5571,8 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)
 	 function.  */
       gcc_assert (TREE_CODE (fn) == FUNCTION_DECL
 		  && DECL_STATIC_FUNCTION_P (fn));
-      mark_used (fn);
+      if (!mark_used (fn, complain) && !(complain & tf_error))
+	return error_mark_node;
       val = build_address (fn);
       if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))
 	/* Do not lose object's side effects.  */
@@ -6519,7 +6537,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,
 	  result = cp_fold_convert (type, result);
 	  /* Make sure we don't fold back down to a named rvalue reference,
 	     because that would be an lvalue.  */
-	  if (DECL_P (result))
+	  if (real_lvalue_p (result))
 	    result = build1 (NON_LVALUE_EXPR, type, result);
 	  return convert_from_reference (result);
 	}
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index d3be589..7c1ddaf 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -355,7 +355,7 @@ Objective-C and Objective-C++ Dialects}.
 -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
 -fopt-info @gol
 -fopt-info-@var{options}@r{[}=@var{file}@r{]} @gol
--frandom-seed=@var{number} -fsched-verbose=@var{n} @gol
+-frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
 -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol
 -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
 -fvar-tracking-assignments  -fvar-tracking-assignments-toggle @gol
@@ -7133,7 +7133,7 @@ the first option takes effect and the subsequent options are
 ignored. Thus only @file{vec.miss} is produced which contains
 dumps from the vectorizer about missed opportunities.
 
-@item -frandom-seed=@var{number}
+@item -frandom-seed=@var{string}
 @opindex frandom-seed
 This option provides a seed that GCC uses in place of
 random numbers in generating certain symbol names
@@ -7142,7 +7142,11 @@ place unique stamps in coverage data files and the object files that
 produce them.  You can use the @option{-frandom-seed} option to produce
 reproducibly identical object files.
 
-The @var{number} should be different for every file you compile.
+The @var{string} can either be a number (decimal, octal or hex) or an
+arbitrary string (in which case it's converted to a number by
+computing CRC32).
+
+The @var{string} should be different for every file you compile.
 
 @item -fsched-verbose=@var{n}
 @opindex fsched-verbose
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index cc184bd..306aa6c 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -3996,7 +3996,7 @@ Integer constant in the range 0 @dots{} 127, for 128-bit shifts.
 Standard 80387 floating point constant.
 
 @item C
-Standard SSE floating point constant.
+SSE constant zero operand.
 
 @item e
 32-bit signed integer constant, or a symbolic reference known
diff --git a/gcc/dse.c b/gcc/dse.c
index 2bb20d7..1e74f6b 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1571,14 +1571,9 @@ record_store (rtx body, bb_info_t bb_info)
 	mem_addr = base->val_rtx;
       else
 	{
-	  group_info_t group
-	    = rtx_group_vec[group_id];
+	  group_info_t group = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
-      /* get_addr can only handle VALUE but cannot handle expr like:
-	 VALUE + OFFSET, so call get_addr to get original addr for
-	 mem_addr before plus_constant.  */
-      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
@@ -2188,14 +2183,9 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
 	mem_addr = base->val_rtx;
       else
 	{
-	  group_info_t group
-	    = rtx_group_vec[group_id];
+	  group_info_t group = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
-      /* get_addr can only handle VALUE but cannot handle expr like:
-	 VALUE + OFFSET, so call get_addr to get original addr for
-	 mem_addr before plus_constant.  */
-      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 3614c10..9077a64 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -20290,9 +20290,10 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,
   /* We are going to output a DIE to represent the unqualified version
      of this type (i.e. without any const or volatile qualifiers) so
      get the main variant (i.e. the unqualified version) of this type
-     now.  (Vectors are special because the debugging info is in the
+     now.  (Vectors and arrays are special because the debugging info is in the
      cloned type itself).  */
-  if (TREE_CODE (type) != VECTOR_TYPE)
+  if (TREE_CODE (type) != VECTOR_TYPE
+      && TREE_CODE (type) != ARRAY_TYPE)
     type = type_main_variant (type);
 
   /* If this is an array type with hidden descriptor, handle it first.  */
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 00ba64e..5b749ac 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -5256,7 +5256,8 @@ set_unique_reg_note (rtx insn, enum reg_note kind, rtx datum)
     {
     case REG_EQUAL:
     case REG_EQUIV:
-      if (!set_for_reg_notes (insn))
+      /* We need to support the REG_EQUAL on USE trick of find_reloads.  */
+      if (!set_for_reg_notes (insn) && GET_CODE (PATTERN (insn)) != USE)
 	return NULL_RTX;
 
       /* Don't add ASM_OPERAND REG_EQUAL/REG_EQUIV notes.
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 029bcb6..844b8f7 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -8731,20 +8731,6 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)
   return total.to_uhwi () > (unsigned HOST_WIDE_INT) size;
 }
 
-/* Return the HOST_WIDE_INT least significant bits of T, a sizetype
-   kind INTEGER_CST.  This makes sure to properly sign-extend the
-   constant.  */
-
-static HOST_WIDE_INT
-size_low_cst (const_tree t)
-{
-  HOST_WIDE_INT w = TREE_INT_CST_ELT (t, 0);
-  int prec = TYPE_PRECISION (TREE_TYPE (t));
-  if (prec < HOST_BITS_PER_WIDE_INT)
-    return sext_hwi (w, prec);
-  return w;
-}
-
 /* Subroutine of fold_binary.  This routine performs all of the
    transformations that are common to the equality/inequality
    operators (EQ_EXPR and NE_EXPR) and the ordering operators
@@ -8889,18 +8875,29 @@ fold_comparison (location_t loc, enum tree_code code, tree type,
 	  STRIP_SIGN_NOPS (base0);
 	  if (TREE_CODE (base0) == ADDR_EXPR)
 	    {
-	      base0 = TREE_OPERAND (base0, 0);
-	      indirect_base0 = true;
+	      base0
+		= get_inner_reference (TREE_OPERAND (base0, 0),
+				       &bitsize, &bitpos0, &offset0, &mode,
+				       &unsignedp, &volatilep, false);
+	      if (TREE_CODE (base0) == INDIRECT_REF)
+		base0 = TREE_OPERAND (base0, 0);
+	      else
+		indirect_base0 = true;
 	    }
-	  offset0 = TREE_OPERAND (arg0, 1);
-	  if (tree_fits_shwi_p (offset0))
+	  if (offset0 == NULL_TREE || integer_zerop (offset0))
+	    offset0 = TREE_OPERAND (arg0, 1);
+	  else
+	    offset0 = size_binop (PLUS_EXPR, offset0,
+				  TREE_OPERAND (arg0, 1));
+	  if (TREE_CODE (offset0) == INTEGER_CST)
 	    {
-	      HOST_WIDE_INT off = size_low_cst (offset0);
-	      if ((HOST_WIDE_INT) (((unsigned HOST_WIDE_INT) off)
-				   * BITS_PER_UNIT)
-		  / BITS_PER_UNIT == (HOST_WIDE_INT) off)
+	      offset_int tem = wi::sext (wi::to_offset (offset0),
+					 TYPE_PRECISION (sizetype));
+	      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);
+	      tem += bitpos0;
+	      if (wi::fits_shwi_p (tem))
 		{
-		  bitpos0 = off * BITS_PER_UNIT;
+		  bitpos0 = tem.to_shwi ();
 		  offset0 = NULL_TREE;
 		}
 	    }
@@ -8923,18 +8920,29 @@ fold_comparison (location_t loc, enum tree_code code, tree type,
 	  STRIP_SIGN_NOPS (base1);
 	  if (TREE_CODE (base1) == ADDR_EXPR)
 	    {
-	      base1 = TREE_OPERAND (base1, 0);
-	      indirect_base1 = true;
+	      base1
+		= get_inner_reference (TREE_OPERAND (base1, 0),
+				       &bitsize, &bitpos1, &offset1, &mode,
+				       &unsignedp, &volatilep, false);
+	      if (TREE_CODE (base1) == INDIRECT_REF)
+		base1 = TREE_OPERAND (base1, 0);
+	      else
+		indirect_base1 = true;
 	    }
-	  offset1 = TREE_OPERAND (arg1, 1);
-	  if (tree_fits_shwi_p (offset1))
+	  if (offset1 == NULL_TREE || integer_zerop (offset1))
+	    offset1 = TREE_OPERAND (arg1, 1);
+	  else
+	    offset1 = size_binop (PLUS_EXPR, offset1,
+				  TREE_OPERAND (arg1, 1));
+	  if (TREE_CODE (offset1) == INTEGER_CST)
 	    {
-	      HOST_WIDE_INT off = size_low_cst (offset1);
-	      if ((HOST_WIDE_INT) (((unsigned HOST_WIDE_INT) off)
-				   * BITS_PER_UNIT)
-		  / BITS_PER_UNIT == (HOST_WIDE_INT) off)
+	      offset_int tem = wi::sext (wi::to_offset (offset1),
+					 TYPE_PRECISION (sizetype));
+	      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);
+	      tem += bitpos1;
+	      if (wi::fits_shwi_p (tem))
 		{
-		  bitpos1 = off * BITS_PER_UNIT;
+		  bitpos1 = tem.to_shwi ();
 		  offset1 = NULL_TREE;
 		}
 	    }
@@ -12375,12 +12383,27 @@ fold_binary_loc (location_t loc,
 	      || POINTER_TYPE_P (TREE_TYPE (arg0))))
 	{
 	  tree val = TREE_OPERAND (arg0, 1);
-	  return omit_two_operands_loc (loc, type,
-				    fold_build2_loc (loc, code, type,
-						 val,
-						 build_int_cst (TREE_TYPE (val),
-								0)),
-				    TREE_OPERAND (arg0, 0), arg1);
+	  val = fold_build2_loc (loc, code, type, val,
+				 build_int_cst (TREE_TYPE (val), 0));
+	  return omit_two_operands_loc (loc, type, val,
+					TREE_OPERAND (arg0, 0), arg1);
+	}
+
+      /* Transform comparisons of the form X CMP X +- Y to Y CMP 0.  */
+      if ((TREE_CODE (arg1) == PLUS_EXPR
+	   || TREE_CODE (arg1) == POINTER_PLUS_EXPR
+	   || TREE_CODE (arg1) == MINUS_EXPR)
+	  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg1,
+									0)),
+			      arg0, 0)
+	  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))
+	      || POINTER_TYPE_P (TREE_TYPE (arg1))))
+	{
+	  tree val = TREE_OPERAND (arg1, 1);
+	  val = fold_build2_loc (loc, code, type, val,
+				 build_int_cst (TREE_TYPE (val), 0));
+	  return omit_two_operands_loc (loc, type, val,
+					TREE_OPERAND (arg1, 0), arg0);
 	}
 
       /* Transform comparisons of the form C - X CMP X if C % 2 == 1.  */
@@ -12390,12 +12413,22 @@ fold_binary_loc (location_t loc,
 									1)),
 			      arg1, 0)
 	  && wi::extract_uhwi (TREE_OPERAND (arg0, 0), 0, 1) == 1)
-	{
-	  return omit_two_operands_loc (loc, type,
-				    code == NE_EXPR
-				    ? boolean_true_node : boolean_false_node,
-				    TREE_OPERAND (arg0, 1), arg1);
-	}
+	return omit_two_operands_loc (loc, type,
+				      code == NE_EXPR
+				      ? boolean_true_node : boolean_false_node,
+				      TREE_OPERAND (arg0, 1), arg1);
+
+      /* Transform comparisons of the form X CMP C - X if C % 2 == 1.  */
+      if (TREE_CODE (arg1) == MINUS_EXPR
+	  && TREE_CODE (TREE_OPERAND (arg1, 0)) == INTEGER_CST
+	  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg1,
+									1)),
+			      arg0, 0)
+	  && wi::extract_uhwi (TREE_OPERAND (arg1, 0), 0, 1) == 1)
+	return omit_two_operands_loc (loc, type,
+				      code == NE_EXPR
+				      ? boolean_true_node : boolean_false_node,
+				      TREE_OPERAND (arg1, 1), arg0);
 
       /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */
       if (TREE_CODE (arg0) == ABS_EXPR
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index c61d9f0..4112e1e 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,1463 +1,281 @@
-2015-12-04  Release Manager
-
-	* GCC 5.3.0 released.
-
-2015-11-27  Andre Vehreschild  <vehre@gcc.gnu.org>
-
-	PR fortran/68218
-	* trans-array.c (gfc_array_init_size): Add gfc_evaluate_now() when
-	array spec in allocate is a function call.
-
-2015-11-24  Paul Thomas  <pault@gcc.gnu.org>
+2016-03-09  Paul Thomas  <pault@gcc.gnu.org>
 
 	Backport from trunk.
-	PR fortran/68196
-	* class.c (has_finalizer_component): Prevent infinite recursion
-	through this function if the derived type and that of its
-	component are the same.
-	* trans-types.c (gfc_get_derived_type): Do the same for proc
-	pointers by ignoring the explicit interface for the component.
-
-	PR fortran/66465
-	* check.c (same_type_check): If either of the expressions is
-	BT_PROCEDURE, use the typespec from the symbol, rather than the
-	expression.
-
-2015-11-18  Dominique d'Humieres <dominiq@lps.ens.fr>
-
-	PR fortran/65751
-	* expr.c (gfc_check_pointer_assign): Fix error message.
-
-2015-11-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/58027
-	PR fortran/60993
-	* expr.c (gfc_check_init_expr): Prevent a redundant check when a
-	__convert_* function was inserted into an array constructor.
-	(gfc_check_assign_symbol): Check for an initialization expression
-	when a __convert_* was inserted.
-
-2015-11-14  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67803
-	* array.c (gfc_match_array_constructor): If array constructor included
-	a CHARACTER typespec, check array elements for compatible type.
-
-2015-11-13  Steven G. Kargl  <kargl@gccc.gnu.org>
-
-	PR fortran/68319
-	* decl.c (gfc_match_data, gfc_match_entry): Enforce F2008:C1206.
-	* io.c (gfc_match_format): Ditto.
-	* match.c (gfc_match_st_function): Ditto.
-
-2015-11-12  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68318
-	* decl.c (get_proc_name): Increment reference count for ENTRY.
-	While here, fix comment and use postfix ++ for consistency.
-
-2015-11-08  Steven g. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68053
-	* decl.c (add_init_expr_to_sym):  Try to reduce initialization expression
-	before testing for a constant value.
-
-2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68224
-	* array.c (match_array_element_spec): Check of invalid NULL().
-	While here, fix nearby comments.
-
-2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68153
-	* check.c (gfc_check_reshape): Improve check for valid SHAPE argument.
-
-2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68151
-	* match.c (match_case_selector):  Check for invalid type.
-
-2015-01-25  Paul Thomas  <pault@gcc.gnu.org>
-
-	Backported from trunk.
-	PR fortran/67171
-	* trans-array.c (structure_alloc_comps): On deallocation of
-	class components, reset the vptr to the declared type vtable
-	and reset the _len field of unlimited polymorphic components.
-	*trans-expr.c (gfc_find_and_cut_at_last_class_ref): Bail out on
-	allocatable component references to the right of part reference
-	with non-zero rank and return NULL.
-	(gfc_reset_vptr): Simplify this function by using the function
-	gfc_get_vptr_from_expr. Return if the vptr is NULL_TREE.
-	(gfc_reset_len): If gfc_find_and_cut_at_last_class_ref returns
-	NULL return.
-
-2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/51993
-	* decl.c (gfc_set_constant_character_len): Convert gcc_assert into an
-	if-statement causing an early return leads to valid error message.
-
-2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68154
-	* decl.c (add_init_expr_to_sym): if the char length in the typespec
-	is NULL, check for and use a constructor.
-
-2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/36192
-	* interface.c (get_expr_storage_size):  Check for INTEGER type before
-	calling gmp routines.
-
-2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68055
-	* decl.c (gfc_match_decl_type_spec): Check for valid kind in old-style
-	declarations.
-
-2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68054
-	* decl.c (match_attr_spec): PROTECTED can only be a module.
-
-2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67939
-	* data.c (create_character_initializer): Deal with zero length string.
-
-2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67885
-	* trans-decl.c (generate_local_decl): Mark PARAMETER entities in
-	BLOCK construct.
-
-2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67805
-	PR fortran/68108
-	* array.c (gfc_match_array_constructor): Check for error from type
-	spec matching.
-	* decl.c (char_len_param_value): Check for valid of charlen parameter.
-	Check for REF_ARRAY.  Reap dead code dating to 2008.
-	match.c (gfc_match_type_spec): Special case the keyword use in REAL.
-
-2015-10-26  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/67177
-	PR fortran/67977
-	Backport from mainline r228940:
-	* primary.c (match_substring): Add an argument 'deferred' to
-	flag that a substring reference with null start and end should
-	not be optimized away for deferred length strings.
-	(match_string_constant, gfc_match_rvalue): Set the argument.
-	* trans-expr.c (alloc_scalar_allocatable_for_assignment): If
-	there is a substring reference return.
-	* trans-intrinsic.c (conv_intrinsic_move_alloc): For deferred
-	characters, assign the 'from' string length to the 'to' string
-	length. If the 'from' expression is deferred, set its string
-	length to zero. If the 'to' expression has allocatable
-	components, deallocate them.
-
-2015-10-22  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/58754
-	* trans-stmt.c (gfc_trans_allocate): Do not use the scalar
-	character assignment if the allocate expression is an array
-	descriptor.
-
-2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67900
-	* resolve.c (gfc_verify_binding_labels): Check for NULL pointer.
-
-2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/68019
-	* decl.c (add_init_expr_to_sym): Remove an assert() to allow an error
-	message to be issued.
-
-2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67987
-	* decl.c (char_len_param_value): Unwrap unlong line.  If LEN < 0,
-	force it to zero per the Fortran 90, 95, 2003, and 2008 Standards.
-	* resolve.c (gfc_resolve_substring_charlen): Unwrap unlong line.
-	If 'start' is larger than 'end', length of substring is negative,
-	so explicitly set it to zero.
-	(resolve_charlen): Remove -Wsurprising warning.  Update comment to
-	reflect that the text is from the F2008 standard.
-
-2015-10-18  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/66079
-	Backport from mainline r224383:
-
-	* trans-expr.c (gfc_conv_procedure_call): Allocatable scalar
-	function results must be freed and nullified after use. Create
-	a temporary to hold the result to prevent duplicate calls.
-	* trans-stmt.c (gfc_trans_allocate): Rename temporary variable
-	as 'source'. Deallocate allocatable components of non-variable
-	'source's.
-
-2015-10-18  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/67721
-	PR fortran/67818
-	Backport from mainline r222477:
-
-	2015-04-27  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/59678
-	PR fortran/65841
-	* trans-array.c (duplicate_allocatable): Fixed deep copy of
-	allocatable components, which are liable for copy only, when
-	they are allocated.
-	(gfc_duplicate_allocatable): Add deep-copy code into if
-	component allocated block. Needed interface change for that.
-	(gfc_copy_allocatable_data): Supplying NULL_TREE for code to
-	add into if-block for checking whether a component was
-	allocated.
-	(gfc_duplicate_allocatable_nocopy): Likewise.
-	(structure_alloc_comps): Likewise.
-	* trans-array.h: Likewise.
-	* trans-expr.c (gfc_trans_alloc_subarray_assign): Likewise.
-	* trans-openmp.c (gfc_walk_alloc_comps): Likewise.
-
-2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67802
-	* decl.c (add_init_expr_to_sym): Numeric constant for character
-	length must be an INTEGER.
-
-2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67616
-	* primary.c (gfc_match_structure_constructor): Use a possibly
-	host-associated symtree to prevent ICE.
-
-2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66979
-	* io.c (gfc_resolve_filepos): Check for a UNIT number.  Add a nearby
-	missing 'return false'.
-
-2015-10-01  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/67721
-	* trans-expr.c (gfc_trans_assignment_1): Remove the non-constantness
-	condition guarding deep copy.
-
-2015-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67614
-	* resolve.c (gfc_resolve_code): Prevent ICE for invalid EXPR_NULL.
-
-2015-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67525
-	* parse.c (match_deferred_characteristics): Remove an assert, which
-	allows an invalid SELECT TYPE selector to be detected.
-
-2015-09-21  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67615
-	* resolve.c (gfc_resolve_code): Check for scalar expression in
-	arithmetic-if.
-
-2015-09-10  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/67526
-	* expr.c (gfc_check_init_expr): Do not dereference a NULL pointer.
-
-2015-09-04  Manuel López-Ibáñez  <manu@gcc.gnu.org>
-
-	PR fortran/67429
-	* error.c (gfc_clear_pp_buffer): Reset last_location, otherwise
-	caret lines might be skipped when actually giving a diagnostic.
+	PR fortran/69423
+	* trans-decl.c (create_function_arglist): Deferred character
+	length functions, with and without declared results, address
+	the passed reference type as '.result' and the local string
+	length as '..result'.
+	(gfc_null_and_pass_deferred_len): Helper function to null and
+	return deferred string lengths, as needed.
+	(gfc_trans_deferred_vars): Call it, thereby reducing repeated
+	code, add call for deferred arrays and reroute pointer function
+	results. Avoid using 'tmp' for anything other that a temporary
+	tree by introducing 'type_of_array' for the arrayspec type.
+
+2016-03-09  Paul Thomas  <pault@gcc.gnu.org>
 
-2015-08-07  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/66929
-	* trans-array.c (gfc_get_proc_ifc_for_expr): Use esym as procedure
-	symbol if available.
-
-2015-08-05  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/64921
-	* class.c (generate_finalization_wrapper): Set finalization
-	procedure symbol's always_explicit attribute.
-
-2015-08-03  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66942
-	* trans-expr.c (gfc_conv_procedure_call): Avoid NULL pointer reference
-
-2015-07-25  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/64986
-	* trans-expr.c (gfc_trans_assignment_1): Put component deallocation
-	code at the beginning of the block.
-
-2015-07-21  Andre Vehreschild  <vehre@gcc.gnu.org>
-
-	PR fortran/66035
-	* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_assignment):
-	Compute the size to allocate for class and derived type objects
-	correclty.
-	(gfc_trans_subcomponent_assign): Only allocate memory for a
-	component when the object to assign is not an allocatable class
-	object (the memory is already present for allocatable class objects).
-	Furthermore use copy_class_to_class for assigning the rhs to the
-	component (may happen for dummy class objects on the rhs).
-
-2015-07-17  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
-
-	* trans-intrinsic.c (conv_co_collective): Remove redundant address
-	operator in the generated code.
-
-2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66724
-	PR fortran/66724
-	* io.c (is_char_type): Call gfc_resolve_expr ().
-	(match_open_element, match_dt_element, match_inquire_element): Fix
-	ASYNCHRONOUS case.
-
-2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66864
-	* simplify.c (gfc_simplify_floor): Set precision of temporary to
-	that of arg.
-
-2015-07-16  Steven G. Kargl   <kargl@gcc.gnu.org>
-
-	PR fortran/66545
-	* primary.c (match_sym_complex_part): Do not dereference NULL pointer.
-
-2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/56520
-	* match.c (gfc_match_name): Special case unary minus and plus.
-
-2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	* io.c (check_char_variable): New function.
-	(match_open_element, match_close_element, match_file_element,
-	match_dt_element, match_inquire_element, match_wait_element): Use it.
-
-2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66725
-	* io.c (is_char_type): New function to test for BT_CHARACTER
-	(gfc_match_open, gfc_match_close, match_dt_element): Use it.
-
-2015-07-16  Release Manager
-
-	* GCC 5.2.0 released.
-
-2015-06-24  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/66549
-	* resolve.c (resolve_global_procedure): Don't save and restore
-	OpenMP state around the call to gfc_resolve.
-	(gfc_resolve): Save OpenMP state on entry and restore it on return.
-
-2015-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
-
-	PR fortran/66385
-	Backport from trunk
-	* frontend-passes.c (combine_array_constructor): Return early if
-	inside a FORALL loop.
-
-2015-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
-
-	* intrinsic.texi:  Change \leq to < in descrition of imaginary
-	part in argument to log.
-
-2015-06-11  Pierre-Marie de Rodat  <derodat@adacore.com>
-
-	* f95-lang.c (gfc_create_decls): Register the main translation unit
-	through the new debug hook.
-
-2015-06-08  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66245
-	* match.c (gfc_match_type_is, gfc_match_class_is):  Check if the
-	return type spec or derived type spec is validate.
-
-2015-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66347
-	* resolve.c (apply_default_init_local): Do not dereference a NULL
-	pointer.
-
-2015-06-05  Russell Whitesides  <russelldub@gmail.com>
-	    Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/40958
-	PR fortran/60780
-	PR fortran/66377
-	* module.c (load_equiv): Add check for loading duplicate EQUIVALENCEs
-	from different modules.  Eliminate the pruning of unused
-	equivalence-objects
-
-
-2015-06-02  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66380
-	* simplify.c (gfc_simplify_reshape): Convert assert into returning
-	NULL, which triggers an error condition.
-
-2015-05-29  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/66257
-	* resolve.c (resolve_actual_arglist): Don't throw an error
-	if the argument with procedure pointer component is not a variable.
+	Backport from trunk.
+	PR fortran/64324
+	* resolve.c (check_uop_procedure): Prevent deferred length
+	characters from being trapped by assumed length error.
 
-2015-05-22  Jakub Jelinek  <jakub@redhat.com>
+	Backport from trunk.
+	PR fortran/49630
+	PR fortran/54070
+	PR fortran/60593
+	PR fortran/60795
+	PR fortran/61147
+	PR fortran/64324
+	* trans-array.c (gfc_conv_scalarized_array_ref): Pass decl for
+	function as well as variable expressions.
+	(gfc_array_init_size): Add 'expr' as an argument. Use this to
+	correctly set the descriptor dtype for deferred characters.
+	(gfc_array_allocate): Add 'expr' to the call to
+	'gfc_array_init_size'.
+	* trans.c (gfc_build_array_ref): Expand logic for setting span
+	to include indirect references to character lengths.
+	* trans-decl.c (gfc_get_symbol_decl): Ensure that deferred
+	result char lengths that are PARM_DECLs are indirectly
+	referenced both for directly passed and by reference.
+	(create_function_arglist): If the length type is a pointer type
+	then store the length as the 'passed_length' and make the char
+	length an indirect reference to it.
+	(gfc_trans_deferred_vars): If a character length has escaped
+	being set as an indirect reference, return it via the 'passed
+	length'.
+	* trans-expr.c (gfc_conv_procedure_call): The length of
+	deferred character length results is set TREE_STATIC and set to
+	zero.
+	(gfc_trans_assignment_1): Do not fix the rse string_length if
+	it is a variable, a parameter or an indirect reference. Add the
+	code to trap assignment of scalars to unallocated arrays.
+	* trans-stmt.c (gfc_trans_allocate): Remove 'def_str_len' and
+	all references to it. Instead, replicate the code to obtain a
+	explicitly defined string length and provide a value before
+	array allocation so that the dtype is correctly set.
+	trans-types.c (gfc_get_character_type): If the character length
+	is a pointer, use the indirect reference.
+
+2016-02-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 
 	Backported from mainline
-	2015-05-19  Jakub Jelinek  <jakub@redhat.com>
-
-	PR middle-end/66199
-	* trans-openmp.c (gfc_trans_omp_teams): Set OMP_TEAMS_COMBINED for
-	combined constructs.
-	(gfc_trans_omp_target): Make sure BIND_EXPR has non-NULL
-	BIND_EXPR_BLOCK.
-
-2015-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR fortran/65903
-	* io.c (format_lex): Change to NONSTRING when checking for
-	possible doubled quote.
-	* scanner.c (gfc_next_char_literal): Revert change from 64506
-	and add a check for quotes and return.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66106
-	* interface.c(gfc_match_end_interface): Enforce F2008 C1202 (R1201).
-	* match.c(gfc_op2string): Return 'none' for INTRINSIC_NONE.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66057
-	* decl.c(gfc_match_generic):  Detected a malformed GENERIC statement.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66052
-	* decl.c(gfc_match_protected): Prevent dereference of NULL pointer.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66045
-	* expr.c (gfc_check_assign):  Check for assignment of NULL() instead
-	of the (intended) pointer assignment.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66044
-	* decl.c(gfc_match_entry):  Change a gfc_internal_error() into
-	a gfc_error()
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66043
-	* check.c (gfc_check_storage_size): Prevent the direct use of NULL()
-	in STORAGE_SIZE() reference.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66040
-	* parse.c(verify_st_order): Replace a gfc_internal_error with your
-	generic gfc_error.
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/66039
-	* io.c (match_filepos): Check for incomplete/mangled REWIND, FLUSH,
-	BACKSPACE, and ENDFILE statements
-
-2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/64925
-	* symbol.c(check_conflict):  Check for a conflict between a dummy
-	argument and an internal procedure name.
-
-2015-05-02  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/65976
-	* invoke.texi:  Remove 'no-' in '-fno-fixed-form'
-
-2015-04-22  Release Manager
-
-	* GCC 5.1.0 released.
-
-2015-04-22  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	PR fortran/65429
-	* decl.c (add_init_expr_to_sym): Set the length type parameter.
-
-2015-04-10  Tobias Burnus  <burnus@net-b.de>
-
-	* trans-stmt.c (gfc_trans_lock_unlock): Implement -fcoarray=lib
-	version; reject not-yet-implemented variants.
-	* trans-types.c (gfc_get_derived_type): For lock_type with
-	-fcoarray=lib, use a void pointer as type.
-	* trans.c (gfc_allocate_using_lib, gfc_allocate_allocatable):
-	Handle lock_type with -fcoarray=lib.
-
-2015-04-10  Mikael Morin  <mikael@gcc.gnu.org>
+	PR fortran/61156
+	* scanner.c (add_path_to_list): If include path is not a directory,
+	issue a fatal error.
 
-	PR fortran/56674
-	PR fortran/58813
-	PR fortran/59016
-	PR fortran/59024
-	* symbol.c (save_symbol_data, gfc_save_symbol_data): Rename the
-	former to the latter and make it non-static.  Update callers.
-	* gfortran.h (gfc_save_symbol_data): New prototype.
-	* decl.c (gfc_match_decl_type_spec): Call 'gfc_save_symbol_data'
-	before modifying symbols 'sym' and 'dt_sym'.
+2016-02-27  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
 
-2013-04-09  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/56852
-	* primary.c (gfc_variable_attr): Avoid ICE on AR_UNKNOWN if any
-	of the index variables are untyped and errors are present.
-
-2015-04-07  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/65548
-	* trans-stmt.c (gfc_trans_allocate): For intrinsic functions
-	use conv_expr_descriptor() instead of conv_expr_reference().
-
-2015-03-30  Jakub Jelinek  <jakub@redhat.com>
-
-	PR fortran/65597
-	* trans-openmp.c (gfc_trans_omp_do): For !simple simd with explicit
-	linear clause for the iterator set OMP_CLAUSE_LINEAR_NO_COPYIN.
-	For implcitly added !simple OMP_CLAUSE_LINEAR set it too.  Use step 1
-	instead of the original step on the new iterator - count.
-
-2015-03-25  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/64952
-	PR fortran/65532
-	* gfortran.h (struct gfc_namespace): New field 'types_resolved'.
-	* resolve.c (resolve_types): Return early if field 'types_resolved'
-	is set.  Set 'types_resolved' at the end.
-
-2015-03-24  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/55901
-	* trans-expr.c (gfc_conv_structure): Fixed indendation.
-	Using integer_zero_node now instead of explicitly
-	constructing a integer constant zero node.
-	(gfc_conv_derived_to_class): Add handling of _len component,
-	i.e., when the rhs has a string_length then assign that to
-	class' _len, else assign 0.
-	(gfc_conv_intrinsic_to_class): Likewise.
-
-2015-03-24  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/64787
-	PR fortran/57456
-	PR fortran/63230
-	* class.c (gfc_add_component_ref):  Free no longer needed
-	ref-chains to prevent memory loss.
-	(find_intrinsic_vtab): For deferred length char arrays or
-	unlimited polymorphic objects, store the size in bytes of one
-	character in the size component of the vtab.
-	* gfortran.h: Added gfc_add_len_component () define.
-	* trans-array.c (gfc_trans_create_temp_array): Switched to new
-	function name for getting a class' vtab's field.
-	(build_class_array_ref): Likewise.
-	(gfc_array_init_size): Using the size information from allocate
-	more consequently now, i.e., the typespec of the entity to
-	allocate is no longer needed.  This is to address the last open
-	comment in PR fortran/57456.
-	(gfc_array_allocate): Likewise.
-	(structure_alloc_comps): gfc_copy_class_to_class () needs to
-	know whether the class is unlimited polymorphic.
-	* trans-array.h: Changed interface of gfc_array_allocate () to
-	reflect the no longer needed typespec.
-	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): New.
-	(gfc_reset_len): New.
-	(gfc_get_class_array_ref): Switch to new function name for
-	getting a class' vtab's field.
-	(gfc_copy_class_to_class):  Added flag to know whether the class
-	to copy is unlimited polymorphic.  Adding _len dependent code
-	then, which calls ->vptr->copy () with four arguments adding
-	the length information ->vptr->copy(from, to, from_len, to_cap).
-	(gfc_conv_procedure_call): Switch to new function name for
-	getting a class' vtab's field.
-	(alloc_scalar_allocatable_for_assignment): Use the string_length
-	as computed by gfc_conv_expr and not the statically backend_decl
-	which may be incorrect when ref-ing.
-	(gfc_trans_assignment_1): Use the string_length variable and
-	not the rse.string_length.  The former has been computed more
-	generally.
-	* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Switch to new
-	function name for getting a class' vtab's field.
-	(gfc_conv_intrinsic_storage_size): Likewise.
-	(gfc_conv_intrinsic_transfer): Likewise.
-	* trans-stmt.c (gfc_trans_allocate): Restructured to evaluate
-	source=expr3 only once before the loop over the objects to
-	allocate, when the objects are not arrays. Doing correct _len
-	initialization and calling of vptr->copy () fixing PR 64787.
-	(gfc_trans_deallocate): Reseting _len to 0, preventing future
-	errors.
-	* trans.c (gfc_build_array_ref): Switch to new function name
-	for getting a class' vtab's field.
-	(gfc_add_comp_finalizer_call): Likewise.
-	* trans.h: Define the prototypes for the gfc_class_vtab_*_get ()
-	and gfc_vptr_*_get () functions.
-	Added gfc_find_and_cut_at_last_class_ref () and
-	gfc_reset_len () routine prototype.  Added flag to
-	gfc_copy_class_to_class () prototype to signal an unlimited
-	polymorphic entity to copy.
-
-2015-03-24  Iain Sandoe  <iain@codesourcery.com>
-	    Tobias Burnus  <burnus@net-b.de>
-
-	* gfortran.texi (_gfortran_caf_sync_memory): Improve wording.
-
-2015-03-23  Paul Thomas  <pault@gcc.gnu.org>
-	    Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/64952
-	* gfortran.h (struct symbol_attribute) : New field
-	'array_outer_dependency'.
-	* trans.h (struct gfc_ss_info): New field 'array_outer_dependency'.
-	* module.c (enum ab_attribute): New value AB_ARRAY_OUTER_DEPENDENCY.
-	(attr_bits): Append same value to initializer.
-	(mio_symbol_attribute): Handle 'array_outer_dependency' attr
-	in module read and write.
-	* resolve.c (update_current_proc_outer_array_dependency): New function.
-	(resolve_function, resolve_call): Add code to update current procedure's
-	'array_outer_dependency' attribute.
-	(resolve_variable): Mark current procedure with attribute
-	array_outer_dependency if the variable is an array coming from outside
-	the current namespace.
-	(resolve_fl_procedure): Mark a procedure without body with attribute
-	'array_outer_dependency'.
-	* trans-array.c (gfc_conv_resolve_dependencies): If any ss is
-	marked as 'array_outer_dependency' generate a temporary.
-	(gfc_walk_function_expr): If the function may reference external arrays,
-	mark the head gfc_ss with flag 'array_outer_dependency'.
-
-2015-03-22 Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR libgfortran/59513
-	* gfortran.texi (Read/Write after EOF marker): New information.
-
-2015-03-21  H.J. Lu  <hongjiu.lu@intel.com>
-
-	* gfortran.texi (_gfortran_caf_sync_memory): Put @{xxx} in one
-	line.
-
-2015-03-21  Tobias Burnus  <burnus@net-b.de>
-
-	* gfortran.texi (_gfortran_caf_sync_all, _gfortran_caf_sync_images,
-	_gfortran_caf_sync_memory, _gfortran_caf_error_stop,
-	_gfortran_caf_error_stop_str, _gfortran_caf_atomic_define,
-	_gfortran_caf_atomic_ref, _gfortran_caf_atomic_cas,
-	_gfortran_caf_atomic_op): New sections.
-
-2015-03-21  Tobias Burnus  <burnus@net-b.de>
-
-	* trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented
-	coindexed coarray accesses.
-
-2015-03-17  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/59198
-	* trans-types.c (gfc_get_derived_type): If an abstract derived
-	type with procedure pointer components has no other type of
-	component, return the backend_decl. Otherwise build the
-	components if any of the non-procedure pointer components have
-	no backend_decl.
-
-2015-03-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR fortran/64432
-	*trans-intrinisic.c (conv_intrinsic_system_clock): Check the
-	smallest kind passed in user arguments and hardcode tesults for
-	KIND=1 or KIND=2 to indicate no clock available.
-
-2015-03-16  Andre Vehreschild  <vehre@gmx.de>
-
-	* resolve.c: Prevent segfault on illegal input.
-
-2015-03-14  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/61138
-	* trans-expr.c (gfc_trans_pointer_assignment): Clear DESCRIPTOR_ONLY
-	field before reusing LSE.
-
-2015-03-11  Janne Blomqvist  <jb@gcc.gnu.org>
-
-	PR libfortran/65200
-	* gfortran.texi: Document behavior when opening files without
-	explicit ACTION= specifier.
-
-2015-03-10  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/65024
-	* trans-expr.c (gfc_conv_component_ref): If the component
-	backend declaration is missing and the derived type symbol is
-	available in the reference, call gfc_build_derived_type.
-
-2015-03-10  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
-	    Tobias Burnus  <burnus@net-b.de>
-
-	* trans.h (caf_sync_memory): New function decl tree.
-	* trans-decl.c (gfc_build_builtin_function_decls): Define it.
-	(create_main_function): Don't call sync_synchronize and leave
-	it to the CAF library.
-	* trans-stmt.c (gfc_trans_stop): Ditto.
-	(gfc_trans_sync): Ditto; add call library call for sync memory.
-
-2015-03-08  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/60898
-	* resolve.c (resolve_symbol): Check that the symbol found by
-	name lookup really is the current symbol being resolved.
-
-2015-03-02  Tobias Burnus  <burnus@net-b.de>
-
-	* check.c (gfc_check_atomic): Properly check for coarrayness
-	and for being coindexed.
-
-2015-02-26  Martin Liska  <mliska@suse.cz>
-
-	* resolve.c: Rename enum 'comparison' to 'compare_result' as
-	solution for -Wodr issue.
-
-2015-02-24  Thomas Schwinge  <thomas@codesourcery.com>
-
-	PR libgomp/64625
-	* f95-lang.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):
-	Remove macros.
-	(DEF_FUNCTION_TYPE_VAR_7, DEF_FUNCTION_TYPE_VAR_11): New macros.
-	* types.def (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)
-	(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
-	Remove function types.
-	(BT_FN_VOID_INT_SIZE_PTR_PTR_PTR)
-	(BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_INT_INT_VAR)
-	(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
-	New function types.
-
-2015-02-22  Bernd Edlinger  <bernd.edlinger@hotmail.de>
-
-	PR fortran/64980
-	PR fortran/61960
-	* trans-expr.c (gfc_apply_interface_mapping_to_expr): Remove mapping
-	for component references to class objects.
-	(gfc_conv_procedure_call): Compare the class by name.
-
-2015-02-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR fortran/64506
-	* scanner.c (gfc_next_char_literal): For free form source,
-	check for '!' and if found, clear the comment and go back
-	and get the next character. For fixed form source, skip the
-	rest of the line.
-
-2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/64932
-	* trans-stmt.c (gfc_trans_deallocate): If a component array
-	expression is not a descriptor type and it is a derived type
-	that has allocatable components and is not finalizable, then
-	deallocate the allocatable components.
-
-2015-02-08  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/63744
-	* module.c (check_for_ambiguous): Change argument type
-	from gfc_symbol to gfc_symtree.  Check local (symtree) name
-	instead of original (symbol) name.
-	(read_module): Update caller.
-
-2015-02-06  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/63205
-	* gfortran.h: Add 'must finalize' field to gfc_expr and
-	prototypes for gfc_is_alloc_class_scalar_function and for
-	gfc_is_alloc_class_array_function.
-	* expr.c (gfc_is_alloc_class_scalar_function,
-	gfc_is_alloc_class_array_function): New functions.
-	* trans-array.c (gfc_add_loop_ss_code): Do not move the
-	expression for allocatable class scalar functions outside the
-	loop.
-	(conv_array_index_offset): Cope with deltas being NULL_TREE.
-	(build_class_array_ref): Do not return with allocatable class
-	array functions. Add code to pick out the returned class array.
-	Dereference if necessary and return if not a class object.
-	(gfc_conv_scalarized_array_ref): Cope with offsets being NULL.
-	(gfc_walk_function_expr): Return an array ss for the result of
-	an allocatable class array function.
-	* trans-expr.c (gfc_conv_subref_array_arg): Remove the assert
-	that the argument should be a variable. If an allocatable class
-	array function, set the offset to zero and skip the write-out
-	loop in this case.
-	(gfc_conv_procedure_call): Add allocatable class array function
-	to the assert. Call gfc_conv_subref_array_arg for allocatable
-	class array function arguments with derived type formal arg..
-	Add the code for handling allocatable class functions, including
-	finalization calls to prevent memory leaks.
-	(arrayfunc_assign_needs_temporary): Return if an allocatable
-	class array function.
-	(gfc_trans_assignment_1): Set must_finalize to rhs expression
-	for allocatable class functions. Set scalar_to_array as needed
-	for scalar class allocatable functions assigned to an array.
-	Nullify the allocatable components corresponding the the lhs
-	derived type so that the finalization does not free them.
-
-2015-01-29  Andre Vehreschild  <vehre@gmx.de>
-	    Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/60289
-	Initial patch by Janus Weil
-	* resolve.c (resolve_allocate_expr): Add check for comp. only
-	when target is not unlimited polymorphic.
-	* trans-stmt.c (gfc_trans_allocate): Assign correct value to
-	_len component of unlimited polymorphic entities.
-
-2015-02-05  Tobias Burnus  <burnus@net-b.de>
-
-	PR fortran/64943
-	* resolve.c (resolve_transfer): Also check structure
-	constructors.
-
-2015-02-05  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/64757
-	* resolve.c (resolve_structure_cons): Obtain the rank of class
-	components.
-	* trans-expr.c (gfc_trans_alloc_subarray_assign): Do the
-	assignment to allocatable class array components.
-	(alloc_scalar_allocatable_for_subcomponent_assignment): If comp
-	is a class component, allocate to the _data field.
-	(gfc_trans_subcomponent_assign): If a class component with a
-	derived type expression set the _vptr field and for array
-	components, call gfc_trans_alloc_subarray_assign. For scalars,
-	the assignment is performed here.
-
-2015-02-04  Jakub Jelinek  <jakub@redhat.com>
-
-	* options.c: Include langhooks.h.
-	(gfc_post_options): Change lang_hooks.name based on
-	selected -std= mode.
-
-2015-02-03  Steven G. Kargl  <kargl@gcc.gnu.org>
-
-	* intrinsic.texi (CO_ASSOCIATED): c_prt_1 should be c_ptr_1.
-
-2015-01-30  Andre Vehreschild  <vehre@gmx.de>
-
-	* trans-decl.c (gfc_get_symbol_decl): Removed duplicate code.
-	* trans-expr.c (gfc_conv_intrinsic_to_class): Fixed indentation.
-	Fixed datatype of charlen to be a 32-bit int.
-
-2015-02-01  Joseph Myers  <joseph@codesourcery.com>
-
-	* error.c (gfc_warning (const char *, ...), gfc_warning_now (const
-	char *, ...)): Remove functions.
-	* gfortran.h (gfc_warning (const char *, ...), gfc_warning_now
-	(const char *, ...)): Remove declarations.
-	* arith.c, check.c, data.c, decl.c, frontend-passes.c,
-	interface.c, intrinsic.c, io.c, matchexp.c, module.c, openmp.c,
-	options.c, parse.c, primary.c, resolve.c, scanner.c, symbol.c,
-	trans-common.c, trans-const.c, trans-stmt.c: All callers of
-	gfc_warning and gfc_warning_now changed to pass 0 or option number
-	as first argument.
-
-2015-01-30  Joseph Myers  <joseph@codesourcery.com>
-
-	* f95-lang.c, gfortranspec.c, trans-const.c, trans-expr.c: All
-	callers of fatal_error changed to pass input_location as first
-	argument.
-
-2015-01-28  Tobias Burnus  <burnus@net-b.de>
-
-	* intrinsic.texi (CO_BROADCAST): Correct argument description.
-
-2015-01-27  Tobias Burnus  <burnus@net-b.de>
-
-	PR fortran/63861
-	* trans-openmp.c (gfc_has_alloc_comps, gfc_trans_omp_clauses):
-	Fix handling for scalar coarrays.
-	* trans-types.c (gfc_get_element_type): Add comment.
-
-2015-01-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
-
-	PR fortran/64771
-	* interface.c: Remove <algorithm>.
-	(check_dummy_characteristics): Use MAX instead of std::max.
-
-2015-01-26  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/62044
-	* resolve.c (resolve_allocate_expr): If the default initializer
-	is NULL, keep the original MOLD expression so that the correct
-	typespec is available.
-
-2015-01-26  Tobias Burnus  <burnus@net-b.de>
-
-	PR fortran/64771
-	* interface.c (check_dummy_characteristics): Fix coarray handling.
-
-2015-01-26  Tobias Burnus  <burnus@net-b.de>
-
-	* io.c (gfc_match_inquire): Replace "-1" by a defined constant.
-
-2015-01-26  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/64230
-	* class.c (finalize_component): New argument 'sub_ns'. Insert code to
-	check if 'expr' is associated.
-	(generate_finalization_wrapper): Rename 'ptr' symbols to 'ptr1' and
-	'ptr2'. Pass 'sub_ns' to finalize_component.
-
-2015-01-25  Mikael Morin  <mikael@gcc.gnu.org>
-
-	PR fortran/62044
-	* decl.c (gfc_match_derived_decl): Don't insert a new symtree element.
-	* module.c (MOD_VERSION): Bump.
-	(write_module): Don't write list of extensions.
-	(read_module): Don't jump over list of extensions;
-	don't load list of extensions.
-	(load_derived_extensions, write_dt_extensions,
-	 write_derived_extensions): Remove.
-
-2015-01-24  Tobias Burnus  <burnus@net-b.de>
-
-	* parse.c (gfc_parse_file): Fix two-location gfc_error call.
-
-2015-01-23  Martin Liska  <mliska@suse.cz>
-
-	* decl.c (attr_decl1): Workaround -Wmaybe-uninitialized
-	false positive during profiledbootstrap by initializing them.
-	* matchexp.c (match_mult_operand): Likewise.
-	* module.c (write_atom): Likewise.
-	(read_module): Likewise.
-
-2015-01-23  Tom de Vries  <tom@codesourcery.com>
-
-	PR libgomp/64672
-	* lang.opt (fopenacc): Mark as LTO option.
-
-2015-01-23  Tom de Vries  <tom@codesourcery.com>
-
-	PR libgomp/64707
-	* lang.opt (fopenmp): Mark as LTO option.
-
-2015-01-23  Andre Vehreschild  <vehre@gmx.de>
-
-	* trans-decl.c (gfc_finish_var_decl): Fixed moved comment.
-	* trans-stmt.c (gfc_trans_allocate): Fixed indentation.
-
-2015-01-23  Jakub Jelinek  <jakub@redhat.com>
-
-	* gfc-diagnostic.def (DK_ICE_NOBT): New kind.
-
-2015-01-23  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/60922
-	* class.c (finalize_component): Apply the check for 'fini_coarray' only
-	to coarray components.
-
-2015-01-23  Tobias Burnus  <burnus@net-b.de>
-
-	PR fortran/64726
-	* trans-openmp.c (gfc_trans_oacc_combined_directive): Fix
-	loop generation.
-
-2015-01-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR fortran/61933
-	* libgfortran.h:
-	* trans-io.c (set_parameter_value): Delete use of has_iostat.
-	Redefine to not generate any runtime error check calls.
-	(set_parameter_value_chk): Rename of the former
-	set_parameter_value with the runtime error checks and fix
-	whitespace. (set_parameter_value_inquire): New function that
-	builds a runtime conditional block to set the INQUIRE
-	common parameter block unit number to -2 when unit numbers
-	exceed positive KIND=4 limits. (gfc_trans_open): Whitespace.
-	For unit, use the renamed set_parameter_value_chk.
-	(gfc_trans_close): Likewise use renamed function.
-	(build_filepos): Whitespace and use renamed function.
-	(gfc_trans_inquire): Whitespace and for unit use
-	set_parameter_value and set_parameter_value_inquire.
-	(gfc_trans_wait): Remove p->iostat from call to
-	set_parameter_value. Use new set_parameter_value_chk for unit.
-	(build_dt): Use the new set_parameter_value without p->iostat
-	and fix whitespace. Use set_parameter_value_chk for unit.
-
-2015-01-21  Thomas Koenig  <tkoenig@netcologne.de>
-
-	PR fortran/57023
-	* dependency.c (callback_dummy_intent_not_int):  New function.
-	(dummy_intent_not_in):  New function.
-	(gfc_full_array_ref_p):  Use dummy_intent_not_in.
-
-2015-01-18  Andre Vehreschild  <vehre@gmx.de>
-	    Janus Weil <janus@gcc.gnu.org>
-
-	PR fortran/60255
-	* class.c (gfc_get_len_component): New.
-	(gfc_build_class_symbol): Add _len component to unlimited
-	polymorphic entities.
-	(find_intrinsic_vtab): Removed emitting of error message.
-	* gfortran.h: Added prototype for gfc_get_len_component.
-	* simplify.c (gfc_simplify_len): Use _len component where
-	available.
-	* trans-expr.c (gfc_class_len_get): New.
-	(gfc_conv_intrinsic_to_class): Add handling for deferred
-	character arrays.
-	(gfc_conv_structure): Treat _len component correctly.
-	(gfc_conv_expr): Prevent bind_c handling when not required.
-	(gfc_trans_pointer_assignment): Propagate _len component.
-	* trans-stmt.c (class_has_len_component): New.
-	(trans_associate_var): _len component treatment for associate
-	context.
-	(gfc_trans_allocate): Same as for trans_associate_var()
-	* trans.h: Added prototype for gfc_class_len_get.
-
-2015-01-18  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/57959
-	* trans-expr.c (gfc_trans_subcomponent_assign): Use a deep copy
-	for allocatable components, where the source is a variable.
-
-2015-01-18  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/55901
-	* primary.c (gfc_match_varspec): Exclude dangling associate-
-	names with dimension 0 from being counted as arrays.
-	* resolve.c (resolve_assoc_var): Sub-strings are permissible
-	for associate-names, so exclude characters from the test for
-	misuse as arrays.
-	* trans-decl.c (gfc_get_symbol_decl): Associate-names can use
-	the hidden string length variable of their associated target.
-	Signal this by setting 'length' to a constant, if the decl for
-	the string length is a variable.
-
-2015-01-17  Paul Thomas  <pault@gcc.gnu.org>
-
-	PR fortran/64578
-	* trans-expr.c (gfc_trans_pointer_assignment): Make sure that
-	before reinitializing rse, to add the rse.pre to block before
-	creating 'ptrtemp'.
-	* trans-intrinsic.c (gfc_conv_associated): Deal with the class
-	data being a descriptor.
-
-2015-01-17  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/60357
-	* primary.c (build_actual_constructor): Prevent warning.
-	* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_
-	assignment): New function encapsulates treatment of allocatable
-	components.
-	(gfc_trans_subcomponent_assign): Needed to distinguish between
-	regular assignment and initilization.
-	(gfc_trans_structure_assign): Same.
-	(gfc_conv_structure): Same.
-
-	PR fortran/61275
-	* gfortran.h: deferred_parameter is not needed, because
-	it artificial does the trick completely.
-	* primary.c (build_actual_constructor): Same.
-	(gfc_convert_to_structure_constructor): Same.
-	* resolve.c (resolve_fl_derived0): Same.
-	* trans-expr.c (gfc_conv_component_ref): Prevent treating
-	allocatable deferred length char arrays here.
-	(gfc_trans_subcomponent_assign): Same as above.
-	* trans-types.c (gfc_sym_type): This is done in
-	gfc_get_derived_type already.
-
-2015-01-17  Andre Vehreschild  <vehre@gmx.de>
-
-	PR fortran/60334
-	* trans-decl.c (gfc_get_symbol_decl):Use a ref on the string
-	length when the symbol is declared to be a result.
-	* trans-expr.c (gfc_conv_procedure_call): Strip deref on the
-	string length when functions are nested and the string length
-	is a reference already.
-
-2015-01-16  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/45290
-	* decl.c (match_pointer_init): Error out if resolution of init expr
-	failed.
+	Backported from mainline
+	* trans.c (gfc_allocate_allocatable): size conversion
+	from byte to number of elements for event variables.
+	* trans-types.c (gfc_get_derived_type): event variables
+	represented as a pointer (like lock variable).
 
-2015-01-15  Tobias Burnus  <burnus@net-b.de>
+2016-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 
-	* openmp.c (check_symbol_not_pointer, resolve_oacc_data_clauses,
-	resolve_oacc_deviceptr_clause, resolve_omp_clauses,
-	gfc_resolve_oacc_declare): Replace '%s' by %qs.
+	Backported from mainline
+	PR fortran/65996
+	* error.c (gfc_error): Save the state of abort_on_error and set
+	it to false for buffered errors to allow normal processing.
+	Restore the state before leaving.
 
-2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>
-	    Cesar Philippidis  <cesar@codesourcery.com>
-	    James Norris  <jnorris@codesourcery.com>
-	    Ilmir Usmanov  <i.usmanov@samsung.com>
-	    Tobias Burnus  <burnus@net-b.de>
+2016-02-12  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
 
-	* lang.opt (fopenacc): New option.
-	* cpp.c (cpp_define_builtins): Conditionally define _OPENACC.
-	* dump-parse-tree.c (show_omp_node): Split part of it into...
-	(show_omp_clauses): ... this new function.
-	(show_omp_node, show_code_node): Handle EXEC_OACC_PARALLEL_LOOP,
-	EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,
-	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
-	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
-	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
-	(show_namespace): Update for OpenACC.
-	* f95-lang.c (DEF_FUNCTION_TYPE_VAR_2, DEF_FUNCTION_TYPE_VAR_8)
-	(DEF_FUNCTION_TYPE_VAR_12, DEF_GOACC_BUILTIN)
-	(DEF_GOACC_BUILTIN_COMPILER): New macros.
-	* types.def (BT_FN_VOID_INT_INT_VAR)
-	(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)
-	(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
-	New function types.
-	* gfortran.h (gfc_statement): Add ST_OACC_PARALLEL_LOOP,
-	ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,
-	ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,
-	ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA,
-	ST_OACC_LOOP, ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE,
-	ST_OACC_WAIT, ST_OACC_CACHE, ST_OACC_KERNELS_LOOP,
-	ST_OACC_END_KERNELS_LOOP, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,
-	ST_OACC_ROUTINE.
-	(struct gfc_expr_list): New data type.
-	(gfc_get_expr_list): New macro.
-	(gfc_omp_map_op): Add OMP_MAP_FORCE_ALLOC, OMP_MAP_FORCE_DEALLOC,
-	OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM, OMP_MAP_FORCE_TOFROM,
-	OMP_MAP_FORCE_PRESENT, OMP_MAP_FORCE_DEVICEPTR.
-	(OMP_LIST_FIRST, OMP_LIST_DEVICE_RESIDENT, OMP_LIST_USE_DEVICE)
-	(OMP_LIST_CACHE): New enumerators.
-	(struct gfc_omp_clauses): Add async_expr, gang_expr, worker_expr,
-	vector_expr, num_gangs_expr, num_workers_expr, vector_length_expr,
-	wait_list, tile_list, async, gang, worker, vector, seq,
-	independent, wait, par_auto, gang_static, and loc members.
-	(struct gfc_namespace): Add oacc_declare_clauses member.
-	(gfc_exec_op): Add EXEC_OACC_KERNELS_LOOP,
-	EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS,
-	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
-	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
-	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
-	(gfc_free_expr_list, gfc_resolve_oacc_directive)
-	(gfc_resolve_oacc_declare, gfc_resolve_oacc_parallel_loop_blocks)
-	(gfc_resolve_oacc_blocks): New prototypes.
-	* match.c (match_exit_cycle): Handle EXEC_OACC_LOOP and
-	EXEC_OACC_PARALLEL_LOOP.
-	* match.h (gfc_match_oacc_cache, gfc_match_oacc_wait)
-	(gfc_match_oacc_update, gfc_match_oacc_declare)
-	(gfc_match_oacc_loop, gfc_match_oacc_host_data)
-	(gfc_match_oacc_data, gfc_match_oacc_kernels)
-	(gfc_match_oacc_kernels_loop, gfc_match_oacc_parallel)
-	(gfc_match_oacc_parallel_loop, gfc_match_oacc_enter_data)
-	(gfc_match_oacc_exit_data, gfc_match_oacc_routine): New
-	prototypes.
-	* openmp.c: Include "diagnostic.h" and "gomp-constants.h".
-	(gfc_free_omp_clauses): Update for members added to struct
-	gfc_omp_clauses.
-	(gfc_match_omp_clauses): Change mask paramter to uint64_t.  Add
-	openacc parameter.
-	(resolve_omp_clauses): Add openacc parameter.  Update for OpenACC.
-	(struct fortran_omp_context): Add is_openmp member.
-	(gfc_resolve_omp_parallel_blocks): Initialize it.
-	(gfc_resolve_do_iterator): Update for OpenACC.
-	(gfc_resolve_omp_directive): Call
-	resolve_omp_directive_inside_oacc_region.
-	(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE)
-	(OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYPRIVATE)
-	(OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN, OMP_CLAUSE_REDUCTION)
-	(OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE)
-	(OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_COLLAPSE)
-	(OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE)
-	(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH)
-	(OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND)
-	(OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM)
-	(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO)
-	(OMP_CLAUSE_FROM, OMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT)
-	(OMP_CLAUSE_DIST_SCHEDULE): Use uint64_t.
-	(OMP_CLAUSE_ASYNC, OMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS)
-	(OMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_COPY, OMP_CLAUSE_COPYOUT)
-	(OMP_CLAUSE_CREATE, OMP_CLAUSE_PRESENT)
-	(OMP_CLAUSE_PRESENT_OR_COPY, OMP_CLAUSE_PRESENT_OR_COPYIN)
-	(OMP_CLAUSE_PRESENT_OR_COPYOUT, OMP_CLAUSE_PRESENT_OR_CREATE)
-	(OMP_CLAUSE_DEVICEPTR, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER)
-	(OMP_CLAUSE_VECTOR, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT)
-	(OMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_DEVICE_RESIDENT)
-	(OMP_CLAUSE_HOST_SELF, OMP_CLAUSE_OACC_DEVICE, OMP_CLAUSE_WAIT)
-	(OMP_CLAUSE_DELETE, OMP_CLAUSE_AUTO, OMP_CLAUSE_TILE): New macros.
-	(gfc_match_omp_clauses): Handle those.
-	(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES)
-	(OACC_LOOP_CLAUSES, OACC_PARALLEL_LOOP_CLAUSES)
-	(OACC_KERNELS_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES)
-	(OACC_DECLARE_CLAUSES, OACC_UPDATE_CLAUSES)
-	(OACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES)
-	(OACC_WAIT_CLAUSES): New macros.
-	(gfc_free_expr_list, match_oacc_expr_list, match_oacc_clause_gang)
-	(gfc_match_omp_map_clause, gfc_match_oacc_parallel_loop)
-	(gfc_match_oacc_parallel, gfc_match_oacc_kernels_loop)
-	(gfc_match_oacc_kernels, gfc_match_oacc_data)
-	(gfc_match_oacc_host_data, gfc_match_oacc_loop)
-	(gfc_match_oacc_declare, gfc_match_oacc_update)
-	(gfc_match_oacc_enter_data, gfc_match_oacc_exit_data)
-	(gfc_match_oacc_wait, gfc_match_oacc_cache)
-	(gfc_match_oacc_routine, oacc_is_loop)
-	(resolve_oacc_scalar_int_expr, resolve_oacc_positive_int_expr)
-	(check_symbol_not_pointer, check_array_not_assumed)
-	(resolve_oacc_data_clauses, resolve_oacc_deviceptr_clause)
-	(oacc_compatible_clauses, oacc_is_parallel, oacc_is_kernels)
-	(omp_code_to_statement, oacc_code_to_statement)
-	(resolve_oacc_directive_inside_omp_region)
-	(resolve_omp_directive_inside_oacc_region)
-	(resolve_oacc_nested_loops, resolve_oacc_params_in_parallel)
-	(resolve_oacc_loop_blocks, gfc_resolve_oacc_blocks)
-	(resolve_oacc_loop, resolve_oacc_cache, gfc_resolve_oacc_declare)
-	(gfc_resolve_oacc_directive): New functions.
-	* parse.c (next_free): Update for OpenACC.  Move some code into...
-	(verify_token_free): ... this new function.
-	(next_fixed): Update for OpenACC.  Move some code into...
-	(verify_token_fixed): ... this new function.
-	(case_executable): Add ST_OACC_UPDATE, ST_OACC_WAIT,
-	ST_OACC_CACHE, ST_OACC_ENTER_DATA, and ST_OACC_EXIT_DATA.
-	(case_exec_markers): Add ST_OACC_PARALLEL_LOOP, ST_OACC_PARALLEL,
-	ST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA, ST_OACC_LOOP,
-	ST_OACC_KERNELS_LOOP.
-	(case_decl): Add ST_OACC_ROUTINE.
-	(push_state, parse_critical_block, parse_progunit): Update for
-	OpenACC.
-	(gfc_ascii_statement): Handle ST_OACC_PARALLEL_LOOP,
-	ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,
-	ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_KERNELS_LOOP,
-	ST_OACC_END_KERNELS_LOOP, ST_OACC_DATA, ST_OACC_END_DATA,
-	ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,
-	ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,
-	ST_OACC_CACHE, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,
-	ST_OACC_ROUTINE.
-	(verify_st_order, parse_spec): Handle ST_OACC_DECLARE.
-	(parse_executable): Handle ST_OACC_PARALLEL_LOOP,
-	ST_OACC_KERNELS_LOOP, ST_OACC_LOOP, ST_OACC_PARALLEL,
-	ST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA.
-	(decode_oacc_directive, parse_oacc_structured_block)
-	(parse_oacc_loop, is_oacc): New functions.
-	* parse.h (struct gfc_state_data): Add oacc_declare_clauses
-	member.
-	(is_oacc): New prototype.
-	* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle
-	EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL,
-	EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS, EXEC_OACC_DATA,
-	EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP, EXEC_OACC_UPDATE,
-	EXEC_OACC_WAIT, EXEC_OACC_CACHE, EXEC_OACC_ENTER_DATA,
-	EXEC_OACC_EXIT_DATA.
-	(resolve_codes): Call gfc_resolve_oacc_declare.
-	* scanner.c (openacc_flag, openacc_locus): New variables.
-	(skip_free_comments): Update for OpenACC.  Move some code into...
-	(skip_omp_attribute): ... this new function.
-	(skip_oacc_attribute): New function.
-	(skip_fixed_comments, gfc_next_char_literal): Update for OpenACC.
-	* st.c (gfc_free_statement): Handle EXEC_OACC_PARALLEL_LOOP,
-	EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,
-	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
-	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
-	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
-	* trans-decl.c (gfc_generate_function_code): Update for OpenACC.
-	* trans-openmp.c: Include "gomp-constants.h".
-	(gfc_omp_finish_clause, gfc_trans_omp_clauses): Use GOMP_MAP_*
-	instead of OMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.
-	(gfc_trans_omp_clauses): Handle OMP_LIST_USE_DEVICE,
-	OMP_LIST_DEVICE_RESIDENT, OMP_LIST_CACHE, and OMP_MAP_FORCE_ALLOC,
-	OMP_MAP_FORCE_DEALLOC, OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM,
-	OMP_MAP_FORCE_TOFROM, OMP_MAP_FORCE_PRESENT,
-	OMP_MAP_FORCE_DEVICEPTR, and gfc_omp_clauses' async, seq,
-	independent, wait_list, num_gangs_expr, num_workers_expr,
-	vector_length_expr, vector, vector_expr, worker, worker_expr,
-	gang, gang_expr members.
-	(gfc_trans_omp_do): Handle EXEC_OACC_LOOP.
-	(gfc_convert_expr_to_tree, gfc_trans_oacc_construct)
-	(gfc_trans_oacc_executable_directive)
-	(gfc_trans_oacc_wait_directive, gfc_trans_oacc_combined_directive)
-	(gfc_trans_oacc_declare, gfc_trans_oacc_directive): New functions.
-	* trans-stmt.c (gfc_trans_block_construct): Update for OpenACC.
-	* trans-stmt.h (gfc_trans_oacc_directive, gfc_trans_oacc_declare):
+	Backported from mainline
+	2015-12-02  Tobias Burnus  <burnus@net-b.de>
+	Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	* check.c (gfc_check_event_query): New function.
+	* dump-parse-tree.c (show_code_node): Handle EXEC_EVENT_POST,
+	EXEC_EVENT_WAIT.
+	* expr.c (gfc_check_vardef_context): New check for event variables
+	definition.
+	* gfortran.h (gfc_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.
+	(gfc_isym_id): GFC_ISYM_EVENT_QUERY.
+	(struct symbol_attribute): New field.
+	(gfc_exec_op): Add EXEC_EVENT_POST and EXEC_EVENT_WAIT.
+	* gfortran.texi: Document about new events functions and minor
+	changes.
+	* interface.c (compare_parameter): New check.
+	(gfc_procedure_use): New check for explicit procedure interface.
+	(add_subroutines): Add event_query.
+	* intrinsic.h (gfc_check_event_query,gfc_resolve_event_query):
 	New prototypes.
-	* trans.c (tranc_code): Handle EXEC_OACC_CACHE, EXEC_OACC_WAIT,
-	EXEC_OACC_UPDATE, EXEC_OACC_LOOP, EXEC_OACC_HOST_DATA,
-	EXEC_OACC_DATA, EXEC_OACC_KERNELS, EXEC_OACC_KERNELS_LOOP,
-	EXEC_OACC_PARALLEL, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ENTER_DATA,
-	EXEC_OACC_EXIT_DATA.
-	* gfortran.texi: Update for OpenACC.
-	* intrinsic.texi: Likewise.
-	* invoke.texi: Likewise.
-
-2015-01-15  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/58023
-	* resolve.c (resolve_fl_derived0): Continue resolving next component
-	after error.
-
-2015-01-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-
-	PR fortran/61933
-	* io.c (gfc_match_inquire): Generate error if unit number in
-	inquire statement is a constant -1.  All other values allowed.
-	* trans-io.c (gfc_trans_inquire): Delete dummy iostat variable.
-	(create_dummy_iostat): Delete function no longer used.
-
-2015-01-13  Jakub Jelinek  <jakub@redhat.com>
-
-	PR fortran/64528
-	* trans-decl.c (create_function_arglist): Don't set TREE_READONLY
-	on dummy args with VALUE attribute.
-
-2015-01-11  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/63733
-	* interface.c (gfc_extend_expr): Look for type-bound operators before
-	non-typebound ones.
-
-2015-01-11  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/58023
-	* resolve.c (resolve_fl_derived0): Set error flag if problems with the
-	interface of a procedure-pointer component were detected.
-
-2015-01-11  Janus Weil  <janus@gcc.gnu.org>
-
-	PR fortran/64508
-	* interface.c (compare_parameter): Interface check for
-	procedure-pointer component as actual argument.
-
-2015-01-10  Thomas Schwinge  <thomas@codesourcery.com>
-
-	* gfortran.texi: Update for libgomp being renamed from "GNU OpenMP
-	Runtime Library" to "GNU Offloading and Multi Processing Runtime
-	Library".
-	* intrinsic.texi: Likewise.
-
-2015-01-10  Tobias Burnus  <burnus@net-b.de>
-
-	PR fortran/64522
-	* invoke.texi (Wline-truncation): Document new behaviour.
-	* lang.opt (Wline-truncation): Add Init(-1).
-	* options.c (gfc_post_options): If -Wline-truncation is unset,
-	enable it for free-form source files; for the latter, also use
-	-Werror=line-truncation, unless -Wno-error has been specified.
-
-2015-01-09  Michael Collison  <michael.collison@linaro.org>
-
-	* convert.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* cpp.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* decl.c: Ditto.
-	* f95.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* iresolve.c: Ditto.
-	* match.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* module.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* options.c: Ditto.
-	* target-memory.c: Include hash-set.h, vec.h,
-	double-int.h, input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans-array.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans-common.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans-const.c: Ditto.
-	* trans-decl.c: Ditto.
-	* trans-expr.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans-intrinsic.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, inchash.h and real.h due to flattening of tree.h.
-	* trans-io.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, options.h, fold-const.h,
-	wide-int.h, and inchash.h due to flattening of tree.h.
-	* trans-openmp.c: Ditto.
-	* trans-stmt.c: Ditto.
-	* trans-types.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
-	input.h, alias.h, symtab.h, fold-const.h,
-	wide-int.h, inchash.h and real.h due to flattening of tree.h.
-
-2015-01-08  Tobias Burnus  <burnus@net-b.de>
+	* iresolve.c (gfc_resolve_event_query): New function.
+	* iso-fortran-env.def (event_type): New type.
+	* match.c (event_statement,gfc_match_event_post,gfc_match_event_wait):
+	New functions.
+	(gfc_match_name): New event post and event wait.
+	* match.h (gfc_match_event_post,gfc_match_event_wait):
+	New prototypes.
+	* module.c (ab_attribute): Add AB_EVENT_COMP.
+	(attr_bits): Likewise.
+	(mio_symbol_attribute): Handle event_comp attribute.
+	* parse.c (decode_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.
+	(next_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.
+	(gfc_ascii_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.
+	(parse_derived): Check for event_type components.
+	* resolve.c (resolve_allocate_expr): Check for event variable def.
+	(resolve_lock_unlock): Renamed to resolve_lock_unlock_event. It
+	includes logic for locks and events.
+	(gfc_resolve_code): Call it.
+	(gfc_resolve_symbol): New check for event variable to be a corray.
+	* st.c (gfc_free_statement): Handle new EXEC_EVENT_POST and
+	EXEC_EVENT_WAIT.
+	* trans-decl.c (gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,
+	gfor_fndecl_caf_event_query): New global variables.
+	(generate_coarray_sym_init): Checking for event_type.
+	(gfc_conv_procedure_call): Check for C bind attribute.
+	* trans-intrinsic.c (conv_intrinsic_event_query): New function.
+	(conv_intrinsic_move_alloc): Call it.
+	* trans-stmt.c (gfc_trans_lock_unlock): Passing address
+	of actual argument.
+	(gfc_trans_sync): Likewise.
+	(gfc_trans_event_post_wait): New function.
+	* trans-stmt.h (gfc_trans_event_post_wait): New prototype.
+	* trans-types.c (gfc_get_derived_type): Integer_kind as event_type.
+	* trans.c (gfc_allocate_using_lib): New argument and logic for events.
+	(gfc_allocate_allocatable): Passing new argument.
+	(trans_code): Handle EXEC_EVENT_POST, EXEC_EVENT_WAIT.
+	* trans.h (gfc_coarray_type): New elements.
+	(gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,
+	gfor_fndecl_caf_event_query): Declare them.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
 
-	* trans-decl.c (gfc_build_qualified_array): Fix coarray tokens
-	for module coarrays with -fcoarray=lib.
-	(get_proc_pointer_decl): As module variable, make only public
-	when not marked as private.
+	Backported from mainline
+	2016-01-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/69128
+	* trans.h (OMPWS_SCALARIZER_BODY): Define.
+	(OMPWS_NOWAIT): Renumber.
+	* trans-stmt.c (gfc_trans_where_3): Only set OMPWS_SCALARIZER_WS
+	if OMPWS_SCALARIZER_BODY is not set already, and set also
+	OMPWS_SCALARIZER_BODY until the final loop creation.
+	* trans-expr.c (gfc_trans_assignment_1): Likewise.
+	* trans-openmp.c (gfc_trans_omp_workshare): Also clear
+	OMPWS_SCALARIZER_BODY.
+	* trans-array.c (gfc_trans_scalarized_loop_end): Don't create
+	OMP_FOR if OMPWS_SCALARIZER_BODY is set.
+
+2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/67451
+	PR fortran/69418
+	* trans-expr.c (gfc_copy_class_to_class): For coarrays just the
+	pointer is passed.  Take it as is without trying to deref the
+	_data component.
+	* trans-stmt.c (gfc_trans_allocate): Take care of coarrays as
+	argument to source=-expression.
+
+2016-01-30  Bud Davis  <jmdavis@link.com>
+	    Mikael Morin  <mikael@gcc.gnu.org>
 
-2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Backport from trunk.
+	PR fortran/59746
+	* symbol.c (gfc_restore_last_undo_checkpoint): Delete
+	a common block symbol if it was put in the list.
 
-	PR fortran/47674
-	* dependency.h:  Actually commit changes.
+2016-01-28  Janus Weil  <janus@gcc.gnu.org>
 
-2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	PR fortran/69484
+	* invoke.texi: Fix documentation of -Wall with respect to -Wtabs.
 
-	PR fortran/47674
-	* dependency.c:  Update copyright years.
-	(gfc_discard_nops):  Add prototype.
-	* dependency.c (discard_nops):  Rename to gfc_discard_nops,
-	make non-static.
-	(gfc_discard_nops):  Use gfc_discard_nops.
-	(gfc_dep_difference):  Likewise.
-	* frontend-passes.c  Update copyright years.
-	(realloc_strings):  New function.  Add prototype.
-	(gfc_run_passes):  Call realloc_strings.
-	(realloc_string_callback):  New function.
-	(create_var):  Add prototype.  Handle case of a
-	scalar character variable.
-	(optimize_trim):  Do not handle allocatable variables.
+2016-01-28  Andre Vehreschild  <vehre@gcc.gnu.org>
 
-2015-01-05  Jakub Jelinek  <jakub@redhat.com>
+	PR fortran/62536
+	* decl.c: Prevent setting gfc_current_ns to NULL when block statement's
+	nesting is incomplete.  There is already an error conditon, so having
+	gfc_current_ns pointing to an eventually wrong namespace does not matter
+	that much.
 
-	Update copyright years.
+2016-01-27  Andre Vehreschild  <vehre@gcc.gnu.org>
 
-	* gfortranspec.c (lang_specific_driver): Update copyright notice
-	dates.
-	* gfc-internals.texi: Bump @copying's copyright year.
-	* gfortran.texi: Ditto.
-	* intrinsic.texi: Ditto.
-	* invoke.texi: Ditto.
+	PR fortran/p69268
+	* trans-stmt.c (gfc_trans_allocate): Make sure the source=
+	expression is evaluated once only. Use gfc_trans_assignment ()
+	instead of explicitly calling gfc_trans_string_copy () to
+	reduce the code complexity in trans_allocate.
 
-2015-01-02  Janus Weil  <janus@gcc.gnu.org>
+2016-01-25  Dominique d'Humieres <dominiq@lps.ens.fr>
 
-	PR fortran/57562
-	* expr.c (find_component_ref): Deal with extended types.
+	PR fortran/68283
+	* primary.c (gfc_variable_attr): revert revision r221955,
+	call gfc_internal_error only if there is no error.
 
-2015-01-02  Tobias Burnus  <burnus@net-b.de>
+2016-01-17  Mikael Morin  <mikael@gcc.gnu.org>
+	    Dominique d'Humieres  <dominiq@lps.ens.fr>
 
-	* trans-decl.c (gfc_build_qualified_array): Fix coarray tokens
-	for module coarrays with -fcoarray=lib.
+	Backport from trunk.
+	PR fortran/61831
+	* trans-array.c (gfc_conv_array_parameter): Guard allocatable
+	component deallocation code generation with descriptorless
+	calling convention flag.
+	* trans-expr.c (gfc_conv_expr_reference): Remove allocatable
+	component deallocation code generation from revision 212329.
+	(expr_may_alias_variables): New function.
+	(gfc_conv_procedure_call): New boolean elemental_proc to factor
+	check for procedure elemental-ness.  Rename boolean f to nodesc_arg
+	and declare it in the outer scope.  Use expr_may_alias_variables,
+	elemental_proc and nodesc_arg to decide whether generate allocatable
+	component deallocation code.
+	(gfc_trans_subarray_assign): Set deep copy flag.
+
+2016-01-17  Paul Thomas  <pault@gcc.gnu.org>
 
-2015-01-02  Janus Weil  <janus@gcc.gnu.org>
+	Backport from trunk.
+	PR fortran/66082
+	* trans-array.c (gfc_conv_array_parameter): Ensure that all
+	non-variable arrays with allocatable components have the
+	components deallocated after the procedure call.
+
+2016-01-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Update copyright years in updated files.
+
+	PR fortran/50221
+	PR fortran/68216
+	PR fortran/63932
+	PR fortran/66408
+	* trans_array.c (gfc_conv_scalarized_array_ref): Pass the
+	symbol decl for deferred character length array references.
+	* trans-stmt.c (gfc_trans_allocate): Keep the string lengths
+	to update deferred length character string lengths.
+	* trans-types.c (gfc_get_dtype_rank_type); Use the string
+	length of deferred character types for the dtype size.
+	* trans.c (gfc_build_array_ref): For references to deferred
+	character arrays, use the domain max value, if it is a variable
+	to set the 'span' and use pointer arithmetic for acces to the
+	element.
+	(trans_code): Set gfc_current_locus for diagnostic purposes.
+
+	PR fortran/67674
+	* trans-expr.c (gfc_conv_procedure_call): Do not fix deferred
+	string lengths of components.
+
+	PR fortran/49954
+	* resolve.c (deferred_op_assign): New function.
+	(gfc_resolve_code): Call it.
+	* trans-array.c (concat_str_length): New function.
+	(gfc_alloc_allocatable_for_assignment): Jump directly to alloc/
+	realloc blocks for deferred character length arrays because the
+	string length might change, even if the shape is the same. Call
+	concat_str_length to obtain the string length for concatenation
+	since it is needed to compute the lhs string length.
+	Set the descriptor dtype appropriately for the new string
+	length.
+	* trans-expr.c (gfc_trans_assignment_1): Fix the rse string
+	length for all characters, other than deferred types. For
+	concatenation operators, push the rse.pre block to the inner
+	most loop so that the temporary pointer and the assignments
+	are properly placed.
+
+	PR fortran/67779
+	* trans_array.c (gfc_conv_scalarized_array_ref): Add missing
+	se->use_offset from condition for calculation of 'base'.
 
-	PR fortran/60507
-	* interface.c (is_procptr_result): New function to check if an
-	expression is a procedure-pointer result.
-	(compare_actual_formal): Use it.
 ^L
 Copyright (C) 2015 Free Software Foundation, Inc.
 
diff --git a/gcc/fortran/ChangeLog-2015 b/gcc/fortran/ChangeLog-2015
new file mode 100644
index 0000000..82e09f9
--- /dev/null
+++ b/gcc/fortran/ChangeLog-2015
@@ -0,0 +1,1491 @@
+2015-12-15  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	Backport from mainline.
+	2015-12-15
+	Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	* resolve.c (resolve_critical): Committing symbols of
+	lock variables.
+
+2015-12-14  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+	Backport from mainline.
+	2015-12-09  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+	* trans.c (gfc_allocate_using_lib,gfc_deallocate_with_status):
+	Introducing __asm__ __volatile__ ("":::"memory")
+	after image control statements.
+	* trans-stmt.c 	(gfc_trans_sync, gfc_trans_event_post_wait,
+	gfc_trans_lock_unlock, gfc_trans_critical): Ditto.
+	* trans-intrinsic.c (gfc_conv_intrinsic_caf_get,
+	conv_caf_send): Introducing __asm__ __volatile__ ("":::"memory")
+	after send, before get and around sendget.
+
+2015-12-04  Release Manager
+
+	* GCC 5.3.0 released.
+
+2015-11-27  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/68218
+	* trans-array.c (gfc_array_init_size): Add gfc_evaluate_now() when
+	array spec in allocate is a function call.
+
+2015-11-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/68196
+	* class.c (has_finalizer_component): Prevent infinite recursion
+	through this function if the derived type and that of its
+	component are the same.
+	* trans-types.c (gfc_get_derived_type): Do the same for proc
+	pointers by ignoring the explicit interface for the component.
+
+	PR fortran/66465
+	* check.c (same_type_check): If either of the expressions is
+	BT_PROCEDURE, use the typespec from the symbol, rather than the
+	expression.
+
+2015-11-18  Dominique d'Humieres <dominiq@lps.ens.fr>
+
+	PR fortran/65751
+	* expr.c (gfc_check_pointer_assign): Fix error message.
+
+2015-11-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/58027
+	PR fortran/60993
+	* expr.c (gfc_check_init_expr): Prevent a redundant check when a
+	__convert_* function was inserted into an array constructor.
+	(gfc_check_assign_symbol): Check for an initialization expression
+	when a __convert_* was inserted.
+
+2015-11-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67803
+	* array.c (gfc_match_array_constructor): If array constructor included
+	a CHARACTER typespec, check array elements for compatible type.
+
+2015-11-13  Steven G. Kargl  <kargl@gccc.gnu.org>
+
+	PR fortran/68319
+	* decl.c (gfc_match_data, gfc_match_entry): Enforce F2008:C1206.
+	* io.c (gfc_match_format): Ditto.
+	* match.c (gfc_match_st_function): Ditto.
+
+2015-11-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68318
+	* decl.c (get_proc_name): Increment reference count for ENTRY.
+	While here, fix comment and use postfix ++ for consistency.
+
+2015-11-08  Steven g. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68053
+	* decl.c (add_init_expr_to_sym):  Try to reduce initialization expression
+	before testing for a constant value.
+
+2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68224
+	* array.c (match_array_element_spec): Check of invalid NULL().
+	While here, fix nearby comments.
+
+2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68153
+	* check.c (gfc_check_reshape): Improve check for valid SHAPE argument.
+
+2015-11-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68151
+	* match.c (match_case_selector):  Check for invalid type.
+
+2015-01-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/67171
+	* trans-array.c (structure_alloc_comps): On deallocation of
+	class components, reset the vptr to the declared type vtable
+	and reset the _len field of unlimited polymorphic components.
+	*trans-expr.c (gfc_find_and_cut_at_last_class_ref): Bail out on
+	allocatable component references to the right of part reference
+	with non-zero rank and return NULL.
+	(gfc_reset_vptr): Simplify this function by using the function
+	gfc_get_vptr_from_expr. Return if the vptr is NULL_TREE.
+	(gfc_reset_len): If gfc_find_and_cut_at_last_class_ref returns
+	NULL return.
+
+2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51993
+	* decl.c (gfc_set_constant_character_len): Convert gcc_assert into an
+	if-statement causing an early return leads to valid error message.
+
+2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68154
+	* decl.c (add_init_expr_to_sym): if the char length in the typespec
+	is NULL, check for and use a constructor.
+
+2015-10-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/36192
+	* interface.c (get_expr_storage_size):  Check for INTEGER type before
+	calling gmp routines.
+
+2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68055
+	* decl.c (gfc_match_decl_type_spec): Check for valid kind in old-style
+	declarations.
+
+2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68054
+	* decl.c (match_attr_spec): PROTECTED can only be a module.
+
+2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67939
+	* data.c (create_character_initializer): Deal with zero length string.
+
+2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67885
+	* trans-decl.c (generate_local_decl): Mark PARAMETER entities in
+	BLOCK construct.
+
+2015-10-29  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67805
+	PR fortran/68108
+	* array.c (gfc_match_array_constructor): Check for error from type
+	spec matching.
+	* decl.c (char_len_param_value): Check for valid of charlen parameter.
+	Check for REF_ARRAY.  Reap dead code dating to 2008.
+	match.c (gfc_match_type_spec): Special case the keyword use in REAL.
+
+2015-10-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/67177
+	PR fortran/67977
+	Backport from mainline r228940:
+	* primary.c (match_substring): Add an argument 'deferred' to
+	flag that a substring reference with null start and end should
+	not be optimized away for deferred length strings.
+	(match_string_constant, gfc_match_rvalue): Set the argument.
+	* trans-expr.c (alloc_scalar_allocatable_for_assignment): If
+	there is a substring reference return.
+	* trans-intrinsic.c (conv_intrinsic_move_alloc): For deferred
+	characters, assign the 'from' string length to the 'to' string
+	length. If the 'from' expression is deferred, set its string
+	length to zero. If the 'to' expression has allocatable
+	components, deallocate them.
+
+2015-10-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/58754
+	* trans-stmt.c (gfc_trans_allocate): Do not use the scalar
+	character assignment if the allocate expression is an array
+	descriptor.
+
+2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67900
+	* resolve.c (gfc_verify_binding_labels): Check for NULL pointer.
+
+2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/68019
+	* decl.c (add_init_expr_to_sym): Remove an assert() to allow an error
+	message to be issued.
+
+2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67987
+	* decl.c (char_len_param_value): Unwrap unlong line.  If LEN < 0,
+	force it to zero per the Fortran 90, 95, 2003, and 2008 Standards.
+	* resolve.c (gfc_resolve_substring_charlen): Unwrap unlong line.
+	If 'start' is larger than 'end', length of substring is negative,
+	so explicitly set it to zero.
+	(resolve_charlen): Remove -Wsurprising warning.  Update comment to
+	reflect that the text is from the F2008 standard.
+
+2015-10-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/66079
+	Backport from mainline r224383:
+
+	* trans-expr.c (gfc_conv_procedure_call): Allocatable scalar
+	function results must be freed and nullified after use. Create
+	a temporary to hold the result to prevent duplicate calls.
+	* trans-stmt.c (gfc_trans_allocate): Rename temporary variable
+	as 'source'. Deallocate allocatable components of non-variable
+	'source's.
+
+2015-10-18  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/67721
+	PR fortran/67818
+	Backport from mainline r222477:
+
+	2015-04-27  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/59678
+	PR fortran/65841
+	* trans-array.c (duplicate_allocatable): Fixed deep copy of
+	allocatable components, which are liable for copy only, when
+	they are allocated.
+	(gfc_duplicate_allocatable): Add deep-copy code into if
+	component allocated block. Needed interface change for that.
+	(gfc_copy_allocatable_data): Supplying NULL_TREE for code to
+	add into if-block for checking whether a component was
+	allocated.
+	(gfc_duplicate_allocatable_nocopy): Likewise.
+	(structure_alloc_comps): Likewise.
+	* trans-array.h: Likewise.
+	* trans-expr.c (gfc_trans_alloc_subarray_assign): Likewise.
+	* trans-openmp.c (gfc_walk_alloc_comps): Likewise.
+
+2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67802
+	* decl.c (add_init_expr_to_sym): Numeric constant for character
+	length must be an INTEGER.
+
+2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67616
+	* primary.c (gfc_match_structure_constructor): Use a possibly
+	host-associated symtree to prevent ICE.
+
+2015-10-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66979
+	* io.c (gfc_resolve_filepos): Check for a UNIT number.  Add a nearby
+	missing 'return false'.
+
+2015-10-01  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/67721
+	* trans-expr.c (gfc_trans_assignment_1): Remove the non-constantness
+	condition guarding deep copy.
+
+2015-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67614
+	* resolve.c (gfc_resolve_code): Prevent ICE for invalid EXPR_NULL.
+
+2015-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67525
+	* parse.c (match_deferred_characteristics): Remove an assert, which
+	allows an invalid SELECT TYPE selector to be detected.
+
+2015-09-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67615
+	* resolve.c (gfc_resolve_code): Check for scalar expression in
+	arithmetic-if.
+
+2015-09-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/67526
+	* expr.c (gfc_check_init_expr): Do not dereference a NULL pointer.
+
+2015-09-04  Manuel López-Ibáñez  <manu@gcc.gnu.org>
+
+	PR fortran/67429
+	* error.c (gfc_clear_pp_buffer): Reset last_location, otherwise
+	caret lines might be skipped when actually giving a diagnostic.
+
+2015-08-07  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/66929
+	* trans-array.c (gfc_get_proc_ifc_for_expr): Use esym as procedure
+	symbol if available.
+
+2015-08-05  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64921
+	* class.c (generate_finalization_wrapper): Set finalization
+	procedure symbol's always_explicit attribute.
+
+2015-08-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66942
+	* trans-expr.c (gfc_conv_procedure_call): Avoid NULL pointer reference
+
+2015-07-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64986
+	* trans-expr.c (gfc_trans_assignment_1): Put component deallocation
+	code at the beginning of the block.
+
+2015-07-21  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/66035
+	* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_assignment):
+	Compute the size to allocate for class and derived type objects
+	correclty.
+	(gfc_trans_subcomponent_assign): Only allocate memory for a
+	component when the object to assign is not an allocatable class
+	object (the memory is already present for allocatable class objects).
+	Furthermore use copy_class_to_class for assigning the rhs to the
+	component (may happen for dummy class objects on the rhs).
+
+2015-07-17  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	* trans-intrinsic.c (conv_co_collective): Remove redundant address
+	operator in the generated code.
+
+2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66724
+	PR fortran/66724
+	* io.c (is_char_type): Call gfc_resolve_expr ().
+	(match_open_element, match_dt_element, match_inquire_element): Fix
+	ASYNCHRONOUS case.
+
+2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66864
+	* simplify.c (gfc_simplify_floor): Set precision of temporary to
+	that of arg.
+
+2015-07-16  Steven G. Kargl   <kargl@gcc.gnu.org>
+
+	PR fortran/66545
+	* primary.c (match_sym_complex_part): Do not dereference NULL pointer.
+
+2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56520
+	* match.c (gfc_match_name): Special case unary minus and plus.
+
+2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	* io.c (check_char_variable): New function.
+	(match_open_element, match_close_element, match_file_element,
+	match_dt_element, match_inquire_element, match_wait_element): Use it.
+
+2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66725
+	* io.c (is_char_type): New function to test for BT_CHARACTER
+	(gfc_match_open, gfc_match_close, match_dt_element): Use it.
+
+2015-07-16  Release Manager
+
+	* GCC 5.2.0 released.
+
+2015-06-24  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/66549
+	* resolve.c (resolve_global_procedure): Don't save and restore
+	OpenMP state around the call to gfc_resolve.
+	(gfc_resolve): Save OpenMP state on entry and restore it on return.
+
+2015-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66385
+	Backport from trunk
+	* frontend-passes.c (combine_array_constructor): Return early if
+	inside a FORALL loop.
+
+2015-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	* intrinsic.texi:  Change \leq to < in descrition of imaginary
+	part in argument to log.
+
+2015-06-11  Pierre-Marie de Rodat  <derodat@adacore.com>
+
+	* f95-lang.c (gfc_create_decls): Register the main translation unit
+	through the new debug hook.
+
+2015-06-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66245
+	* match.c (gfc_match_type_is, gfc_match_class_is):  Check if the
+	return type spec or derived type spec is validate.
+
+2015-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66347
+	* resolve.c (apply_default_init_local): Do not dereference a NULL
+	pointer.
+
+2015-06-05  Russell Whitesides  <russelldub@gmail.com>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/40958
+	PR fortran/60780
+	PR fortran/66377
+	* module.c (load_equiv): Add check for loading duplicate EQUIVALENCEs
+	from different modules.  Eliminate the pruning of unused
+	equivalence-objects
+
+
+2015-06-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66380
+	* simplify.c (gfc_simplify_reshape): Convert assert into returning
+	NULL, which triggers an error condition.
+
+2015-05-29  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/66257
+	* resolve.c (resolve_actual_arglist): Don't throw an error
+	if the argument with procedure pointer component is not a variable.
+
+2015-05-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-05-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/66199
+	* trans-openmp.c (gfc_trans_omp_teams): Set OMP_TEAMS_COMBINED for
+	combined constructs.
+	(gfc_trans_omp_target): Make sure BIND_EXPR has non-NULL
+	BIND_EXPR_BLOCK.
+
+2015-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/65903
+	* io.c (format_lex): Change to NONSTRING when checking for
+	possible doubled quote.
+	* scanner.c (gfc_next_char_literal): Revert change from 64506
+	and add a check for quotes and return.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66106
+	* interface.c(gfc_match_end_interface): Enforce F2008 C1202 (R1201).
+	* match.c(gfc_op2string): Return 'none' for INTRINSIC_NONE.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66057
+	* decl.c(gfc_match_generic):  Detected a malformed GENERIC statement.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66052
+	* decl.c(gfc_match_protected): Prevent dereference of NULL pointer.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66045
+	* expr.c (gfc_check_assign):  Check for assignment of NULL() instead
+	of the (intended) pointer assignment.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66044
+	* decl.c(gfc_match_entry):  Change a gfc_internal_error() into
+	a gfc_error()
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66043
+	* check.c (gfc_check_storage_size): Prevent the direct use of NULL()
+	in STORAGE_SIZE() reference.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66040
+	* parse.c(verify_st_order): Replace a gfc_internal_error with your
+	generic gfc_error.
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/66039
+	* io.c (match_filepos): Check for incomplete/mangled REWIND, FLUSH,
+	BACKSPACE, and ENDFILE statements
+
+2015-05-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64925
+	* symbol.c(check_conflict):  Check for a conflict between a dummy
+	argument and an internal procedure name.
+
+2015-05-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65976
+	* invoke.texi:  Remove 'no-' in '-fno-fixed-form'
+
+2015-04-22  Release Manager
+
+	* GCC 5.1.0 released.
+
+2015-04-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65429
+	* decl.c (add_init_expr_to_sym): Set the length type parameter.
+
+2015-04-10  Tobias Burnus  <burnus@net-b.de>
+
+	* trans-stmt.c (gfc_trans_lock_unlock): Implement -fcoarray=lib
+	version; reject not-yet-implemented variants.
+	* trans-types.c (gfc_get_derived_type): For lock_type with
+	-fcoarray=lib, use a void pointer as type.
+	* trans.c (gfc_allocate_using_lib, gfc_allocate_allocatable):
+	Handle lock_type with -fcoarray=lib.
+
+2015-04-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/56674
+	PR fortran/58813
+	PR fortran/59016
+	PR fortran/59024
+	* symbol.c (save_symbol_data, gfc_save_symbol_data): Rename the
+	former to the latter and make it non-static.  Update callers.
+	* gfortran.h (gfc_save_symbol_data): New prototype.
+	* decl.c (gfc_match_decl_type_spec): Call 'gfc_save_symbol_data'
+	before modifying symbols 'sym' and 'dt_sym'.
+
+2013-04-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/56852
+	* primary.c (gfc_variable_attr): Avoid ICE on AR_UNKNOWN if any
+	of the index variables are untyped and errors are present.
+
+2015-04-07  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/65548
+	* trans-stmt.c (gfc_trans_allocate): For intrinsic functions
+	use conv_expr_descriptor() instead of conv_expr_reference().
+
+2015-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/65597
+	* trans-openmp.c (gfc_trans_omp_do): For !simple simd with explicit
+	linear clause for the iterator set OMP_CLAUSE_LINEAR_NO_COPYIN.
+	For implcitly added !simple OMP_CLAUSE_LINEAR set it too.  Use step 1
+	instead of the original step on the new iterator - count.
+
+2015-03-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64952
+	PR fortran/65532
+	* gfortran.h (struct gfc_namespace): New field 'types_resolved'.
+	* resolve.c (resolve_types): Return early if field 'types_resolved'
+	is set.  Set 'types_resolved' at the end.
+
+2015-03-24  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/55901
+	* trans-expr.c (gfc_conv_structure): Fixed indendation.
+	Using integer_zero_node now instead of explicitly
+	constructing a integer constant zero node.
+	(gfc_conv_derived_to_class): Add handling of _len component,
+	i.e., when the rhs has a string_length then assign that to
+	class' _len, else assign 0.
+	(gfc_conv_intrinsic_to_class): Likewise.
+
+2015-03-24  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/64787
+	PR fortran/57456
+	PR fortran/63230
+	* class.c (gfc_add_component_ref):  Free no longer needed
+	ref-chains to prevent memory loss.
+	(find_intrinsic_vtab): For deferred length char arrays or
+	unlimited polymorphic objects, store the size in bytes of one
+	character in the size component of the vtab.
+	* gfortran.h: Added gfc_add_len_component () define.
+	* trans-array.c (gfc_trans_create_temp_array): Switched to new
+	function name for getting a class' vtab's field.
+	(build_class_array_ref): Likewise.
+	(gfc_array_init_size): Using the size information from allocate
+	more consequently now, i.e., the typespec of the entity to
+	allocate is no longer needed.  This is to address the last open
+	comment in PR fortran/57456.
+	(gfc_array_allocate): Likewise.
+	(structure_alloc_comps): gfc_copy_class_to_class () needs to
+	know whether the class is unlimited polymorphic.
+	* trans-array.h: Changed interface of gfc_array_allocate () to
+	reflect the no longer needed typespec.
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): New.
+	(gfc_reset_len): New.
+	(gfc_get_class_array_ref): Switch to new function name for
+	getting a class' vtab's field.
+	(gfc_copy_class_to_class):  Added flag to know whether the class
+	to copy is unlimited polymorphic.  Adding _len dependent code
+	then, which calls ->vptr->copy () with four arguments adding
+	the length information ->vptr->copy(from, to, from_len, to_cap).
+	(gfc_conv_procedure_call): Switch to new function name for
+	getting a class' vtab's field.
+	(alloc_scalar_allocatable_for_assignment): Use the string_length
+	as computed by gfc_conv_expr and not the statically backend_decl
+	which may be incorrect when ref-ing.
+	(gfc_trans_assignment_1): Use the string_length variable and
+	not the rse.string_length.  The former has been computed more
+	generally.
+	* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Switch to new
+	function name for getting a class' vtab's field.
+	(gfc_conv_intrinsic_storage_size): Likewise.
+	(gfc_conv_intrinsic_transfer): Likewise.
+	* trans-stmt.c (gfc_trans_allocate): Restructured to evaluate
+	source=expr3 only once before the loop over the objects to
+	allocate, when the objects are not arrays. Doing correct _len
+	initialization and calling of vptr->copy () fixing PR 64787.
+	(gfc_trans_deallocate): Reseting _len to 0, preventing future
+	errors.
+	* trans.c (gfc_build_array_ref): Switch to new function name
+	for getting a class' vtab's field.
+	(gfc_add_comp_finalizer_call): Likewise.
+	* trans.h: Define the prototypes for the gfc_class_vtab_*_get ()
+	and gfc_vptr_*_get () functions.
+	Added gfc_find_and_cut_at_last_class_ref () and
+	gfc_reset_len () routine prototype.  Added flag to
+	gfc_copy_class_to_class () prototype to signal an unlimited
+	polymorphic entity to copy.
+
+2015-03-24  Iain Sandoe  <iain@codesourcery.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	* gfortran.texi (_gfortran_caf_sync_memory): Improve wording.
+
+2015-03-23  Paul Thomas  <pault@gcc.gnu.org>
+	    Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64952
+	* gfortran.h (struct symbol_attribute) : New field
+	'array_outer_dependency'.
+	* trans.h (struct gfc_ss_info): New field 'array_outer_dependency'.
+	* module.c (enum ab_attribute): New value AB_ARRAY_OUTER_DEPENDENCY.
+	(attr_bits): Append same value to initializer.
+	(mio_symbol_attribute): Handle 'array_outer_dependency' attr
+	in module read and write.
+	* resolve.c (update_current_proc_outer_array_dependency): New function.
+	(resolve_function, resolve_call): Add code to update current procedure's
+	'array_outer_dependency' attribute.
+	(resolve_variable): Mark current procedure with attribute
+	array_outer_dependency if the variable is an array coming from outside
+	the current namespace.
+	(resolve_fl_procedure): Mark a procedure without body with attribute
+	'array_outer_dependency'.
+	* trans-array.c (gfc_conv_resolve_dependencies): If any ss is
+	marked as 'array_outer_dependency' generate a temporary.
+	(gfc_walk_function_expr): If the function may reference external arrays,
+	mark the head gfc_ss with flag 'array_outer_dependency'.
+
+2015-03-22 Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/59513
+	* gfortran.texi (Read/Write after EOF marker): New information.
+
+2015-03-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gfortran.texi (_gfortran_caf_sync_memory): Put @{xxx} in one
+	line.
+
+2015-03-21  Tobias Burnus  <burnus@net-b.de>
+
+	* gfortran.texi (_gfortran_caf_sync_all, _gfortran_caf_sync_images,
+	_gfortran_caf_sync_memory, _gfortran_caf_error_stop,
+	_gfortran_caf_error_stop_str, _gfortran_caf_atomic_define,
+	_gfortran_caf_atomic_ref, _gfortran_caf_atomic_cas,
+	_gfortran_caf_atomic_op): New sections.
+
+2015-03-21  Tobias Burnus  <burnus@net-b.de>
+
+	* trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented
+	coindexed coarray accesses.
+
+2015-03-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/59198
+	* trans-types.c (gfc_get_derived_type): If an abstract derived
+	type with procedure pointer components has no other type of
+	component, return the backend_decl. Otherwise build the
+	components if any of the non-procedure pointer components have
+	no backend_decl.
+
+2015-03-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/64432
+	*trans-intrinisic.c (conv_intrinsic_system_clock): Check the
+	smallest kind passed in user arguments and hardcode tesults for
+	KIND=1 or KIND=2 to indicate no clock available.
+
+2015-03-16  Andre Vehreschild  <vehre@gmx.de>
+
+	* resolve.c: Prevent segfault on illegal input.
+
+2015-03-14  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/61138
+	* trans-expr.c (gfc_trans_pointer_assignment): Clear DESCRIPTOR_ONLY
+	field before reusing LSE.
+
+2015-03-11  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	PR libfortran/65200
+	* gfortran.texi: Document behavior when opening files without
+	explicit ACTION= specifier.
+
+2015-03-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/65024
+	* trans-expr.c (gfc_conv_component_ref): If the component
+	backend declaration is missing and the derived type symbol is
+	available in the reference, call gfc_build_derived_type.
+
+2015-03-10  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	* trans.h (caf_sync_memory): New function decl tree.
+	* trans-decl.c (gfc_build_builtin_function_decls): Define it.
+	(create_main_function): Don't call sync_synchronize and leave
+	it to the CAF library.
+	* trans-stmt.c (gfc_trans_stop): Ditto.
+	(gfc_trans_sync): Ditto; add call library call for sync memory.
+
+2015-03-08  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/60898
+	* resolve.c (resolve_symbol): Check that the symbol found by
+	name lookup really is the current symbol being resolved.
+
+2015-03-02  Tobias Burnus  <burnus@net-b.de>
+
+	* check.c (gfc_check_atomic): Properly check for coarrayness
+	and for being coindexed.
+
+2015-02-26  Martin Liska  <mliska@suse.cz>
+
+	* resolve.c: Rename enum 'comparison' to 'compare_result' as
+	solution for -Wodr issue.
+
+2015-02-24  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/64625
+	* f95-lang.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):
+	Remove macros.
+	(DEF_FUNCTION_TYPE_VAR_7, DEF_FUNCTION_TYPE_VAR_11): New macros.
+	* types.def (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)
+	(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
+	Remove function types.
+	(BT_FN_VOID_INT_SIZE_PTR_PTR_PTR)
+	(BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_INT_INT_VAR)
+	(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
+	New function types.
+
+2015-02-22  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR fortran/64980
+	PR fortran/61960
+	* trans-expr.c (gfc_apply_interface_mapping_to_expr): Remove mapping
+	for component references to class objects.
+	(gfc_conv_procedure_call): Compare the class by name.
+
+2015-02-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/64506
+	* scanner.c (gfc_next_char_literal): For free form source,
+	check for '!' and if found, clear the comment and go back
+	and get the next character. For fixed form source, skip the
+	rest of the line.
+
+2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/64932
+	* trans-stmt.c (gfc_trans_deallocate): If a component array
+	expression is not a descriptor type and it is a derived type
+	that has allocatable components and is not finalizable, then
+	deallocate the allocatable components.
+
+2015-02-08  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/63744
+	* module.c (check_for_ambiguous): Change argument type
+	from gfc_symbol to gfc_symtree.  Check local (symtree) name
+	instead of original (symbol) name.
+	(read_module): Update caller.
+
+2015-02-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/63205
+	* gfortran.h: Add 'must finalize' field to gfc_expr and
+	prototypes for gfc_is_alloc_class_scalar_function and for
+	gfc_is_alloc_class_array_function.
+	* expr.c (gfc_is_alloc_class_scalar_function,
+	gfc_is_alloc_class_array_function): New functions.
+	* trans-array.c (gfc_add_loop_ss_code): Do not move the
+	expression for allocatable class scalar functions outside the
+	loop.
+	(conv_array_index_offset): Cope with deltas being NULL_TREE.
+	(build_class_array_ref): Do not return with allocatable class
+	array functions. Add code to pick out the returned class array.
+	Dereference if necessary and return if not a class object.
+	(gfc_conv_scalarized_array_ref): Cope with offsets being NULL.
+	(gfc_walk_function_expr): Return an array ss for the result of
+	an allocatable class array function.
+	* trans-expr.c (gfc_conv_subref_array_arg): Remove the assert
+	that the argument should be a variable. If an allocatable class
+	array function, set the offset to zero and skip the write-out
+	loop in this case.
+	(gfc_conv_procedure_call): Add allocatable class array function
+	to the assert. Call gfc_conv_subref_array_arg for allocatable
+	class array function arguments with derived type formal arg..
+	Add the code for handling allocatable class functions, including
+	finalization calls to prevent memory leaks.
+	(arrayfunc_assign_needs_temporary): Return if an allocatable
+	class array function.
+	(gfc_trans_assignment_1): Set must_finalize to rhs expression
+	for allocatable class functions. Set scalar_to_array as needed
+	for scalar class allocatable functions assigned to an array.
+	Nullify the allocatable components corresponding the the lhs
+	derived type so that the finalization does not free them.
+
+2015-01-29  Andre Vehreschild  <vehre@gmx.de>
+	    Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/60289
+	Initial patch by Janus Weil
+	* resolve.c (resolve_allocate_expr): Add check for comp. only
+	when target is not unlimited polymorphic.
+	* trans-stmt.c (gfc_trans_allocate): Assign correct value to
+	_len component of unlimited polymorphic entities.
+
+2015-02-05  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64943
+	* resolve.c (resolve_transfer): Also check structure
+	constructors.
+
+2015-02-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/64757
+	* resolve.c (resolve_structure_cons): Obtain the rank of class
+	components.
+	* trans-expr.c (gfc_trans_alloc_subarray_assign): Do the
+	assignment to allocatable class array components.
+	(alloc_scalar_allocatable_for_subcomponent_assignment): If comp
+	is a class component, allocate to the _data field.
+	(gfc_trans_subcomponent_assign): If a class component with a
+	derived type expression set the _vptr field and for array
+	components, call gfc_trans_alloc_subarray_assign. For scalars,
+	the assignment is performed here.
+
+2015-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* options.c: Include langhooks.h.
+	(gfc_post_options): Change lang_hooks.name based on
+	selected -std= mode.
+
+2015-02-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	* intrinsic.texi (CO_ASSOCIATED): c_prt_1 should be c_ptr_1.
+
+2015-01-30  Andre Vehreschild  <vehre@gmx.de>
+
+	* trans-decl.c (gfc_get_symbol_decl): Removed duplicate code.
+	* trans-expr.c (gfc_conv_intrinsic_to_class): Fixed indentation.
+	Fixed datatype of charlen to be a 32-bit int.
+
+2015-02-01  Joseph Myers  <joseph@codesourcery.com>
+
+	* error.c (gfc_warning (const char *, ...), gfc_warning_now (const
+	char *, ...)): Remove functions.
+	* gfortran.h (gfc_warning (const char *, ...), gfc_warning_now
+	(const char *, ...)): Remove declarations.
+	* arith.c, check.c, data.c, decl.c, frontend-passes.c,
+	interface.c, intrinsic.c, io.c, matchexp.c, module.c, openmp.c,
+	options.c, parse.c, primary.c, resolve.c, scanner.c, symbol.c,
+	trans-common.c, trans-const.c, trans-stmt.c: All callers of
+	gfc_warning and gfc_warning_now changed to pass 0 or option number
+	as first argument.
+
+2015-01-30  Joseph Myers  <joseph@codesourcery.com>
+
+	* f95-lang.c, gfortranspec.c, trans-const.c, trans-expr.c: All
+	callers of fatal_error changed to pass input_location as first
+	argument.
+
+2015-01-28  Tobias Burnus  <burnus@net-b.de>
+
+	* intrinsic.texi (CO_BROADCAST): Correct argument description.
+
+2015-01-27  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/63861
+	* trans-openmp.c (gfc_has_alloc_comps, gfc_trans_omp_clauses):
+	Fix handling for scalar coarrays.
+	* trans-types.c (gfc_get_element_type): Add comment.
+
+2015-01-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR fortran/64771
+	* interface.c: Remove <algorithm>.
+	(check_dummy_characteristics): Use MAX instead of std::max.
+
+2015-01-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/62044
+	* resolve.c (resolve_allocate_expr): If the default initializer
+	is NULL, keep the original MOLD expression so that the correct
+	typespec is available.
+
+2015-01-26  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64771
+	* interface.c (check_dummy_characteristics): Fix coarray handling.
+
+2015-01-26  Tobias Burnus  <burnus@net-b.de>
+
+	* io.c (gfc_match_inquire): Replace "-1" by a defined constant.
+
+2015-01-26  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/64230
+	* class.c (finalize_component): New argument 'sub_ns'. Insert code to
+	check if 'expr' is associated.
+	(generate_finalization_wrapper): Rename 'ptr' symbols to 'ptr1' and
+	'ptr2'. Pass 'sub_ns' to finalize_component.
+
+2015-01-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/62044
+	* decl.c (gfc_match_derived_decl): Don't insert a new symtree element.
+	* module.c (MOD_VERSION): Bump.
+	(write_module): Don't write list of extensions.
+	(read_module): Don't jump over list of extensions;
+	don't load list of extensions.
+	(load_derived_extensions, write_dt_extensions,
+	 write_derived_extensions): Remove.
+
+2015-01-24  Tobias Burnus  <burnus@net-b.de>
+
+	* parse.c (gfc_parse_file): Fix two-location gfc_error call.
+
+2015-01-23  Martin Liska  <mliska@suse.cz>
+
+	* decl.c (attr_decl1): Workaround -Wmaybe-uninitialized
+	false positive during profiledbootstrap by initializing them.
+	* matchexp.c (match_mult_operand): Likewise.
+	* module.c (write_atom): Likewise.
+	(read_module): Likewise.
+
+2015-01-23  Tom de Vries  <tom@codesourcery.com>
+
+	PR libgomp/64672
+	* lang.opt (fopenacc): Mark as LTO option.
+
+2015-01-23  Tom de Vries  <tom@codesourcery.com>
+
+	PR libgomp/64707
+	* lang.opt (fopenmp): Mark as LTO option.
+
+2015-01-23  Andre Vehreschild  <vehre@gmx.de>
+
+	* trans-decl.c (gfc_finish_var_decl): Fixed moved comment.
+	* trans-stmt.c (gfc_trans_allocate): Fixed indentation.
+
+2015-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* gfc-diagnostic.def (DK_ICE_NOBT): New kind.
+
+2015-01-23  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/60922
+	* class.c (finalize_component): Apply the check for 'fini_coarray' only
+	to coarray components.
+
+2015-01-23  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64726
+	* trans-openmp.c (gfc_trans_oacc_combined_directive): Fix
+	loop generation.
+
+2015-01-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/61933
+	* libgfortran.h:
+	* trans-io.c (set_parameter_value): Delete use of has_iostat.
+	Redefine to not generate any runtime error check calls.
+	(set_parameter_value_chk): Rename of the former
+	set_parameter_value with the runtime error checks and fix
+	whitespace. (set_parameter_value_inquire): New function that
+	builds a runtime conditional block to set the INQUIRE
+	common parameter block unit number to -2 when unit numbers
+	exceed positive KIND=4 limits. (gfc_trans_open): Whitespace.
+	For unit, use the renamed set_parameter_value_chk.
+	(gfc_trans_close): Likewise use renamed function.
+	(build_filepos): Whitespace and use renamed function.
+	(gfc_trans_inquire): Whitespace and for unit use
+	set_parameter_value and set_parameter_value_inquire.
+	(gfc_trans_wait): Remove p->iostat from call to
+	set_parameter_value. Use new set_parameter_value_chk for unit.
+	(build_dt): Use the new set_parameter_value without p->iostat
+	and fix whitespace. Use set_parameter_value_chk for unit.
+
+2015-01-21  Thomas Koenig  <tkoenig@netcologne.de>
+
+	PR fortran/57023
+	* dependency.c (callback_dummy_intent_not_int):  New function.
+	(dummy_intent_not_in):  New function.
+	(gfc_full_array_ref_p):  Use dummy_intent_not_in.
+
+2015-01-18  Andre Vehreschild  <vehre@gmx.de>
+	    Janus Weil <janus@gcc.gnu.org>
+
+	PR fortran/60255
+	* class.c (gfc_get_len_component): New.
+	(gfc_build_class_symbol): Add _len component to unlimited
+	polymorphic entities.
+	(find_intrinsic_vtab): Removed emitting of error message.
+	* gfortran.h: Added prototype for gfc_get_len_component.
+	* simplify.c (gfc_simplify_len): Use _len component where
+	available.
+	* trans-expr.c (gfc_class_len_get): New.
+	(gfc_conv_intrinsic_to_class): Add handling for deferred
+	character arrays.
+	(gfc_conv_structure): Treat _len component correctly.
+	(gfc_conv_expr): Prevent bind_c handling when not required.
+	(gfc_trans_pointer_assignment): Propagate _len component.
+	* trans-stmt.c (class_has_len_component): New.
+	(trans_associate_var): _len component treatment for associate
+	context.
+	(gfc_trans_allocate): Same as for trans_associate_var()
+	* trans.h: Added prototype for gfc_class_len_get.
+
+2015-01-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/57959
+	* trans-expr.c (gfc_trans_subcomponent_assign): Use a deep copy
+	for allocatable components, where the source is a variable.
+
+2015-01-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/55901
+	* primary.c (gfc_match_varspec): Exclude dangling associate-
+	names with dimension 0 from being counted as arrays.
+	* resolve.c (resolve_assoc_var): Sub-strings are permissible
+	for associate-names, so exclude characters from the test for
+	misuse as arrays.
+	* trans-decl.c (gfc_get_symbol_decl): Associate-names can use
+	the hidden string length variable of their associated target.
+	Signal this by setting 'length' to a constant, if the decl for
+	the string length is a variable.
+
+2015-01-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/64578
+	* trans-expr.c (gfc_trans_pointer_assignment): Make sure that
+	before reinitializing rse, to add the rse.pre to block before
+	creating 'ptrtemp'.
+	* trans-intrinsic.c (gfc_conv_associated): Deal with the class
+	data being a descriptor.
+
+2015-01-17  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/60357
+	* primary.c (build_actual_constructor): Prevent warning.
+	* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_
+	assignment): New function encapsulates treatment of allocatable
+	components.
+	(gfc_trans_subcomponent_assign): Needed to distinguish between
+	regular assignment and initilization.
+	(gfc_trans_structure_assign): Same.
+	(gfc_conv_structure): Same.
+
+	PR fortran/61275
+	* gfortran.h: deferred_parameter is not needed, because
+	it artificial does the trick completely.
+	* primary.c (build_actual_constructor): Same.
+	(gfc_convert_to_structure_constructor): Same.
+	* resolve.c (resolve_fl_derived0): Same.
+	* trans-expr.c (gfc_conv_component_ref): Prevent treating
+	allocatable deferred length char arrays here.
+	(gfc_trans_subcomponent_assign): Same as above.
+	* trans-types.c (gfc_sym_type): This is done in
+	gfc_get_derived_type already.
+
+2015-01-17  Andre Vehreschild  <vehre@gmx.de>
+
+	PR fortran/60334
+	* trans-decl.c (gfc_get_symbol_decl):Use a ref on the string
+	length when the symbol is declared to be a result.
+	* trans-expr.c (gfc_conv_procedure_call): Strip deref on the
+	string length when functions are nested and the string length
+	is a reference already.
+
+2015-01-16  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/45290
+	* decl.c (match_pointer_init): Error out if resolution of init expr
+	failed.
+
+2015-01-15  Tobias Burnus  <burnus@net-b.de>
+
+	* openmp.c (check_symbol_not_pointer, resolve_oacc_data_clauses,
+	resolve_oacc_deviceptr_clause, resolve_omp_clauses,
+	gfc_resolve_oacc_declare): Replace '%s' by %qs.
+
+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>
+	    Cesar Philippidis  <cesar@codesourcery.com>
+	    James Norris  <jnorris@codesourcery.com>
+	    Ilmir Usmanov  <i.usmanov@samsung.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	* lang.opt (fopenacc): New option.
+	* cpp.c (cpp_define_builtins): Conditionally define _OPENACC.
+	* dump-parse-tree.c (show_omp_node): Split part of it into...
+	(show_omp_clauses): ... this new function.
+	(show_omp_node, show_code_node): Handle EXEC_OACC_PARALLEL_LOOP,
+	EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,
+	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
+	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
+	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
+	(show_namespace): Update for OpenACC.
+	* f95-lang.c (DEF_FUNCTION_TYPE_VAR_2, DEF_FUNCTION_TYPE_VAR_8)
+	(DEF_FUNCTION_TYPE_VAR_12, DEF_GOACC_BUILTIN)
+	(DEF_GOACC_BUILTIN_COMPILER): New macros.
+	* types.def (BT_FN_VOID_INT_INT_VAR)
+	(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)
+	(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):
+	New function types.
+	* gfortran.h (gfc_statement): Add ST_OACC_PARALLEL_LOOP,
+	ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,
+	ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,
+	ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA,
+	ST_OACC_LOOP, ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE,
+	ST_OACC_WAIT, ST_OACC_CACHE, ST_OACC_KERNELS_LOOP,
+	ST_OACC_END_KERNELS_LOOP, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,
+	ST_OACC_ROUTINE.
+	(struct gfc_expr_list): New data type.
+	(gfc_get_expr_list): New macro.
+	(gfc_omp_map_op): Add OMP_MAP_FORCE_ALLOC, OMP_MAP_FORCE_DEALLOC,
+	OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM, OMP_MAP_FORCE_TOFROM,
+	OMP_MAP_FORCE_PRESENT, OMP_MAP_FORCE_DEVICEPTR.
+	(OMP_LIST_FIRST, OMP_LIST_DEVICE_RESIDENT, OMP_LIST_USE_DEVICE)
+	(OMP_LIST_CACHE): New enumerators.
+	(struct gfc_omp_clauses): Add async_expr, gang_expr, worker_expr,
+	vector_expr, num_gangs_expr, num_workers_expr, vector_length_expr,
+	wait_list, tile_list, async, gang, worker, vector, seq,
+	independent, wait, par_auto, gang_static, and loc members.
+	(struct gfc_namespace): Add oacc_declare_clauses member.
+	(gfc_exec_op): Add EXEC_OACC_KERNELS_LOOP,
+	EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS,
+	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
+	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
+	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
+	(gfc_free_expr_list, gfc_resolve_oacc_directive)
+	(gfc_resolve_oacc_declare, gfc_resolve_oacc_parallel_loop_blocks)
+	(gfc_resolve_oacc_blocks): New prototypes.
+	* match.c (match_exit_cycle): Handle EXEC_OACC_LOOP and
+	EXEC_OACC_PARALLEL_LOOP.
+	* match.h (gfc_match_oacc_cache, gfc_match_oacc_wait)
+	(gfc_match_oacc_update, gfc_match_oacc_declare)
+	(gfc_match_oacc_loop, gfc_match_oacc_host_data)
+	(gfc_match_oacc_data, gfc_match_oacc_kernels)
+	(gfc_match_oacc_kernels_loop, gfc_match_oacc_parallel)
+	(gfc_match_oacc_parallel_loop, gfc_match_oacc_enter_data)
+	(gfc_match_oacc_exit_data, gfc_match_oacc_routine): New
+	prototypes.
+	* openmp.c: Include "diagnostic.h" and "gomp-constants.h".
+	(gfc_free_omp_clauses): Update for members added to struct
+	gfc_omp_clauses.
+	(gfc_match_omp_clauses): Change mask paramter to uint64_t.  Add
+	openacc parameter.
+	(resolve_omp_clauses): Add openacc parameter.  Update for OpenACC.
+	(struct fortran_omp_context): Add is_openmp member.
+	(gfc_resolve_omp_parallel_blocks): Initialize it.
+	(gfc_resolve_do_iterator): Update for OpenACC.
+	(gfc_resolve_omp_directive): Call
+	resolve_omp_directive_inside_oacc_region.
+	(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE)
+	(OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYPRIVATE)
+	(OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN, OMP_CLAUSE_REDUCTION)
+	(OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE)
+	(OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_COLLAPSE)
+	(OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE)
+	(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH)
+	(OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND)
+	(OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM)
+	(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO)
+	(OMP_CLAUSE_FROM, OMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT)
+	(OMP_CLAUSE_DIST_SCHEDULE): Use uint64_t.
+	(OMP_CLAUSE_ASYNC, OMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS)
+	(OMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_COPY, OMP_CLAUSE_COPYOUT)
+	(OMP_CLAUSE_CREATE, OMP_CLAUSE_PRESENT)
+	(OMP_CLAUSE_PRESENT_OR_COPY, OMP_CLAUSE_PRESENT_OR_COPYIN)
+	(OMP_CLAUSE_PRESENT_OR_COPYOUT, OMP_CLAUSE_PRESENT_OR_CREATE)
+	(OMP_CLAUSE_DEVICEPTR, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER)
+	(OMP_CLAUSE_VECTOR, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT)
+	(OMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_DEVICE_RESIDENT)
+	(OMP_CLAUSE_HOST_SELF, OMP_CLAUSE_OACC_DEVICE, OMP_CLAUSE_WAIT)
+	(OMP_CLAUSE_DELETE, OMP_CLAUSE_AUTO, OMP_CLAUSE_TILE): New macros.
+	(gfc_match_omp_clauses): Handle those.
+	(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES)
+	(OACC_LOOP_CLAUSES, OACC_PARALLEL_LOOP_CLAUSES)
+	(OACC_KERNELS_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES)
+	(OACC_DECLARE_CLAUSES, OACC_UPDATE_CLAUSES)
+	(OACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES)
+	(OACC_WAIT_CLAUSES): New macros.
+	(gfc_free_expr_list, match_oacc_expr_list, match_oacc_clause_gang)
+	(gfc_match_omp_map_clause, gfc_match_oacc_parallel_loop)
+	(gfc_match_oacc_parallel, gfc_match_oacc_kernels_loop)
+	(gfc_match_oacc_kernels, gfc_match_oacc_data)
+	(gfc_match_oacc_host_data, gfc_match_oacc_loop)
+	(gfc_match_oacc_declare, gfc_match_oacc_update)
+	(gfc_match_oacc_enter_data, gfc_match_oacc_exit_data)
+	(gfc_match_oacc_wait, gfc_match_oacc_cache)
+	(gfc_match_oacc_routine, oacc_is_loop)
+	(resolve_oacc_scalar_int_expr, resolve_oacc_positive_int_expr)
+	(check_symbol_not_pointer, check_array_not_assumed)
+	(resolve_oacc_data_clauses, resolve_oacc_deviceptr_clause)
+	(oacc_compatible_clauses, oacc_is_parallel, oacc_is_kernels)
+	(omp_code_to_statement, oacc_code_to_statement)
+	(resolve_oacc_directive_inside_omp_region)
+	(resolve_omp_directive_inside_oacc_region)
+	(resolve_oacc_nested_loops, resolve_oacc_params_in_parallel)
+	(resolve_oacc_loop_blocks, gfc_resolve_oacc_blocks)
+	(resolve_oacc_loop, resolve_oacc_cache, gfc_resolve_oacc_declare)
+	(gfc_resolve_oacc_directive): New functions.
+	* parse.c (next_free): Update for OpenACC.  Move some code into...
+	(verify_token_free): ... this new function.
+	(next_fixed): Update for OpenACC.  Move some code into...
+	(verify_token_fixed): ... this new function.
+	(case_executable): Add ST_OACC_UPDATE, ST_OACC_WAIT,
+	ST_OACC_CACHE, ST_OACC_ENTER_DATA, and ST_OACC_EXIT_DATA.
+	(case_exec_markers): Add ST_OACC_PARALLEL_LOOP, ST_OACC_PARALLEL,
+	ST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA, ST_OACC_LOOP,
+	ST_OACC_KERNELS_LOOP.
+	(case_decl): Add ST_OACC_ROUTINE.
+	(push_state, parse_critical_block, parse_progunit): Update for
+	OpenACC.
+	(gfc_ascii_statement): Handle ST_OACC_PARALLEL_LOOP,
+	ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,
+	ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_KERNELS_LOOP,
+	ST_OACC_END_KERNELS_LOOP, ST_OACC_DATA, ST_OACC_END_DATA,
+	ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,
+	ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,
+	ST_OACC_CACHE, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,
+	ST_OACC_ROUTINE.
+	(verify_st_order, parse_spec): Handle ST_OACC_DECLARE.
+	(parse_executable): Handle ST_OACC_PARALLEL_LOOP,
+	ST_OACC_KERNELS_LOOP, ST_OACC_LOOP, ST_OACC_PARALLEL,
+	ST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA.
+	(decode_oacc_directive, parse_oacc_structured_block)
+	(parse_oacc_loop, is_oacc): New functions.
+	* parse.h (struct gfc_state_data): Add oacc_declare_clauses
+	member.
+	(is_oacc): New prototype.
+	* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle
+	EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL,
+	EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS, EXEC_OACC_DATA,
+	EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP, EXEC_OACC_UPDATE,
+	EXEC_OACC_WAIT, EXEC_OACC_CACHE, EXEC_OACC_ENTER_DATA,
+	EXEC_OACC_EXIT_DATA.
+	(resolve_codes): Call gfc_resolve_oacc_declare.
+	* scanner.c (openacc_flag, openacc_locus): New variables.
+	(skip_free_comments): Update for OpenACC.  Move some code into...
+	(skip_omp_attribute): ... this new function.
+	(skip_oacc_attribute): New function.
+	(skip_fixed_comments, gfc_next_char_literal): Update for OpenACC.
+	* st.c (gfc_free_statement): Handle EXEC_OACC_PARALLEL_LOOP,
+	EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,
+	EXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,
+	EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
+	EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.
+	* trans-decl.c (gfc_generate_function_code): Update for OpenACC.
+	* trans-openmp.c: Include "gomp-constants.h".
+	(gfc_omp_finish_clause, gfc_trans_omp_clauses): Use GOMP_MAP_*
+	instead of OMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.
+	(gfc_trans_omp_clauses): Handle OMP_LIST_USE_DEVICE,
+	OMP_LIST_DEVICE_RESIDENT, OMP_LIST_CACHE, and OMP_MAP_FORCE_ALLOC,
+	OMP_MAP_FORCE_DEALLOC, OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM,
+	OMP_MAP_FORCE_TOFROM, OMP_MAP_FORCE_PRESENT,
+	OMP_MAP_FORCE_DEVICEPTR, and gfc_omp_clauses' async, seq,
+	independent, wait_list, num_gangs_expr, num_workers_expr,
+	vector_length_expr, vector, vector_expr, worker, worker_expr,
+	gang, gang_expr members.
+	(gfc_trans_omp_do): Handle EXEC_OACC_LOOP.
+	(gfc_convert_expr_to_tree, gfc_trans_oacc_construct)
+	(gfc_trans_oacc_executable_directive)
+	(gfc_trans_oacc_wait_directive, gfc_trans_oacc_combined_directive)
+	(gfc_trans_oacc_declare, gfc_trans_oacc_directive): New functions.
+	* trans-stmt.c (gfc_trans_block_construct): Update for OpenACC.
+	* trans-stmt.h (gfc_trans_oacc_directive, gfc_trans_oacc_declare):
+	New prototypes.
+	* trans.c (tranc_code): Handle EXEC_OACC_CACHE, EXEC_OACC_WAIT,
+	EXEC_OACC_UPDATE, EXEC_OACC_LOOP, EXEC_OACC_HOST_DATA,
+	EXEC_OACC_DATA, EXEC_OACC_KERNELS, EXEC_OACC_KERNELS_LOOP,
+	EXEC_OACC_PARALLEL, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ENTER_DATA,
+	EXEC_OACC_EXIT_DATA.
+	* gfortran.texi: Update for OpenACC.
+	* intrinsic.texi: Likewise.
+	* invoke.texi: Likewise.
+
+2015-01-15  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/58023
+	* resolve.c (resolve_fl_derived0): Continue resolving next component
+	after error.
+
+2015-01-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/61933
+	* io.c (gfc_match_inquire): Generate error if unit number in
+	inquire statement is a constant -1.  All other values allowed.
+	* trans-io.c (gfc_trans_inquire): Delete dummy iostat variable.
+	(create_dummy_iostat): Delete function no longer used.
+
+2015-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/64528
+	* trans-decl.c (create_function_arglist): Don't set TREE_READONLY
+	on dummy args with VALUE attribute.
+
+2015-01-11  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/63733
+	* interface.c (gfc_extend_expr): Look for type-bound operators before
+	non-typebound ones.
+
+2015-01-11  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/58023
+	* resolve.c (resolve_fl_derived0): Set error flag if problems with the
+	interface of a procedure-pointer component were detected.
+
+2015-01-11  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/64508
+	* interface.c (compare_parameter): Interface check for
+	procedure-pointer component as actual argument.
+
+2015-01-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* gfortran.texi: Update for libgomp being renamed from "GNU OpenMP
+	Runtime Library" to "GNU Offloading and Multi Processing Runtime
+	Library".
+	* intrinsic.texi: Likewise.
+
+2015-01-10  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64522
+	* invoke.texi (Wline-truncation): Document new behaviour.
+	* lang.opt (Wline-truncation): Add Init(-1).
+	* options.c (gfc_post_options): If -Wline-truncation is unset,
+	enable it for free-form source files; for the latter, also use
+	-Werror=line-truncation, unless -Wno-error has been specified.
+
+2015-01-09  Michael Collison  <michael.collison@linaro.org>
+
+	* convert.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* cpp.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* decl.c: Ditto.
+	* f95.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* iresolve.c: Ditto.
+	* match.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* module.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* options.c: Ditto.
+	* target-memory.c: Include hash-set.h, vec.h,
+	double-int.h, input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans-array.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans-common.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans-const.c: Ditto.
+	* trans-decl.c: Ditto.
+	* trans-expr.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans-intrinsic.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, inchash.h and real.h due to flattening of tree.h.
+	* trans-io.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, options.h, fold-const.h,
+	wide-int.h, and inchash.h due to flattening of tree.h.
+	* trans-openmp.c: Ditto.
+	* trans-stmt.c: Ditto.
+	* trans-types.c: Include hash-set.h, machmode.h, vec.h, double-int.h,
+	input.h, alias.h, symtab.h, fold-const.h,
+	wide-int.h, inchash.h and real.h due to flattening of tree.h.
+
+2015-01-08  Tobias Burnus  <burnus@net-b.de>
+
+	* trans-decl.c (gfc_build_qualified_array): Fix coarray tokens
+	for module coarrays with -fcoarray=lib.
+	(get_proc_pointer_decl): As module variable, make only public
+	when not marked as private.
+
+2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/47674
+	* dependency.h:  Actually commit changes.
+
+2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/47674
+	* dependency.c:  Update copyright years.
+	(gfc_discard_nops):  Add prototype.
+	* dependency.c (discard_nops):  Rename to gfc_discard_nops,
+	make non-static.
+	(gfc_discard_nops):  Use gfc_discard_nops.
+	(gfc_dep_difference):  Likewise.
+	* frontend-passes.c  Update copyright years.
+	(realloc_strings):  New function.  Add prototype.
+	(gfc_run_passes):  Call realloc_strings.
+	(realloc_string_callback):  New function.
+	(create_var):  Add prototype.  Handle case of a
+	scalar character variable.
+	(optimize_trim):  Do not handle allocatable variables.
+
+2015-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	Update copyright years.
+
+	* gfortranspec.c (lang_specific_driver): Update copyright notice
+	dates.
+	* gfc-internals.texi: Bump @copying's copyright year.
+	* gfortran.texi: Ditto.
+	* intrinsic.texi: Ditto.
+	* invoke.texi: Ditto.
+
+2015-01-02  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/57562
+	* expr.c (find_component_ref): Deal with extended types.
+
+2015-01-02  Tobias Burnus  <burnus@net-b.de>
+
+	* trans-decl.c (gfc_build_qualified_array): Fix coarray tokens
+	for module coarrays with -fcoarray=lib.
+
+2015-01-02  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/60507
+	* interface.c (is_procptr_result): New function to check if an
+	expression is a procedure-pointer result.
+	(compare_actual_formal): Use it.
+^L
+Copyright (C) 2015 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 3196420..049a6fb 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -1157,6 +1157,59 @@ gfc_check_atomic_cas (gfc_expr *atom, gfc_expr *old, gfc_expr *compare,
   return true;
 }
 
+bool
+gfc_check_event_query (gfc_expr *event, gfc_expr *count, gfc_expr *stat)
+{
+  if (event->ts.type != BT_DERIVED
+      || event->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV
+      || event->ts.u.derived->intmod_sym_id != ISOFORTRAN_EVENT_TYPE)
+    {
+      gfc_error ("EVENT argument at %L to the intrinsic EVENT_QUERY "
+		 "shall be of type EVENT_TYPE", &event->where);
+      return false;
+    }
+
+  if (!scalar_check (event, 0))
+    return false;
+
+  if (!gfc_check_vardef_context (count, false, false, false, NULL))
+    {
+      gfc_error ("COUNT argument of the EVENT_QUERY intrinsic function at %L "
+		 "shall be definable", &count->where);
+      return false;
+    }
+
+  if (!type_check (count, 1, BT_INTEGER))
+    return false;
+
+  int i = gfc_validate_kind (BT_INTEGER, count->ts.kind, false);
+  int j = gfc_validate_kind (BT_INTEGER, gfc_default_integer_kind, false);
+
+  if (gfc_integer_kinds[i].range < gfc_integer_kinds[j].range)
+    {
+      gfc_error ("COUNT argument of the EVENT_QUERY intrinsic function at %L "
+		 "shall have at least the range of the default integer",
+		 &count->where);
+      return false;
+    }
+
+  if (stat != NULL)
+    {
+      if (!type_check (stat, 2, BT_INTEGER))
+	return false;
+      if (!scalar_check (stat, 2))
+	return false;
+      if (!variable_check (stat, 2, false))
+	return false;
+
+      if (!gfc_notify_std (GFC_STD_F2008_TS, "STAT= argument to %s at %L",
+			   gfc_current_intrinsic, &stat->where))
+	return false;
+    }
+
+  return true;
+}
+
 
 bool
 gfc_check_atomic_fetch_op (gfc_expr *atom, gfc_expr *value, gfc_expr *old,
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 2708413..adea3f3 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -6454,9 +6454,16 @@ cleanup:
 	  prev_ns = ns;
 	  ns = ns->sibling;
 	}
-  
-      gfc_free_namespace (gfc_current_ns);
-      gfc_current_ns = parent_ns;
+
+      if (parent_ns)
+	{
+	  /* Free the current namespace only when the parent one exists.  This
+	     prevents an ICE when more END BLOCK then BLOCK statements are
+	     present.  It does not mean any further harm, because we already
+	     have errored.  */
+	  gfc_free_namespace (gfc_current_ns);
+	  gfc_current_ns = parent_ns;
+	}
     }
 
   return MATCH_ERROR;
diff --git a/gcc/fortran/dump-parse-tree.c b/gcc/fortran/dump-parse-tree.c
index 83ecbaa..c886010 100644
--- a/gcc/fortran/dump-parse-tree.c
+++ b/gcc/fortran/dump-parse-tree.c
@@ -1659,6 +1659,33 @@ show_code_node (int level, gfc_code *c)
 	}
       break;
 
+    case EXEC_EVENT_POST:
+    case EXEC_EVENT_WAIT:
+      if (c->op == EXEC_EVENT_POST)
+	fputs ("EVENT POST ", dumpfile);
+      else
+	fputs ("EVENT WAIT ", dumpfile);
+
+      fputs ("event-variable=", dumpfile);
+      if (c->expr1 != NULL)
+	show_expr (c->expr1);
+      if (c->expr4 != NULL)
+	{
+	  fputs (" until_count=", dumpfile);
+	  show_expr (c->expr4);
+	}
+      if (c->expr2 != NULL)
+	{
+	  fputs (" stat=", dumpfile);
+	  show_expr (c->expr2);
+	}
+      if (c->expr3 != NULL)
+	{
+	  fputs (" errmsg=", dumpfile);
+	  show_expr (c->expr3);
+	}
+      break;
+
     case EXEC_LOCK:
     case EXEC_UNLOCK:
       if (c->op == EXEC_LOCK)
diff --git a/gcc/fortran/error.c b/gcc/fortran/error.c
index 683aa59..0d292ea 100644
--- a/gcc/fortran/error.c
+++ b/gcc/fortran/error.c
@@ -1391,6 +1391,7 @@ gfc_error (const char *gmsgid, va_list ap)
 {
   va_list argp;
   va_copy (argp, ap);
+  bool saved_abort_on_error = false;
 
   if (warnings_not_errors)
     {
@@ -1414,10 +1415,14 @@ gfc_error (const char *gmsgid, va_list ap)
 
   if (buffered_p)
     {
+      /* To prevent -dH from triggering an abort on a buffered error,
+	 save abort_on_error and restore it below.  */
+      saved_abort_on_error = global_dc->abort_on_error;
+      global_dc->abort_on_error = false;
       pp->buffer = pp_error_buffer;
       global_dc->fatal_errors = false;
       /* To prevent -fmax-errors= triggering, we decrease it before
-     report_diagnostic increases it.  */
+	 report_diagnostic increases it.  */
       --errorcount;
     }
 
@@ -1428,6 +1433,8 @@ gfc_error (const char *gmsgid, va_list ap)
     {
       pp->buffer = tmp_buffer;
       global_dc->fatal_errors = fatal_errors;
+      global_dc->abort_on_error = saved_abort_on_error;
+
     }
 
   va_end (argp);
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index c90e823..2e74375 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -4864,6 +4864,19 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,
       return false;
     }
 
+  /* TS18508, C702/C203.  */
+  if (!alloc_obj
+      && (attr.lock_comp
+	  || (e->ts.type == BT_DERIVED
+	      && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	      && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)))
+    {
+      if (context)
+	gfc_error ("LOCK_EVENT in variable definition context (%s) at %L",
+		   context, &e->where);
+      return false;
+    }
+
   /* INTENT(IN) dummy argument.  Check this, unless the object itself is the
      component of sub-component of a pointer; we need to distinguish
      assignment to a pointer component from pointer-assignment to a pointer
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 9d09de6..1c38d82 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -253,7 +253,8 @@ typedef enum
   ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,
   ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,
   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,
-  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE
+  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,
+  ST_EVENT_WAIT,ST_NONE
 }
 gfc_statement;
 
@@ -413,6 +414,7 @@ enum gfc_isym_id
   GFC_ISYM_ERFC,
   GFC_ISYM_ERFC_SCALED,
   GFC_ISYM_ETIME,
+  GFC_ISYM_EVENT_QUERY,
   GFC_ISYM_EXECUTE_COMMAND_LINE,
   GFC_ISYM_EXIT,
   GFC_ISYM_EXP,
@@ -847,7 +849,7 @@ typedef struct
      entities.  */
   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,
 	   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,
-	   defined_assign_comp:1, unlimited_polymorphic:1;
+	   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1;
 
   /* This is a temporary selector for SELECT TYPE or an associate
      variable for SELECT_TYPE or ASSOCIATE.  */
@@ -2330,7 +2332,7 @@ typedef enum
   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,
   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,
   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,
-  EXEC_LOCK, EXEC_UNLOCK,
+  EXEC_LOCK, EXEC_UNLOCK, EXEC_EVENT_POST, EXEC_EVENT_WAIT,
   EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP,
   EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,
   EXEC_OACC_LOOP, EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,
diff --git a/gcc/fortran/gfortran.texi b/gcc/fortran/gfortran.texi
index a06c5fc..c6b7af5 100644
--- a/gcc/fortran/gfortran.texi
+++ b/gcc/fortran/gfortran.texi
@@ -3306,7 +3306,9 @@ typedef enum caf_register_t {
   CAF_REGTYPE_COARRAY_ALLOC,
   CAF_REGTYPE_LOCK_STATIC,
   CAF_REGTYPE_LOCK_ALLOC,
-  CAF_REGTYPE_CRITICAL
+  CAF_REGTYPE_CRITICAL,
+  CAF_REGTYPE_EVENT_STATIC,
+  CAF_REGTYPE_EVENT_ALLOC
 }
 caf_register_t;
 @end verbatim
@@ -3327,6 +3329,9 @@ caf_register_t;
 * _gfortran_caf_sendget:: Sending data between remote images
 * _gfortran_caf_lock:: Locking a lock variable
 * _gfortran_caf_unlock:: Unlocking a lock variable
+* _gfortran_caf_event_post:: Post an event
+* _gfortran_caf_event_wait:: Wait that an event occurred
+* _gfortran_caf_event_query:: Query event count
 * _gfortran_caf_sync_all:: All-image barrier
 * _gfortran_caf_sync_images:: Barrier for selected images
 * _gfortran_caf_sync_memory:: Wait for completion of segment-memory operations
@@ -3480,7 +3485,7 @@ int *stat, char *errmsg, int errmsg_len)}
 @item @emph{Arguments}:
 @multitable @columnfractions .15 .70
 @item @var{size} @tab For normal coarrays, the byte size of the coarray to be
-allocated; for lock types, the number of elements.
+allocated; for lock types and event types, the number of elements.
 @item @var{type} @tab one of the caf_register_t types.
 @item @var{token} @tab intent(out) An opaque pointer identifying the coarray.
 @item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;
@@ -3505,7 +3510,10 @@ image. For lock types, the value shall only used for checking the allocation
 status. Note that for critical blocks, the locking is only required on one
 image; in the locking statement, the processor shall always pass always an
 image index of one for critical-block lock variables
-(@code{CAF_REGTYPE_CRITICAL}).
+(@code{CAF_REGTYPE_CRITICAL}). For lock types and critical-block variables,
+the initial value shall be unlocked (or, respecitively, not in critical
+section) such as the value false; for event types, the initial state should
+be no event, e.g. zero.
 @end table
 
 
@@ -3525,8 +3533,7 @@ int errmsg_len)}
 
 @item @emph{Arguments}:
 @multitable @columnfractions .15 .70
-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;
-may be NULL
+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL
 @item @var{errmsg} @tab intent(out) When an error occurs, this will be set
 to an error message; may be NULL
 @item @var{errmsg_len} @tab the buffer size of errmsg.
@@ -3733,8 +3740,7 @@ always 0.
 number.
 @item @var{aquired_lock} @tab intent(out) If not NULL, it returns whether lock
 could be obtained
-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;
-may be NULL
+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL
 @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to
 an error message; may be NULL
 @item @var{errmsg_len} @tab the buffer size of errmsg.
@@ -3746,7 +3752,6 @@ is always zero and the image index is one.  Libraries are permitted to use other
 images for critical-block locking variables.
 @end table
 
-
 @node _gfortran_caf_unlock
 @subsection @code{_gfortran_caf_lock} --- Unlocking a lock variable
 @cindex Coarray, _gfortran_caf_unlock
@@ -3781,6 +3786,115 @@ is always zero and the image index is one.  Libraries are permitted to use other
 images for critical-block locking variables.
 @end table
 
+@node _gfortran_caf_event_post
+@subsection @code{_gfortran_caf_event_post} --- Post an event
+@cindex Coarray, _gfortran_caf_event_post
+
+@table @asis
+@item @emph{Description}:
+Increment the event count of the specified event variable.
+
+@item @emph{Syntax}:
+@code{void _gfortran_caf_event_post (caf_token_t token, size_t index,
+int image_index, int *stat, char *errmsg, int errmsg_len)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.
+@item @var{index} @tab Array index; first array index is 0. For scalars, it is
+always 0.
+@item @var{image_index} @tab The ID of the remote image; must be a positive
+number; zero indicates the current image when accessed noncoindexed.
+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL
+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to
+an error message; may be NULL
+@item @var{errmsg_len} @tab the buffer size of errmsg.
+@end multitable
+
+@item @emph{NOTES}
+This acts like an atomic add of one to the remote image's event variable.
+The statement is an image-control statement but does not imply sync memory.
+Still, all preceeding push communications of this image to the specified
+remote image has to be completed before @code{event_wait} on the remote
+image returns.
+@end table
+
+
+
+@node _gfortran_caf_event_wait
+@subsection @code{_gfortran_caf_event_wait} --- Wait that an event occurred
+@cindex Coarray, _gfortran_caf_event_wait
+
+@table @asis
+@item @emph{Description}:
+Wait until the event count has reached at least the specified
+@var{until_count}; if so, atomically decrement the event variable by this
+amount and return.
+
+@item @emph{Syntax}:
+@code{void _gfortran_caf_event_wait (caf_token_t token, size_t index,
+int until_count, int *stat, char *errmsg, int errmsg_len)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.
+@item @var{index} @tab Array index; first array index is 0. For scalars, it is
+always 0.
+@item @var{until_count} @tab The number of events which have to be available
+before the function returns.
+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL
+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to
+an error message; may be NULL
+@item @var{errmsg_len} @tab the buffer size of errmsg.
+@end multitable
+
+@item @emph{NOTES}
+This function only operates on a local coarray. It acts like a loop checking
+atomically the value of the event variable, breaking if the value is greater
+or equal the requested number of counts. Before the function returns, the
+event variable has to be decremented by the requested @var{until_count} value.
+A possible implementation would be a busy loop for a certain number of spins
+(possibly depending on the number of threads relative to the number of available
+cores) followed by other waiting strategy such as a sleeping wait (possibly with
+an increasing number of sleep time) or, if possible, a futex wait.
+
+The statement is an image-control statement but does not imply sync memory.
+Still, all preceeding push communications to this image of images having
+issued a @code{event_push} have to be completed before this function returns.
+@end table
+
+
+
+@node _gfortran_caf_event_query
+@subsection @code{_gfortran_caf_event_query} --- Query event count
+@cindex Coarray, _gfortran_caf_event_query
+
+@table @asis
+@item @emph{Description}:
+Return the event count of the specified event count.
+
+@item @emph{Syntax}:
+@code{void _gfortran_caf_event_query (caf_token_t token, size_t index,
+int image_index, int *count, int *stat)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.
+@item @var{index} @tab Array index; first array index is 0. For scalars, it is
+always 0.
+@item @var{image_index} @tab The ID of the remote image; must be a positive
+number; zero indicates the current image when accessed noncoindexed.
+@item @var{count} @tab intent(out) The number of events currently posted to
+the event variable
+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL
+@end multitable
+
+@item @emph{NOTES}
+The typical use is to check the local even variable to only call
+@code{event_wait} when the data is available. However, a coindexed variable
+is permitted; there is no ordering or synchronization implied.  It acts like
+an atomic fetch of the value of the event variable.
+@end table
 
 @node _gfortran_caf_sync_all
 @subsection @code{_gfortran_caf_sync_all} --- All-image barrier
@@ -3926,7 +4040,7 @@ int image_index, void *value, int *stat, int type, int kind)}
 @item @var{offset} @tab By which amount of bytes the actual data is shifted
 compared to the base address of the coarray.
 @item @var{image_index} @tab The ID of the remote image; must be a positive
-number.
+number; zero indicates the current image when used noncoindexed.
 @item @var{value} @tab intent(in) the value to be assigned, passed by reference.
 @item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.
 @item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or
@@ -3956,7 +4070,7 @@ int image_index, void *value, int *stat, int type, int kind)}
 @item @var{offset} @tab By which amount of bytes the actual data is shifted
 compared to the base address of the coarray.
 @item @var{image_index} @tab The ID of the remote image; must be a positive
-number.
+number; zero indicates the current image when used noncoindexed.
 @item @var{value} @tab intent(out) The variable assigned the atomically
 referenced variable.
 @item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.
@@ -3989,7 +4103,7 @@ int type, int kind)}
 @item @var{offset} @tab By which amount of bytes the actual data is shifted
 compared to the base address of the coarray.
 @item @var{image_index} @tab The ID of the remote image; must be a positive
-number.
+number; zero indicates the current image when used noncoindexed.
 @item @var{old} @tab intent(out) the value which the atomic variable had
 just before the cas operation.
 @item @var{compare} @tab intent(in) The value used for comparision.
@@ -4031,7 +4145,7 @@ int image_index, void *value, void *old, int *stat, int type, int kind)}
 @item @var{offset} @tab By which amount of bytes the actual data is shifted
 compared to the base address of the coarray.
 @item @var{image_index} @tab The ID of the remote image; must be a positive
-number.
+number; zero indicates the current image when used noncoindexed.
 @item @var{old} @tab intent(out) the value which the atomic variable had
 just before the atomic operation.
 @item @var{val} @tab intent(in) The new value for the atomic variable,
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 5cbe96a..0ada5ed 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -2144,6 +2144,21 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
 		       formal->name, &actual->where);
 	  return 0;
 	}
+
+      /* TS18508, C702/C703.  */
+      if (formal->attr.intent != INTENT_INOUT
+	  && (((formal->ts.type == BT_DERIVED || formal->ts.type == BT_CLASS)
+	       && formal->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	       && formal->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+	      || formal->attr.event_comp))
+
+    	{
+	  if (where)
+	    gfc_error ("Actual argument to non-INTENT(INOUT) dummy %qs at %L, "
+		       "which is EVENT_TYPE or has a EVENT_TYPE component",
+		       formal->name, &actual->where);
+	  return 0;
+	}
     }
 
   /* F2008, C1239/C1240.  */
@@ -3377,6 +3392,19 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 	      break;
 	    }
 
+	  if (a->expr
+	      && (a->expr->ts.type == BT_DERIVED || a->expr->ts.type == BT_CLASS)
+	      && ((a->expr->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+		   && a->expr->ts.u.derived->intmod_sym_id
+		      == ISOFORTRAN_EVENT_TYPE)
+		  || gfc_expr_attr (a->expr).event_comp))
+	    {
+	      gfc_error ("Actual argument of EVENT_TYPE or with EVENT_TYPE "
+			 "component at %L requires an explicit interface for "
+			 "procedure %qs", &a->expr->where, sym->name);
+	      break;
+	    }
+
 	  if (a->expr && a->expr->expr_type == EXPR_NULL
 	      && a->expr->ts.type == BT_UNKNOWN)
 	    {
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index a958f8e..3a971cb 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -3128,6 +3128,13 @@ add_subroutines (void)
 	      GFC_STD_F95, gfc_check_cpu_time, NULL, gfc_resolve_cpu_time,
 	      tm, BT_REAL, dr, REQUIRED, INTENT_OUT);
 
+  add_sym_3s ("event_query", GFC_ISYM_EVENT_QUERY, CLASS_ATOMIC,
+	      BT_UNKNOWN, 0, GFC_STD_F2008_TS,
+	      gfc_check_event_query, NULL, gfc_resolve_event_query,
+	      "event", BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      c, BT_INTEGER, di, OPTIONAL, INTENT_IN,
+	      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
+
   /* More G77 compatibility garbage.  */
   add_sym_2s ("ctime", GFC_ISYM_CTIME, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_ctime_sub, NULL, gfc_resolve_ctime_sub,
diff --git a/gcc/fortran/intrinsic.h b/gcc/fortran/intrinsic.h
index be7f214..2ca41aa 100644
--- a/gcc/fortran/intrinsic.h
+++ b/gcc/fortran/intrinsic.h
@@ -70,6 +70,7 @@ bool gfc_check_dprod (gfc_expr *, gfc_expr *);
 bool gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);
 bool gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);
 bool gfc_check_dtime_etime (gfc_expr *);
+bool gfc_check_event_query (gfc_expr *, gfc_expr *, gfc_expr *);
 bool gfc_check_fgetputc (gfc_expr *, gfc_expr *);
 bool gfc_check_fgetput (gfc_expr *);
 bool gfc_check_float (gfc_expr *);
@@ -462,6 +463,7 @@ void gfc_resolve_dtime_sub (gfc_code *);
 void gfc_resolve_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,
 			  gfc_expr *);
 void gfc_resolve_etime_sub (gfc_code *);
+void gfc_resolve_event_query (gfc_code *);
 void gfc_resolve_exp (gfc_expr *, gfc_expr *);
 void gfc_resolve_exponent (gfc_expr *, gfc_expr *);
 void gfc_resolve_extends_type_of (gfc_expr *, gfc_expr *, gfc_expr *);
diff --git a/gcc/fortran/invoke.texi b/gcc/fortran/invoke.texi
index af123db..b0963fa 100644
--- a/gcc/fortran/invoke.texi
+++ b/gcc/fortran/invoke.texi
@@ -742,7 +742,7 @@ Enables commonly used warning options pertaining to usage that
 we recommend avoiding and that we believe are easy to avoid.
 This currently includes @option{-Waliasing}, @option{-Wampersand},
 @option{-Wconversion}, @option{-Wsurprising}, @option{-Wc-binding-type},
-@option{-Wintrinsics-std}, @option{-Wno-tabs}, @option{-Wintrinsic-shadow},
+@option{-Wintrinsics-std}, @option{-Wtabs}, @option{-Wintrinsic-shadow},
 @option{-Wline-truncation}, @option{-Wtarget-lifetime},
 @option{-Wreal-q-constant} and @option{-Wunused}.
 
diff --git a/gcc/fortran/iresolve.c b/gcc/fortran/iresolve.c
index 6fa0994..2595826 100644
--- a/gcc/fortran/iresolve.c
+++ b/gcc/fortran/iresolve.c
@@ -2955,6 +2955,12 @@ gfc_resolve_atomic_ref (gfc_code *c)
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
 }
 
+void
+gfc_resolve_event_query (gfc_code *c)
+{
+  const char *name = "event_query";
+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+}
 
 void
 gfc_resolve_mvbits (gfc_code *c)
diff --git a/gcc/fortran/iso-fortran-env.def b/gcc/fortran/iso-fortran-env.def
index eba0b4c..c5fb3ff 100644
--- a/gcc/fortran/iso-fortran-env.def
+++ b/gcc/fortran/iso-fortran-env.def
@@ -123,6 +123,11 @@ NAMED_FUNCTION (ISOFORTRAN_COMPILER_VERSION, "compiler_version", \
 NAMED_DERIVED_TYPE (ISOFORTRAN_LOCK_TYPE, "lock_type", \
               get_int_kind_from_node (ptr_type_node), GFC_STD_F2008)
 
+NAMED_DERIVED_TYPE (ISOFORTRAN_EVENT_TYPE, "event_type", \
+		    flag_coarray == GFC_FCOARRAY_LIB
+		    ?  get_int_kind_from_node (ptr_type_node)
+		    : gfc_default_integer_kind, GFC_STD_F2008_TS)
+
 #undef NAMED_INTCST
 #undef NAMED_KINDARRAY
 #undef NAMED_FUNCTION
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 60c6e65..bf8439a 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -1474,6 +1474,8 @@ gfc_match_if (gfc_statement *if_type)
   match ("deallocate", gfc_match_deallocate, ST_DEALLOCATE)
   match ("end file", gfc_match_endfile, ST_END_FILE)
   match ("error stop", gfc_match_error_stop, ST_ERROR_STOP)
+  match ("event post", gfc_match_event_post, ST_EVENT_POST)
+  match ("event wait", gfc_match_event_wait, ST_EVENT_WAIT)
   match ("exit", gfc_match_exit, ST_EXIT)
   match ("flush", gfc_match_flush, ST_FLUSH)
   match ("forall", match_simple_forall, ST_FORALL)
@@ -2758,6 +2760,202 @@ gfc_match_error_stop (void)
   return gfc_match_stopcode (ST_ERROR_STOP);
 }
 
+/* Match EVENT POST/WAIT statement. Syntax:
+     EVENT POST ( event-variable [, sync-stat-list] )
+     EVENT WAIT ( event-variable [, wait-spec-list] )
+   with
+      wait-spec-list  is  sync-stat-list  or until-spec
+      until-spec  is  UNTIL_COUNT = scalar-int-expr
+      sync-stat  is  STAT= or ERRMSG=.  */
+
+static match
+event_statement (gfc_statement st)
+{
+  match m;
+  gfc_expr *tmp, *eventvar, *until_count, *stat, *errmsg;
+  bool saw_until_count, saw_stat, saw_errmsg;
+
+  tmp = eventvar = until_count = stat = errmsg = NULL;
+  saw_until_count = saw_stat = saw_errmsg = false;
+
+  if (gfc_pure (NULL))
+    {
+      gfc_error ("Image control statement EVENT %s at %C in PURE procedure",
+		 st == ST_EVENT_POST ? "POST" : "WAIT");
+      return MATCH_ERROR;
+    }
+
+  gfc_unset_implicit_pure (NULL);
+
+  if (flag_coarray == GFC_FCOARRAY_NONE)
+    {
+       gfc_fatal_error ("Coarrays disabled at %C, use %<-fcoarray=%> to enable");
+       return MATCH_ERROR;
+    }
+
+  if (gfc_find_state (COMP_CRITICAL))
+    {
+      gfc_error ("Image control statement EVENT %s at %C in CRITICAL block",
+		 st == ST_EVENT_POST ? "POST" : "WAIT");
+      return MATCH_ERROR;
+    }
+
+  if (gfc_find_state (COMP_DO_CONCURRENT))
+    {
+      gfc_error ("Image control statement EVENT %s at %C in DO CONCURRENT "
+		 "block", st == ST_EVENT_POST ? "POST" : "WAIT");
+      return MATCH_ERROR;
+    }
+
+  if (gfc_match_char ('(') != MATCH_YES)
+    goto syntax;
+
+  if (gfc_match ("%e", &eventvar) != MATCH_YES)
+    goto syntax;
+  m = gfc_match_char (',');
+  if (m == MATCH_ERROR)
+    goto syntax;
+  if (m == MATCH_NO)
+    {
+      m = gfc_match_char (')');
+      if (m == MATCH_YES)
+	goto done;
+      goto syntax;
+    }
+
+  for (;;)
+    {
+      m = gfc_match (" stat = %v", &tmp);
+      if (m == MATCH_ERROR)
+	goto syntax;
+      if (m == MATCH_YES)
+	{
+	  if (saw_stat)
+	    {
+	      gfc_error ("Redundant STAT tag found at %L ", &tmp->where);
+	      goto cleanup;
+	    }
+	  stat = tmp;
+	  saw_stat = true;
+
+	  m = gfc_match_char (',');
+	  if (m == MATCH_YES)
+	    continue;
+
+	  tmp = NULL;
+	  break;
+	}
+
+      m = gfc_match (" errmsg = %v", &tmp);
+      if (m == MATCH_ERROR)
+	goto syntax;
+      if (m == MATCH_YES)
+	{
+	  if (saw_errmsg)
+	    {
+	      gfc_error ("Redundant ERRMSG tag found at %L ", &tmp->where);
+	      goto cleanup;
+	    }
+	  errmsg = tmp;
+	  saw_errmsg = true;
+
+	  m = gfc_match_char (',');
+	  if (m == MATCH_YES)
+	    continue;
+
+	  tmp = NULL;
+	  break;
+	}
+
+      m = gfc_match (" until_count = %e", &tmp);
+      if (m == MATCH_ERROR || st == ST_EVENT_POST)
+	goto syntax;
+      if (m == MATCH_YES)
+	{
+	  if (saw_until_count)
+	    {
+	      gfc_error ("Redundant UNTIL_COUNT tag found at %L ",
+			 &tmp->where);
+	      goto cleanup;
+	    }
+	  until_count = tmp;
+	  saw_until_count = true;
+
+	  m = gfc_match_char (',');
+	  if (m == MATCH_YES)
+	    continue;
+
+	  tmp = NULL;
+	  break;
+	}
+
+      break;
+    }
+
+  if (m == MATCH_ERROR)
+    goto syntax;
+
+  if (gfc_match (" )%t") != MATCH_YES)
+    goto syntax;
+
+done:
+  switch (st)
+    {
+    case ST_EVENT_POST:
+      new_st.op = EXEC_EVENT_POST;
+      break;
+    case ST_EVENT_WAIT:
+      new_st.op = EXEC_EVENT_WAIT;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  new_st.expr1 = eventvar;
+  new_st.expr2 = stat;
+  new_st.expr3 = errmsg;
+  new_st.expr4 = until_count;
+
+  return MATCH_YES;
+
+syntax:
+  gfc_syntax_error (st);
+
+cleanup:
+  if (until_count != tmp)
+    gfc_free_expr (until_count);
+  if (errmsg != tmp)
+    gfc_free_expr (errmsg);
+  if (stat != tmp)
+    gfc_free_expr (stat);
+
+  gfc_free_expr (tmp);
+  gfc_free_expr (eventvar);
+
+  return MATCH_ERROR;
+
+}
+
+
+match
+gfc_match_event_post (void)
+{
+  if (!gfc_notify_std (GFC_STD_F2008_TS, "EVENT POST statement at %C"))
+    return MATCH_ERROR;
+
+  return event_statement (ST_EVENT_POST);
+}
+
+
+match
+gfc_match_event_wait (void)
+{
+  if (!gfc_notify_std (GFC_STD_F2008_TS, "EVENT WAIT statement at %C"))
+    return MATCH_ERROR;
+
+  return event_statement (ST_EVENT_WAIT);
+}
+
 
 /* Match LOCK/UNLOCK statement. Syntax:
      LOCK ( lock-variable [ , lock-stat-list ] )
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index 96d3ec1..7427b50 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -69,6 +69,8 @@ match gfc_match_assignment (void);
 match gfc_match_if (gfc_statement *);
 match gfc_match_else (void);
 match gfc_match_elseif (void);
+match gfc_match_event_post (void);
+match gfc_match_event_wait (void);
 match gfc_match_critical (void);
 match gfc_match_block (void);
 match gfc_match_associate (void);
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 2a7e986..3ec24f2 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -1889,7 +1889,7 @@ typedef enum
   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,
   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE,
   AB_ALLOC_COMP, AB_POINTER_COMP, AB_PROC_POINTER_COMP, AB_PRIVATE_COMP,
-  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_LOCK_COMP,
+  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_LOCK_COMP, AB_EVENT_COMP,
   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,
   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,
   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,
@@ -1935,6 +1935,7 @@ static const mstring attr_bits[] =
     minit ("ALLOC_COMP", AB_ALLOC_COMP),
     minit ("COARRAY_COMP", AB_COARRAY_COMP),
     minit ("LOCK_COMP", AB_LOCK_COMP),
+    minit ("EVENT_COMP", AB_EVENT_COMP),
     minit ("POINTER_COMP", AB_POINTER_COMP),
     minit ("PROC_POINTER_COMP", AB_PROC_POINTER_COMP),
     minit ("PRIVATE_COMP", AB_PRIVATE_COMP),
@@ -2117,6 +2118,8 @@ mio_symbol_attribute (symbol_attribute *attr)
 	MIO_NAME (ab_attribute) (AB_COARRAY_COMP, attr_bits);
       if (attr->lock_comp)
 	MIO_NAME (ab_attribute) (AB_LOCK_COMP, attr_bits);
+      if (attr->event_comp)
+	MIO_NAME (ab_attribute) (AB_EVENT_COMP, attr_bits);
       if (attr->zero_comp)
 	MIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);
       if (attr->is_class)
@@ -2269,6 +2272,9 @@ mio_symbol_attribute (symbol_attribute *attr)
 	    case AB_LOCK_COMP:
 	      attr->lock_comp = 1;
 	      break;
+	    case AB_EVENT_COMP:
+	      attr->event_comp = 1;
+	      break;
 	    case AB_POINTER_COMP:
 	      attr->pointer_comp = 1;
 	      break;
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 27ead21..6394e2e 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -457,6 +457,8 @@ decode_statement (void)
       match ("entry% ", gfc_match_entry, ST_ENTRY);
       match ("equivalence", gfc_match_equivalence, ST_EQUIVALENCE);
       match ("external", gfc_match_external, ST_ATTR_DECL);
+      match ("event post", gfc_match_event_post, ST_EVENT_POST);
+      match ("event wait", gfc_match_event_wait, ST_EVENT_WAIT);
       break;
 
     case 'f':
@@ -1323,6 +1325,7 @@ next_statement (void)
   case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \
   case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \
   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \
+  case ST_EVENT_POST: case ST_EVENT_WAIT: \
   case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \
   case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA
 
@@ -1628,6 +1631,12 @@ gfc_ascii_statement (gfc_statement st)
     case ST_ELSEWHERE:
       p = "ELSEWHERE";
       break;
+    case ST_EVENT_POST:
+      p = "EVENT POST";
+      break;
+    case ST_EVENT_WAIT:
+      p = "EVENT WAIT";
+      break;
     case ST_END_ASSOCIATE:
       p = "END ASSOCIATE";
       break;
@@ -2608,7 +2617,7 @@ parse_derived (void)
   gfc_statement st;
   gfc_state_data s;
   gfc_symbol *sym;
-  gfc_component *c, *lock_comp = NULL;
+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;
 
   accept_statement (ST_DERIVED_DECL);
   push_state (&s, COMP_DERIVED, gfc_new_block);
@@ -2716,8 +2725,8 @@ endType:
   sym = gfc_current_block ();
   for (c = sym->components; c; c = c->next)
     {
-      bool coarray, lock_type, allocatable, pointer;
-      coarray = lock_type = allocatable = pointer = false;
+      bool coarray, lock_type, event_type, allocatable, pointer;
+      coarray = lock_type = event_type = allocatable = pointer = false;
 
       /* Look for allocatable components.  */
       if (c->attr.allocatable
@@ -2779,6 +2788,23 @@ endType:
 	  sym->attr.lock_comp = 1;
 	}
 
+      /* Looking for event_type components.  */
+      if ((c->ts.type == BT_DERIVED
+	      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+	  || (c->ts.type == BT_CLASS && c->attr.class_ok
+	      && CLASS_DATA (c)->ts.u.derived->from_intmod
+		 == INTMOD_ISO_FORTRAN_ENV
+	      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
+		 == ISOFORTRAN_EVENT_TYPE)
+	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp
+	      && !allocatable && !pointer))
+	{
+	  event_type = 1;
+	  event_comp = c;
+	  sym->attr.event_comp = 1;
+	}
+
       /* Check for F2008, C1302 - and recall that pointers may not be coarrays
 	 (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
 	 unless there are nondirect [allocatable or pointer] components
@@ -2819,6 +2845,43 @@ endType:
 		   "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
 		   sym->name, c->name, &c->loc);
 
+      /* Similarly for EVENT TYPE.  */
+
+      if (pointer && !coarray && event_type)
+	gfc_error ("Component %s at %L of type EVENT_TYPE must have a "
+		   "codimension or be a subcomponent of a coarray, "
+		   "which is not possible as the component has the "
+		   "pointer attribute", c->name, &c->loc);
+      else if (pointer && !coarray && c->ts.type == BT_DERIVED
+	       && c->ts.u.derived->attr.event_comp)
+	gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
+		   "of type EVENT_TYPE, which must have a codimension or be a "
+		   "subcomponent of a coarray", c->name, &c->loc);
+
+      if (event_type && allocatable && !coarray)
+	gfc_error ("Allocatable component %s at %L of type EVENT_TYPE must have "
+		   "a codimension", c->name, &c->loc);
+      else if (event_type && allocatable && c->ts.type == BT_DERIVED
+	       && c->ts.u.derived->attr.event_comp)
+	gfc_error ("Allocatable component %s at %L must have a codimension as "
+		   "it has a noncoarray subcomponent of type EVENT_TYPE",
+		   c->name, &c->loc);
+
+      if (sym->attr.coarray_comp && !coarray && event_type)
+	gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
+		   "subcomponent of type EVENT_TYPE must have a codimension or "
+		   "be a subcomponent of a coarray. (Variables of type %s may "
+		   "not have a codimension as already a coarray "
+		   "subcomponent exists)", c->name, &c->loc, sym->name);
+
+      if (sym->attr.event_comp && coarray && !event_type)
+	gfc_error ("Noncoarray component %s at %L of type EVENT_TYPE or with "
+		   "subcomponent of type EVENT_TYPE must have a codimension or "
+		   "be a subcomponent of a coarray. (Variables of type %s may "
+		   "not have a codimension as %s at %L has a codimension or a "
+		   "coarray subcomponent)", event_comp->name, &event_comp->loc,
+		   sym->name, c->name, &c->loc);
+
       /* Look for private components.  */
       if (sym->component_access == ACCESS_PRIVATE
 	  || c->attr.access == ACCESS_PRIVATE
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index f845917..44b9901 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -2142,7 +2142,7 @@ check_substring:
 symbol_attribute
 gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)
 {
-  int dimension, codimension, pointer, allocatable, target, n;
+  int dimension, codimension, pointer, allocatable, target;
   symbol_attribute attr;
   gfc_ref *ref;
   gfc_symbol *sym;
@@ -2201,22 +2201,9 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)
 	  case AR_UNKNOWN:
 	    /* If any of start, end or stride is not integer, there will
 	       already have been an error issued.  */
-	    for (n = 0; n < ref->u.ar.as->rank; n++)
-	      {
-		int errors;
-		gfc_get_errors (NULL, &errors);
-		if (((ref->u.ar.start[n]
-		      && ref->u.ar.start[n]->ts.type == BT_UNKNOWN)
-		     ||
-		     (ref->u.ar.end[n]
-		      && ref->u.ar.end[n]->ts.type == BT_UNKNOWN)
-		     ||
-		     (ref->u.ar.stride[n]
-		      && ref->u.ar.stride[n]->ts.type == BT_UNKNOWN))
-		    && errors > 0)
-		  break;
-	      }
-	    if (n == ref->u.ar.as->rank)
+	    int errors;
+	    gfc_get_errors (NULL, &errors);
+	    if (errors == 0)
 	      gfc_internal_error ("gfc_variable_attr(): Bad array reference");
 	  }
 
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 00a9f94..9a8bd9a 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1,5 +1,5 @@
 /* Perform type resolution on the various structures.
-   Copyright (C) 2001-2015 Free Software Foundation, Inc.
+   Copyright (C) 2001-2016 Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
 This file is part of GCC.
@@ -6977,6 +6977,21 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
 		      &code->expr3->where, &e->where);
 	  goto failure;
 	}
+
+      /* Check TS18508, C702/C703.  */
+      if (code->expr3->ts.type == BT_DERIVED
+	  && ((codimension && gfc_expr_attr (code->expr3).event_comp)
+	      || (code->expr3->ts.u.derived->from_intmod
+		     == INTMOD_ISO_FORTRAN_ENV
+		  && code->expr3->ts.u.derived->intmod_sym_id
+		     == ISOFORTRAN_EVENT_TYPE)))
+	{
+	  gfc_error ("The source-expr at %L shall neither be of type "
+		     "EVENT_TYPE nor have a EVENT_TYPE component if "
+		      "allocate-object at %L is a coarray",
+		      &code->expr3->where, &e->where);
+	  goto failure;
+	}
     }
 
   /* Check F08:C629.  */
@@ -7028,6 +7043,13 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
 	 no SOURCE exists by setting expr3.  */
       code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);
     }
+  else if (flag_coarray != GFC_FCOARRAY_LIB && e->ts.type == BT_DERIVED
+	   && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	   && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+    {
+      /* We have to zero initialize the integer variable.  */
+      code->expr3 = gfc_get_int_expr (gfc_default_integer_kind, &e->where, 0);
+    }
   else if (!code->expr3)
     {
       /* Set up default initializer if needed.  */
@@ -8494,7 +8516,7 @@ resolve_transfer (gfc_code *code)
 	  return;
 	}
     }
-   
+
   if (exp->expr_type == EXPR_STRUCTURE)
     return;
 
@@ -8545,21 +8567,40 @@ find_reachable_labels (gfc_code *block)
 
 
 static void
-resolve_lock_unlock (gfc_code *code)
+resolve_lock_unlock_event (gfc_code *code)
 {
   if (code->expr1->expr_type == EXPR_FUNCTION
       && code->expr1->value.function.isym
       && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)
     remove_caf_get_intrinsic (code->expr1);
 
-  if (code->expr1->ts.type != BT_DERIVED
-      || code->expr1->expr_type != EXPR_VARIABLE
-      || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV
-      || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE
-      || code->expr1->rank != 0
-      || (!gfc_is_coarray (code->expr1) && !gfc_is_coindexed (code->expr1)))
+  if ((code->op == EXEC_LOCK || code->op == EXEC_UNLOCK)
+      && (code->expr1->ts.type != BT_DERIVED
+	  || code->expr1->expr_type != EXPR_VARIABLE
+	  || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV
+	  || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE
+	  || code->expr1->rank != 0
+	  || (!gfc_is_coarray (code->expr1) &&
+	      !gfc_is_coindexed (code->expr1))))
     gfc_error ("Lock variable at %L must be a scalar of type LOCK_TYPE",
 	       &code->expr1->where);
+  else if ((code->op == EXEC_EVENT_POST || code->op == EXEC_EVENT_WAIT)
+	   && (code->expr1->ts.type != BT_DERIVED
+	       || code->expr1->expr_type != EXPR_VARIABLE
+	       || code->expr1->ts.u.derived->from_intmod
+		  != INTMOD_ISO_FORTRAN_ENV
+	       || code->expr1->ts.u.derived->intmod_sym_id
+		  != ISOFORTRAN_EVENT_TYPE
+	       || code->expr1->rank != 0))
+    gfc_error ("Event variable at %L must be a scalar of type EVENT_TYPE",
+	       &code->expr1->where);
+  else if (code->op == EXEC_EVENT_POST && !gfc_is_coarray (code->expr1)
+	   && !gfc_is_coindexed (code->expr1))
+    gfc_error ("Event variable argument at %L must be a coarray or coindexed",
+	       &code->expr1->where);
+  else if (code->op == EXEC_EVENT_WAIT && !gfc_is_coarray (code->expr1))
+    gfc_error ("Event variable argument at %L must be a coarray but not "
+	       "coindexed", &code->expr1->where);
 
   /* Check STAT.  */
   if (code->expr2
@@ -8585,17 +8626,23 @@ resolve_lock_unlock (gfc_code *code)
 				    _("ERRMSG variable")))
     return;
 
-  /* Check ACQUIRED_LOCK.  */
-  if (code->expr4
+  /* Check for LOCK the ACQUIRED_LOCK.  */
+  if (code->op != EXEC_EVENT_WAIT && code->expr4
       && (code->expr4->ts.type != BT_LOGICAL || code->expr4->rank != 0
 	  || code->expr4->expr_type != EXPR_VARIABLE))
     gfc_error ("ACQUIRED_LOCK= argument at %L must be a scalar LOGICAL "
 	       "variable", &code->expr4->where);
 
-  if (code->expr4
+  if (code->op != EXEC_EVENT_WAIT && code->expr4
       && !gfc_check_vardef_context (code->expr4, false, false, false,
 				    _("ACQUIRED_LOCK variable")))
     return;
+
+  /* Check for EVENT WAIT the UNTIL_COUNT.  */
+  if (code->op == EXEC_EVENT_WAIT && code->expr4
+      && (code->expr4->ts.type != BT_INTEGER || code->expr4->rank != 0))
+    gfc_error ("UNTIL_COUNT= argument at %L must be a scalar INTEGER "
+	       "expression", &code->expr4->where);
 }
 
 
@@ -8643,6 +8690,7 @@ resolve_critical (gfc_code *code)
   symtree->n.sym->as->cotype = AS_EXPLICIT;
   symtree->n.sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind,
 						   NULL, 1);
+  gfc_commit_symbols();
 }
 
 
@@ -9992,6 +10040,50 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)
 }
 
 
+/* Deferred character length assignments from an operator expression
+   require a temporary because the character length of the lhs can
+   change in the course of the assignment.  */
+
+static bool
+deferred_op_assign (gfc_code **code, gfc_namespace *ns)
+{
+  gfc_expr *tmp_expr;
+  gfc_code *this_code;
+
+  if (!((*code)->expr1->ts.type == BT_CHARACTER
+	 && (*code)->expr1->ts.deferred && (*code)->expr1->rank
+	 && (*code)->expr2->expr_type == EXPR_OP))
+    return false;
+
+  if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
+    return false;
+
+  tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
+  tmp_expr->where = (*code)->loc;
+
+  /* A new charlen is required to ensure that the variable string
+     length is different to that of the original lhs.  */
+  tmp_expr->ts.u.cl = gfc_get_charlen();
+  tmp_expr->symtree->n.sym->ts.u.cl = tmp_expr->ts.u.cl;
+  tmp_expr->ts.u.cl->next = (*code)->expr2->ts.u.cl->next;
+  (*code)->expr2->ts.u.cl->next = tmp_expr->ts.u.cl;
+
+  tmp_expr->symtree->n.sym->ts.deferred = 1;
+
+  this_code = build_assignment (EXEC_ASSIGN,
+				(*code)->expr1,
+				gfc_copy_expr (tmp_expr),
+				NULL, NULL, (*code)->loc);
+
+  (*code)->expr1 = tmp_expr;
+
+  this_code->next = (*code)->next;
+  (*code)->next = this_code;
+
+  return true;
+}
+
+
 /* Given a block of code, recursively resolve everything pointed to by this
    code block.  */
 
@@ -10128,7 +10220,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)
 
 	case EXEC_LOCK:
 	case EXEC_UNLOCK:
-	  resolve_lock_unlock (code);
+	case EXEC_EVENT_POST:
+	case EXEC_EVENT_WAIT:
+	  resolve_lock_unlock_event (code);
 	  break;
 
 	case EXEC_ENTRY:
@@ -10189,6 +10283,11 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)
 		goto call;
 	    }
 
+	  /* Check for dependencies in deferred character length array
+	     assignments and generate a temporary, if necessary.  */
+	  if (code->op == EXEC_ASSIGN && deferred_op_assign (&code, ns))
+	    break;
+
 	  /* F03 7.4.1.3 for non-allocatable, non-pointer components.  */
 	  if (code->op != EXEC_CALL && code->expr1->ts.type == BT_DERIVED
 	      && code->expr1->ts.u.derived->attr.defined_assign_comp)
@@ -10561,7 +10660,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)
       sym->binding_label = NULL;
 
     }
-  else if (sym->attr.flavor == FL_VARIABLE && module 
+  else if (sym->attr.flavor == FL_VARIABLE && module
 	   && (strcmp (module, gsym->mod_name) != 0
 	       || strcmp (sym->name, gsym->sym_name) != 0))
     {
@@ -13613,6 +13712,19 @@ resolve_symbol (gfc_symbol *sym)
       return;
     }
 
+  /* TS18508, C702/C703.  */
+  if (sym->ts.type == BT_DERIVED
+      && ((sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	   && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+	  || sym->ts.u.derived->attr.event_comp)
+      && !sym->attr.codimension && !sym->ts.u.derived->attr.coarray_comp)
+    {
+      gfc_error ("Variable %s at %L of type EVENT_TYPE or with subcomponent of "
+		 "type LOCK_TYPE must be a coarray", sym->name,
+		 &sym->declared_at);
+      return;
+    }
+
   /* An assumed-size array with INTENT(OUT) shall not be of a type for which
      default initialization is defined (5.1.2.4.4).  */
   if (sym->ts.type == BT_DERIVED
@@ -13642,6 +13754,15 @@ resolve_symbol (gfc_symbol *sym)
       return;
     }
 
+  /* TS18508.  */
+  if (sym->ts.type == BT_DERIVED && sym->attr.dummy
+      && sym->attr.intent == INTENT_OUT && sym->attr.event_comp)
+    {
+      gfc_error ("Dummy argument %qs at %L of EVENT_TYPE shall not be "
+		 "INTENT(OUT)", sym->name, &sym->declared_at);
+      return;
+    }
+
   /* F2008, C525.  */
   if ((((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)
 	 || (sym->ts.type == BT_CLASS && sym->attr.class_ok
@@ -14854,9 +14975,9 @@ check_uop_procedure (gfc_symbol *sym, locus where)
     }
 
   if (sym->ts.type == BT_CHARACTER
-      && !(sym->ts.u.cl && sym->ts.u.cl->length)
-      && !(sym->result && sym->result->ts.u.cl
-	   && sym->result->ts.u.cl->length))
+      && !((sym->ts.u.cl && sym->ts.u.cl->length) || sym->ts.deferred)
+      && !(sym->result && ((sym->result->ts.u.cl
+	   && sym->result->ts.u.cl->length) || sym->result->ts.deferred)))
     {
       gfc_error ("User operator procedure %qs at %L cannot be assumed "
 		 "character length", sym->name, &where);
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index f9d7811..db23463 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -336,7 +336,7 @@ add_path_to_list (gfc_directorylist **list, const char *path,
     }
   else if (!S_ISDIR (st.st_mode))
     {
-      gfc_warning_now (0, "%qs is not a directory", path);
+      gfc_fatal_error ("%qs is not a directory", path);
       return;
     }
 
diff --git a/gcc/fortran/st.c b/gcc/fortran/st.c
index 116af15..03792f8 100644
--- a/gcc/fortran/st.c
+++ b/gcc/fortran/st.c
@@ -118,6 +118,8 @@ gfc_free_statement (gfc_code *p)
     case EXEC_SYNC_MEMORY:
     case EXEC_LOCK:
     case EXEC_UNLOCK:
+    case EXEC_EVENT_POST:
+    case EXEC_EVENT_WAIT:
       break;
 
     case EXEC_BLOCK:
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 8c43854..a4a906b 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -3121,49 +3121,49 @@ gfc_restore_last_undo_checkpoint (void)
 
   FOR_EACH_VEC_ELT (latest_undo_chgset->syms, i, p)
     {
-      if (p->gfc_new)
+      /* Symbol was new. Or was old and just put in common */
+      if ((p->gfc_new
+	   || (p->attr.in_common && !p->old_symbol->attr.in_common ))
+	  && p->attr.in_common && p->common_block && p->common_block->head)
 	{
-	  /* Symbol was new.  */
-	  if (p->attr.in_common && p->common_block && p->common_block->head)
-	    {
-	      /* If the symbol was added to any common block, it
-		 needs to be removed to stop the resolver looking
-		 for a (possibly) dead symbol.  */
+	  /* If the symbol was added to any common block, it
+	     needs to be removed to stop the resolver looking
+	     for a (possibly) dead symbol.  */
 
-	      if (p->common_block->head == p && !p->common_next)
+	  if (p->common_block->head == p && !p->common_next)
+	    {
+	      gfc_symtree st, *st0;
+	      st0 = find_common_symtree (p->ns->common_root,
+					 p->common_block);
+	      if (st0)
 		{
-		  gfc_symtree st, *st0;
-		  st0 = find_common_symtree (p->ns->common_root,
-					     p->common_block);
-		  if (st0)
-		    {
-		      st.name = st0->name;
-		      gfc_delete_bbt (&p->ns->common_root, &st, compare_symtree);
-		      free (st0);
-		    }
+		  st.name = st0->name;
+		  gfc_delete_bbt (&p->ns->common_root, &st, compare_symtree);
+		  free (st0);
 		}
+	    }
 
-	      if (p->common_block->head == p)
-	        p->common_block->head = p->common_next;
-	      else
-		{
-		  gfc_symbol *cparent, *csym;
-
-		  cparent = p->common_block->head;
-		  csym = cparent->common_next;
-
-		  while (csym != p)
-		    {
-		      cparent = csym;
-		      csym = csym->common_next;
-		    }
+	  if (p->common_block->head == p)
+	    p->common_block->head = p->common_next;
+	  else
+	    {
+	      gfc_symbol *cparent, *csym;
 
-		  gcc_assert(cparent->common_next == p);
+	      cparent = p->common_block->head;
+	      csym = cparent->common_next;
 
-		  cparent->common_next = csym->common_next;
+	      while (csym != p)
+		{
+		  cparent = csym;
+		  csym = csym->common_next;
 		}
-	    }
 
+	      gcc_assert(cparent->common_next == p);
+	      cparent->common_next = csym->common_next;
+	    }
+	}
+      if (p->gfc_new)
+	{
 	  /* The derived type is saved in the symtree with the first
 	     letter capitalized; the all lower-case version to the
 	     derived type contains its associated generic function.  */
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 3c2c640..c2a248a 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -1,5 +1,5 @@
 /* Array translation routines
-   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
    Contributed by Paul Brook <paul@nowt.org>
    and Steven Bosscher <s.bosscher@student.tudelft.nl>
 
@@ -3112,7 +3112,9 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)
     index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,
 			     index, info->offset);
 
-  if (expr && is_subref_array (expr))
+  if (expr && (is_subref_array (expr)
+	       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE
+					 || expr->expr_type == EXPR_FUNCTION))))
     decl = expr->symtree->n.sym->backend_decl;
 
   tmp = build_fold_indirect_ref_loc (input_location, info->data);
@@ -3532,7 +3534,8 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,
   tree init;
   tree incr;
 
-  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS))
+  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS
+		      | OMPWS_SCALARIZER_BODY))
       == (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS)
       && n == loop->dimen - 1)
     {
@@ -4409,7 +4412,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,
 	  if (!nDepend && dest_expr->rank > 0
 	      && dest_expr->ts.type == BT_CHARACTER
 	      && ss_expr->expr_type == EXPR_VARIABLE)
-	    
+
 	    nDepend = gfc_check_dependency (dest_expr, ss_expr, false);
 
 	  continue;
@@ -4956,7 +4959,8 @@ static tree
 gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,
 		     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,
 		     stmtblock_t * descriptor_block, tree * overflow,
-		     tree expr3_elem_size, tree *nelems, gfc_expr *expr3)
+		     tree expr3_elem_size, tree *nelems, gfc_expr *expr3,
+		     gfc_expr *expr)
 {
   tree type;
   tree tmp;
@@ -4981,8 +4985,19 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,
   offset = gfc_index_zero_node;
 
   /* Set the dtype.  */
-  tmp = gfc_conv_descriptor_dtype (descriptor);
-  gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));
+  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred
+      && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL)
+    {
+      type = gfc_typenode_for_spec (&expr->ts);
+      tmp = gfc_conv_descriptor_dtype (descriptor);
+      gfc_add_modify (descriptor_block, tmp,
+		      gfc_get_dtype_rank_type (rank, type));
+    }
+  else
+    {
+      tmp = gfc_conv_descriptor_dtype (descriptor);
+      gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));
+    }
 
   or_expr = boolean_false_node;
 
@@ -5294,7 +5309,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,
   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,
 			      ref->u.ar.as->corank, &offset, lower, upper,
 			      &se->pre, &set_descriptor_block, &overflow,
-			      expr3_elem_size, nelems, expr3);
+			      expr3_elem_size, nelems, expr3, expr);
 
   if (dimension)
     {
@@ -6945,7 +6960,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
 				    gfc_array_index_type,
 				    stride, info->stride[n]);
 
-	  if (se->direct_byref
+	  if ((se->direct_byref || se->use_offset)
 	      && ((info->ref && info->ref->u.ar.type != AR_FULL)
 		  || (expr->expr_type == EXPR_ARRAY && se->use_offset)))
 	    {
@@ -7191,6 +7206,17 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,
   if (no_pack || array_constructor || good_allocatable || ultimate_alloc_comp)
     {
       gfc_conv_expr_descriptor (se, expr);
+      /* Deallocate the allocatable components of structures that are
+	 not variable.  */
+      if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)
+	   && expr->ts.u.derived->attr.alloc_comp
+	   && expr->expr_type != EXPR_VARIABLE)
+	{
+	  tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, se->expr, expr->rank);
+
+	  /* The components shall be deallocated before their containing entity.  */
+	  gfc_prepend_expr_to_block (&se->post, tmp);
+	}
       if (expr->ts.type == BT_CHARACTER)
 	se->string_length = expr->ts.u.cl->backend_decl;
       if (size)
@@ -7226,10 +7252,11 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,
     }
 
   /* Deallocate the allocatable components of structures that are
-     not variable.  */
-  if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)
-	&& expr->ts.u.derived->attr.alloc_comp
-	&& expr->expr_type != EXPR_VARIABLE)
+     not variable, for descriptorless arguments.
+     Arguments with a descriptor are handled in gfc_conv_procedure_call.  */
+  if (g77 && (expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)
+	  && expr->ts.u.derived->attr.alloc_comp
+	  && expr->expr_type != EXPR_VARIABLE)
     {
       tmp = build_fold_indirect_ref_loc (input_location, se->expr);
       tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);
@@ -8269,6 +8296,75 @@ gfc_is_reallocatable_lhs (gfc_expr *expr)
 }
 
 
+static tree
+concat_str_length (gfc_expr* expr)
+{
+  tree type;
+  tree len1;
+  tree len2;
+  gfc_se se;
+
+  type = gfc_typenode_for_spec (&expr->value.op.op1->ts);
+  len1 = TYPE_MAX_VALUE (TYPE_DOMAIN (type));
+  if (len1 == NULL_TREE)
+    {
+      if (expr->value.op.op1->expr_type == EXPR_OP)
+	len1 = concat_str_length (expr->value.op.op1);
+      else if (expr->value.op.op1->expr_type == EXPR_CONSTANT)
+	len1 = build_int_cst (gfc_charlen_type_node,
+			expr->value.op.op1->value.character.length);
+      else if (expr->value.op.op1->ts.u.cl->length)
+	{
+	  gfc_init_se (&se, NULL);
+	  gfc_conv_expr (&se, expr->value.op.op1->ts.u.cl->length);
+	  len1 = se.expr;
+	}
+      else
+	{
+	  /* Last resort!  */
+	  gfc_init_se (&se, NULL);
+	  se.want_pointer = 1;
+	  se.descriptor_only = 1;
+	  gfc_conv_expr (&se, expr->value.op.op1);
+	  len1 = se.string_length;
+	}
+    }
+
+  type = gfc_typenode_for_spec (&expr->value.op.op2->ts);
+  len2 = TYPE_MAX_VALUE (TYPE_DOMAIN (type));
+  if (len2 == NULL_TREE)
+    {
+      if (expr->value.op.op2->expr_type == EXPR_OP)
+	len2 = concat_str_length (expr->value.op.op2);
+      else if (expr->value.op.op2->expr_type == EXPR_CONSTANT)
+	len2 = build_int_cst (gfc_charlen_type_node,
+			expr->value.op.op2->value.character.length);
+      else if (expr->value.op.op2->ts.u.cl->length)
+	{
+	  gfc_init_se (&se, NULL);
+	  gfc_conv_expr (&se, expr->value.op.op2->ts.u.cl->length);
+	  len2 = se.expr;
+	}
+      else
+	{
+	  /* Last resort!  */
+	  gfc_init_se (&se, NULL);
+	  se.want_pointer = 1;
+	  se.descriptor_only = 1;
+	  gfc_conv_expr (&se, expr->value.op.op2);
+	  len2 = se.string_length;
+	}
+    }
+
+  gcc_assert(len1 && len2);
+  len1 = fold_convert (gfc_charlen_type_node, len1);
+  len2 = fold_convert (gfc_charlen_type_node, len2);
+
+  return fold_build2_loc (input_location, PLUS_EXPR,
+			  gfc_charlen_type_node, len1, len2);
+}
+
+
 /* Allocate the lhs of an assignment to an allocatable array, otherwise
    reallocate it.  */
 
@@ -8366,6 +8462,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   /* Allocate if data is NULL.  */
   cond_null = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,
 			 array1, build_int_cst (TREE_TYPE (array1), 0));
+
+  if (expr1->ts.deferred)
+    cond_null = gfc_evaluate_now (boolean_true_node, &fblock);
+  else
+    cond_null= gfc_evaluate_now (cond_null, &fblock);
+
   tmp = build3_v (COND_EXPR, cond_null,
 		  build1_v (GOTO_EXPR, jump_label1),
 		  build_empty_stmt (input_location));
@@ -8454,7 +8556,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 
   cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,
 			  size1, size2);
-  neq_size = gfc_evaluate_now (cond, &fblock);
+
+  /* If the lhs is deferred length, assume that the element size
+     changes and force a reallocation.  */
+  if (expr1->ts.deferred)
+    neq_size = gfc_evaluate_now (boolean_true_node, &fblock);
+  else
+    neq_size = gfc_evaluate_now (cond, &fblock);
 
   /* Deallocation of allocatable components will have to occur on
      reallocation.  Fix the old descriptor now.  */
@@ -8559,6 +8667,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
       else
 	{
 	  tmp = expr2->ts.u.cl->backend_decl;
+	  if (!tmp && expr2->expr_type == EXPR_OP
+	      && expr2->value.op.op == INTRINSIC_CONCAT)
+	    {
+	      tmp = concat_str_length (expr2);
+	      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);
+	    }
 	  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);
 	}
 
@@ -8586,6 +8700,22 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 			   size2, size_one_node);
   size2 = gfc_evaluate_now (size2, &fblock);
 
+  /* For deferred character length, the 'size' field of the dtype might
+     have changed so set the dtype.  */
+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))
+      && expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
+    {
+      tree type;
+      tmp = gfc_conv_descriptor_dtype (desc);
+      if (expr2->ts.u.cl->backend_decl)
+	type = gfc_typenode_for_spec (&expr2->ts);
+      else
+	type = gfc_typenode_for_spec (&expr1->ts);
+
+      gfc_add_modify (&fblock, tmp,
+		      gfc_get_dtype_rank_type (expr1->rank,type));
+    }
+
   /* Realloc expression.  Note that the scalarizer uses desc.data
      in the array reference - (*desc.data)[<element>].  */
   gfc_init_block (&realloc_block);
@@ -8628,8 +8758,16 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 			     1, size2);
   gfc_conv_descriptor_data_set (&alloc_block,
 				desc, tmp);
-  tmp = gfc_conv_descriptor_dtype (desc);
-  gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));
+
+  /* We already set the dtype in the case of deferred character
+     length arrays.  */
+  if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))
+        && expr1->ts.type == BT_CHARACTER && expr1->ts.deferred))
+    {
+      tmp = gfc_conv_descriptor_dtype (desc);
+      gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));
+    }
+
   if ((expr1->ts.type == BT_DERIVED)
 	&& expr1->ts.u.derived->attr.alloc_comp)
     {
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 900015d..e046a5e 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -163,6 +163,9 @@ tree gfor_fndecl_caf_atomic_cas;
 tree gfor_fndecl_caf_atomic_op;
 tree gfor_fndecl_caf_lock;
 tree gfor_fndecl_caf_unlock;
+tree gfor_fndecl_caf_event_post;
+tree gfor_fndecl_caf_event_wait;
+tree gfor_fndecl_caf_event_query;
 tree gfor_fndecl_co_broadcast;
 tree gfor_fndecl_co_max;
 tree gfor_fndecl_co_min;
@@ -1340,8 +1343,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 	&& TREE_CODE (sym->ts.u.cl->backend_decl) == PARM_DECL)
     {
       sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;
-      sym->ts.u.cl->backend_decl = NULL_TREE;
-      length = gfc_create_string_length (sym);
+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (sym->ts.u.cl->passed_length)));
+      sym->ts.u.cl->backend_decl = build_fold_indirect_ref (sym->ts.u.cl->backend_decl);
     }
 
   fun_or_res = byref && (sym->attr.result
@@ -1383,9 +1386,12 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 		  /* We need to insert a indirect ref for param decls.  */
 		  if (sym->ts.u.cl->backend_decl
 		      && TREE_CODE (sym->ts.u.cl->backend_decl) == PARM_DECL)
+		    {
+		      sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;
 		    sym->ts.u.cl->backend_decl =
 			build_fold_indirect_ref (sym->ts.u.cl->backend_decl);
 		}
+		}
 	      /* For all other parameters make sure, that they are copied so
 		 that the value and any modifications are local to the routine
 		 by generating a temporary variable.  */
@@ -1394,6 +1400,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 		       && sym->ts.u.cl->backend_decl)
 		{
 		  sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;
+		  if (POINTER_TYPE_P (TREE_TYPE (sym->ts.u.cl->passed_length)))
+		    sym->ts.u.cl->backend_decl
+			= build_fold_indirect_ref (sym->ts.u.cl->backend_decl);
+		  else
 		  sym->ts.u.cl->backend_decl = NULL_TREE;
 		}
 	    }
@@ -2170,7 +2180,12 @@ create_function_arglist (gfc_symbol * sym)
 			       PARM_DECL,
 			       get_identifier (".__result"),
 			       len_type);
-	  if (!sym->ts.u.cl->length)
+	  if (POINTER_TYPE_P (len_type))
+	    {
+	      sym->ts.u.cl->passed_length = length;
+	      TREE_USED (length) = 1;
+	    }
+	  else if (!sym->ts.u.cl->length)
 	    {
 	      sym->ts.u.cl->backend_decl = length;
 	      TREE_USED (length) = 1;
@@ -2290,7 +2305,10 @@ create_function_arglist (gfc_symbol * sym)
 	  if (f->sym->ts.u.cl->backend_decl == NULL
 	      || f->sym->ts.u.cl->backend_decl == length)
 	    {
-	      if (f->sym->ts.u.cl->backend_decl == NULL)
+	      if (POINTER_TYPE_P (len_type))
+		f->sym->ts.u.cl->backend_decl =
+			build_fold_indirect_ref_loc (input_location, length);
+	      else if (f->sym->ts.u.cl->backend_decl == NULL)
 		gfc_create_string_length (f->sym);
 
 	      /* Make sure PARM_DECL type doesn't point to incomplete type.  */
@@ -3505,6 +3523,21 @@ gfc_build_builtin_function_decls (void)
 	void_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,
 	pint_type, pchar_type_node, integer_type_node);
 
+      gfor_fndecl_caf_event_post = gfc_build_library_function_decl_with_spec (
+	get_identifier (PREFIX("caf_event_post")), "R..WW",
+	void_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,
+	pint_type, pchar_type_node, integer_type_node);
+
+      gfor_fndecl_caf_event_wait = gfc_build_library_function_decl_with_spec (
+	get_identifier (PREFIX("caf_event_wait")), "R..WW",
+	void_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,
+	pint_type, pchar_type_node, integer_type_node);
+
+      gfor_fndecl_caf_event_query = gfc_build_library_function_decl_with_spec (
+	get_identifier (PREFIX("caf_event_query")), "R..WW",
+	void_type_node, 5, pvoid_type_node, size_type_node, integer_type_node,
+	pint_type, pint_type);
+
       gfor_fndecl_co_broadcast = gfc_build_library_function_decl_with_spec (
 	get_identifier (PREFIX("caf_co_broadcast")), "W.WW",
 	void_type_node, 5, pvoid_type_node, integer_type_node,
@@ -3828,6 +3861,62 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 }
 
 
+/* Helper function to manage deferred string lengths.  */
+
+static tree
+gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,
+			        locus *loc)
+{
+  tree tmp;
+
+  /* Character length passed by reference.  */
+  tmp = sym->ts.u.cl->passed_length;
+  tmp = build_fold_indirect_ref_loc (input_location, tmp);
+  tmp = fold_convert (gfc_charlen_type_node, tmp);
+
+  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)
+    /* Zero the string length when entering the scope.  */
+    gfc_add_modify (init, sym->ts.u.cl->backend_decl,
+		    build_int_cst (gfc_charlen_type_node, 0));
+  else
+    {
+      tree tmp2;
+
+      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR,
+			      gfc_charlen_type_node,
+			      sym->ts.u.cl->backend_decl, tmp);
+      if (sym->attr.optional)
+	{
+	  tree present = gfc_conv_expr_present (sym);
+	  tmp2 = build3_loc (input_location, COND_EXPR,
+			     void_type_node, present, tmp2,
+			     build_empty_stmt (input_location));
+	}
+      gfc_add_expr_to_block (init, tmp2);
+    }
+
+  gfc_restore_backend_locus (loc);
+
+  /* Pass the final character length back.  */
+  if (sym->attr.intent != INTENT_IN)
+    {
+      tmp = fold_build2_loc (input_location, MODIFY_EXPR,
+			     gfc_charlen_type_node, tmp,
+			     sym->ts.u.cl->backend_decl);
+      if (sym->attr.optional)
+	{
+	  tree present = gfc_conv_expr_present (sym);
+	  tmp = build3_loc (input_location, COND_EXPR,
+			    void_type_node, present, tmp,
+			    build_empty_stmt (input_location));
+	}
+    }
+  else
+    tmp = NULL_TREE;
+
+  return tmp;
+}
+
 /* Generate function entry and exit code, and add it to the function body.
    This includes:
     Allocation and initialization of array variables.
@@ -3877,7 +3966,19 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	  /* An automatic character length, pointer array result.  */
 	  if (proc_sym->ts.type == BT_CHARACTER
 		&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)
-	    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);
+	    {
+	      tmp = NULL;
+	      if (proc_sym->ts.deferred)
+		{
+		  gfc_save_backend_locus (&loc);
+		  gfc_set_backend_locus (&proc_sym->declared_at);
+		  gfc_start_block (&init);
+		  tmp = gfc_null_and_pass_deferred_len (proc_sym, &init, &loc);
+		  gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);
+		}
+	      else
+		gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);
+	    }
 	}
       else if (proc_sym->ts.type == BT_CHARACTER)
 	{
@@ -3903,12 +4004,20 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	      gfc_restore_backend_locus (&loc);
 
 	      /* Pass back the string length on exit.  */
+	      tmp = proc_sym->ts.u.cl->backend_decl;
+	      if (TREE_CODE (tmp) != INDIRECT_REF
+		  && proc_sym->ts.u.cl->passed_length)
+		{
 	      tmp = proc_sym->ts.u.cl->passed_length;
 	      tmp = build_fold_indirect_ref_loc (input_location, tmp);
 	      tmp = fold_convert (gfc_charlen_type_node, tmp);
 	      tmp = fold_build2_loc (input_location, MODIFY_EXPR,
 				     gfc_charlen_type_node, tmp,
 				     proc_sym->ts.u.cl->backend_decl);
+		}
+	      else
+		tmp = NULL_TREE;
+
 	      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);
 	    }
 	  else if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)
@@ -3979,10 +4088,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
       else if (sym->attr.dimension || sym->attr.codimension)
 	{
           /* Assumed-size Cray pointees need to be treated as AS_EXPLICIT.  */
-          array_type tmp = sym->as->type;
-          if (tmp == AS_ASSUMED_SIZE && sym->as->cp_was_assumed)
-            tmp = AS_EXPLICIT;
-          switch (tmp)
+          array_type type_of_array = sym->as->type;
+          if (type_of_array == AS_ASSUMED_SIZE && sym->as->cp_was_assumed)
+            type_of_array = AS_EXPLICIT;
+          switch (type_of_array)
 	    {
 	    case AS_EXPLICIT:
 	      if (sym->attr.dummy || sym->attr.result)
@@ -4059,6 +4168,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	    case AS_DEFERRED:
 	      seen_trans_deferred_array = true;
 	      gfc_trans_deferred_array (sym, block);
+	      if (sym->ts.type == BT_CHARACTER && sym->ts.deferred
+		  && sym->attr.result)
+		{
+		  gfc_start_block (&init);
+		  gfc_save_backend_locus (&loc);
+		  gfc_set_backend_locus (&sym->declared_at);
+		  tmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);
+		  gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);
+		}
 	      break;
 
 	    default:
@@ -4073,6 +4191,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	continue;
       else if ((!sym->attr.dummy || sym->ts.deferred)
 		&& (sym->attr.allocatable
+		    || (sym->attr.pointer && sym->attr.result)
 		    || (sym->ts.type == BT_CLASS
 			&& CLASS_DATA (sym)->attr.allocatable)))
 	{
@@ -4080,95 +4199,50 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	    {
 	      tree descriptor = NULL_TREE;
 
-	      /* Nullify and automatic deallocation of allocatable
-		 scalars.  */
-	      e = gfc_lval_expr_from_sym (sym);
-	      if (sym->ts.type == BT_CLASS)
-		gfc_add_data_component (e);
-
-	      gfc_init_se (&se, NULL);
-	      if (sym->ts.type != BT_CLASS
-		  || sym->ts.u.derived->attr.dimension
-		  || sym->ts.u.derived->attr.codimension)
-		{
-		  se.want_pointer = 1;
-		  gfc_conv_expr (&se, e);
-		}
-	      else if (sym->ts.type == BT_CLASS
-		       && !CLASS_DATA (sym)->attr.dimension
-		       && !CLASS_DATA (sym)->attr.codimension)
-		{
-		  se.want_pointer = 1;
-		  gfc_conv_expr (&se, e);
-		}
-	      else
-		{
-		  gfc_conv_expr (&se, e);
-		  descriptor = se.expr;
-		  se.expr = gfc_conv_descriptor_data_addr (se.expr);
-		  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);
-		}
-	      gfc_free_expr (e);
-
 	      gfc_save_backend_locus (&loc);
 	      gfc_set_backend_locus (&sym->declared_at);
 	      gfc_start_block (&init);
 
-	      if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)
+	      if (!sym->attr.pointer)
 		{
-		  /* Nullify when entering the scope.  */
-		  tmp = fold_build2_loc (input_location, MODIFY_EXPR,
-					 TREE_TYPE (se.expr), se.expr,
-					 fold_convert (TREE_TYPE (se.expr),
-						       null_pointer_node));
-		  if (sym->attr.optional)
+		  /* Nullify and automatic deallocation of allocatable
+		     scalars.  */
+		  e = gfc_lval_expr_from_sym (sym);
+		  if (sym->ts.type == BT_CLASS)
+		    gfc_add_data_component (e);
+
+		  gfc_init_se (&se, NULL);
+		  if (sym->ts.type != BT_CLASS
+		      || sym->ts.u.derived->attr.dimension
+		      || sym->ts.u.derived->attr.codimension)
 		    {
-		      tree present = gfc_conv_expr_present (sym);
-		      tmp = build3_loc (input_location, COND_EXPR,
-					void_type_node, present, tmp,
-					build_empty_stmt (input_location));
+		      se.want_pointer = 1;
+		      gfc_conv_expr (&se, e);
+		    }
+		  else if (sym->ts.type == BT_CLASS
+			   && !CLASS_DATA (sym)->attr.dimension
+			   && !CLASS_DATA (sym)->attr.codimension)
+		    {
+		      se.want_pointer = 1;
+		      gfc_conv_expr (&se, e);
 		    }
-		  gfc_add_expr_to_block (&init, tmp);
-		}
-
-	      if ((sym->attr.dummy || sym->attr.result)
-		    && sym->ts.type == BT_CHARACTER
-		    && sym->ts.deferred)
-		{
-		  /* Character length passed by reference.  */
-		  tmp = sym->ts.u.cl->passed_length;
-		  tmp = build_fold_indirect_ref_loc (input_location, tmp);
-		  tmp = fold_convert (gfc_charlen_type_node, tmp);
-
-		  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)
-		    /* Zero the string length when entering the scope.  */
-		    gfc_add_modify (&init, sym->ts.u.cl->backend_decl,
-				build_int_cst (gfc_charlen_type_node, 0));
 		  else
 		    {
-		      tree tmp2;
-
-		      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR,
-					      gfc_charlen_type_node,
-					      sym->ts.u.cl->backend_decl, tmp);
-		      if (sym->attr.optional)
-			{
-			  tree present = gfc_conv_expr_present (sym);
-			  tmp2 = build3_loc (input_location, COND_EXPR,
-					     void_type_node, present, tmp2,
-					     build_empty_stmt (input_location));
-			}
-		      gfc_add_expr_to_block (&init, tmp2);
+		      se.descriptor_only = 1;
+		      gfc_conv_expr (&se, e);
+		      descriptor = se.expr;
+		      se.expr = gfc_conv_descriptor_data_addr (se.expr);
+		      se.expr = build_fold_indirect_ref_loc (input_location, se.expr);
 		    }
+		  gfc_free_expr (e);
 
-		  gfc_restore_backend_locus (&loc);
-
-		  /* Pass the final character length back.  */
-		  if (sym->attr.intent != INTENT_IN)
+		  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)
 		    {
+		      /* Nullify when entering the scope.  */
 		      tmp = fold_build2_loc (input_location, MODIFY_EXPR,
-					     gfc_charlen_type_node, tmp,
-					     sym->ts.u.cl->backend_decl);
+					     TREE_TYPE (se.expr), se.expr,
+					     fold_convert (TREE_TYPE (se.expr),
+							   null_pointer_node));
 		      if (sym->attr.optional)
 			{
 			  tree present = gfc_conv_expr_present (sym);
@@ -4176,16 +4250,21 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 					    void_type_node, present, tmp,
 					    build_empty_stmt (input_location));
 			}
+		      gfc_add_expr_to_block (&init, tmp);
 		    }
-		  else
-		    tmp = NULL_TREE;
 		}
+
+	      if ((sym->attr.dummy || sym->attr.result)
+		    && sym->ts.type == BT_CHARACTER
+		    && sym->ts.deferred
+		    && sym->ts.u.cl->passed_length)
+		tmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);
 	      else
 		gfc_restore_backend_locus (&loc);
 
 	      /* Deallocate when leaving the scope. Nullifying is not
 		 needed.  */
-	      if (!sym->attr.result && !sym->attr.dummy
+	      if (!sym->attr.result && !sym->attr.dummy && !sym->attr.pointer
 		  && !sym->ns->proc_name->attr.is_main_program)
 		{
 		  if (sym->ts.type == BT_CLASS
@@ -4202,6 +4281,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 		      gfc_free_expr (expr);
 		    }
 		}
+
 	      if (sym->ts.type == BT_CLASS)
 		{
 		  /* Initialize _vptr to declared type.  */
@@ -4242,19 +4322,9 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 	  if (sym->attr.dummy)
 	    {
 	      gfc_start_block (&init);
-
-	      /* Character length passed by reference.  */
-	      tmp = sym->ts.u.cl->passed_length;
-	      tmp = build_fold_indirect_ref_loc (input_location, tmp);
-	      tmp = fold_convert (gfc_charlen_type_node, tmp);
-	      gfc_add_modify (&init, sym->ts.u.cl->backend_decl, tmp);
-	      /* Pass the final character length back.  */
-	      if (sym->attr.intent != INTENT_IN)
-		tmp = fold_build2_loc (input_location, MODIFY_EXPR,
-				       gfc_charlen_type_node, tmp,
-				       sym->ts.u.cl->backend_decl);
-	      else
-		tmp = NULL_TREE;
+	      gfc_save_backend_locus (&loc);
+	      gfc_set_backend_locus (&sym->declared_at);
+	      tmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);
 	      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);
 	    }
 	}
@@ -4784,7 +4854,7 @@ static void
 generate_coarray_sym_init (gfc_symbol *sym)
 {
   tree tmp, size, decl, token;
-  bool is_lock_type;
+  bool is_lock_type, is_event_type;
   int reg_type;
 
   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension
@@ -4800,13 +4870,17 @@ generate_coarray_sym_init (gfc_symbol *sym)
 		 && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
 		 && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE;
 
+  is_event_type = sym->ts.type == BT_DERIVED
+		  && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+		  && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE;
+
   /* FIXME: Workaround for PR middle-end/49106, cf. also PR middle-end/49108
      to make sure the variable is not optimized away.  */
   DECL_PRESERVE_P (DECL_CONTEXT (decl)) = 1;
 
   /* For lock types, we pass the array size as only the library knows the
      size of the variable.  */
-  if (is_lock_type)
+  if (is_lock_type || is_event_type)
     size = gfc_index_one_node;
   else
     size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));
@@ -4828,6 +4902,8 @@ generate_coarray_sym_init (gfc_symbol *sym)
 			       GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE(decl)));
   if (is_lock_type)
     reg_type = sym->attr.artificial ? GFC_CAF_CRITICAL : GFC_CAF_LOCK_STATIC;
+  else if (is_event_type)
+    reg_type = GFC_CAF_EVENT_STATIC;
   else
     reg_type = GFC_CAF_COARRAY_STATIC;
   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 6, size,
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index 2b1cbc7..1681d14 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1,5 +1,5 @@
 /* Expression translation
-   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
    Contributed by Paul Brook <paul@nowt.org>
    and Steven Bosscher <s.bosscher@student.tudelft.nl>
 
@@ -1019,6 +1019,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)
   tree fcn;
   tree fcn_type;
   tree from_data;
+  tree from_class_base = NULL;
   tree from_len;
   tree to_data;
   tree to_len;
@@ -1035,21 +1036,41 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)
   from_len = to_len = NULL_TREE;
 
   if (from != NULL_TREE)
-    fcn = gfc_class_vtab_copy_get (from);
+    {
+      /* Check that from is a class.  When the class is part of a coarray,
+	 then from is a common pointer and is to be used as is.  */
+      tmp = POINTER_TYPE_P (TREE_TYPE (from)) && !DECL_P (from)
+	  ? TREE_OPERAND (from, 0) : from;
+      if (GFC_CLASS_TYPE_P (TREE_TYPE (tmp))
+	  || (DECL_P (tmp) && GFC_DECL_CLASS (tmp)))
+	{
+	  from_class_base = from;
+	  from_data = gfc_class_data_get (from_class_base);
+	}
+      else
+	{
+	  /* For arrays two component_refs can be present.  */
+	  if (TREE_CODE (tmp) == COMPONENT_REF)
+	    tmp = TREE_OPERAND (tmp, 0);
+	  if (TREE_CODE (tmp) == COMPONENT_REF)
+	    tmp = TREE_OPERAND (tmp, 0);
+	  from_class_base = tmp;
+	  from_data = from;
+	}
+      fcn = gfc_class_vtab_copy_get (from_class_base);
+    }
   else
-    fcn = gfc_class_vtab_copy_get (to);
+    {
+      fcn = gfc_class_vtab_copy_get (to);
+      from_data = gfc_class_vtab_def_init_get (to);
+    }
 
   fcn_type = TREE_TYPE (TREE_TYPE (fcn));
 
-  if (from != NULL_TREE)
-      from_data = gfc_class_data_get (from);
-  else
-    from_data = gfc_class_vtab_def_init_get (to);
-
   if (unlimited)
     {
-      if (from != NULL_TREE && unlimited)
-	from_len = gfc_class_len_get (from);
+      if (from_class_base != NULL_TREE)
+	from_len = gfc_class_len_get (from_class_base);
       else
 	from_len = integer_zero_node;
     }
@@ -4398,6 +4419,62 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)
 }
 
 
+/* This function tells whether the middle-end representation of the expression
+   E given as input may point to data otherwise accessible through a variable
+   (sub-)reference.
+   It is assumed that the only expressions that may alias are variables,
+   and array constructors if ARRAY_MAY_ALIAS is true and some of its elements
+   may alias.
+   This function is used to decide whether freeing an expression's allocatable
+   components is safe or should be avoided.
+
+   If ARRAY_MAY_ALIAS is true, an array constructor may alias if some of
+   its elements are copied from a variable.  This ARRAY_MAY_ALIAS trick
+   is necessary because for array constructors, aliasing depends on how
+   the array is used:
+    - If E is an array constructor used as argument to an elemental procedure,
+      the array, which is generated through shallow copy by the scalarizer,
+      is used directly and can alias the expressions it was copied from.
+    - If E is an array constructor used as argument to a non-elemental
+      procedure,the scalarizer is used in gfc_conv_expr_descriptor to generate
+      the array as in the previous case, but then that array is used
+      to initialize a new descriptor through deep copy.  There is no alias
+      possible in that case.
+   Thus, the ARRAY_MAY_ALIAS flag is necessary to distinguish the two cases
+   above.  */
+
+static bool
+expr_may_alias_variables (gfc_expr *e, bool array_may_alias)
+{
+  gfc_constructor *c;
+
+  if (e->expr_type == EXPR_VARIABLE)
+    return true;
+  else if (e->expr_type == EXPR_FUNCTION)
+    {
+      gfc_symbol *proc_ifc = gfc_get_proc_ifc_for_expr (e);
+
+      if ((proc_ifc->result->ts.type == BT_CLASS
+	   && proc_ifc->result->ts.u.derived->attr.is_class
+	   && CLASS_DATA (proc_ifc->result)->attr.class_pointer)
+	  || proc_ifc->result->attr.pointer)
+	return true;
+      else
+	return false;
+    }
+  else if (e->expr_type != EXPR_ARRAY || !array_may_alias)
+    return false;
+
+  for (c = gfc_constructor_first (e->value.constructor);
+       c; c = gfc_constructor_next (c))
+    if (c->expr
+	&& expr_may_alias_variables (c->expr, array_may_alias))
+      return true;
+
+  return false;
+}
+
+
 /* Generate code for a procedure call.  Note can return se->post != NULL.
    If se->direct_byref is set then se->expr contains the return parameter.
    Return nonzero, if the call has alternate specifiers.
@@ -4448,9 +4525,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
   comp = gfc_get_proc_ptr_comp (expr);
 
+  bool elemental_proc = (comp
+			 && comp->ts.interface
+			 && comp->ts.interface->attr.elemental)
+			|| (comp && comp->attr.elemental)
+			|| sym->attr.elemental;
+
   if (se->ss != NULL)
     {
-      if (!sym->attr.elemental && !(comp && comp->attr.elemental))
+      if (!elemental_proc)
 	{
 	  gcc_assert (se->ss->info->type == GFC_SS_FUNCTION);
 	  if (se->ss->info->useflags)
@@ -4501,6 +4584,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
       fsym = formal ? formal->sym : NULL;
       parm_kind = MISSING;
 
+      /* If the procedure requires an explicit interface, the actual
+	 argument is passed according to the corresponding formal
+	 argument.  If the corresponding formal argument is a POINTER,
+	 ALLOCATABLE or assumed shape, we do not use g77's calling
+	 convention, and pass the address of the array descriptor
+	 instead.  Otherwise we use g77's calling convention, in other words
+	 pass the array data pointer without descriptor.  */
+      bool nodesc_arg = fsym != NULL
+			&& !(fsym->attr.pointer || fsym->attr.allocatable)
+			&& fsym->as
+			&& fsym->as->type != AS_ASSUMED_SHAPE
+			&& fsym->as->type != AS_ASSUMED_RANK;
+      if (comp)
+	nodesc_arg = nodesc_arg || !comp->attr.always_explicit;
+      else
+	nodesc_arg = nodesc_arg || !sym->attr.always_explicit;
+
       /* Class array expressions are sometimes coming completely unadorned
 	 with either arrayspec or _data component.  Correct that here.
 	 OOP-TODO: Move this to the frontend.  */
@@ -5020,22 +5120,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	    }
 	  else
 	    {
-              /* If the procedure requires an explicit interface, the actual
-                 argument is passed according to the corresponding formal
-                 argument.  If the corresponding formal argument is a POINTER,
-                 ALLOCATABLE or assumed shape, we do not use g77's calling
-                 convention, and pass the address of the array descriptor
-                 instead. Otherwise we use g77's calling convention.  */
-	      bool f;
-	      f = (fsym != NULL)
-		  && !(fsym->attr.pointer || fsym->attr.allocatable)
-		  && fsym->as && fsym->as->type != AS_ASSUMED_SHAPE
-		  && fsym->as->type != AS_ASSUMED_RANK;
-	      if (comp)
-		f = f || !comp->attr.always_explicit;
-	      else
-		f = f || !sym->attr.always_explicit;
-
 	      /* If the argument is a function call that may not create
 		 a temporary for the result, we have to check that we
 		 can do it, i.e. that there is no alias between this
@@ -5080,7 +5164,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		   array of derived types.  In this case, the argument
 		   is converted to a temporary, which is passed and then
 		   written back after the procedure call.  */
-		gfc_conv_subref_array_arg (&parmse, e, f,
+		gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 	      else if (gfc_is_class_array_ref (e, NULL)
@@ -5092,7 +5176,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		   OOP-TODO: Insert code so that if the dynamic type is
 		   the same as the declared type, copy-in/copy-out does
 		   not occur.  */
-		gfc_conv_subref_array_arg (&parmse, e, f,
+		gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
@@ -5103,12 +5187,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		   intent in.  */
 		{
 		  e->must_finalize = 1;
-		  gfc_conv_subref_array_arg (&parmse, e, f,
+		  gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
 					     INTENT_IN,
 					     fsym && fsym->attr.pointer);
 		}
 	      else
-	        gfc_conv_array_parameter (&parmse, e, f, fsym, sym->name, NULL);
+		gfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,
+					  sym->name, NULL);
 
 	      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is
 		 allocated on entry, it must be deallocated.  */
@@ -5150,7 +5235,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	     but do not always set fsym.  */
 	  if (e->expr_type == EXPR_VARIABLE
 	      && e->symtree->n.sym->attr.optional
-	      && ((e->rank != 0 && sym->attr.elemental)
+	      && ((e->rank != 0 && elemental_proc)
 		  || e->representation.length || e->ts.type == BT_CHARACTER
 		  || (e->rank != 0
 		      && (fsym == NULL
@@ -5185,13 +5270,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
       gfc_add_block_to_block (&post, &parmse.post);
 
       /* Allocated allocatable components of derived types must be
-	 deallocated for non-variable scalars.  Non-variable arrays are
-	 dealt with in trans-array.c(gfc_conv_array_parameter).  */
+	 deallocated for non-variable scalars, array arguments to elemental
+	 procedures, and array arguments with descriptor to non-elemental
+	 procedures.  As bounds information for descriptorless arrays is no
+	 longer available here, they are dealt with in trans-array.c
+	 (gfc_conv_array_parameter).  */
       if (e && (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS)
 	    && e->ts.u.derived->attr.alloc_comp
-	    && !(e->symtree && e->symtree->n.sym->attr.pointer)
-	    && (e->expr_type != EXPR_VARIABLE && !e->rank))
-        {
+	    && (e->rank == 0 || elemental_proc || !nodesc_arg)
+	    && !expr_may_alias_variables (e, elemental_proc))
+	{
 	  int parm_rank;
 	  tmp = build_fold_indirect_ref_loc (input_location,
 					 parmse.expr);
@@ -5343,7 +5431,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	  else
 	    {
 	      tmp = parmse.string_length;
-	      if (TREE_CODE (tmp) != VAR_DECL)
+	      if (TREE_CODE (tmp) != VAR_DECL
+		  && TREE_CODE (tmp) != COMPONENT_REF)
 		tmp = gfc_evaluate_now (parmse.string_length, &se->pre);
 	      parmse.string_length = gfc_build_addr_expr (NULL_TREE, tmp);
 	    }
@@ -5527,8 +5616,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
       len = cl.backend_decl;
     }
 
-  byref = (comp && (comp->attr.dimension || comp->ts.type == BT_CHARACTER))
-	  || (!comp && gfc_return_by_reference (sym));
+  byref = (comp && (comp->attr.dimension
+	   || (comp->ts.type == BT_CHARACTER && !sym->attr.is_bind_c)))
+	   || (!comp && gfc_return_by_reference (sym));
   if (byref)
     {
       if (se->direct_byref)
@@ -5684,6 +5774,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	  tmp = len;
 	  if (TREE_CODE (tmp) != VAR_DECL)
 	    tmp = gfc_evaluate_now (len, &se->pre);
+	  TREE_STATIC (tmp) = 1;
+	  gfc_add_modify (&se->pre, tmp,
+			  build_int_cst (TREE_TYPE (tmp), 0));
 	  tmp = gfc_build_addr_expr (NULL_TREE, tmp);
 	  vec_safe_push (retargs, tmp);
 	}
@@ -6354,6 +6447,11 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,
 {
   gfc_se se;
 
+  if (flag_coarray != GFC_FCOARRAY_LIB && ts->type == BT_DERIVED
+      && ts->u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+      && ts->u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+    return build_constructor (type, NULL);
+
   if (!(expr || pointer || procptr))
     return NULL_TREE;
 
@@ -6518,7 +6616,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)
 
   gfc_conv_expr (&rse, expr);
 
-  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts, true, false, true);
+  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts, true, true, true);
   gfc_add_expr_to_block (&body, tmp);
 
   gcc_assert (rse.ss == gfc_ss_terminator);
@@ -7403,20 +7501,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)
 
   /* Take the address of that value.  */
   se->expr = gfc_build_addr_expr (NULL_TREE, var);
-  if (expr->ts.type == BT_DERIVED && expr->rank
-      && !gfc_is_finalizable (expr->ts.u.derived, NULL)
-      && expr->ts.u.derived->attr.alloc_comp
-      && expr->expr_type != EXPR_VARIABLE)
-    {
-      tree tmp;
-
-      tmp = build_fold_indirect_ref_loc (input_location, se->expr);
-      tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);
-
-      /* The components shall be deallocated before
-         their containing entity.  */
-      gfc_prepend_expr_to_block (&se->post, tmp);
-    }
 }
 
 
@@ -8901,6 +8985,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
   bool scalar_to_array;
   tree string_length;
   int n;
+  bool maybe_workshare = false;
 
   /* Assignment of the form lhs = rhs.  */
   gfc_start_block (&block);
@@ -8975,8 +9060,13 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	}
 
       /* Allow the scalarizer to workshare array assignments.  */
-      if ((ompws_flags & OMPWS_WORKSHARE_FLAG) && loop.temp_ss == NULL)
-	ompws_flags |= OMPWS_SCALARIZER_WS;
+      if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_BODY))
+	  == OMPWS_WORKSHARE_FLAG
+	  && loop.temp_ss == NULL)
+	{
+	  maybe_workshare = true;
+	  ompws_flags |= OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY;
+	}
 
       /* Start the scalarized loop body.  */
       gfc_start_scalarized_body (&loop, &body);
@@ -8998,8 +9088,13 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
     }
 
   /* Stabilize a string length for temporaries.  */
-  if (expr2->ts.type == BT_CHARACTER)
+  if (expr2->ts.type == BT_CHARACTER && !expr1->ts.deferred
+      && !(TREE_CODE (rse.string_length) == VAR_DECL
+	   || TREE_CODE (rse.string_length) == PARM_DECL
+	   || TREE_CODE (rse.string_length) == INDIRECT_REF))
     string_length = gfc_evaluate_now (rse.string_length, &rse.pre);
+  else if (expr2->ts.type == BT_CHARACTER)
+    string_length = rse.string_length;
   else
     string_length = NULL_TREE;
 
@@ -9010,7 +9105,32 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	lse.string_length = string_length;
     }
   else
+    {
     gfc_conv_expr (&lse, expr1);
+      if (gfc_option.rtcheck & GFC_RTCHECK_MEM
+	  && gfc_expr_attr (expr1).allocatable
+	  && expr1->rank
+	  && !expr2->rank)
+	{
+	  tree cond;
+	  const char* msg;
+
+	  tmp = expr1->symtree->n.sym->backend_decl;
+	  if (POINTER_TYPE_P (TREE_TYPE (tmp)))
+	    tmp = build_fold_indirect_ref_loc (input_location, tmp);
+
+	  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
+	    tmp = gfc_conv_descriptor_data_get (tmp);
+	  else
+	    tmp = TREE_OPERAND (lse.expr, 0);
+
+	  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,
+				  tmp, build_int_cst (TREE_TYPE (tmp), 0));
+	  msg = _("Assignment of scalar to unallocated array");
+	  gfc_trans_runtime_check (true, false, cond, &loop.pre,
+				   &expr1->where, msg);
+	}
+    }
 
   /* Assignments of scalar derived types with allocatable components
      to arrays must be done with a deep copy and the rhs temporary
@@ -9033,8 +9153,14 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
      the function call must happen before the (re)allocation of the lhs -
      otherwise the character length of the result is not known.
      NOTE: This relies on having the exact dependence of the length type
-     parameter available to the caller; gfortran saves it in the .mod files.  */
-  if (flag_realloc_lhs && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred)
+     parameter available to the caller; gfortran saves it in the .mod files.
+     NOTE ALSO: The concatenation operation generates a temporary pointer,
+     whose allocation must go to the innermost loop.  */
+  if (flag_realloc_lhs
+      && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred
+      && !(lss != gfc_ss_terminator
+	   && expr2->expr_type == EXPR_OP
+	   && expr2->value.op.op == INTRINSIC_CONCAT))
     gfc_add_block_to_block (&block, &rse.pre);
 
   /* Nullify the allocatable components corresponding to those of the lhs
@@ -9117,6 +9243,9 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	    gfc_add_expr_to_block (&loop.code[expr1->rank - 1], tmp);
 	}
 
+      if (maybe_workshare)
+	ompws_flags &= ~OMPWS_SCALARIZER_BODY;
+
       /* Generate the copying loops.  */
       gfc_trans_scalarizing_loops (&loop, &body);
 
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 9b06259..6d7389a 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -1221,12 +1221,22 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,
   /* No overlap possible as we have generated a temporary.  */
   if (lhs == NULL_TREE)
     may_require_tmp = boolean_false_node;
+  
+  /* It guarantees memory consistency within the same segment */
+  tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+    tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+		      gfc_build_string_const (1, ""),
+		      NULL_TREE, NULL_TREE,
+		      tree_cons (NULL_TREE, tmp, NULL_TREE),
+		      NULL_TREE);
+  ASM_VOLATILE_P (tmp) = 1;
+  gfc_add_expr_to_block (&se->pre, tmp);
 
   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 9,
 			     token, offset, image_index, argse.expr, vec,
 			     dst_var, kind, lhs_kind, may_require_tmp);
   gfc_add_expr_to_block (&se->pre, tmp);
-
+  
   if (se->ss)
     gfc_advance_se_ss_chain (se);
 
@@ -1386,6 +1396,16 @@ conv_caf_send (gfc_code *code) {
     {
       tree rhs_token, rhs_offset, rhs_image_index;
 
+      /* It guarantees memory consistency within the same segment */
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+      gfc_add_expr_to_block (&block, tmp);
+
       caf_decl = gfc_get_tree_for_caf_expr (rhs_expr);
       if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)
 	caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);
@@ -1401,6 +1421,17 @@ conv_caf_send (gfc_code *code) {
   gfc_add_expr_to_block (&block, tmp);
   gfc_add_block_to_block (&block, &lhs_se.post);
   gfc_add_block_to_block (&block, &rhs_se.post);
+
+  /* It guarantees memory consistency within the same segment */
+  tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+    tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+		      gfc_build_string_const (1, ""),
+		      NULL_TREE, NULL_TREE,
+		      tree_cons (NULL_TREE, tmp, NULL_TREE),
+		      NULL_TREE);
+  ASM_VOLATILE_P (tmp) = 1;
+  gfc_add_expr_to_block (&block, tmp);
+
   return gfc_finish_block (&block);
 }
 
@@ -9243,6 +9274,154 @@ conv_intrinsic_atomic_cas (gfc_code *code)
   return gfc_finish_block (&block);
 }
 
+static tree
+conv_intrinsic_event_query (gfc_code *code)
+{
+  gfc_se se, argse;
+  tree stat = NULL_TREE, stat2 = NULL_TREE;
+  tree count = NULL_TREE, count2 = NULL_TREE;
+
+  gfc_expr *event_expr = code->ext.actual->expr;
+
+  if (code->ext.actual->next->next->expr)
+    {
+      gcc_assert (code->ext.actual->next->next->expr->expr_type
+		  == EXPR_VARIABLE);
+      gfc_init_se (&argse, NULL);
+      gfc_conv_expr_val (&argse, code->ext.actual->next->next->expr);
+      stat = argse.expr;
+    }
+  else if (flag_coarray == GFC_FCOARRAY_LIB)
+    stat = null_pointer_node;
+
+  if (code->ext.actual->next->expr)
+    {
+      gcc_assert (code->ext.actual->next->expr->expr_type == EXPR_VARIABLE);
+      gfc_init_se (&argse, NULL);
+      gfc_conv_expr_val (&argse, code->ext.actual->next->expr);
+      count = argse.expr;
+    }
+
+  gfc_start_block (&se.pre);
+  if (flag_coarray == GFC_FCOARRAY_LIB)
+    {
+      tree tmp, token, image_index;
+      tree index = size_zero_node;
+
+      if (event_expr->expr_type == EXPR_FUNCTION
+	  && event_expr->value.function.isym
+	  && event_expr->value.function.isym->id == GFC_ISYM_CAF_GET)
+	event_expr = event_expr->value.function.actual->expr;
+
+      tree caf_decl = gfc_get_tree_for_caf_expr (event_expr);
+
+      if (event_expr->symtree->n.sym->ts.type != BT_DERIVED
+	  || event_expr->symtree->n.sym->ts.u.derived->from_intmod
+	     != INTMOD_ISO_FORTRAN_ENV
+	  || event_expr->symtree->n.sym->ts.u.derived->intmod_sym_id
+	     != ISOFORTRAN_EVENT_TYPE)
+	{
+	  gfc_error ("Sorry, the event component of derived type at %L is not "
+		     "yet supported", &event_expr->where);
+	  return NULL_TREE;
+	}
+
+      if (gfc_is_coindexed (event_expr))
+	{
+	  gfc_error ("The event variable at %L shall not be coindexed ",
+		     &event_expr->where);
+          return NULL_TREE;
+	}
+
+      image_index = integer_zero_node;
+
+      gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, event_expr);
+
+      /* For arrays, obtain the array index.  */
+      if (gfc_expr_attr (event_expr).dimension)
+	{
+	  tree desc, tmp, extent, lbound, ubound;
+          gfc_array_ref *ar, ar2;
+          int i;
+
+	  /* TODO: Extend this, once DT components are supported.  */
+	  ar = &event_expr->ref->u.ar;
+	  ar2 = *ar;
+	  memset (ar, '\0', sizeof (*ar));
+	  ar->as = ar2.as;
+	  ar->type = AR_FULL;
+
+	  gfc_init_se (&argse, NULL);
+	  argse.descriptor_only = 1;
+	  gfc_conv_expr_descriptor (&argse, event_expr);
+	  gfc_add_block_to_block (&se.pre, &argse.pre);
+	  desc = argse.expr;
+	  *ar = ar2;
+
+	  extent = integer_one_node;
+	  for (i = 0; i < ar->dimen; i++)
+	    {
+	      gfc_init_se (&argse, NULL);
+	      gfc_conv_expr_type (&argse, ar->start[i], integer_type_node);
+	      gfc_add_block_to_block (&argse.pre, &argse.pre);
+	      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);
+	      tmp = fold_build2_loc (input_location, MINUS_EXPR,
+				     integer_type_node, argse.expr,
+				     fold_convert(integer_type_node, lbound));
+	      tmp = fold_build2_loc (input_location, MULT_EXPR,
+				     integer_type_node, extent, tmp);
+	      index = fold_build2_loc (input_location, PLUS_EXPR,
+				       integer_type_node, index, tmp);
+	      if (i < ar->dimen - 1)
+		{
+		  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);
+		  tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);
+		  tmp = fold_convert (integer_type_node, tmp);
+		  extent = fold_build2_loc (input_location, MULT_EXPR,
+					    integer_type_node, extent, tmp);
+		}
+	    }
+	}
+
+      if (count != null_pointer_node && TREE_TYPE (count) != integer_type_node)
+	{
+	  count2 = count;
+	  count = gfc_create_var (integer_type_node, "count");
+	}
+
+      if (stat != null_pointer_node && TREE_TYPE (stat) != integer_type_node)
+	{
+	  stat2 = stat;
+	  stat = gfc_create_var (integer_type_node, "stat");
+	}
+
+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_query, 5,
+                                   token, index, image_index, count
+				   ? gfc_build_addr_expr (NULL, count) : count,
+				   stat != null_pointer_node
+				   ? gfc_build_addr_expr (NULL, stat) : stat);
+      gfc_add_expr_to_block (&se.pre, tmp);
+
+      if (count2 != NULL_TREE)
+	gfc_add_modify (&se.pre, count2,
+			fold_convert (TREE_TYPE (count2), count));
+
+      if (stat2 != NULL_TREE)
+	gfc_add_modify (&se.pre, stat2,
+			fold_convert (TREE_TYPE (stat2), stat));
+
+      return gfc_finish_block (&se.pre);
+    }
+
+  gfc_init_se (&argse, NULL);
+  gfc_conv_expr_val (&argse, code->ext.actual->expr);
+  gfc_add_modify (&se.pre, count, fold_convert (TREE_TYPE (count), argse.expr));
+
+  if (stat != NULL_TREE)
+    gfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));
+
+  return gfc_finish_block (&se.pre);
+}
 
 static tree
 conv_intrinsic_move_alloc (gfc_code *code)
@@ -9539,6 +9718,10 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)
       res = conv_intrinsic_atomic_ref (code);
       break;
 
+    case GFC_ISYM_EVENT_QUERY:
+      res = conv_intrinsic_event_query (code);
+      break;
+
     case GFC_ISYM_C_F_POINTER:
     case GFC_ISYM_C_F_PROCPOINTER:
       res = conv_isocbinding_subroutine (code);
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
index 9d95e86..a413ac9 100644
--- a/gcc/fortran/trans-openmp.c
+++ b/gcc/fortran/trans-openmp.c
@@ -4255,7 +4255,7 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)
 
       /* By default, every gfc_code is a single unit of work.  */
       ompws_flags |= OMPWS_CURR_SINGLEUNIT;
-      ompws_flags &= ~OMPWS_SCALARIZER_WS;
+      ompws_flags &= ~(OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY);
 
       switch (code->op)
 	{
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 776f78f..7414c0d 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1,5 +1,5 @@
 /* Statement translation -- generate GCC trees from gfc_code.
-   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
    Contributed by Paul Brook <paul@nowt.org>
    and Steven Bosscher <s.bosscher@student.tudelft.nl>
 
@@ -788,6 +788,7 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)
       if (code->expr3)
 	{
 	  gfc_init_se (&argse, NULL);
+	  argse.want_pointer = 1;
 	  gfc_conv_expr (&argse, code->expr3);
 	  gfc_add_block_to_block (&se.pre, &argse.pre);
 	  errmsg = argse.expr;
@@ -829,6 +830,17 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)
 				   errmsg, errmsg_len);
       gfc_add_expr_to_block (&se.pre, tmp);
 
+      /* It guarantees memory consistency within the same segment */
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+
+      gfc_add_expr_to_block (&se.pre, tmp);
+
       if (stat2 != NULL_TREE)
 	gfc_add_modify (&se.pre, stat2,
 			fold_convert (TREE_TYPE (stat2), stat));
@@ -852,6 +864,165 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)
   return gfc_finish_block (&se.pre);
 }
 
+tree
+gfc_trans_event_post_wait (gfc_code *code, gfc_exec_op op)
+{
+  gfc_se se, argse;
+  tree stat = NULL_TREE, stat2 = NULL_TREE;
+  tree until_count = NULL_TREE;
+
+  if (code->expr2)
+    {
+      gcc_assert (code->expr2->expr_type == EXPR_VARIABLE);
+      gfc_init_se (&argse, NULL);
+      gfc_conv_expr_val (&argse, code->expr2);
+      stat = argse.expr;
+    }
+  else if (flag_coarray == GFC_FCOARRAY_LIB)
+    stat = null_pointer_node;
+
+  if (code->expr4)
+    {
+      gfc_init_se (&argse, NULL);
+      gfc_conv_expr_val (&argse, code->expr4);
+      until_count = fold_convert (integer_type_node, argse.expr);
+    }
+  else
+    until_count = integer_one_node;
+
+  if (flag_coarray != GFC_FCOARRAY_LIB)
+    {
+      gfc_start_block (&se.pre);
+      gfc_init_se (&argse, NULL);
+      gfc_conv_expr_val (&argse, code->expr1);
+
+      if (op == EXEC_EVENT_POST)
+	gfc_add_modify (&se.pre, argse.expr,
+			fold_build2_loc (input_location, PLUS_EXPR,
+				TREE_TYPE (argse.expr), argse.expr,
+				build_int_cst (TREE_TYPE (argse.expr), 1)));
+      else
+	gfc_add_modify (&se.pre, argse.expr,
+			fold_build2_loc (input_location, MINUS_EXPR,
+				TREE_TYPE (argse.expr), argse.expr,
+				fold_convert (TREE_TYPE (argse.expr),
+					      until_count)));
+      if (stat != NULL_TREE)
+	gfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));
+
+      return gfc_finish_block (&se.pre);
+    }
+
+  gfc_start_block (&se.pre);
+  tree tmp, token, image_index, errmsg, errmsg_len;
+  tree index = size_zero_node;
+  tree caf_decl = gfc_get_tree_for_caf_expr (code->expr1);
+
+  if (code->expr1->symtree->n.sym->ts.type != BT_DERIVED
+      || code->expr1->symtree->n.sym->ts.u.derived->from_intmod
+	 != INTMOD_ISO_FORTRAN_ENV
+      || code->expr1->symtree->n.sym->ts.u.derived->intmod_sym_id
+	 != ISOFORTRAN_EVENT_TYPE)
+    {
+      gfc_error ("Sorry, the event component of derived type at %L is not "
+		 "yet supported", &code->expr1->where);
+      return NULL_TREE;
+    }
+
+  gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, code->expr1);
+
+  if (gfc_is_coindexed (code->expr1))
+    image_index = gfc_caf_get_image_index (&se.pre, code->expr1, caf_decl);
+  else
+    image_index = integer_zero_node;
+
+  /* For arrays, obtain the array index.  */
+  if (gfc_expr_attr (code->expr1).dimension)
+    {
+      tree desc, tmp, extent, lbound, ubound;
+      gfc_array_ref *ar, ar2;
+      int i;
+
+      /* TODO: Extend this, once DT components are supported.  */
+      ar = &code->expr1->ref->u.ar;
+      ar2 = *ar;
+      memset (ar, '\0', sizeof (*ar));
+      ar->as = ar2.as;
+      ar->type = AR_FULL;
+
+      gfc_init_se (&argse, NULL);
+      argse.descriptor_only = 1;
+      gfc_conv_expr_descriptor (&argse, code->expr1);
+      gfc_add_block_to_block (&se.pre, &argse.pre);
+      desc = argse.expr;
+      *ar = ar2;
+
+      extent = integer_one_node;
+      for (i = 0; i < ar->dimen; i++)
+	{
+	  gfc_init_se (&argse, NULL);
+	  gfc_conv_expr_type (&argse, ar->start[i], integer_type_node);
+	  gfc_add_block_to_block (&argse.pre, &argse.pre);
+	  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);
+	  tmp = fold_build2_loc (input_location, MINUS_EXPR,
+				 integer_type_node, argse.expr,
+				 fold_convert(integer_type_node, lbound));
+	  tmp = fold_build2_loc (input_location, MULT_EXPR,
+				 integer_type_node, extent, tmp);
+	  index = fold_build2_loc (input_location, PLUS_EXPR,
+				   integer_type_node, index, tmp);
+	  if (i < ar->dimen - 1)
+	    {
+	      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);
+	      tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);
+	      tmp = fold_convert (integer_type_node, tmp);
+	      extent = fold_build2_loc (input_location, MULT_EXPR,
+					integer_type_node, extent, tmp);
+	    }
+	}
+    }
+
+  /* errmsg.  */
+  if (code->expr3)
+    {
+      gfc_init_se (&argse, NULL);
+      argse.want_pointer = 1;
+      gfc_conv_expr (&argse, code->expr3);
+      gfc_add_block_to_block (&se.pre, &argse.pre);
+      errmsg = argse.expr;
+      errmsg_len = fold_convert (integer_type_node, argse.string_length);
+    }
+  else
+    {
+      errmsg = null_pointer_node;
+      errmsg_len = integer_zero_node;
+    }
+
+  if (stat != null_pointer_node && TREE_TYPE (stat) != integer_type_node)
+    {
+      stat2 = stat;
+      stat = gfc_create_var (integer_type_node, "stat");
+    }
+
+  if (op == EXEC_EVENT_POST)
+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_post, 6,
+			       token, index, image_index,
+			       stat != null_pointer_node
+			       ? gfc_build_addr_expr (NULL, stat) : stat,
+			       errmsg, errmsg_len);
+  else
+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_wait, 6,
+			       token, index, until_count,
+			       stat != null_pointer_node
+			       ? gfc_build_addr_expr (NULL, stat) : stat,
+			       errmsg, errmsg_len);
+  gfc_add_expr_to_block (&se.pre, tmp);
+
+  if (stat2 != NULL_TREE)
+    gfc_add_modify (&se.pre, stat2, fold_convert (TREE_TYPE (stat2), stat));
+
+  return gfc_finish_block (&se.pre);
+}
 
 tree
 gfc_trans_sync (gfc_code *code, gfc_exec_op type)
@@ -891,6 +1062,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)
     {
       gcc_assert (code->expr3->expr_type == EXPR_VARIABLE);
       gfc_init_se (&argse, NULL);
+      argse.want_pointer = 1;
       gfc_conv_expr (&argse, code->expr3);
       gfc_conv_string_parameter (&argse);
       errmsg = gfc_build_addr_expr (NULL, argse.expr);
@@ -931,6 +1103,20 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)
 			       fold_convert (integer_type_node, images));
     }
 
+  /* Per F2008, 8.5.1, a SYNC MEMORY is implied by calling the
+     image control statements SYNC IMAGES and SYNC ALL.  */
+  if (flag_coarray == GFC_FCOARRAY_LIB)
+    {
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+      gfc_add_expr_to_block (&se.pre, tmp);
+    }
+
   if (flag_coarray != GFC_FCOARRAY_LIB)
     {
       /* Set STAT to zero.  */
@@ -1250,6 +1436,17 @@ gfc_trans_critical (gfc_code *code)
 				 null_pointer_node, null_pointer_node,
 				 null_pointer_node, integer_zero_node);
       gfc_add_expr_to_block (&block, tmp);
+
+      /* It guarantees memory consistency within the same segment */
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+
+      gfc_add_expr_to_block (&block, tmp);
     }
 
   tmp = gfc_trans_code (code->block->next);
@@ -1262,8 +1459,18 @@ gfc_trans_critical (gfc_code *code)
 				 null_pointer_node, null_pointer_node,
 				 integer_zero_node);
       gfc_add_expr_to_block (&block, tmp);
-    }
 
+      /* It guarantees memory consistency within the same segment */
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+
+      gfc_add_expr_to_block (&block, tmp);
+    }
 
   return gfc_finish_block (&block);
 }
@@ -4839,10 +5046,15 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)
   gfc_loopinfo loop;
   gfc_ss *edss = 0;
   gfc_ss *esss = 0;
+  bool maybe_workshare = false;
 
   /* Allow the scalarizer to workshare simple where loops.  */
-  if (ompws_flags & OMPWS_WORKSHARE_FLAG)
-    ompws_flags |= OMPWS_SCALARIZER_WS;
+  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_BODY))
+      == OMPWS_WORKSHARE_FLAG)
+    {
+      maybe_workshare = true;
+      ompws_flags |= OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY;
+    }
 
   cond = cblock->expr1;
   tdst = cblock->next->expr1;
@@ -4942,6 +5154,8 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)
   gfc_add_expr_to_block (&body, tmp);
   gfc_add_block_to_block (&body, &cse.post);
 
+  if (maybe_workshare)
+    ompws_flags &= ~OMPWS_SCALARIZER_BODY;
   gfc_trans_scalarizing_loops (&loop, &body);
   gfc_add_block_to_block (&block, &loop.pre);
   gfc_add_block_to_block (&block, &loop.post);
@@ -5062,7 +5276,7 @@ tree
 gfc_trans_allocate (gfc_code * code)
 {
   gfc_alloc *al;
-  gfc_expr *expr;
+  gfc_expr *expr, *e3rhs = NULL;
   gfc_se se, se_sz;
   tree tmp;
   tree parm;
@@ -5073,6 +5287,7 @@ gfc_trans_allocate (gfc_code * code)
   tree label_finish;
   tree memsz;
   tree al_vptr, al_len;
+
   /* If an expr3 is present, then store the tree for accessing its
      _vptr, and _len components in the variables, respectively.  The
      element size, i.e. _vptr%size, is stored in expr3_esize.  Any of
@@ -5083,6 +5298,7 @@ gfc_trans_allocate (gfc_code * code)
   stmtblock_t post;
   tree nelems;
   bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set;
+  gfc_symtree *newsym = NULL;
 
   if (!code->ext.alloc.list)
     return NULL_TREE;
@@ -5132,7 +5348,7 @@ gfc_trans_allocate (gfc_code * code)
      _vptr, _len and element_size for expr3.  */
   if (code->expr3)
     {
-      bool vtab_needed = false;
+      bool vtab_needed = false, is_coarray = gfc_is_coarray (code->expr3);
       /* expr3_tmp gets the tree when code->expr3.mold is set, i.e.,
 	 the expression is only needed to get the _vptr, _len a.s.o.  */
       tree expr3_tmp = NULL_TREE;
@@ -5192,16 +5408,29 @@ gfc_trans_allocate (gfc_code * code)
 					 false, false);
 	      gfc_add_block_to_block (&block, &se.pre);
 	      gfc_add_block_to_block (&post, &se.post);
-	      /* Prevent aliasing, i.e., se.expr may be already a
-		 variable declaration.  */
+
 	      if (!VAR_P (se.expr))
 		{
-		  tmp = build_fold_indirect_ref_loc (input_location,
+		  tree var;
+
+		  tmp = is_coarray ? se.expr
+				  : build_fold_indirect_ref_loc (input_location,
 						     se.expr);
-		  tmp = gfc_evaluate_now (tmp, &block);
+
+		  /* We need a regular (non-UID) symbol here, therefore give a
+		     prefix.  */
+		  var = gfc_create_var (TREE_TYPE (tmp), "source");
+		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
+		    {
+		      gfc_allocate_lang_decl (var);
+		      GFC_DECL_SAVED_DESCRIPTOR (var) = GFC_DECL_SAVED_DESCRIPTOR (tmp);
+		    }
+		  gfc_add_modify_loc (input_location, &block, var, tmp);
+		  tmp = var;
 		}
 	      else
 		tmp = se.expr;
+
 	      if (!code->expr3->mold)
 		expr3 = tmp;
 	      else
@@ -5237,6 +5466,16 @@ gfc_trans_allocate (gfc_code * code)
 	  else if (expr3_tmp != NULL_TREE
 		   && (VAR_P (expr3_tmp) ||!code->expr3->ref))
 	    tmp = gfc_class_vptr_get (expr3_tmp);
+	  else if (is_coarray && expr3 != NULL_TREE)
+	    {
+	      /* Get the ref to coarray's data.  May be wrapped in a
+		 NOP_EXPR.  */
+	      tmp = POINTER_TYPE_P (TREE_TYPE (expr3)) ? TREE_OPERAND (expr3, 0)
+						       : tmp;
+	      /* Get to the base variable, i.e., strip _data.data.  */
+	      tmp = TREE_OPERAND (TREE_OPERAND (tmp, 0), 0);
+	      tmp = gfc_class_vptr_get (tmp);
+	    }
 	  else
 	    {
 	      rhs = gfc_find_and_cut_at_last_class_ref (code->expr3);
@@ -5310,6 +5549,71 @@ gfc_trans_allocate (gfc_code * code)
 	  else
 	    expr3_esize = TYPE_SIZE_UNIT (
 		  gfc_typenode_for_spec (&code->expr3->ts));
+
+	  /* The routine gfc_trans_assignment () already implements all
+	     techniques needed.  Unfortunately we may have a temporary
+	     variable for the source= expression here.  When that is the
+	     case convert this variable into a temporary gfc_expr of type
+	     EXPR_VARIABLE and used it as rhs for the assignment.  The
+	     advantage is, that we get scalarizer support for free,
+	     don't have to take care about scalar to array treatment and
+	     will benefit of every enhancements gfc_trans_assignment ()
+	     gets.
+	     Exclude variables since the following block does not handle
+	     array sections.  In any case, there is no harm in sending
+	     variables to gfc_trans_assignment because there is no
+	     evaluation of variables.  */
+	  if (code->expr3->expr_type != EXPR_VARIABLE
+	      && code->expr3->mold != 1 && expr3 != NULL_TREE
+	      && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))
+	    {
+	      /* Build a temporary symtree and symbol.  Do not add it to
+		 the current namespace to prevent accidently modifying
+		 a colliding symbol's as.  */
+	      newsym = XCNEW (gfc_symtree);
+	      /* The name of the symtree should be unique, because
+		 gfc_create_var () took care about generating the
+		 identifier.  */
+	      newsym->name = gfc_get_string (IDENTIFIER_POINTER (
+					       DECL_NAME (expr3)));
+	      newsym->n.sym = gfc_new_symbol (newsym->name, NULL);
+	      /* The backend_decl is known.  It is expr3, which is inserted
+		 here.  */
+	      newsym->n.sym->backend_decl = expr3;
+	      e3rhs = gfc_get_expr ();
+	      e3rhs->ts = code->expr3->ts;
+	      e3rhs->rank = code->expr3->rank;
+	      e3rhs->symtree = newsym;
+	      /* Mark the symbol referenced or gfc_trans_assignment will
+		 bug.  */
+	      newsym->n.sym->attr.referenced = 1;
+	      e3rhs->expr_type = EXPR_VARIABLE;
+	      e3rhs->where = code->expr3->where;
+	      /* Set the symbols type, upto it was BT_UNKNOWN.  */
+	      newsym->n.sym->ts = e3rhs->ts;
+	      /* Check whether the expr3 is array valued.  */
+	      if (e3rhs->rank)
+		{
+		  gfc_array_spec *arr;
+		  arr = gfc_get_array_spec ();
+		  arr->rank = e3rhs->rank;
+		  arr->type = AS_DEFERRED;
+		  /* Set the dimension and pointer attribute for arrays
+		     to be on the safe side.  */
+		  newsym->n.sym->attr.dimension = 1;
+		  newsym->n.sym->attr.pointer = 1;
+		  newsym->n.sym->as = arr;
+		  gfc_add_full_array_ref (e3rhs, arr);
+		}
+	      else if (POINTER_TYPE_P (TREE_TYPE (expr3)))
+		newsym->n.sym->attr.pointer = 1;
+	      /* The string length is known to.  Set it for char arrays.  */
+	      if (e3rhs->ts.type == BT_CHARACTER)
+		newsym->n.sym->ts.u.cl->backend_decl = expr3_len;
+	      gfc_commit_symbol (newsym->n.sym);
+	    }
+	  else
+	    e3rhs = gfc_copy_expr (code->expr3);
 	}
       gcc_assert (expr3_esize);
       expr3_esize = fold_convert (sizetype, expr3_esize);
@@ -5386,6 +5690,7 @@ gfc_trans_allocate (gfc_code * code)
 
       se.want_pointer = 1;
       se.descriptor_only = 1;
+
       gfc_conv_expr (&se, expr);
       if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)
 	/* se.string_length now stores the .string_length variable of expr
@@ -5519,6 +5824,20 @@ gfc_trans_allocate (gfc_code * code)
 	      /* Prevent setting the length twice.  */
 	      al_len_needs_set = false;
 	    }
+	  else if (expr->ts.type == BT_CHARACTER && al_len != NULL_TREE
+		   && code->ext.alloc.ts.u.cl->length)
+	    {
+	      /* Cover the cases where a string length is explicitly
+		 specified by a type spec for deferred length character
+		 arrays or unlimited polymorphic objects without a
+		 source= or mold= expression.  */
+	      gfc_init_se (&se_sz, NULL);
+	      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);
+	      gfc_add_modify (&block, al_len,
+			      fold_convert (TREE_TYPE (al_len),
+					    se_sz.expr));
+	      al_len_needs_set = false;
+	    }
 	}
 
       gfc_add_block_to_block (&block, &se.pre);
@@ -5615,7 +5934,6 @@ gfc_trans_allocate (gfc_code * code)
 	{
 	  /* Initialization via SOURCE block
 	     (or static default initializer).  */
-	  gfc_expr *rhs = gfc_copy_expr (code->expr3);
 	  if (expr3 != NULL_TREE
 	      && ((POINTER_TYPE_P (TREE_TYPE (expr3))
 		   && TREE_CODE (expr3) != POINTER_PLUS_EXPR)
@@ -5629,25 +5947,13 @@ gfc_trans_allocate (gfc_code * code)
 	      tmp = gfc_copy_class_to_class (expr3, to,
 					     nelems, upoly_expr);
 	    }
-	  else if (code->expr3->ts.type == BT_CHARACTER
-		   && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))
-	    {
-	      tmp = INDIRECT_REF_P (se.expr) ?
-			se.expr :
-			build_fold_indirect_ref_loc (input_location,
-						     se.expr);
-	      gfc_trans_string_copy (&block, al_len, tmp,
-				     code->expr3->ts.kind,
-				     expr3_len, expr3,
-				     code->expr3->ts.kind);
-	      tmp = NULL_TREE;
-	    }
 	  else if (al->expr->ts.type == BT_CLASS)
 	    {
 	      gfc_actual_arglist *actual, *last_arg;
 	      gfc_expr *ppc;
 	      gfc_code *ppc_code;
 	      gfc_ref *ref, *dataref;
+	      gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);
 
 	      /* Do a polymorphic deep copy.  */
 	      actual = gfc_get_actual_arglist ();
@@ -5759,6 +6065,8 @@ gfc_trans_allocate (gfc_code * code)
 					 void_type_node, tmp, extcopy, stdcopy);
 		}
 	      gfc_free_statements (ppc_code);
+	      if (rhs != e3rhs)
+		gfc_free_expr (rhs);
 	    }
 	  else
 	    {
@@ -5767,10 +6075,9 @@ gfc_trans_allocate (gfc_code * code)
 	      int realloc_lhs = flag_realloc_lhs;
 	      flag_realloc_lhs = 0;
 	      tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),
-					  rhs, false, false);
+					  e3rhs, false, false);
 	      flag_realloc_lhs = realloc_lhs;
 	    }
-	  gfc_free_expr (rhs);
 	  gfc_add_expr_to_block (&block, tmp);
 	}
      else if (code->expr3 && code->expr3->mold
@@ -5788,6 +6095,15 @@ gfc_trans_allocate (gfc_code * code)
        gfc_free_expr (expr);
     } // for-loop
 
+  if (e3rhs)
+    {
+      if (newsym)
+	{
+	  gfc_free_symbol (newsym->n.sym);
+	  XDELETE (newsym);
+	}
+      gfc_free_expr (e3rhs);
+    }
   /* STAT.  */
   if (code->expr1)
     {
diff --git a/gcc/fortran/trans-stmt.h b/gcc/fortran/trans-stmt.h
index 2f2a0b3..9841fb8 100644
--- a/gcc/fortran/trans-stmt.h
+++ b/gcc/fortran/trans-stmt.h
@@ -55,6 +55,7 @@ tree gfc_trans_do_while (gfc_code *);
 tree gfc_trans_select (gfc_code *);
 tree gfc_trans_sync (gfc_code *, gfc_exec_op);
 tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);
+tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);
 tree gfc_trans_forall (gfc_code *);
 tree gfc_trans_where (gfc_code *);
 tree gfc_trans_allocate (gfc_code *);
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index a267040..fa553f4 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1,5 +1,5 @@
 /* Backend support for Fortran 95 basic types and derived types.
-   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
    Contributed by Paul Brook <paul@nowt.org>
    and Steven Bosscher <s.bosscher@student.tudelft.nl>
 
@@ -1067,6 +1067,8 @@ gfc_get_character_type (int kind, gfc_charlen * cl)
   tree len;
 
   len = (cl == NULL) ? NULL_TREE : cl->backend_decl;
+  if (len && POINTER_TYPE_P (TREE_TYPE (len)))
+    len = build_fold_indirect_ref (len);
 
   return gfc_get_character_type_len (kind, len);
 }
@@ -2380,9 +2382,15 @@ gfc_get_derived_type (gfc_symbol * derived)
   if (derived->attr.unlimited_polymorphic
       || (flag_coarray == GFC_FCOARRAY_LIB
 	  && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	  && derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE))
+	  && (derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE
+	      || derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)))
     return ptr_type_node;
 
+  if (flag_coarray != GFC_FCOARRAY_LIB
+      && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+      && derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
+    return gfc_get_int_type (gfc_default_integer_kind);
+
   if (derived && derived->attr.flavor == FL_PROCEDURE
       && derived->attr.generic)
     derived = gfc_find_dt_in_generic (derived);
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index 549e921..d52e062 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -1,5 +1,5 @@
 /* Code translation -- generate GCC trees from gfc_code.
-   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
    Contributed by Paul Brook
 
 This file is part of GCC.
@@ -344,6 +344,21 @@ gfc_build_array_ref (tree base, tree offset, tree decl)
 
   type = TREE_TYPE (type);
 
+  /* Use pointer arithmetic for deferred character length array
+     references.  */
+  if (type && TREE_CODE (type) == ARRAY_TYPE
+      && TYPE_MAXVAL (TYPE_DOMAIN (type)) != NULL_TREE
+      && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == VAR_DECL
+	  || TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF)
+      && decl
+      && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF
+	  || TREE_CODE (decl) == FUNCTION_DECL
+	  || DECL_CONTEXT (TYPE_MAXVAL (TYPE_DOMAIN (type)))
+					== DECL_CONTEXT (decl)))
+    span = TYPE_MAXVAL (TYPE_DOMAIN (type));
+  else
+    span = NULL_TREE;
+
   if (DECL_P (base))
     TREE_ADDRESSABLE (base) = 1;
 
@@ -355,10 +370,12 @@ gfc_build_array_ref (tree base, tree offset, tree decl)
      and reference the element with pointer arithmetic.  */
   if (decl && (TREE_CODE (decl) == FIELD_DECL
 		 || TREE_CODE (decl) == VAR_DECL
-		 || TREE_CODE (decl) == PARM_DECL)
+		 || TREE_CODE (decl) == PARM_DECL
+		 || TREE_CODE (decl) == FUNCTION_DECL)
 	&& ((GFC_DECL_SUBREF_ARRAY_P (decl)
 	      && !integer_zerop (GFC_DECL_SPAN(decl)))
-	   || GFC_DECL_CLASS (decl)))
+	   || GFC_DECL_CLASS (decl)
+	   || span != NULL_TREE))
     {
       if (GFC_DECL_CLASS (decl))
 	{
@@ -377,6 +394,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl)
 	}
       else if (GFC_DECL_SUBREF_ARRAY_P (decl))
 	span = GFC_DECL_SPAN(decl);
+      else if (span)
+	span = fold_convert (gfc_array_index_type, span);
       else
 	gcc_unreachable ();
 
@@ -701,7 +720,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,
 static void
 gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,
 			tree token, tree status, tree errmsg, tree errlen,
-			bool lock_var)
+			bool lock_var, bool event_var)
 {
   tree tmp, pstat;
 
@@ -732,13 +751,24 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,
 			      build_int_cst (size_type_node, 1)),
 	     build_int_cst (integer_type_node,
 			    lock_var ? GFC_CAF_LOCK_ALLOC
-				     : GFC_CAF_COARRAY_ALLOC),
+                            : event_var ? GFC_CAF_EVENT_ALLOC
+					: GFC_CAF_COARRAY_ALLOC),
 	     token, pstat, errmsg, errlen);
 
   tmp = fold_build2_loc (input_location, MODIFY_EXPR,
 			 TREE_TYPE (pointer), pointer,
 			 fold_convert ( TREE_TYPE (pointer), tmp));
   gfc_add_expr_to_block (block, tmp);
+
+  /* It guarantees memory consistency within the same segment */
+  tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+    tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+		      gfc_build_string_const (1, ""),
+		      NULL_TREE, NULL_TREE,
+		      tree_cons (NULL_TREE, tmp, NULL_TREE),
+		      NULL_TREE);
+  ASM_VOLATILE_P (tmp) = 1;
+  gfc_add_expr_to_block (block, tmp);
 }
 
 
@@ -794,16 +824,21 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,
 			 == INTMOD_ISO_FORTRAN_ENV
 		      && expr->ts.u.derived->intmod_sym_id
 		         == ISOFORTRAN_LOCK_TYPE;
+      bool event_var = expr->ts.type == BT_DERIVED
+		       && expr->ts.u.derived->from_intmod
+			 == INTMOD_ISO_FORTRAN_ENV
+		       && expr->ts.u.derived->intmod_sym_id
+		         == ISOFORTRAN_EVENT_TYPE;
       /* In the front end, we represent the lock variable as pointer. However,
 	 the FE only passes the pointer around and leaves the actual
 	 representation to the library. Hence, we have to convert back to the
 	 number of elements.  */
-      if (lock_var)
+      if (lock_var || event_var)
 	size = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,
 				size, TYPE_SIZE_UNIT (ptr_type_node));
 
       gfc_allocate_using_lib (&alloc_block, mem, size, token, status,
-			      errmsg, errlen, lock_var);
+			      errmsg, errlen, lock_var, event_var);
 
       if (status != NULL_TREE)
 	{
@@ -1360,6 +1395,16 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,
 	     token, pstat, errmsg, errlen);
       gfc_add_expr_to_block (&non_null, tmp);
 
+      /* It guarantees memory consistency within the same segment */
+      tmp = gfc_build_string_const (strlen ("memory")+1, "memory"),
+	tmp = build5_loc (input_location, ASM_EXPR, void_type_node,
+			  gfc_build_string_const (1, ""),
+			  NULL_TREE, NULL_TREE,
+			  tree_cons (NULL_TREE, tmp, NULL_TREE),
+			  NULL_TREE);
+      ASM_VOLATILE_P (tmp) = 1;
+      gfc_add_expr_to_block (&non_null, tmp);
+
       if (status != NULL_TREE)
 	{
 	  tree stat = build_fold_indirect_ref_loc (input_location, status);
@@ -1647,6 +1692,7 @@ trans_code (gfc_code * code, tree cond)
 	  gfc_add_expr_to_block (&block, res);
 	}
 
+      gfc_current_locus = code->loc;
       gfc_set_backend_locus (&code->loc);
 
       switch (code->op)
@@ -1808,6 +1854,11 @@ trans_code (gfc_code * code, tree cond)
 	  res = gfc_trans_lock_unlock (code, code->op);
 	  break;
 
+	case EXEC_EVENT_POST:
+	case EXEC_EVENT_WAIT:
+	  res = gfc_trans_event_post_wait (code, code->op);
+	  break;
+
 	case EXEC_FORALL:
 	  res = gfc_trans_forall (code);
 	  break;
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 1998358..e6544f9 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -109,7 +109,9 @@ typedef enum
   GFC_CAF_COARRAY_ALLOC,
   GFC_CAF_LOCK_STATIC,
   GFC_CAF_LOCK_ALLOC,
-  GFC_CAF_CRITICAL
+  GFC_CAF_CRITICAL,
+  GFC_CAF_EVENT_STATIC,
+  GFC_CAF_EVENT_ALLOC
 }
 gfc_coarray_type;
 
@@ -756,6 +758,9 @@ extern GTY(()) tree gfor_fndecl_caf_atomic_cas;
 extern GTY(()) tree gfor_fndecl_caf_atomic_op;
 extern GTY(()) tree gfor_fndecl_caf_lock;
 extern GTY(()) tree gfor_fndecl_caf_unlock;
+extern GTY(()) tree gfor_fndecl_caf_event_post;
+extern GTY(()) tree gfor_fndecl_caf_event_wait;
+extern GTY(()) tree gfor_fndecl_caf_event_query;
 extern GTY(()) tree gfor_fndecl_co_broadcast;
 extern GTY(()) tree gfor_fndecl_co_max;
 extern GTY(()) tree gfor_fndecl_co_min;
@@ -1027,7 +1032,9 @@ extern const char gfc_msg_wrong_return[];
 					   construct is not workshared.  */
 #define OMPWS_SCALARIZER_WS	4	/* Set if scalarizer should attempt
 					   to create parallel loops.  */
-#define OMPWS_NOWAIT		8	/* Use NOWAIT on OMP_FOR.  */
+#define OMPWS_SCALARIZER_BODY	8	/* Set if handling body of potential
+					   parallel loop.  */
+#define OMPWS_NOWAIT		16	/* Use NOWAIT on OMP_FOR.  */
 extern int ompws_flags;
 
 #endif /* GFC_TRANS_H */
diff --git a/gcc/gcse.c b/gcc/gcse.c
index 37aac6a..0f6d456 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -3830,10 +3830,8 @@ compute_ld_motion_mems (void)
 		{
 		  rtx src = SET_SRC (PATTERN (insn));
 		  rtx dest = SET_DEST (PATTERN (insn));
-		  rtx note = find_reg_equal_equiv_note (insn);
-		  rtx src_eq;
 
-		  /* Check for a simple LOAD...  */
+		  /* Check for a simple load.  */
 		  if (MEM_P (src) && simple_mem (src))
 		    {
 		      ptr = ldst_entry (src);
@@ -3848,12 +3846,11 @@ compute_ld_motion_mems (void)
 		      invalidate_any_buried_refs (src);
 		    }
 
-		  if (note != 0 && REG_NOTE_KIND (note) == REG_EQUAL)
-		    src_eq = XEXP (note, 0);
-		  else
-		    src_eq = NULL_RTX;
-
-		  if (src_eq != NULL_RTX
+		  /* Check for a simple load through a REG_EQUAL note.  */
+		  rtx note = find_reg_equal_equiv_note (insn), src_eq;
+		  if (note
+		      && REG_NOTE_KIND (note) == REG_EQUAL
+		      && (src_eq = XEXP (note, 0))
 		      && !(MEM_P (src_eq) && simple_mem (src_eq)))
 		    invalidate_any_buried_refs (src_eq);
 
@@ -3876,7 +3873,17 @@ compute_ld_motion_mems (void)
 		    }
 		}
 	      else
-		invalidate_any_buried_refs (PATTERN (insn));
+		{
+		  /* Invalidate all MEMs in the pattern and...  */
+		  invalidate_any_buried_refs (PATTERN (insn));
+
+		  /* ...in REG_EQUAL notes for PARALLELs with single SET.  */
+		  rtx note = find_reg_equal_equiv_note (insn), src_eq;
+		  if (note
+		      && REG_NOTE_KIND (note) == REG_EQUAL
+		      && (src_eq = XEXP (note, 0)))
+		    invalidate_any_buried_refs (src_eq);
+		}
 	    }
 	}
     }
diff --git a/gcc/genpreds.c b/gcc/genpreds.c
index 1eb3368..1dcb769 100644
--- a/gcc/genpreds.c
+++ b/gcc/genpreds.c
@@ -640,12 +640,14 @@ struct constraint_data
   const char *regclass;  /* for register constraints */
   rtx exp;               /* for other constraints */
   unsigned int lineno;   /* line of definition */
-  unsigned int is_register  : 1;
-  unsigned int is_const_int : 1;
-  unsigned int is_const_dbl : 1;
-  unsigned int is_extra     : 1;
-  unsigned int is_memory    : 1;
-  unsigned int is_address   : 1;
+  unsigned int is_register	: 1;
+  unsigned int is_const_int	: 1;
+  unsigned int is_const_dbl	: 1;
+  unsigned int is_extra		: 1;
+  unsigned int is_memory	: 1;
+  unsigned int is_address	: 1;
+  unsigned int maybe_allows_reg : 1;
+  unsigned int maybe_allows_mem : 1;
 };
 
 /* Overview of all constraints beginning with a given letter.  */
@@ -691,6 +693,9 @@ static unsigned int satisfied_start;
 static unsigned int const_int_start, const_int_end;
 static unsigned int memory_start, memory_end;
 static unsigned int address_start, address_end;
+static unsigned int maybe_allows_none_start, maybe_allows_none_end;
+static unsigned int maybe_allows_reg_start, maybe_allows_reg_end;
+static unsigned int maybe_allows_mem_start, maybe_allows_mem_end;
 
 /* Convert NAME, which contains angle brackets and/or underscores, to
    a string that can be used as part of a C identifier.  The string
@@ -711,6 +716,34 @@ mangle (const char *name)
   return XOBFINISH (rtl_obstack, const char *);
 }
 
+/* Return a bitmask, bit 1 if EXP maybe allows a REG/SUBREG, 2 if EXP
+   maybe allows a MEM.  Bits should be clear only when we are sure it
+   will not allow a REG/SUBREG or a MEM.  */
+static int
+compute_maybe_allows (rtx exp)
+{
+  switch (GET_CODE (exp))
+    {
+    case IF_THEN_ELSE:
+      /* Conservative answer is like IOR, of the THEN and ELSE branches.  */
+      return compute_maybe_allows (XEXP (exp, 1))
+	     | compute_maybe_allows (XEXP (exp, 2));
+    case AND:
+      return compute_maybe_allows (XEXP (exp, 0))
+	     & compute_maybe_allows (XEXP (exp, 1));
+    case IOR:
+      return compute_maybe_allows (XEXP (exp, 0))
+	     | compute_maybe_allows (XEXP (exp, 1));
+    case MATCH_CODE:
+      if (*XSTR (exp, 1) == '\0')
+	return (strstr (XSTR (exp, 0), "reg") != NULL ? 1 : 0)
+	       | (strstr (XSTR (exp, 0), "mem") != NULL ? 2 : 0);
+      /* FALLTHRU */
+    default:
+      return 3;
+    }
+}
+
 /* Add one constraint, of any sort, to the tables.  NAME is its name;
    REGCLASS is the register class, if any; EXP is the expression to
    test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address
@@ -866,6 +899,11 @@ add_constraint (const char *name, const char *regclass,
   c->is_extra = !(regclass || is_const_int || is_const_dbl);
   c->is_memory = is_memory;
   c->is_address = is_address;
+  int maybe_allows = 3;
+  if (exp)
+    maybe_allows = compute_maybe_allows (exp);
+  c->maybe_allows_reg = (maybe_allows & 1) != 0;
+  c->maybe_allows_mem = (maybe_allows & 2) != 0;
 
   c->next_this_letter = *slot;
   *slot = c;
@@ -940,8 +978,30 @@ choose_enum_order (void)
       enum_order[next++] = c;
   address_end = next;
 
+  maybe_allows_none_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& !c->maybe_allows_reg && !c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_none_end = next;
+
+  maybe_allows_reg_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& c->maybe_allows_reg && !c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_reg_end = next;
+
+  maybe_allows_mem_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& !c->maybe_allows_reg && c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_mem_end = next;
+
   FOR_ALL_CONSTRAINTS (c)
-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& c->maybe_allows_reg && c->maybe_allows_mem)
       enum_order[next++] = c;
   gcc_assert (next == num_constraints);
 }
@@ -1229,6 +1289,41 @@ write_range_function (const char *name, unsigned int start, unsigned int end)
 	    "}\n\n", name);
 }
 
+/* Write a definition for insn_extra_constraint_allows_reg_mem function.  */
+static void
+write_allows_reg_mem_function (void)
+{
+  printf ("static inline void\n"
+	  "insn_extra_constraint_allows_reg_mem (enum constraint_num c,\n"
+	  "\t\t\t\t      bool *allows_reg, bool *allows_mem)\n"
+	  "{\n");
+  if (maybe_allows_none_start != maybe_allows_none_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    return;\n",
+	    enum_order[maybe_allows_none_start]->c_name,
+	    enum_order[maybe_allows_none_end - 1]->c_name);
+  if (maybe_allows_reg_start != maybe_allows_reg_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    {\n"
+	    "      *allows_reg = true;\n"
+	    "      return;\n"
+	    "    }\n",
+	    enum_order[maybe_allows_reg_start]->c_name,
+	    enum_order[maybe_allows_reg_end - 1]->c_name);
+  if (maybe_allows_mem_start != maybe_allows_mem_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    {\n"
+	    "      *allows_mem = true;\n"
+	    "      return;\n"
+	    "    }\n",
+	    enum_order[maybe_allows_mem_start]->c_name,
+	    enum_order[maybe_allows_mem_end - 1]->c_name);
+  printf ("  (void) c;\n"
+	  "  *allows_reg = true;\n"
+	  "  *allows_mem = true;\n"
+	  "}\n\n");
+}
+
 /* VEC is a list of key/value pairs, with the keys being lower bounds
    of a range.  Output a decision tree that handles the keys covered by
    [VEC[START], VEC[END]), returning FALLBACK for keys lower then VEC[START]'s.
@@ -1326,6 +1421,7 @@ write_tm_preds_h (void)
 			    memory_start, memory_end);
       write_range_function ("insn_extra_address_constraint",
 			    address_start, address_end);
+      write_allows_reg_mem_function ();
 
       if (constraint_max_namelen > 1)
         {
diff --git a/gcc/gimple-expr.c b/gcc/gimple-expr.c
index efc93b7..f555189 100644
--- a/gcc/gimple-expr.c
+++ b/gcc/gimple-expr.c
@@ -387,6 +387,11 @@ copy_var_decl (tree var, tree name, tree type)
   TREE_USED (copy) = 1;
   DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;
   DECL_ATTRIBUTES (copy) = DECL_ATTRIBUTES (var);
+  if (DECL_USER_ALIGN (var))
+    {
+      DECL_ALIGN (copy) = DECL_ALIGN (var);
+      DECL_USER_ALIGN (copy) = 1;
+    }
 
   return copy;
 }
diff --git a/gcc/gimple-ssa-strength-reduction.c b/gcc/gimple-ssa-strength-reduction.c
index 5b84bbe..fef5905 100644
--- a/gcc/gimple-ssa-strength-reduction.c
+++ b/gcc/gimple-ssa-strength-reduction.c
@@ -2267,7 +2267,7 @@ create_phi_basis (slsr_cand_t c, gimple from_phi, tree basis_name,
   slsr_cand_t basis = lookup_cand (c->basis);
   int nargs = gimple_phi_num_args (from_phi);
   basic_block phi_bb = gimple_bb (from_phi);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (from_phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (from_phi);
   phi_args.create (nargs);
 
   /* Process each argument of the existing phi that represents
@@ -2376,7 +2376,7 @@ phi_add_costs (gimple phi, slsr_cand_t c, int one_add_cost)
 {
   unsigned i;
   int cost = 0;
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);
 
   /* If we work our way back to a phi that isn't dominated by the hidden
      basis, this isn't a candidate for replacement.  Indicate this by
@@ -2587,7 +2587,7 @@ static void
 record_phi_increments (slsr_cand_t basis, gimple phi)
 {
   unsigned i;
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);
   
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -2658,7 +2658,7 @@ phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple phi, int *savings)
   unsigned i;
   int cost = 0;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -3002,7 +3002,7 @@ ncd_with_phi (slsr_cand_t c, const widest_int &incr, gphi *phi,
 {
   unsigned i;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -3212,7 +3212,7 @@ all_phi_incrs_profitable (slsr_cand_t c, gimple phi)
 {
   unsigned i;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
diff --git a/gcc/gimple.c b/gcc/gimple.c
index a5c1192..1f31914 100644
--- a/gcc/gimple.c
+++ b/gcc/gimple.c
@@ -1953,6 +1953,11 @@ gimple_could_trap_p_1 (gimple s, bool include_mem, bool include_stores)
 				       && TYPE_OVERFLOW_TRAPS (t)),
 				      div));
 
+    case GIMPLE_COND:
+      t = TREE_TYPE (gimple_cond_lhs (s));
+      return operation_could_trap_p (gimple_cond_code (s),
+				     FLOAT_TYPE_P (t), false, NULL_TREE);
+
     default:
       break;
     }
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index c85f83a..250d660 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -5208,12 +5208,38 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	    TREE_VALUE (link) = error_mark_node;
 	  tret = gimplify_expr (&TREE_VALUE (link), pre_p, post_p,
 				is_gimple_lvalue, fb_lvalue | fb_mayfail);
+	  if (tret != GS_ERROR)
+	    {
+	      /* Unlike output operands, memory inputs are not guaranteed
+		 to be lvalues by the FE, and while the expressions are
+		 marked addressable there, if it is e.g. a statement
+		 expression, temporaries in it might not end up being
+		 addressable.  They might be already used in the IL and thus
+		 it is too late to make them addressable now though.  */
+	      tree x = TREE_VALUE (link);
+	      while (handled_component_p (x))
+		x = TREE_OPERAND (x, 0);
+	      if (TREE_CODE (x) == MEM_REF
+		  && TREE_CODE (TREE_OPERAND (x, 0)) == ADDR_EXPR)
+		x = TREE_OPERAND (TREE_OPERAND (x, 0), 0);
+	      if ((TREE_CODE (x) == VAR_DECL
+		   || TREE_CODE (x) == PARM_DECL
+		   || TREE_CODE (x) == RESULT_DECL)
+		  && !TREE_ADDRESSABLE (x)
+		  && is_gimple_reg (x))
+		{
+		  warning_at (EXPR_LOC_OR_LOC (TREE_VALUE (link),
+					       input_location), 0,
+			      "memory input %d is not directly addressable",
+			      i);
+		  prepare_gimple_addressable (&TREE_VALUE (link), pre_p);
+		}
+	    }
 	  mark_addressable (TREE_VALUE (link));
 	  if (tret == GS_ERROR)
 	    {
-	      if (EXPR_HAS_LOCATION (TREE_VALUE (link)))
-	        input_location = EXPR_LOCATION (TREE_VALUE (link));
-	      error ("memory input %d is not directly addressable", i);
+	      error_at (EXPR_LOC_OR_LOC (TREE_VALUE (link), input_location),
+			"memory input %d is not directly addressable", i);
 	      ret = tret;
 	    }
 	}
diff --git a/gcc/ifcvt.c b/gcc/ifcvt.c
index db07889..e26b2c8 100644
--- a/gcc/ifcvt.c
+++ b/gcc/ifcvt.c
@@ -2152,45 +2152,22 @@ noce_try_abs (struct noce_if_info *if_info)
      Note that these rtx constants are known to be CONST_INT, and
      therefore imply integer comparisons.
      The one_cmpl case is more complicated, as we want to handle
-     only x < 0 ? ~x : x or x >= 0 ? ~x : x but not
-     x <= 0 ? ~x : x or x > 0 ? ~x : x, as the latter two
-     have different result for x == 0.  */
+     only x < 0 ? ~x : x or x >= 0 ? x : ~x to one_cmpl_abs (x)
+     and x < 0 ? x : ~x or x >= 0 ? ~x : x to ~one_cmpl_abs (x),
+     but not other cases (x > -1 is equivalent of x >= 0).  */
   if (c == constm1_rtx && GET_CODE (cond) == GT)
-    {
-      if (one_cmpl && negate)
-	return FALSE;
-    }
+    ;
   else if (c == const1_rtx && GET_CODE (cond) == LT)
     {
-      if (one_cmpl && !negate)
+      if (one_cmpl)
 	return FALSE;
     }
   else if (c == CONST0_RTX (GET_MODE (b)))
     {
-      if (one_cmpl)
-	switch (GET_CODE (cond))
-	  {
-	  case GT:
-	    if (!negate)
-	      return FALSE;
-	    break;
-	  case GE:
-	    /* >= 0 is the same case as above > -1.  */
-	    if (negate)
-	      return FALSE;
-	    break;
-	  case LT:
-	    if (negate)
-	      return FALSE;
-	    break;
-	  case LE:
-	    /* <= 0 is the same case as above < 1.  */
-	    if (!negate)
-	      return FALSE;
-	    break;
-	  default:
-	    return FALSE;
-	  }
+      if (one_cmpl
+	  && GET_CODE (cond) != GE
+	  && GET_CODE (cond) != LT)
+	return FALSE;
     }
   else
     return FALSE;
@@ -3847,8 +3824,11 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)
     return FALSE;
 
   /* If the conditional jump is more than just a conditional jump, then
-     we can not do if-conversion on this block.  */
-  if (! onlyjump_p (jump))
+     we can not do if-conversion on this block.  Give up for returnjump_p,
+     changing a conditional return followed by unconditional trap for
+     conditional trap followed by unconditional return is likely not
+     beneficial and harder to handle.  */
+  if (! onlyjump_p (jump) || returnjump_p (jump))
     return FALSE;
 
   /* We must be comparing objects whose modes imply the size.  */
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index bfe4821..81a6ef8 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -1787,6 +1787,18 @@ propagate_aggs_accross_jump_function (struct cgraph_edge *cs,
   return ret;
 }
 
+/* Return true if on the way cfrom CS->caller to the final (non-alias and
+   non-thunk) destination, the call passes through a thunk.  */
+
+static bool
+call_passes_through_thunk_p (cgraph_edge *cs)
+{
+  cgraph_node *alias_or_thunk = cs->callee;
+  while (alias_or_thunk->alias)
+    alias_or_thunk = alias_or_thunk->get_alias_target ();
+  return alias_or_thunk->thunk.thunk_p;
+}
+
 /* Propagate constants from the caller to the callee of CS.  INFO describes the
    caller.  */
 
@@ -1795,7 +1807,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)
 {
   struct ipa_node_params *callee_info;
   enum availability availability;
-  struct cgraph_node *callee, *alias_or_thunk;
+  cgraph_node *callee;
   struct ipa_edge_args *args;
   bool ret = false;
   int i, args_count, parms_count;
@@ -1833,10 +1845,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)
   /* If this call goes through a thunk we must not propagate to the first (0th)
      parameter.  However, we might need to uncover a thunk from below a series
      of aliases first.  */
-  alias_or_thunk = cs->callee;
-  while (alias_or_thunk->alias)
-    alias_or_thunk = alias_or_thunk->get_alias_target ();
-  if (alias_or_thunk->thunk.thunk_p)
+  if (call_passes_through_thunk_p (cs))
     {
       ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,
 							       0));
@@ -3404,7 +3413,11 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,
 	  struct ipa_jump_func *jump_func;
 	  tree t;
 
-          if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs)))
+          if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))
+	      || (i == 0
+		  && call_passes_through_thunk_p (cs))
+	      || (!cs->callee->instrumentation_clone
+		  && cs->callee->function_symbol ()->instrumentation_clone))
             {
               newval = NULL_TREE;
               break;
diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
index e319785..c165bce 100644
--- a/gcc/ipa-devirt.c
+++ b/gcc/ipa-devirt.c
@@ -1536,6 +1536,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,
 	break;
       }
     case VOID_TYPE:
+    case NULLPTR_TYPE:
       break;
 
     default:
diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
index 3f29011..47f2bf6 100644
--- a/gcc/ipa-icf.c
+++ b/gcc/ipa-icf.c
@@ -444,7 +444,7 @@ bool
 sem_function::param_used_p (unsigned int i)
 {
   if (ipa_node_params_sum == NULL)
-    return false;
+    return true;
 
   struct ipa_node_params *parms_info = IPA_NODE_REF (get_node ());
 
diff --git a/gcc/ira.c b/gcc/ira.c
index e63b0fa..e9a95e2 100644
--- a/gcc/ira.c
+++ b/gcc/ira.c
@@ -3349,9 +3349,6 @@ adjust_cleared_regs (rtx loc, const_rtx old_rtx ATTRIBUTE_UNUSED, void *data)
   return NULL_RTX;
 }
 
-/* Nonzero if we recorded an equivalence for a LABEL_REF.  */
-static int recorded_label_ref;
-
 /* Find registers that are equivalent to a single value throughout the
    compilation (either because they can be referenced in memory or are
    set once from a single constant).  Lower their priority for a
@@ -3361,10 +3358,8 @@ static int recorded_label_ref;
    value into the using insn.  If it succeeds, we can eliminate the
    register completely.
 
-   Initialize init_insns in ira_reg_equiv array.
-
-   Return non-zero if jump label rebuilding should be done.  */
-static int
+   Initialize init_insns in ira_reg_equiv array.  */
+static void
 update_equiv_regs (void)
 {
   rtx_insn *insn;
@@ -3373,10 +3368,6 @@ update_equiv_regs (void)
   bitmap cleared_regs;
   bool *pdx_subregs;
 
-  /* We need to keep track of whether or not we recorded a LABEL_REF so
-     that we know if the jump optimizer needs to be rerun.  */
-  recorded_label_ref = 0;
-
   /* Use pdx_subregs to show whether a reg is used in a paradoxical
      subreg.  */
   pdx_subregs = XCNEWVEC (bool, max_regno);
@@ -3422,7 +3413,8 @@ update_equiv_regs (void)
 
 	  /* If this insn contains more (or less) than a single SET,
 	     only mark all destinations as having no known equivalence.  */
-	  if (set == NULL_RTX)
+	  if (set == NULL_RTX
+	      || side_effects_p (SET_SRC (set)))
 	    {
 	      note_stores (PATTERN (insn), no_equiv, NULL);
 	      continue;
@@ -3607,17 +3599,6 @@ update_equiv_regs (void)
 		  = gen_rtx_INSN_LIST (VOIDmode, insn,
 				       ira_reg_equiv[regno].init_insns);
 
-	      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.
-		 We might end up substituting the LABEL_REF for uses of the
-		 pseudo here or later.  That kind of transformation may turn an
-		 indirect jump into a direct jump, in which case we must rerun the
-		 jump optimizer to ensure that the JUMP_LABEL fields are valid.  */
-	      if (GET_CODE (x) == LABEL_REF
-		  || (GET_CODE (x) == CONST
-		      && GET_CODE (XEXP (x, 0)) == PLUS
-		      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))
-		recorded_label_ref = 1;
-
 	      reg_equiv[regno].replacement = x;
 	      reg_equiv[regno].src_p = &SET_SRC (set);
 	      reg_equiv[regno].loop_depth = (short) loop_depth;
@@ -3735,9 +3716,9 @@ update_equiv_regs (void)
 	  if (! INSN_P (insn))
 	    continue;
 
-	  /* Don't substitute into a non-local goto, this confuses CFG.  */
-	  if (JUMP_P (insn)
-	      && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))
+	  /* Don't substitute into jumps.  indirect_jump_optimize does
+	     this for anything we are prepared to handle.  */
+	  if (JUMP_P (insn))
 	    continue;
 
 	  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
@@ -3889,11 +3870,50 @@ update_equiv_regs (void)
   end_alias_analysis ();
   free (reg_equiv);
   free (pdx_subregs);
-  return recorded_label_ref;
 }
 
-
+/* A pass over indirect jumps, converting simple cases to direct jumps.  */
+static void
+indirect_jump_optimize (void)
+{
+  basic_block bb;
+  bool rebuild_p = false;
+
+  FOR_EACH_BB_REVERSE_FN (bb, cfun)
+    {
+      rtx_insn *insn = BB_END (bb);
+      if (!JUMP_P (insn))
+	continue;
+
+      rtx x = pc_set (insn);
+      if (!x || !REG_P (SET_SRC (x)))
+	continue;
+
+      int regno = REGNO (SET_SRC (x));
+      if (DF_REG_DEF_COUNT (regno) == 1)
+	{
+	  rtx_insn *def_insn = DF_REF_INSN (DF_REG_DEF_CHAIN (regno));
+	  rtx note = find_reg_note (def_insn, REG_LABEL_OPERAND, NULL_RTX);
+
+	  if (note)
+	    {
+	      rtx lab = gen_rtx_LABEL_REF (Pmode, XEXP (note, 0));
+	      if (validate_replace_rtx (SET_SRC (x), lab, insn))
+		rebuild_p = true;
+	    }
+	}
+    }
 
+  if (rebuild_p)
+    {
+      timevar_push (TV_JUMP);
+      rebuild_jump_labels (get_insns ());
+      if (purge_all_dead_edges ())
+	delete_unreachable_blocks ();
+      timevar_pop (TV_JUMP);
+    }
+}
+
 /* Set up fields memory, constant, and invariant from init_insns in
    the structures of array ira_reg_equiv.  */
 static void
@@ -5123,7 +5143,6 @@ ira (FILE *f)
 {
   bool loops_p;
   int ira_max_point_before_emit;
-  int rebuild_p;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
 
@@ -5200,6 +5219,10 @@ ira (FILE *f)
 
   df_clear_flags (DF_NO_INSN_RESCAN);
 
+  indirect_jump_optimize ();
+  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))
+    df_analyze ();
+
   regstat_init_n_sets_and_refs ();
   regstat_compute_ri ();
 
@@ -5217,24 +5240,12 @@ ira (FILE *f)
   if (resize_reg_info () && flag_ira_loop_pressure)
     ira_set_pseudo_classes (true, ira_dump_file);
 
-  rebuild_p = update_equiv_regs ();
+  update_equiv_regs ();
   setup_reg_equiv ();
   setup_reg_equiv_init ();
 
-  if (optimize && rebuild_p)
-    {
-      timevar_push (TV_JUMP);
-      rebuild_jump_labels (get_insns ());
-      if (purge_all_dead_edges ())
-	delete_unreachable_blocks ();
-      timevar_pop (TV_JUMP);
-    }
-
   allocated_reg_info_size = max_reg_num ();
 
-  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))
-    df_analyze ();
-
   /* It is not worth to do such improvement when we use a simple
      allocation because of -O0 usage or because the function is too
      big.  */
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index c79a515..7d3830f 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -5163,8 +5163,10 @@ update_ebb_live_info (rtx_insn *head, rtx_insn *tail)
       curr_id = lra_get_insn_recog_data (curr_insn);
       curr_static_id = curr_id->insn_static_data;
       remove_p = false;
-      if ((set = single_set (curr_insn)) != NULL_RTX && REG_P (SET_DEST (set))
+      if ((set = single_set (curr_insn)) != NULL_RTX
+	  && REG_P (SET_DEST (set))
 	  && (regno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER
+	  && SET_DEST (set) != pic_offset_table_rtx
 	  && bitmap_bit_p (&check_only_regs, regno)
 	  && ! bitmap_bit_p (&live_regs, regno))
 	remove_p = true;
diff --git a/gcc/lra-remat.c b/gcc/lra-remat.c
index f2d226c..5e5d62c 100644
--- a/gcc/lra-remat.c
+++ b/gcc/lra-remat.c
@@ -112,6 +112,9 @@ static int call_used_regs_arr[FIRST_PSEUDO_REGISTER];
 /* Bitmap used for different calculations.  */
 static bitmap_head temp_bitmap;
 
+/* Registers accessed via subreg_p.  */
+static bitmap_head subreg_regs;
+
 typedef struct cand *cand_t;
 typedef const struct cand *const_cand_t;
 
@@ -144,6 +147,10 @@ static vec<cand_t> all_cands;
 /* Map: insn -> candidate representing it.  It is null if the insn can
    not be used for rematerialization.  */
 static cand_t *insn_to_cand;
+/* A secondary map, for candidates that involve two insns, where the
+   second one makes the equivalence.  The candidate must not be used
+   before seeing this activation insn.  */
+static cand_t *insn_to_cand_activation;
 
 /* Map regno -> candidates can be used for the regno
    rematerialization.  */
@@ -418,30 +425,30 @@ operand_to_remat (rtx_insn *insn)
     return -1;
   /* First find a pseudo which can be rematerialized.  */
   for (reg = id->regs; reg != NULL; reg = reg->next)
-    /* True FRAME_POINTER_NEEDED might be because we can not follow
-       changing sp offsets, e.g. alloca is used.  If the insn contains
-       stack pointer in such case, we can not rematerialize it as we
-       can not know sp offset at a rematerialization place.  */
-    if (reg->regno == STACK_POINTER_REGNUM && frame_pointer_needed)
-      return -1;
-    else if (reg->type == OP_OUT && ! reg->subreg_p
-	     && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)
-      {
-	/* We permits only one spilled reg.  */
-	if (found_reg != NULL)
-	  return -1;
-	found_reg = reg;
-      }
-    /* IRA calculates conflicts separately for subregs of two words
-       pseudo.  Even if the pseudo lives, e.g. one its subreg can be
-       used lately, another subreg hard register can be already used
-       for something else.  In such case, it is not safe to
-       rematerialize the insn.  */
-    else if (reg->type == OP_IN && reg->subreg_p
-	     && reg->regno >= FIRST_PSEUDO_REGISTER
-	     && (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno))
-		 == 2 * UNITS_PER_WORD))
-      return -1;
+    {
+      /* True FRAME_POINTER_NEEDED might be because we can not follow
+	 changing sp offsets, e.g. alloca is used.  If the insn contains
+	 stack pointer in such case, we can not rematerialize it as we
+	 can not know sp offset at a rematerialization place.  */
+      if (reg->regno == STACK_POINTER_REGNUM && frame_pointer_needed)
+	return -1;
+      else if (reg->type == OP_OUT && ! reg->subreg_p
+	       && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)
+	{
+	  /* We permits only one spilled reg.  */
+	  if (found_reg != NULL)
+	    return -1;
+	  found_reg = reg;
+        }
+      /* IRA calculates conflicts separately for subregs of two words
+	 pseudo.  Even if the pseudo lives, e.g. one its subreg can be
+	 used lately, another subreg hard register can be already used
+	 for something else.  In such case, it is not safe to
+	 rematerialize the insn.  */
+      if (reg->regno >= FIRST_PSEUDO_REGISTER
+	  && bitmap_bit_p (&subreg_regs, reg->regno))
+	return -1;
+    }
   if (found_reg == NULL)
     return -1;
   if (found_reg->regno < FIRST_PSEUDO_REGISTER)
@@ -493,7 +500,7 @@ operand_to_remat (rtx_insn *insn)
    REGNO.  Insert the candidate into the table and set up the
    corresponding INSN_TO_CAND element.  */
 static void
-create_cand (rtx_insn *insn, int nop, int regno)
+create_cand (rtx_insn *insn, int nop, int regno, rtx_insn *activation = NULL)
 {
   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);
   rtx reg = *id->operand_loc[nop];
@@ -518,6 +525,8 @@ create_cand (rtx_insn *insn, int nop, int regno)
       cand->next_regno_cand = regno_cands[cand->regno];
       regno_cands[cand->regno] = cand;
     }
+  if (activation)
+    insn_to_cand_activation[INSN_UID (activation)] = cand_in_table;
 }
 
 /* Create rematerialization candidates (inserting them into the
@@ -536,43 +545,55 @@ create_cands (void)
   /* Create candidates.  */
   regno_potential_cand = XCNEWVEC (struct potential_cand, max_reg_num ());
   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
-    if (INSN_P (insn))
+    if (NONDEBUG_INSN_P (insn))
       {
-	rtx set;
-	int src_regno, dst_regno;
-	rtx_insn *insn2;
 	lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);
-	int nop = operand_to_remat (insn);
-	int regno = -1;
-
-	if ((set = single_set (insn)) != NULL
-	    && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))
-	    && ((src_regno = REGNO (SET_SRC (set)))
-		>= lra_constraint_new_regno_start)
-	    && (dst_regno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER
-	    && reg_renumber[dst_regno] < 0
-	    && (insn2 = regno_potential_cand[src_regno].insn) != NULL
-	    && BLOCK_FOR_INSN (insn2) == BLOCK_FOR_INSN (insn))
-	  /* It is an output reload insn after insn can be
-	     rematerialized (potential candidate).  */
-	  create_cand (insn2, regno_potential_cand[src_regno].nop, dst_regno);
-	if (nop < 0)
-	  goto fail;
-	gcc_assert (REG_P (*id->operand_loc[nop]));
- 	regno = REGNO (*id->operand_loc[nop]);
-	gcc_assert (regno >= FIRST_PSEUDO_REGISTER);
-	if (reg_renumber[regno] < 0)
-	  create_cand (insn, nop, regno);
-	else
+	int keep_regno = -1;
+	rtx set = single_set (insn);
+	int nop;
+
+	/* See if this is an output reload for a previous insn.  */
+	if (set != NULL
+	    && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set)))
+	  {
+	    rtx dstreg = SET_DEST (set);
+	    int src_regno = REGNO (SET_SRC (set));
+	    int dst_regno = REGNO (dstreg);
+	    rtx_insn *insn2 = regno_potential_cand[src_regno].insn;
+
+	    if (insn2 != NULL 
+		&& dst_regno >= FIRST_PSEUDO_REGISTER
+		&& reg_renumber[dst_regno] < 0
+		&& BLOCK_FOR_INSN (insn2) == BLOCK_FOR_INSN (insn))
+	      {
+		create_cand (insn2, regno_potential_cand[src_regno].nop,
+			     dst_regno, insn);
+		goto done;
+	      }
+	  }
+
+	nop = operand_to_remat (insn);
+	if (nop >= 0)
 	  {
-	    regno_potential_cand[regno].insn = insn;
-	    regno_potential_cand[regno].nop = nop;
-	    goto fail;
+	    gcc_assert (REG_P (*id->operand_loc[nop]));
+	    int regno = REGNO (*id->operand_loc[nop]);
+	    gcc_assert (regno >= FIRST_PSEUDO_REGISTER);
+	    /* If we're setting an unrenumbered pseudo, make a candidate immediately.
+	       If it's an output reload register, save it for later; the code above
+	       looks for output reload insns later on.  */
+	    if (reg_renumber[regno] < 0)
+	      create_cand (insn, nop, regno);
+	    else if (regno >= lra_constraint_new_regno_start)
+	      {
+		regno_potential_cand[regno].insn = insn;
+		regno_potential_cand[regno].nop = nop;
+		keep_regno = regno;
+	      }
 	  }
-	regno = -1;
-      fail:
+
+      done:
 	for (struct lra_insn_reg *reg = id->regs; reg != NULL; reg = reg->next)
-	  if (reg->type != OP_IN && reg->regno != regno
+	  if (reg->type != OP_IN && reg->regno != keep_regno
 	      && reg->regno >= FIRST_PSEUDO_REGISTER)
 	    regno_potential_cand[reg->regno].insn = NULL;
       }
@@ -668,6 +689,9 @@ dump_candidates_and_remat_bb_data (void)
       lra_dump_bitmap_with_title ("avout cands in BB",
 				  &get_remat_bb_data (bb)->avout_cands, bb->index);
     }
+  fprintf (lra_dump_file, "subreg regs:");
+  dump_regset (&subreg_regs, lra_dump_file);
+  putc ('\n', lra_dump_file);
 }
 
 /* Free all BB data.  */
@@ -692,21 +716,24 @@ finish_remat_bb_data (void)
 
 
 
-/* Update changed_regs and dead_regs of BB from INSN.  */
+/* Update changed_regs, dead_regs, subreg_regs of BB from INSN.  */
 static void
 set_bb_regs (basic_block bb, rtx_insn *insn)
 {
   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);
+  remat_bb_data_t bb_info = get_remat_bb_data (bb);
   struct lra_insn_reg *reg;
 
   for (reg = id->regs; reg != NULL; reg = reg->next)
-    if (reg->type != OP_IN)
-      bitmap_set_bit (&get_remat_bb_data (bb)->changed_regs, reg->regno);
-    else
-      {
-	if (find_regno_note (insn, REG_DEAD, (unsigned) reg->regno) != NULL)
-	  bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs, reg->regno);
-      }
+    {
+      unsigned regno = reg->regno;
+      if (reg->type != OP_IN)
+        bitmap_set_bit (&bb_info->changed_regs, regno);
+      else if (find_regno_note (insn, REG_DEAD, regno) != NULL)
+	bitmap_set_bit (&bb_info->dead_regs, regno);
+      if (regno >= FIRST_PSEUDO_REGISTER && reg->subreg_p)
+	bitmap_set_bit (&subreg_regs, regno);
+    }
   if (CALL_P (insn))
     for (int i = 0; i < call_used_regs_arr_len; i++)
       bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs,
@@ -722,7 +749,7 @@ calculate_local_reg_remat_bb_data (void)
 
   FOR_EACH_BB_FN (bb, cfun)
     FOR_BB_INSNS (bb, insn)
-      if (INSN_P (insn))
+      if (NONDEBUG_INSN_P (insn))
 	set_bb_regs (bb, insn);
 }
 
@@ -1100,16 +1127,21 @@ do_remat (void)
   rtx_insn *insn;
   basic_block bb;
   bitmap_head avail_cands;
+  bitmap_head active_cands;
   bool changed_p = false;
   /* Living hard regs and hard registers of living pseudos.  */
   HARD_REG_SET live_hard_regs;
 
   bitmap_initialize (&avail_cands, &reg_obstack);
+  bitmap_initialize (&active_cands, &reg_obstack);
   FOR_EACH_BB_FN (bb, cfun)
     {
       REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_out (bb));
       bitmap_and (&avail_cands, &get_remat_bb_data (bb)->avin_cands,
 		  &get_remat_bb_data (bb)->livein_cands);
+      /* Activating insns are always in the same block as their corresponding
+	 remat insn, so at the start of a block the two bitsets are equal.  */
+      bitmap_copy (&active_cands, &avail_cands);
       FOR_BB_INSNS (bb, insn)
 	{
 	  if (!NONDEBUG_INSN_P (insn))
@@ -1143,7 +1175,8 @@ do_remat (void)
 	      for (cand = regno_cands[src_regno];
 		   cand != NULL;
 		   cand = cand->next_regno_cand)
-		if (bitmap_bit_p (&avail_cands, cand->index))
+		if (bitmap_bit_p (&avail_cands, cand->index)
+		    && bitmap_bit_p (&active_cands, cand->index))
 		  break;
 	    }
 	  int i, hard_regno, nregs;
@@ -1237,9 +1270,23 @@ do_remat (void)
 	      }
 
 	  bitmap_and_compl_into (&avail_cands, &temp_bitmap);
-	  if ((cand = insn_to_cand[INSN_UID (insn)]) != NULL)
-	    bitmap_set_bit (&avail_cands, cand->index);
-	    
+
+	  /* Now see whether a candidate is made active or available
+	     by this insn.  */
+	  cand = insn_to_cand_activation[INSN_UID (insn)];
+	  if (cand)
+	    bitmap_set_bit (&active_cands, cand->index);
+
+	  cand = insn_to_cand[INSN_UID (insn)];
+	  if (cand != NULL)
+	    {
+	      bitmap_set_bit (&avail_cands, cand->index);
+	      if (cand->reload_regno == -1)
+		bitmap_set_bit (&active_cands, cand->index);
+	      else
+		bitmap_clear_bit (&active_cands, cand->index);
+	    }
+
 	  if (remat_insn != NULL)
 	    {
 	      HOST_WIDE_INT sp_offset_change = cand_sp_offset - id->sp_offset;
@@ -1286,6 +1333,7 @@ do_remat (void)
 	}
     }
   bitmap_clear (&avail_cands);
+  bitmap_clear (&active_cands);
   return changed_p;
 }
 
@@ -1314,6 +1362,7 @@ lra_remat (void)
 	     lra_rematerialization_iter);
   timevar_push (TV_LRA_REMAT);
   insn_to_cand = XCNEWVEC (cand_t, get_max_uid ());
+  insn_to_cand_activation = XCNEWVEC (cand_t, get_max_uid ());
   regno_cands = XCNEWVEC (cand_t, max_regno);
   all_cands.create (8000);
   call_used_regs_arr_len = 0;
@@ -1321,10 +1370,11 @@ lra_remat (void)
     if (call_used_regs[i])
       call_used_regs_arr[call_used_regs_arr_len++] = i;
   initiate_cand_table ();
-  create_cands ();
   create_remat_bb_data ();
   bitmap_initialize (&temp_bitmap, &reg_obstack);
+  bitmap_initialize (&subreg_regs, &reg_obstack);
   calculate_local_reg_remat_bb_data ();
+  create_cands ();
   calculate_livein_cands ();
   calculate_gen_cands ();
   bitmap_initialize (&all_blocks, &reg_obstack);
@@ -1335,11 +1385,13 @@ lra_remat (void)
   result = do_remat ();
   all_cands.release ();
   bitmap_clear (&temp_bitmap);
+  bitmap_clear (&subreg_regs);
   finish_remat_bb_data ();
   finish_cand_table ();
   bitmap_clear (&all_blocks);
   free (regno_cands);
   free (insn_to_cand);
+  free (insn_to_cand_activation);
   timevar_pop (TV_LRA_REMAT);
   return result;
 }
diff --git a/gcc/match.pd b/gcc/match.pd
index e40720e..405fec6 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -382,12 +382,15 @@ along with GCC; see the file COPYING3.  If not see
   (bit_not (bit_not @0))
   @0)
 
+/* Disable on GENERIC because of PR68513.  */
+#if GIMPLE
 /* (x & ~m) | (y & m) -> ((x ^ y) & m) ^ x */
 (simplify
   (bit_ior:c (bit_and:c@3 @0 (bit_not @2)) (bit_and:c@4 @1 @2))
   (if ((TREE_CODE (@3) != SSA_NAME || has_single_use (@3))
 	&& (TREE_CODE (@4) != SSA_NAME || has_single_use (@4)))
    (bit_xor (bit_and (bit_xor @0 @1) @2) @0)))
+#endif
 
 
 /* Associate (p +p off1) +p off2 as (p +p (off1 + off2)).  */
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index a1ac6a6..3f08b72 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -12779,7 +12779,8 @@ simd_clone_create (struct cgraph_node *old_node)
       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;
       DECL_STATIC_DESTRUCTOR (new_decl) = 0;
       new_node = old_node->create_version_clone (new_decl, vNULL, NULL);
-      symtab->call_cgraph_insertion_hooks (new_node);
+      if (old_node->in_other_partition)
+	new_node->in_other_partition = 1;
     }
   if (new_node == NULL)
     return new_node;
diff --git a/gcc/po/ChangeLog b/gcc/po/ChangeLog
index f438874..3b97503 100644
--- a/gcc/po/ChangeLog
+++ b/gcc/po/ChangeLog
@@ -1,3 +1,11 @@
+2016-01-11  Joseph Myers  <joseph@codesourcery.com>
+
+	* zh_CN.po: Update.
+
+2015-12-31  Joseph Myers  <joseph@codesourcery.com>
+
+	* fr.po: Update.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/gcc/po/fr.po b/gcc/po/fr.po
index 9483d9d..4596e55 100644
--- a/gcc/po/fr.po
+++ b/gcc/po/fr.po
@@ -122,10 +122,10 @@
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gcc 5.1.0\n"
+"Project-Id-Version: gcc 5.2.0\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2015-07-02 12:31+0000\n"
-"PO-Revision-Date: 2015-04-29 12:25+0200\n"
+"PO-Revision-Date: 2015-12-30 14:31+0100\n"
 "Last-Translator: Stéphane Aulery <lkppo@free.fr>\n"
 "Language-Team: French <traduc@traduc.org>\n"
 "Language: fr\n"
@@ -136,19 +136,19 @@ msgstr ""
 
 #: cfgrtl.c:2698
 msgid "flow control insn inside a basic block"
-msgstr "insn de contrôle de flot à l'intérieur d'un bloc de base"
+msgstr "insn de contrôle de flot à l’intérieur d’un bloc de base"
 
 #: cfgrtl.c:2930
 msgid "wrong insn in the fallthru edge"
-msgstr "insn erronée dans l'arrête fallthru"
+msgstr "insn erronée dans l’arrête fallthru"
 
 #: cfgrtl.c:2987
 msgid "insn outside basic block"
-msgstr "insn à l'extérieur de tout bloc de base"
+msgstr "insn à l’extérieur de tout bloc de base"
 
 #: cfgrtl.c:2994
 msgid "return not followed by barrier"
-msgstr "return n'est pas suivi d'une barrière"
+msgstr "return n’est pas suivi d’une barrière"
 
 #: collect-utils.c:164
 #, c-format
@@ -203,11 +203,11 @@ msgid ""
 "ldd output with constructors/destructors.\n"
 msgstr ""
 "\n"
-"sortie de ldd avec constructeurs/destructeurs.\n"
+"sortie de ldd avec constructeurs / destructeurs.\n"
 
 #: cprop.c:1793
 msgid "const/copy propagation disabled"
-msgstr "propagation de const/copy désactivée"
+msgstr "propagation de const / copie désactivée"
 
 #: diagnostic.c:212
 #, c-format
@@ -240,13 +240,13 @@ msgid ""
 "Please submit a full bug report,\n"
 "with preprocessed source if appropriate.\n"
 msgstr ""
-"Veuillez soumettre un rapport d'anomalies complet,\n"
-"avec le source pré-traité si nécessaire.\n"
+"Veuillez soumettre un rapport d’anomalies complet,\n"
+"avec la sortie du préprocesseur si nécessaire.\n"
 
 #: diagnostic.c:540
 #, c-format
 msgid "See %s for instructions.\n"
-msgstr ""
+msgstr "Voir %s pour les instructions.\n"
 
 #: diagnostic.c:549
 #, c-format
@@ -262,11 +262,11 @@ msgstr "%s:%d: embrouillé par les erreurs précédentes, abandon\n"
 #: diagnostic.c:1273
 #, c-format
 msgid "Internal compiler error: Error reporting routines re-entered.\n"
-msgstr "erreur interne au compilateur : routine de rapport d'erreur préemptée.\n"
+msgstr "erreur interne au compilateur : routine de rapport d’erreur préemptée.\n"
 
 #: final.c:1229
 msgid "negative insn length"
-msgstr "longueur négative insn"
+msgstr "longueur insn négative"
 
 #: final.c:3020
 msgid "could not split insn"
@@ -279,32 +279,32 @@ msgstr "asm invalide : "
 #: final.c:3564
 #, c-format
 msgid "nested assembly dialect alternatives"
-msgstr "assemblage de dialectes alternatifs imbriqués"
+msgstr "alternatives imbriquées de dialecte assembleur"
 
 #: final.c:3592 final.c:3604
 #, c-format
 msgid "unterminated assembly dialect alternative"
-msgstr "assemblage de dialectes alternatifs non terminé"
+msgstr "alternative non terminée de dialecte assembleur"
 
 #: final.c:3746
 #, c-format
 msgid "operand number missing after %%-letter"
-msgstr "numéro d'opérande manquant après %%-letter"
+msgstr "numéro d’opérande manquant après %%-lettre"
 
 #: final.c:3749 final.c:3790
 #, c-format
 msgid "operand number out of range"
-msgstr "nombre d'opérandes hors limite"
+msgstr "numéro d’opérande hors limite"
 
 #: final.c:3807
 #, c-format
 msgid "invalid %%-code"
-msgstr "%%-code est invalide"
+msgstr "%%-code invalide"
 
 #: final.c:3837
 #, c-format
 msgid "'%%l' operand isn't a label"
-msgstr "l'opérande « %%l » n'est pas une étiquette"
+msgstr "l’opérande « %%l » n'est pas une étiquette"
 
 #. We can't handle floating point constants;
 #. PRINT_OPERAND must handle them.
@@ -335,23 +335,23 @@ msgid ""
 "Setting spec %s to '%s'\n"
 "\n"
 msgstr ""
-"Initialisation des spec %s à « %s »\n"
+"Initialisation des specs %s à « %s »\n"
 "\n"
 
 #: gcc.c:1808
 #, c-format
 msgid "Reading specs from %s\n"
-msgstr "Lecture des spécification à partir de %s\n"
+msgstr "Lecture des spécifications à partir de %s\n"
 
 #: gcc.c:1935
 #, c-format
 msgid "could not find specs file %s\n"
-msgstr "ne peut repérer le fichiers des specs %s\n"
+msgstr "impossible de trouver le fichier des specs %s\n"
 
 #: gcc.c:2010
 #, c-format
 msgid "rename spec %s to %s\n"
-msgstr "renommé les specs %s à %s\n"
+msgstr "renommer les specs %s à %s\n"
 
 #: gcc.c:2012
 #, c-format
@@ -374,7 +374,7 @@ msgid ""
 "Go ahead? (y or n) "
 msgstr ""
 "\n"
-"Aller de l'avant? (y ou n) "
+"Continuer ? (y ou n) "
 
 #: gcc.c:2965
 #, c-format
@@ -384,133 +384,124 @@ msgstr "# %s %.2f %.2f\n"
 #: gcc.c:3171
 #, c-format
 msgid "Usage: %s [options] file...\n"
-msgstr "Usage: %s [options] fichier...\n"
+msgstr "Usage : %s [options] fichier…\n"
 
 #: gcc.c:3172
 msgid "Options:\n"
-msgstr "Options:\n"
+msgstr "Options :\n"
 
 #: gcc.c:3174
 msgid "  -pass-exit-codes         Exit with highest error code from a phase\n"
-msgstr "  -pass-exit-codes         quitter avec le plus grand code d'erreur de la phase\n"
+msgstr "  -pass-exit-codes         Quitter avec le plus grand code d’erreur d’une phase\n"
 
 #: gcc.c:3175
 msgid "  --help                   Display this information\n"
-msgstr "  --help                   afficher l'aide mémoire\n"
+msgstr "  --help                   Afficher cette aide\n"
 
 #: gcc.c:3176
 msgid "  --target-help            Display target specific command line options\n"
-msgstr "  --target-help            afficher les options spécifiques de la ligne de commande\n"
+msgstr "  --target-help            Afficher les options de ligne de commande spécifiques à la cible\n"
 
 #: gcc.c:3177
 msgid "  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...]\n"
-msgstr ""
+msgstr " --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,…]\n"
 
 #: gcc.c:3178
-#, fuzzy
-#| msgid "  --target-help            Display target specific command line options\n"
 msgid "                           Display specific types of command line options\n"
-msgstr "  --target-help            afficher les options spécifiques de la ligne de commande\n"
+msgstr "                           Afficher les types spécifiques des options de la ligne de commande\n"
 
 #: gcc.c:3180
 msgid "  (Use '-v --help' to display command line options of sub-processes)\n"
-msgstr "  (Utiliser «-v --help» pour afficher les options de la ligne de commande des sous-processus)\n"
+msgstr "  (Utiliser « -v --help » pour afficher les options de la ligne de commande des sous-processus)\n"
 
 #: gcc.c:3181
 msgid "  --version                Display compiler version information\n"
-msgstr "  --help                   afficher des informations sur la version du compilateur\n"
+msgstr "  --help                   Afficher des informations sur la version du compilateur\n"
 
 #: gcc.c:3182
 msgid "  -dumpspecs               Display all of the built in spec strings\n"
-msgstr "  -dumpspecs               afficher tous les construits des chaînes de specs\n"
+msgstr "  -dumpspecs               Afficher tous les chaînes de specs internes\n"
 
 #: gcc.c:3183
 msgid "  -dumpversion             Display the version of the compiler\n"
-msgstr "  -dumpversion             afficher la version du compilateur\n"
+msgstr "  -dumpversion             Afficher la version du compilateur\n"
 
 #: gcc.c:3184
 msgid "  -dumpmachine             Display the compiler's target processor\n"
-msgstr "  -dumpmachine             afficher le processeur ciblé par le compilateur\n"
+msgstr "  -dumpmachine             Afficher le processeur ciblé par le compilateur\n"
 
 #: gcc.c:3185
 msgid "  -print-search-dirs       Display the directories in the compiler's search path\n"
-msgstr "  -print-search-dirs       afficher les répertoires du chemin de recherche du compilateur\n"
+msgstr "  -print-search-dirs       Afficher les répertoires du chemin de recherche du compilateur\n"
 
 #: gcc.c:3186
 msgid "  -print-libgcc-file-name  Display the name of the compiler's companion library\n"
-msgstr "  -print-libgcc-file-name  afficher le nom de la bibliothèque compagne du compilateur\n"
+msgstr "  -print-libgcc-file-name  Afficher le nom de la bibliothèque accompagnant le compilateur\n"
 
 #: gcc.c:3187
 msgid "  -print-file-name=<lib>   Display the full path to library <lib>\n"
-msgstr "  -print-file-name=<lib>   afficher le chemin d'accès complet vers la bibliothèque <lib>\n"
+msgstr "  -print-file-name=<lib>   Afficher le chemin d’accès complet vers la bibliothèque <lib>\n"
 
 #: gcc.c:3188
 msgid "  -print-prog-name=<prog>  Display the full path to compiler component <prog>\n"
-msgstr "  -print-prog-name=<prog>  afficher le chemin d'accès complet vers le composant du compilateur <prog>\n"
+msgstr "  -print-prog-name=<prog>  Afficher le chemin d’accès complet vers le composant du compilateur <prog>\n"
 
 #: gcc.c:3189
-#, fuzzy
-#| msgid ""
-#| "  -print-multi-lib         Display the mapping between command line options and\n"
-#| "                           multiple library search directories\n"
 msgid ""
 "  -print-multiarch         Display the target's normalized GNU triplet, used as\n"
 "                           a component in the library path\n"
 msgstr ""
-"  -print-multi-lib         Afficher la table de projection entre les options de\n"
-"                           la ligne de commande et les multiples répertoires de\n"
-"                           recherches des bibliothèques\n"
+"  -print-multiarch         Afficher le triplet GNU normalisé de la cible, utilisé comme\n"
+"                           un composant dans le chemin d’accès de la bibliothèque\n"
 
 #: gcc.c:3192
 msgid "  -print-multi-directory   Display the root directory for versions of libgcc\n"
-msgstr "  -print-multi-directory   afficher la racine du répertoire des version libgcc\n"
+msgstr "  -print-multi-directory   Afficher la racine du répertoire des versions de libgcc\n"
 
 #: gcc.c:3193
 msgid ""
 "  -print-multi-lib         Display the mapping between command line options and\n"
 "                           multiple library search directories\n"
 msgstr ""
-"  -print-multi-lib         Afficher la table de projection entre les options de\n"
+"  -print-multi-lib         Afficher la table de correspondance entre les options de\n"
 "                           la ligne de commande et les multiples répertoires de\n"
-"                           recherches des bibliothèques\n"
+"                           recherche des bibliothèques\n"
 
 #: gcc.c:3196
 msgid "  -print-multi-os-directory Display the relative path to OS libraries\n"
-msgstr "  -print-multi-os-directory   afficher le chemin relatif du répertoire vers les librairies de l'OS\n"
+msgstr "  -print-multi-os-directory Afficher le chemin relatif du répertoire vers les bibliothèques de l’OS\n"
 
 #: gcc.c:3197
-#, fuzzy
-#| msgid "  -dumpmachine             Display the compiler's target processor\n"
 msgid "  -print-sysroot           Display the target libraries directory\n"
-msgstr "  -dumpmachine             afficher le processeur ciblé par le compilateur\n"
+msgstr "  -print-sysroot           Afficher le répertoire des bibliothèques de la cible\n"
 
 #: gcc.c:3198
 msgid "  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers\n"
-msgstr ""
+msgstr "  -print-sysroot-headers-suffix Afficher le suffixe de la racine système utilisé pour trouver les en-têtes\n"
 
 #: gcc.c:3199
 msgid "  -Wa,<options>            Pass comma-separated <options> on to the assembler\n"
-msgstr "  -Wa,<options>            passer les <options> séparées par des virgules à l'assembleur\n"
+msgstr "  -Wa,<options>            Passer les <options> séparées par des virgules à l’assembleur\n"
 
 #: gcc.c:3200
 msgid "  -Wp,<options>            Pass comma-separated <options> on to the preprocessor\n"
-msgstr "  -Wp,<options>            passer les <options> séparées par des virgules au préprocesseur\n"
+msgstr "  -Wp,<options>            Passer les <options> séparées par des virgules au préprocesseur\n"
 
 #: gcc.c:3201
 msgid "  -Wl,<options>            Pass comma-separated <options> on to the linker\n"
-msgstr "  -Wl,<options>            passer les <options> séparées par des virgules  à l'éditeur de liens\n"
+msgstr "  -Wl,<options>            Passer les <options> séparées par des virgules à l'éditeur de liens\n"
 
 #: gcc.c:3202
 msgid "  -Xassembler <arg>        Pass <arg> on to the assembler\n"
-msgstr "  -Xassembler <arg>        passer l'<arg>ument à l'assembleur\n"
+msgstr "  -Xassembler <argument>   Passer l’<argument> à l’assembleur\n"
 
 #: gcc.c:3203
 msgid "  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor\n"
-msgstr "  -Xpreprocessor <arg>     passer l'<arg>ument au pré-processeur\n"
+msgstr "  -Xpreprocessor <argument>  Passer l’<argument> au préprocesseur\n"
 
 #: gcc.c:3204
 msgid "  -Xlinker <arg>           Pass <arg> on to the linker\n"
-msgstr "  -Xlinker <argument>      passer l'<argument> à l'éditeur de liens\n"
+msgstr "  -Xlinker <argument>       Passer l’<argument> à l’éditeur de liens\n"
 
 #: gcc.c:3205
 msgid "  -save-temps              Do not delete intermediate files\n"
@@ -562,11 +553,11 @@ msgstr "  -###                     identique à -v mais les options et les comma
 
 #: gcc.c:3220
 msgid "  -E                       Preprocess only; do not compile, assemble or link\n"
-msgstr "  -E                       pré-traiter seulement; ne pas compiler, assembler ou éditer les liens\n"
+msgstr "  -E                       pré-traiter seulement ; ne pas compiler, assembler ou éditer les liens\n"
 
 #: gcc.c:3221
 msgid "  -S                       Compile only; do not assemble or link\n"
-msgstr "  -S                       compiler seulement; ne pas assembler ou éditer les liens\n"
+msgstr "  -S                       compiler seulement ; ne pas assembler ou éditer les liens\n"
 
 #: gcc.c:3222
 msgid "  -c                       Compile and assemble, but do not link\n"
@@ -1199,10 +1190,8 @@ msgid "Cannot open source file %s\n"
 msgstr "N'a pu ouvrir le fichier source %s\n"
 
 #: gcse.c:2601
-#, fuzzy
-#| msgid "GCSE disabled"
 msgid "PRE disabled"
-msgstr "GCSE désactivé"
+msgstr "PRE désactivé"
 
 #: gcse.c:3529
 msgid "GCSE disabled"
@@ -1260,10 +1249,8 @@ msgid "'"
 msgstr ""
 
 #: ipa-pure-const.c:218
-#, fuzzy
-#| msgid "function might be possible candidate for attribute `noreturn'"
 msgid "function might be candidate for attribute %<%s%>"
-msgstr "fonction peut être une possible candidate pour l'attribut « norreturn »"
+msgstr "fonction peut être une candidate pour l'attribut %<%s%>"
 
 #: ipa-pure-const.c:219
 #, fuzzy
@@ -1428,11 +1415,11 @@ msgstr "Les options suivantes sont indépendantes du langage:\n"
 
 #: plugin.c:806
 msgid "Event"
-msgstr ""
+msgstr "Événement"
 
 #: plugin.c:806
 msgid "Plugins"
-msgstr ""
+msgstr "Extensions"
 
 #: plugin.c:838
 #, c-format
@@ -1492,7 +1479,7 @@ msgstr "collect: tordage de %s dans %s\n"
 #: tlink.c:846
 #, c-format
 msgid "collect: relinking\n"
-msgstr "collect: ré-édition des liens\n"
+msgstr "collect: réédition des liens\n"
 
 #: toplev.c:379
 #, c-format
@@ -1534,7 +1521,7 @@ msgstr "options passées : "
 
 #: toplev.c:951
 msgid "options enabled: "
-msgstr "options autorisées: "
+msgstr "options autorisées : "
 
 #: tree-diagnostic.c:306 c/c-decl.c:5184 c/c-typeck.c:6556 cp/error.c:700
 #: cp/error.c:1006 c-family/c-pretty-print.c:443
@@ -1642,9 +1629,7 @@ msgstr "Autoriser le traitement des exceptions"
 #| "\n"
 #| "Target specific options:\n"
 msgid "target specific option mismatch"
-msgstr ""
-"\n"
-"Options spécifiques à la cible:\n"
+msgstr "Options spécifiques à la cible:\n"
 
 #: cif-code.def:117
 #, fuzzy
@@ -1673,7 +1658,7 @@ msgstr ""
 #. The remainder are real diagnostic types.
 #: diagnostic.def:33
 msgid "fatal error: "
-msgstr "erreur fatale: "
+msgstr "erreur fatale : "
 
 #. This is like DK_ICE, but backtrace is not printed.  Used in the driver
 #. when reporting fatal signal in the compiler.
@@ -1685,7 +1670,7 @@ msgstr "erreur interne du compilateur: "
 #. due to -Werror and -Werror=warning.
 #: diagnostic.def:35 diagnostic.def:47
 msgid "error: "
-msgstr "erreur: "
+msgstr "erreur : "
 
 #: diagnostic.def:36
 msgid "sorry, unimplemented: "
@@ -1697,15 +1682,15 @@ msgstr "attention : "
 
 #: diagnostic.def:38
 msgid "anachronism: "
-msgstr "anachronisme: "
+msgstr "anachronisme : "
 
 #: diagnostic.def:39
 msgid "note: "
-msgstr "note: "
+msgstr "note : "
 
 #: diagnostic.def:40
 msgid "debug: "
-msgstr "mise au point: "
+msgstr "débogage : "
 
 #. These two would be re-classified as DK_WARNING or DK_ERROR, so the
 #. prefix does not matter.
@@ -1716,10 +1701,8 @@ msgid "pedwarn: "
 msgstr "attention : "
 
 #: diagnostic.def:44
-#, fuzzy
-#| msgid "error: "
 msgid "permerror: "
-msgstr "erreur: "
+msgstr "permerreur : "
 
 #: params.def:44
 msgid "Maximal estimated outcome of branch considered predictable"
@@ -2232,7 +2215,7 @@ msgstr ""
 
 #: params.def:765
 msgid "The size of L1 cache"
-msgstr ""
+msgstr "La taille du cache L1"
 
 #: params.def:772
 msgid "The size of L1 cache line"
@@ -2240,7 +2223,7 @@ msgstr ""
 
 #: params.def:779
 msgid "The size of L2 cache"
-msgstr ""
+msgstr "La taille du cache L2"
 
 #: params.def:790
 msgid "Whether to use canonical types"
@@ -2504,7 +2487,7 @@ msgstr ""
 
 #: c-family/c-format.c:356
 msgid "format"
-msgstr ""
+msgstr "format"
 
 #: c-family/c-format.c:357
 #, fuzzy
@@ -3075,24 +3058,24 @@ msgstr "erreur internal du compilateur. Mode inconnu:"
 
 #: config/avr/avr.c:3426 config/avr/avr.c:4356 config/avr/avr.c:4805
 msgid "invalid insn:"
-msgstr "insn invalide:"
+msgstr "insn invalide :"
 
 #: config/avr/avr.c:3480 config/avr/avr.c:3585 config/avr/avr.c:3643
 #: config/avr/avr.c:3689 config/avr/avr.c:3708 config/avr/avr.c:3900
 #: config/avr/avr.c:4208 config/avr/avr.c:4492 config/avr/avr.c:4698
 #: config/avr/avr.c:4862 config/avr/avr.c:4956 config/avr/avr.c:5152
 msgid "incorrect insn:"
-msgstr "insn incorrect:"
+msgstr "insn incorrect :"
 
 #: config/avr/avr.c:3724 config/avr/avr.c:3999 config/avr/avr.c:4279
 #: config/avr/avr.c:4564 config/avr/avr.c:4744 config/avr/avr.c:5012
 #: config/avr/avr.c:5210
 msgid "unknown move insn:"
-msgstr "insn de déplacement inconnu:"
+msgstr "insn de déplacement inconnu :"
 
 #: config/avr/avr.c:5641
 msgid "bad shift insn:"
-msgstr "décalage insn erroné:"
+msgstr "décalage insn erroné :"
 
 #: config/avr/avr.c:5749 config/avr/avr.c:6230 config/avr/avr.c:6645
 msgid "internal compiler error.  Incorrect shift:"
@@ -3907,22 +3890,16 @@ msgid "invalid operand to %%S"
 msgstr "opérande invalide pour %%S"
 
 #: config/sh/sh.c:9957
-#, fuzzy
-#| msgid "created and used with different settings of -fpic"
 msgid "created and used with different architectures / ABIs"
-msgstr "créé et utilisé avec des configurations différentes de -fpic"
+msgstr "créé et utilisé avec des architectures / ABI différentes"
 
 #: config/sh/sh.c:9959
-#, fuzzy
-#| msgid "created and used with different settings of -fpic"
 msgid "created and used with different ABIs"
-msgstr "créé et utilisé avec des configurations différentes de -fpic"
+msgstr "créé et utilisé avec des ABI différentes"
 
 #: config/sh/sh.c:9961
-#, fuzzy
-#| msgid "created and used with different settings of -fpic"
 msgid "created and used with different endianness"
-msgstr "créé et utilisé avec des configurations différentes de -fpic"
+msgstr "créé et utilisé avec des boutismes différents"
 
 #: config/sparc/sparc.c:8834 config/sparc/sparc.c:8840
 #, c-format
@@ -4395,10 +4372,8 @@ msgid "(anonymous namespace)"
 msgstr "(espace de nom anonyme)"
 
 #: cp/error.c:1231
-#, fuzzy
-#| msgid "template argument required for `%s %T'"
 msgid "<template arguments error>"
-msgstr "<argument du patron>"
+msgstr "<erreur argument du patron>"
 
 #: cp/error.c:1252
 msgid "<enumerator>"
@@ -4409,10 +4384,8 @@ msgid "<declaration error>"
 msgstr "<erreur de déclaration>"
 
 #: cp/error.c:1793 cp/error.c:1813
-#, fuzzy
-#| msgid "template parameter `%#D'"
 msgid "<template parameter error>"
-msgstr "<patron de paramètre>"
+msgstr "<erreur de patron de paramètre>"
 
 #: cp/error.c:1943
 msgid "<statement>"
@@ -4558,7 +4531,7 @@ msgstr[1] "candidats sont :"
 #, fuzzy
 #| msgid "  overriding `%#D' (must be pointer or reference to class)"
 msgid "target is not pointer or reference to class"
-msgstr "  écrasant « %#D » (doit être un pointeur ou une référence vers un classe)"
+msgstr "doit être un pointeur ou une référence vers un classe"
 
 #: cp/rtti.c:562
 #, fuzzy
@@ -4591,10 +4564,8 @@ msgid "source is a pointer to incomplete type"
 msgstr "ne peut utiliser %s comme pointeur sur un type incomplet « %T »"
 
 #: cp/rtti.c:609
-#, fuzzy
-#| msgid "%T is not a class type"
 msgid "source is not of class type"
-msgstr "« %T » n'est pas un type de classe"
+msgstr "la source n'est pas de type classe"
 
 #: cp/rtti.c:614
 #, fuzzy
@@ -5965,10 +5936,9 @@ msgid "-fconvert=<big-endian|little-endian|native|swap> The endianness used for
 msgstr ""
 
 #: fortran/lang.opt:389
-#, fuzzy, c-format
-#| msgid "Unrecognized option `%s'"
+#, c-format
 msgid "Unrecognized option to endianess value: %qs"
-msgstr "Option non reconnue `%s'"
+msgstr "Option non reconnue pour la valeur de boutisme : %qs"
 
 #: fortran/lang.opt:405
 msgid "Use the Cray Pointer extension"
@@ -6423,7 +6393,7 @@ msgstr "Avertir à propos des transtypage qui écartent les qualificateurs"
 
 #: c-family/c.opt:332
 msgid "Warn about subscripts whose type is \"char\""
-msgstr "Avertir à propos des souscripts dont le type est \"char\""
+msgstr "Avertir à propos des sous-scripts dont le type est \"char\""
 
 #: c-family/c.opt:336
 msgid "Warn about memory access errors found by Pointer Bounds Checker"
@@ -6593,7 +6563,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Warn about variables which are initialized to themselves."
 msgid "Warn about variables which are initialized to themselves"
-msgstr "Avertir au sujet des variables qui sont initialisés par elles-même"
+msgstr "Avertir au sujet des variables qui sont initialisés par elles-mêmes"
 
 #: c-family/c.opt:488
 #, fuzzy
@@ -6809,7 +6779,7 @@ msgstr "Avertir à propos de la surcharge des noms de fonctions virtuelles"
 #, fuzzy
 #| msgid "Warn about variables which are initialized to themselves."
 msgid "Warn about overriding initializers without side effects"
-msgstr "Avertir au sujet des variables qui sont initialisés par elles-même"
+msgstr "Avertir au sujet des variables qui sont initialisés par elles-mêmes"
 
 #: c-family/c.opt:714
 #, fuzzy
@@ -6863,7 +6833,7 @@ msgstr "Avertir lorsque le compilateur réordonne le code"
 
 #: c-family/c.opt:762
 msgid "Warn whenever a function's return type defaults to \"int\" (C), or about inconsistent return types (C++)"
-msgstr "Avertir lorsque le type de fonction à retourner par défaut est \"int\" (C) ou à propos d'un type inconsisten à retourner (C++)"
+msgstr "Avertir lorsque le type de fonction à retourner par défaut est \"int\" (C) ou à propos d'un type inconsistent à retourner (C++)"
 
 #: c-family/c.opt:766
 msgid "Warn if a selector has multiple methods"
@@ -7038,7 +7008,7 @@ msgstr ""
 #: c-family/c.opt:945 c-family/c.opt:1170 c-family/c.opt:1445
 #: c-family/c.opt:1449 c-family/c.opt:1465
 msgid "No longer supported"
-msgstr "Prise en charge suprimée"
+msgstr "Prise en charge supprimée"
 
 #: c-family/c.opt:949
 msgid "Recognize the \"asm\" keyword"
@@ -7291,7 +7261,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "unrecognized register name \"%s\""
 msgid "unrecognized ivar visibility value %qs"
-msgstr "nom de registre non reconnue \"%s\""
+msgstr "nom de registre non reconnue %qs"
 
 #: c-family/c.opt:1257
 msgid "Treat a throw() exception specification as noexcept to improve code size"
@@ -7717,7 +7687,7 @@ msgstr ""
 #, fuzzy
 #| msgid "-fdump-<type>\tDump various compiler internals to a file"
 msgid "-fgo-dump-<type>\tDump Go frontend internal information"
-msgstr "--fgo-dump-<type>\tVidander les divers internes du compilateur dans un fichier"
+msgstr "--fgo-dump-<type>\tVidanger les divers internes du compilateur dans un fichier"
 
 #: go/lang.opt:54
 msgid "-fgo-optimize-<type>\tTurn on optimization passes in the frontend"
@@ -8826,7 +8796,7 @@ msgstr "Cible a un I&D séparé"
 
 #: config/pdp11/pdp11.opt:87
 msgid "Use UNIX assembler syntax"
-msgstr "Uitliser la syntaxe de l'assembleur UNIX"
+msgstr "Utiliser la syntaxe de l'assembleur UNIX"
 
 #: config/xtensa/xtensa.opt:23
 msgid "Use CONST16 instruction to load constants"
@@ -9512,7 +9482,7 @@ msgstr "Supporte les fonctions internes MMX et SSE et la génération de code"
 #, fuzzy
 #| msgid "Call mcount for profiling after a function prologue"
 msgid "Emit profiling counter call at function entry before prologue."
-msgstr "Ne pas appeller mcount pour le profilage avant le prologue de la fonction"
+msgstr "Ne pas appeler mcount pour le profilage avant le prologue de la fonction"
 
 #: config/i386/i386.opt:831
 msgid "Generate __mcount_loc section with all mcount or __fentry__ calls."
@@ -9681,7 +9651,7 @@ msgstr "Ne pas utiliser l'instruction callt"
 
 #: config/v850/v850.opt:45
 msgid "Reuse r30 on a per function basis"
-msgstr "Ré-utiliser R30 sur une base par fonction"
+msgstr "Réutiliser R30 sur une base par fonction"
 
 #: config/v850/v850.opt:52
 msgid "Prohibit PC relative function calls"
@@ -12410,7 +12380,7 @@ msgstr "Aucun défaut pour crt0.o"
 
 #: config/iq2000/iq2000.opt:74 config/mips/mips.opt:397
 msgid "Put uninitialized constants in ROM (needs -membedded-data)"
-msgstr "Placer les constantes non itialisées dans le ROM (a besoin de -membedded-data)"
+msgstr "Placer les constantes non initialisées dans le ROM (a besoin de -membedded-data)"
 
 #: config/c6x/c6x-tables.opt:24
 msgid "Known C6X ISAs (for use with the -march= option):"
@@ -12478,7 +12448,7 @@ msgstr "Ne pas aligner les items dans le code ou les données"
 
 #: config/cris/cris.opt:142
 msgid "Do not emit function prologue or epilogue"
-msgstr "Ne pas générer de prologue ou d'épilogue de fonction"
+msgstr "Ne pas générer de prologue ou d’épilogue de fonction"
 
 #: config/cris/cris.opt:149
 msgid "Use the most feature-enabling options allowed by other options"
@@ -12795,7 +12765,7 @@ msgstr "Générer du code pour un système à octets de poids faible"
 #, fuzzy
 #| msgid "PIC register `%s' clobbered in `asm'"
 msgid "Mark MAC register as call-clobbered"
-msgstr "registre PIC « %s » est maltraité dans «asm »"
+msgstr "registre PIC « %s » est maltraité"
 
 #: config/sh/sh.opt:311
 msgid "Make structs a multiple of 4 bytes (warning: ABI altered)"
@@ -12809,7 +12779,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Assume floating-point operations can trap"
 msgid "Assume pt* instructions won't trap"
-msgstr "On assume que les opérations en virgule flottante peuvent être attrappées"
+msgstr "On assume que les opérations en virgule flottante peuvent être attrapées"
 
 #: config/sh/sh.opt:323
 msgid "Shorten address references during linking"
@@ -13755,7 +13725,7 @@ msgstr ""
 
 #: java/lang.opt:202
 msgid "--encoding=<encoding>\tChoose input encoding (defaults from your locale)"
-msgstr "--encoding=<encodage>\tchoisir l'encodade d'entrée (par défaut provient de la locale)"
+msgstr "--encoding=<encodage>\tchoisir l'encodage d'entrée (par défaut provient de la locale)"
 
 #: java/lang.opt:206
 msgid "--extdirs=<path>\tSet the extension directory path"
@@ -13789,7 +13759,7 @@ msgstr "Présumer que les fonctions natives sont implantées et qu'elles utilise
 
 #: java/lang.opt:246
 msgid "Enable optimization of static class initialization code"
-msgstr "Autorisser l'optimisation du code d'initialisation de classe statique"
+msgstr "Autoriser l'optimisation du code d'initialisation de classe statique"
 
 #: java/lang.opt:253
 msgid "Reduce the amount of reflection meta-data generated"
@@ -13797,7 +13767,7 @@ msgstr ""
 
 #: java/lang.opt:257
 msgid "Enable assignability checks for stores into object arrays"
-msgstr "Autoriser la vérificaitions des affectations dans le stockage des tableaux d'objets"
+msgstr "Autoriser la vérifications des affectations dans le stockage des tableaux d'objets"
 
 #: java/lang.opt:261
 msgid "Generate code for the Boehm GC"
@@ -13859,7 +13829,7 @@ msgstr "Alias pour --help=target"
 
 #: common.opt:429
 msgid "--param <param>=<value>\tSet parameter <param> to value.  See below for a complete list of parameters"
-msgstr "--param <paramètre>=<valeur>\tinitialiser le <paramètre> avec la valeur.  Voir ci-bas pour la liste complète des paramètres"
+msgstr "--param <paramètre>=<valeur>\tinitialiser le <paramètre> avec la valeur.  Voir ci-dessous pour la liste complète des paramètres"
 
 #: common.opt:457
 msgid "-O<number>\tSet optimization level to <number>"
@@ -14271,7 +14241,7 @@ msgstr ""
 
 #: common.opt:1014
 msgid "Perform a register copy-propagation optimization pass"
-msgstr "Effectuer la passe d'optimisation de la propagation-de-copie par registre"
+msgstr "Effectuer la passe d'optimisation de la propagation de copie par registre"
 
 #: common.opt:1018
 msgid "Perform cross-jumping optimization"
@@ -14365,7 +14335,7 @@ msgstr ""
 
 #: common.opt:1145
 msgid "-fdump-<type>\tDump various compiler internals to a file"
-msgstr "-fdump-<type>\tvidander les divers internes du compilateur dans un fichier"
+msgstr "-fdump-<type>\tvidanger les divers internes du compilateur dans un fichier"
 
 #: common.opt:1152
 msgid "-fdump-final-insns=filename\tDump to filename the insns at the end of translation"
@@ -14451,7 +14421,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "unknown string token %s\n"
 msgid "unknown excess precision style %qs"
-msgstr "élément lexical %s inconnu\n"
+msgstr "élément lexical %qs inconnu"
 
 #: common.opt:1233
 msgid "Output lto objects containing both the intermediate language and binary output."
@@ -14475,7 +14445,7 @@ msgstr "Contrôle l'ordre d'allocation des registres entier"
 #, fuzzy
 #| msgid "Perform a register copy-propagation optimization pass"
 msgid "Perform a forward propagation pass on RTL"
-msgstr "Effectuer la passe d'optimisation de la propagation-de-copie par registre"
+msgstr "Effectuer la passe d'optimisation de la propagation de copie par registre"
 
 #: common.opt:1257
 msgid "-ffp-contract=[off|on|fast] Perform floating-point expression contraction."
@@ -14583,7 +14553,7 @@ msgstr "Traiter les directive #ident"
 
 #: common.opt:1373
 msgid "Perform conversion of conditional jumps to branchless equivalents"
-msgstr "Exécuter la conversion des sauts conditionels à des équivalents sans branchements"
+msgstr "Exécuter la conversion des sauts conditionnels à des équivalents sans branchements"
 
 #: common.opt:1377
 msgid "Perform conversion of conditional jumps to conditional execution"
@@ -14602,7 +14572,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Perform conversion of conditional jumps to branchless equivalents"
 msgid "Convert conditional jumps in innermost loops to branchless equivalents"
-msgstr "Exécuter la conversion des sauts conditionels à des équivalents sans branchements"
+msgstr "Exécuter la conversion des sauts conditionnels à des équivalents sans branchements"
 
 #: common.opt:1401
 msgid "Also if-convert conditional jumps containing memory writes"
@@ -14713,20 +14683,18 @@ msgid "-fira-algorithm=[CB|priority] Set the used IRA algorithm"
 msgstr ""
 
 #: common.opt:1509
-#, fuzzy, c-format
-#| msgid "unknown register name: %s"
+#, c-format
 msgid "unknown IRA algorithm %qs"
-msgstr "nom de registre inconnu: %s"
+msgstr "algorithme IRA inconnu %qs"
 
 #: common.opt:1519
 msgid "-fira-region=[one|all|mixed] Set regions for IRA"
 msgstr ""
 
 #: common.opt:1522
-#, fuzzy, c-format
-#| msgid "unknown register name: %s"
+#, c-format
 msgid "unknown IRA region %qs"
-msgstr "nom de registre inconnu: %s"
+msgstr "région IRA inconnue %qs"
 
 #: common.opt:1535 common.opt:1540
 msgid "Use IRA based register pressure calculation"
@@ -14736,7 +14704,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Store locals in argument registers"
 msgid "Share slots for saving different hard registers."
-msgstr "Stocker les var. locales dans redistres d'arguments"
+msgstr "Stocker les var. locales dans registres d'arguments"
 
 #: common.opt:1549
 msgid "Share stack slots for spilled pseudo-registers."
@@ -14773,10 +14741,8 @@ msgid "Do CFG-sensitive rematerialization in LRA"
 msgstr ""
 
 #: common.opt:1585
-#, fuzzy
-#| msgid "Enable linker optimizations"
 msgid "Enable link-time optimization."
-msgstr "Activer les optimisations par l'éditeur de liens"
+msgstr "Activer les optimisations durant l'édition de liens."
 
 #: common.opt:1589
 msgid "Link-time optimization with number of parallel jobs or jobserver."
@@ -14786,7 +14752,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "unknown machine mode `%s'"
 msgid "unknown LTO partitioning model %qs"
-msgstr "mode machine « %s » inconnu"
+msgstr "mode machine %qs inconnu"
 
 #: common.opt:1611
 msgid "Specify the algorithm to partition symbols and vars at linktime"
@@ -14844,7 +14810,7 @@ msgstr "Tentative de fusion de constantes identiques à travers des unités de c
 
 #: common.opt:1663
 msgid "-fmessage-length=<number>\tLimit diagnostics to <number> characters per line.  0 suppresses line-wrapping"
-msgstr "-fmessage-length=<nombre>\tlimiter la longueur des diagnotiques à <nombre> de caractères par ligne.  0 supprime l'enroulement de ligne"
+msgstr "-fmessage-length=<nombre>\tLimiter la longueur des diagnostiques à <nombre> de caractères par ligne.  0 supprime l'enroulement de ligne"
 
 #: common.opt:1667
 msgid "Perform SMS based modulo scheduling before the first scheduling pass"
@@ -14881,10 +14847,9 @@ msgid "Support synchronous non-call exceptions"
 msgstr "Supporter les exceptions synchrones des non appels"
 
 #: common.opt:1694
-#, fuzzy, c-format
-#| msgid "target missing after %s"
+#, c-format
 msgid "options or targets missing after %qs"
-msgstr "cible manquante après %s"
+msgstr "options ou cibles manquantes après %qs"
 
 #: common.opt:1695
 msgid "-foffload=<targets>=<options>  Specify offloading targets and options for them"
@@ -14898,7 +14863,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "unknown tls-model \"%s\""
 msgid "unknown offload ABI %qs"
-msgstr "tls-model  \"%s\" inconnu"
+msgstr "tls-model %qs inconnu"
 
 #: common.opt:1712
 msgid "When possible do not generate stack frames"
@@ -15044,13 +15009,11 @@ msgstr ""
 #, fuzzy
 #| msgid "Reorder functions to improve code placement"
 msgid "Enable function reordering that improves code placement"
-msgstr "Ré-ordonner les fonctions pour améliorer l'emplacement de code"
+msgstr "Réordonner les fonctions pour améliorer l'emplacement de code"
 
 #: common.opt:1848
-#, fuzzy
-#| msgid "-frandom-seed=<string>\tMake compile reproducible using <string>"
 msgid "-frandom-seed=<number>\tMake compile reproducible using <number>"
-msgstr "-frandom-seed=<chaîne>\tfaire une compilation reproduisible en utilisant <chaîne>"
+msgstr "-frandom-seed=<nombre>\tfaire une compilation reproductible en utilisant <nombre>"
 
 #: common.opt:1858
 msgid "Record gcc command line switches in the object file."
@@ -15080,17 +15043,17 @@ msgstr "Effectuer une changement de nom de registres après une passe d'optimisa
 
 #: common.opt:1887
 msgid "Reorder basic blocks to improve code placement"
-msgstr "Ré-ordonner les blocs de base pour améliorer l'emplacement de code"
+msgstr "Réordonner les blocs de base pour améliorer l'emplacement de code"
 
 #: common.opt:1891
 #, fuzzy
 #| msgid "Reorder basic blocks to improve code placement"
 msgid "Reorder basic blocks and partition into hot and cold sections"
-msgstr "Ré-ordonner les blocs de base pour améliorer l'emplacement de code"
+msgstr "Réordonner les blocs de base pour améliorer l'emplacement de code"
 
 #: common.opt:1895
 msgid "Reorder functions to improve code placement"
-msgstr "Ré-ordonner les fonctions pour améliorer l'emplacement de code"
+msgstr "Réordonner les fonctions pour améliorer l'emplacement de code"
 
 #: common.opt:1899
 msgid "Add a common subexpression elimination pass after loop optimizations"
@@ -15122,7 +15085,7 @@ msgstr "Autoriser le mouvement spéculatif de plusieurs chargements"
 
 #: common.opt:1931
 msgid "-fsched-verbose=<number>\tSet the verbosity level of the scheduler"
-msgstr "-fsched-verbose=<numéro>\tnitialiser le niveau de verbosité de l'ordonnanceur"
+msgstr "-fsched-verbose=<numéro>\tinitialiser le niveau de verbosité de l'ordonnanceur"
 
 #: common.opt:1935
 msgid "If scheduling post reload, do superblock scheduling"
@@ -15165,20 +15128,16 @@ msgid "Allow premature scheduling of queued insns"
 msgstr "Autoriser l'ordonnancement prématuré de queues insns"
 
 #: common.opt:1984
-#, fuzzy
-#| msgid "-fsched-stalled-insns=<number>       Set number of queued insns that can be prematurely scheduled"
 msgid "-fsched-stalled-insns=<number>\tSet number of queued insns that can be prematurely scheduled"
-msgstr "-fsched-stalled-insns=<nombre>       fixer le nombre d'insns en queu qui peuvent être prématurément ordonnancés"
+msgstr "-fsched-stalled-insns=<nombre>\tFixer le nombre d'insns en queue qui peuvent être prématurément ordonnancés"
 
 #: common.opt:1992
 msgid "Set dependence distance checking in premature scheduling of queued insns"
 msgstr "Fixer la distance de vérification de dépendance dans l'ordonnancement prématuré d'insns en queue"
 
 #: common.opt:1996
-#, fuzzy
-#| msgid "-fsched-stalled-insns-dep=<number>   Set dependence distance checking in premature scheduling of queued insns"
 msgid "-fsched-stalled-insns-dep=<number>\tSet dependence distance checking in premature scheduling of queued insns"
-msgstr "-fsched-stalled-insns-dep=<nombre>   fixer la distance de vérification de dépendance dans l'ordonnancement d'insnsn en queue"
+msgstr "-fsched-stalled-insns-dep=<nombre>\tFixer la distance de vérification de dépendance dans l'ordonnancement d'insnsn en queue"
 
 #: common.opt:2000
 msgid "Enable the group heuristic in the scheduler"
@@ -15264,13 +15223,13 @@ msgstr ""
 #, fuzzy
 #| msgid "Insert stack checking code into the program"
 msgid "-fstack-check=[no|generic|specific]\tInsert stack checking code into the program"
-msgstr "Insérer du code de vérificaion de la pile dans le programme"
+msgstr "Insérer du code de vérification de la pile dans le programme"
 
 #: common.opt:2089
 #, fuzzy
 #| msgid "Insert stack checking code into the program"
 msgid "Insert stack checking code into the program.  Same as -fstack-check=specific"
-msgstr "Insérer du code de vérificaion de la pile dans le programme"
+msgstr "Insérer du code de vérification de la pile dans le programme"
 
 #: common.opt:2096
 msgid "-fstack-limit-register=<register>\tTrap if the stack goes past <register>"
@@ -15300,7 +15259,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Reuse r30 on a per function basis"
 msgid "Output stack usage information on a per-function basis"
-msgstr "Ré-utiliser R30 sur une base par fonction"
+msgstr "Réutiliser R30 sur une base par fonction"
 
 #: common.opt:2132
 msgid "Assume strict aliasing rules apply"
@@ -15337,10 +15296,9 @@ msgid "-ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]\tSet t
 msgstr "-ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]\tinitialiser le modèle de génération de code par défaut de thread local"
 
 #: common.opt:2163
-#, fuzzy, c-format
-#| msgid "unknown tls-model \"%s\""
+#, c-format
 msgid "unknown TLS model %qs"
-msgstr "tls-model  \"%s\" inconnu"
+msgstr "modèle TLS %qs inconnu"
 
 #: common.opt:2179
 msgid "Reorder top level functions, variables, and asms"
@@ -15352,23 +15310,19 @@ msgstr "Exécuter la formation du super bloc via la duplication de la queue"
 
 #: common.opt:2190
 msgid "Assume floating-point operations can trap"
-msgstr "On assume que les opérations en virgule flottante peuvent être attrappées"
+msgstr "On assume que les opérations en virgule flottante peuvent être attrapées"
 
 #: common.opt:2194
 msgid "Trap for signed overflow in addition, subtraction and multiplication"
-msgstr "Attrapper les débordements de signe dans l'addition, la soustraction et la multiplication"
+msgstr "Attraper les débordements de signe dans l'addition, la soustraction et la multiplication"
 
 #: common.opt:2198
-#, fuzzy
-#| msgid "Enable SSA optimizations"
 msgid "Enable SSA-CCP optimization on trees"
-msgstr "Autoriser les optimisations SSA"
+msgstr "Activer les optimisations SSA-CCP sur les arbres"
 
 #: common.opt:2202
-#, fuzzy
-#| msgid "Enable SSA optimizations"
 msgid "Enable SSA-BIT-CCP optimization on trees"
-msgstr "Autoriser les optimisations SSA"
+msgstr "Activer les optimisations SSA-BIT-CCP sur les arbres"
 
 #: common.opt:2210
 msgid "Enable loop header copying on trees"
@@ -15388,7 +15342,7 @@ msgstr ""
 
 #: common.opt:2226
 msgid "Enable copy propagation on trees"
-msgstr ""
+msgstr "Activer la propagation de copie sur les arbres"
 
 #: common.opt:2234
 #, fuzzy
@@ -15538,7 +15492,7 @@ msgstr ""
 #, fuzzy
 #| msgid "Perform a register copy-propagation optimization pass"
 msgid "Perform Value Range Propagation on trees"
-msgstr "Effectuer la passe d'optimisation de la propagation-de-copie par registre"
+msgstr "Effectuer la passe d'optimisation de la propagation de copie par registre"
 
 #: common.opt:2359
 msgid "Compile whole compilation unit at a time"
@@ -15546,7 +15500,7 @@ msgstr "Compiler complètement à la fois une unité de compilation"
 
 #: common.opt:2363
 msgid "Perform loop unrolling when iteration count is known"
-msgstr "Exécuter un dé-roulement des boucles lorsque le compteur d'itération est connu"
+msgstr "Exécuter un déroulement des boucles lorsque le compteur d'itération est connu"
 
 #: common.opt:2367
 msgid "Perform loop unrolling for all loops"
@@ -15660,7 +15614,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "unrecognized register name \"%s\""
 msgid "unrecognized visibility value %qs"
-msgstr "nom de registre non reconnue \"%s\""
+msgstr "nom de registre non reconnue %qs"
 
 #: common.opt:2526
 msgid "Validate vtable pointers before using them."
@@ -15670,7 +15624,7 @@ msgstr ""
 #, fuzzy, c-format
 #| msgid "(near initialization for `%s')"
 msgid "unknown vtable verify initialization priority %qs"
-msgstr "(près de l'initialisation de « %s »)"
+msgstr "près de l'initialisation de %qs"
 
 #: common.opt:2542
 msgid "Output vtable verification counters."
@@ -15870,16 +15824,13 @@ msgstr ""
 
 #: go/gofrontend/expressions.cc:93 c-family/c-common.c:1910 cp/cvt.c:1182
 #: cp/cvt.c:1430
-#, fuzzy, gcc-internal-format
-#| msgid "%Hvalue computed is not used"
+#, gcc-internal-format
 msgid "value computed is not used"
-msgstr "%Hvaleur calculée n'est pas utilisée"
+msgstr "valeur calculée n'est pas utilisée"
 
 #: go/gofrontend/expressions.cc:628
-#, fuzzy
-#| msgid "invalid use of %D"
 msgid "invalid use of type"
-msgstr "utilisation invalide de %D"
+msgstr "utilisation invalide du type"
 
 #: go/gofrontend/expressions.cc:2725 go/gofrontend/expressions.cc:2791
 #: go/gofrontend/expressions.cc:2807
@@ -15887,10 +15838,8 @@ msgid "constant refers to itself"
 msgstr ""
 
 #: go/gofrontend/expressions.cc:3704 go/gofrontend/expressions.cc:4082
-#, fuzzy
-#| msgid "unexpected operand"
 msgid "expected pointer"
-msgstr "opérande inattendue"
+msgstr "pointeur attendu"
 
 #: go/gofrontend/expressions.cc:4049
 #, fuzzy
@@ -16164,7 +16113,7 @@ msgstr ""
 #, fuzzy
 #| msgid "%s is not addressable"
 msgid "slice of unaddressable value"
-msgstr "%s n'est pas adressable"
+msgstr "%s n'est pas addressable"
 
 #: go/gofrontend/expressions.cc:10741
 #, fuzzy
@@ -16402,16 +16351,14 @@ msgid "type has no methods"
 msgstr "erreur lors de l'analyse syntaxique des méthodes"
 
 #: go/gofrontend/types.cc:7495
-#, fuzzy, c-format
-#| msgid "ambiguous abbreviation %s"
+#, c-format
 msgid "ambiguous method %s%s%s"
-msgstr "abréviation %s est ambiguë"
+msgstr "méthode ambiguë %s%s%s"
 
 #: go/gofrontend/types.cc:7498
-#, fuzzy, c-format
-#| msgid "missing argument to \"%s\""
+#, c-format
 msgid "missing method %s%s%s"
-msgstr "argument manquant à \"%s\""
+msgstr "méthode manquante %s%s%s"
 
 #: go/gofrontend/types.cc:7539
 #, c-format
@@ -16426,31 +16373,27 @@ msgstr ""
 #. Warn about and ignore all others for now, but store them.
 #: attribs.c:455 c-family/c-common.c:8544 objc/objc-act.c:4985
 #: objc/objc-act.c:6954 objc/objc-act.c:8143 objc/objc-act.c:8194
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute directive ignored"
+#, gcc-internal-format
 msgid "%qE attribute directive ignored"
-msgstr "attribut de directive « %s » ignoré"
+msgstr "attribut de directive %qE ignoré"
 
 #: attribs.c:459
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute directive ignored"
+#, gcc-internal-format
 msgid "%<%E::%E%> scoped attribute directive ignored"
-msgstr "attribut de directive « %s » ignoré"
+msgstr ""
 
 #: attribs.c:468
-#, fuzzy, gcc-internal-format
-#| msgid "wrong number of arguments specified for `%s' attribute"
+#, gcc-internal-format
 msgid "wrong number of arguments specified for %qE attribute"
-msgstr "nombre erroné d'arguments spécifié pour l'attribut « %s »"
+msgstr "nombre erroné d'arguments spécifié pour l'attribut %qE"
 
 #. This is a c++11 attribute that appertains to a
 #. type-specifier, outside of the definition of, a class
 #. type.  Ignore it.
 #: attribs.c:481
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute ignored"
+#, gcc-internal-format
 msgid "attribute ignored"
-msgstr "attribut « %s » ignoré"
+msgstr "attribut ignoré"
 
 #: attribs.c:483
 #, gcc-internal-format
@@ -16458,16 +16401,14 @@ msgid "an attribute that appertains to a type-specifier is ignored"
 msgstr ""
 
 #: attribs.c:500
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute does not apply to types"
+#, gcc-internal-format
 msgid "%qE attribute does not apply to types"
-msgstr "l'attribut « %s » ne s'applique pas aux types"
+msgstr "l'attribut %qE ne s'applique pas aux types"
 
 #: attribs.c:548
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute only applies to function types"
+#, gcc-internal-format
 msgid "%qE attribute only applies to function types"
-msgstr "l'attribut « %s » ne s'applique qu'à des types de fonction"
+msgstr "l'attribut %qE ne s'applique qu'à des types de fonction"
 
 #: attribs.c:558
 #, fuzzy, gcc-internal-format
@@ -16481,16 +16422,15 @@ msgid "Offset exceeds 16 bytes."
 msgstr ""
 
 #: auto-profile.c:859
-#, fuzzy, gcc-internal-format
-#| msgid "';' expected"
+#, gcc-internal-format
 msgid "Not expected TAG."
-msgstr "«;» attendu"
+msgstr "TAG inattendu."
 
 #: auto-profile.c:924
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "Could not open source file %s.\n"
 msgid "Cannot open profile file %s."
-msgstr "N'a pu ouvrir le fichier source %s.\n"
+msgstr "N'a pu ouvrir le fichier source %s."
 
 #: auto-profile.c:927
 #, gcc-internal-format
@@ -16511,13 +16451,13 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "cannot find file for class %s"
 msgid "Cannot read function profile from %s."
-msgstr "ne peut repérer le fichier pour la classe %s."
+msgstr "Ne peut repérer le fichier pour la classe %s."
 
 #: auto-profile.c:953
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "%s: cannot get working directory: %s\n"
 msgid "Cannot read working set from %s."
-msgstr "%s: ne peut repérer le répertoire de travail: %s\n"
+msgstr "Ne peut repérer le répertoire de travail %s."
 
 #: bt-load.c:1593
 #, gcc-internal-format
@@ -16593,7 +16533,7 @@ msgstr "l'argument de « __builtin_eh_return_regno » doit être une constante"
 #, fuzzy, gcc-internal-format
 #| msgid "initializer specified for non-member function `%D'"
 msgid "trampoline generated for nested function %qD"
-msgstr "initialisation spécifiée pour une fonction « %D » n'étant pas membre"
+msgstr "initialisation spécifiée pour une fonction %qD n'étant pas membre"
 
 #: builtins.c:5248 builtins.c:5261
 #, gcc-internal-format
@@ -16609,7 +16549,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "invalid type `%T' for default argument to `%T'"
 msgid "invalid memory model argument to builtin"
-msgstr "type invalide « %T » pour l'argument par défaut « %T »"
+msgstr "type invalide pour l'argument par défaut"
 
 #: builtins.c:5431
 #, gcc-internal-format
@@ -16763,58 +16703,51 @@ msgstr "l'appel de fonction a une valeur d'agrégat"
 #, fuzzy, gcc-internal-format
 #| msgid "Pass all arguments on stack"
 msgid "passing too large argument on stack"
-msgstr "PAsser tous les arguments par la pile"
+msgstr "Passer tous les arguments par la pile"
 
 #: cfgexpand.c:1376 function.c:1002 varasm.c:2163
-#, fuzzy, gcc-internal-format
-#| msgid "%Jsize of variable '%D' is too large"
+#, gcc-internal-format
 msgid "size of variable %q+D is too large"
-msgstr "taille de la variable « %D » est trop grande"
+msgstr "taille de la variable %q+D est trop grande"
 
 #: cfgexpand.c:2452
-#, fuzzy, gcc-internal-format
-#| msgid "too many alternatives in `asm'"
+#, gcc-internal-format
 msgid "too many alternatives in %<asm%>"
-msgstr "trop d'alternatives dans « asm »"
+msgstr "trop d'alternatives dans %<asm%>"
 
 #: cfgexpand.c:2464
 #, fuzzy, gcc-internal-format
 #| msgid "operand constraints for `asm' differ in number of alternatives"
 msgid "operand constraints for %<asm%> differ in number of alternatives"
-msgstr "contraintes de l'opérande pour « asm » diffèrent en nombre d'alternatives"
+msgstr "contraintes de l'opérande pour %<asm%> diffèrent en nombre d'alternatives"
 
 #: cfgexpand.c:2492
-#, fuzzy, gcc-internal-format
-#| msgid "asm-specifier for variable `%s' conflicts with asm clobber list"
+#, gcc-internal-format
 msgid "asm-specifier for variable %qE conflicts with asm clobber list"
-msgstr "asm-specifier pour la variable « %s » est en conflit avec la liste asm clobber"
+msgstr "asm-specifier pour la variable %qE est en conflit avec la liste asm clobber"
 
 #: cfgexpand.c:2589
-#, fuzzy, gcc-internal-format
-#| msgid "unknown register name `%s' in `asm'"
+#, gcc-internal-format
 msgid "unknown register name %qs in %<asm%>"
-msgstr "nom de registre inconnu « %s » dans «asm »"
+msgstr "nom de registre %qs inconnu dans %<asm%>"
 
 #: cfgexpand.c:2603
-#, fuzzy, gcc-internal-format
-#| msgid "PIC register `%s' clobbered in `asm'"
+#, gcc-internal-format
 msgid "PIC register clobbered by %qs in %<asm%>"
-msgstr "registre PIC « %s » est maltraité dans «asm »"
+msgstr "registre PIC %qs est maltraité dans %<asm%>"
 
 #: cfgexpand.c:2651
-#, fuzzy, gcc-internal-format
-#| msgid "more than %d operands in `asm'"
+#, gcc-internal-format
 msgid "more than %d operands in %<asm%>"
-msgstr "plus que %d opérandes dans « asm »"
+msgstr "plus que %d opérandes dans %<asm%>"
 
 #: cfgexpand.c:2719
 #, gcc-internal-format, gfc-internal-format
 msgid "output number %d not directly addressable"
-msgstr "nombre de sortie %d n,est pas directement adressable"
+msgstr "nombre de sortie %d n,est pas directement addressable"
 
 #: cfgexpand.c:2805
-#, fuzzy, gcc-internal-format
-#| msgid "asm operand %d probably doesn't match constraints"
+#, gcc-internal-format
 msgid "asm operand %d probably doesn%'t match constraints"
 msgstr "opérande asm %d ne concorde pas probablement avec les contraintes"
 
@@ -16849,45 +16782,46 @@ msgid "prev_bb of %d should be %d, not %d"
 msgstr "prev_bb de %d devrait être %d, pas %d"
 
 #: cfghooks.c:154
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
+#| msgid "verify_flow_info: Basic block %d succ edge is corrupted"
 msgid "verify_flow_info: Block %i has loop_father, but there are no loops"
-msgstr ""
+msgstr "verify_flow_info : le bloc %i manque d’un loop_father"
 
 #: cfghooks.c:160
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "verify_flow_info: Basic block %d succ edge is corrupted"
 msgid "verify_flow_info: Block %i lacks loop_father"
-msgstr "verify_flow_info: l'arrête succ du bloc de base %d est corrompue"
+msgstr "verify_flow_info : le bloc %i manque d’un loop_father"
 
 #: cfghooks.c:166
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Wrong count of block %i %i"
-msgstr "verify_flow_info: Nombre de blocs erroné %i %i"
+msgstr "verify_flow_info : Nombre de blocs erroné %i %i"
 
 #: cfghooks.c:172
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Wrong frequency of block %i %i"
-msgstr "verify_flow_info: Fréquence de blocs erronée %i %i"
+msgstr "verify_flow_info : Fréquence de blocs erronée %i %i"
 
 #: cfghooks.c:180
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Duplicate edge %i->%i"
-msgstr "verify_flow_info: arrête dupliquée %i->%i"
+msgstr "verify_flow_info : arrête dupliquée %i->%i"
 
 #: cfghooks.c:186
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Wrong probability of edge %i->%i %i"
-msgstr "verify_flow_info: probabilité de l'arrête %i->%i %i erronée"
+msgstr "verify_flow_info : probabilité de l'arrête %i->%i %i erronée"
 
 #: cfghooks.c:192
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Wrong count of edge %i->%i %i"
-msgstr "verify_flow_info: Mauvais nombre d'arrête %i->%i %i"
+msgstr "verify_flow_info : Mauvais nombre d'arrête %i->%i %i"
 
 #: cfghooks.c:204
 #, gcc-internal-format, gfc-internal-format
 msgid "verify_flow_info: Basic block %d succ edge is corrupted"
-msgstr "verify_flow_info: l'arrête succ du bloc de base %d est corrompue"
+msgstr "verify_flow_info : l'arrête succ du bloc de base %d est corrompue"
 
 #: cfghooks.c:218
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -17499,7 +17433,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "range mode has non-constant limits"
 msgid "cgraph_node has wrong clone list"
-msgstr "mode d'étendue a des limites non contantes"
+msgstr "mode d'étendue a des limites non constantes"
 
 #: cgraph.c:2933
 #, gcc-internal-format
@@ -17560,7 +17494,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "cannot declare references to references"
 msgid "Wrong node is referenced with chkp reference"
-msgstr "ne peut décalrer des références vers des références"
+msgstr "ne peut déclarer des références vers des références"
 
 #: cgraph.c:3032
 #, gcc-internal-format
@@ -17693,7 +17627,7 @@ msgstr "Déclaration invalide"
 #, fuzzy, gcc-internal-format
 #| msgid "field `%s' declared as a function"
 msgid "failed to reclaim unneeded function"
-msgstr "champ « %s » déclaré comme une fonction"
+msgstr "champ déclaré comme une fonction"
 
 #: cgraphunit.c:1329
 #, gcc-internal-format
@@ -17970,10 +17904,9 @@ msgid "cannot merge separate %s counters for function %u"
 msgstr "ne peut faire la fusion séparée des compteurs %s pour la fonction %u"
 
 #: coverage.c:370
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' has overflowed"
+#, gcc-internal-format
 msgid "%qs has overflowed"
-msgstr "« %s » a déborbé"
+msgstr "%qs a débordé"
 
 #: coverage.c:428
 #, gcc-internal-format
@@ -17997,10 +17930,9 @@ msgid "source locations for function %qE have changed, the profile data may be o
 msgstr ""
 
 #: coverage.c:719
-#, fuzzy, gcc-internal-format
-#| msgid "error writing `%s'"
+#, gcc-internal-format
 msgid "error writing %qs"
-msgstr "erreur d'écriture dans %s"
+msgstr "erreur d'écriture dans %qs"
 
 #: coverage.c:1256
 #, gcc-internal-format, gfc-internal-format
@@ -18039,9 +17971,9 @@ msgstr ""
 
 #: dbgcnt.c:135
 #, fuzzy, gcc-internal-format, gfc-internal-format
-#| msgid "        `%D'"
+#| msgid "        %s"
 msgid "          %s"
-msgstr "        « %D »"
+msgstr "        %s"
 
 #: dbxout.c:3346
 #, gcc-internal-format
@@ -18288,7 +18220,7 @@ msgstr "comparaison est toujours %d"
 #, fuzzy, gcc-internal-format
 #| msgid "`or' of unmatched not-equal tests is always 1"
 msgid "%<or%> of unmatched not-equal tests is always 1"
-msgstr "« or » de tests non pairé de non égalité est troujours 1"
+msgstr "« or » de tests non pairé de non égalité est toujours 1"
 
 #: fold-const.c:5778
 #, fuzzy, gcc-internal-format
@@ -18375,7 +18307,7 @@ msgstr "specs de la spécification %s n'a pas été trouvé pour être renommer"
 #, fuzzy, gcc-internal-format
 #| msgid "%s: attempt to rename spec '%s' to already defined spec '%s'"
 msgid "%s: attempt to rename spec %qs to already defined spec %qs"
-msgstr "%s: tentative pour renommner la spécification « %s » à un spécification « %s » déjà définie"
+msgstr "%s: tentative pour renommer la spécification « %s » à un spécification « %s » déjà définie"
 
 #: gcc.c:2026
 #, gcc-internal-format, gfc-internal-format
@@ -18685,13 +18617,13 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "environment variable DJGPP not defined"
 msgid "environment variable %qs not defined"
-msgstr "variable d'environment DJGPP non définie"
+msgstr "variable d'environnement DJGPP non définie"
 
 #: gcc.c:8948 gcc.c:8953
 #, fuzzy, gcc-internal-format
 #| msgid "invalid version number format"
 msgid "invalid version number %qs"
-msgstr "format de numéro de verson invalide"
+msgstr "format de numéro de version invalide"
 
 #: gcc.c:8996
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -18862,7 +18794,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "output number %d not directly addressable"
 msgid "memory input %d is not directly addressable"
-msgstr "nombre de sortie %d n,est pas directement adressable"
+msgstr "nombre de sortie %d n’est pas directement addressable"
 
 #: gimplify.c:5736
 #, fuzzy, gcc-internal-format
@@ -19420,7 +19352,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "inconsistent operand constraints in an `asm'"
 msgid "inconsistent operand constraints in an %<asm%>"
-msgstr "contrainte d'opérande inconsistente en « asm »"
+msgstr "contrainte d'opérande inconsistante en « asm »"
 
 #: lra-constraints.c:4366
 #, gcc-internal-format, gfc-internal-format
@@ -19594,13 +19526,13 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "environment variable DJGPP not defined"
 msgid "environment variable COLLECT_GCC must be set"
-msgstr "variable d'environment DJGPP non définie"
+msgstr "variable d'environnement DJGPP non définie"
 
 #: lto-wrapper.c:908 config/nvptx/mkoffload.c:883
 #, fuzzy, gcc-internal-format
 #| msgid "environment variable DJGPP not defined"
 msgid "environment variable COLLECT_GCC_OPTIONS must be set"
-msgstr "variable d'environment DJGPP non définie"
+msgstr "variable d'environnement DJGPP non définie"
 
 # I18N
 #: lto-wrapper.c:1174
@@ -20047,7 +19979,7 @@ msgstr "limite maximale obtenue de la taille du fichier de vidange (core file):
 #: opts.c:2275
 #, gcc-internal-format
 msgid "setting core file size limit to maximum: %m"
-msgstr "initialisation de la limite maximal de la taille du fichier de vidance (core file): %m"
+msgstr "initialisation de la limite maximal de la taille du fichier de vidange (core file): %m"
 
 #: opts.c:2320
 #, gcc-internal-format, gfc-internal-format
@@ -20509,7 +20441,7 @@ msgstr "contrainte d'entrée de l'opérande contient « %c »"
 #: stmt.c:424
 #, gcc-internal-format
 msgid "matching constraint references invalid operand number"
-msgstr "nombre d'opérandes invalides pour références de containte concordantes"
+msgstr "nombre d'opérandes invalides pour références de contrainte concordantes"
 
 #: stmt.c:458
 #, fuzzy, gcc-internal-format
@@ -20520,7 +20452,7 @@ msgstr "ponctuation invalide « %c » dans la contrainte"
 #: stmt.c:479
 #, gcc-internal-format
 msgid "matching constraint does not allow a register"
-msgstr "contrainte de concordance ne permet pas de reigstre"
+msgstr "contrainte de concordance ne permet pas de registre"
 
 #: stmt.c:573
 #, fuzzy, gcc-internal-format
@@ -20531,7 +20463,7 @@ msgstr "nom d'opérande asm « %s » apparaît en double"
 #: stmt.c:669
 #, gcc-internal-format
 msgid "missing close brace for named operand"
-msgstr "accolade de fermeture manquante pour l'opérandé nommée"
+msgstr "accolade de fermeture manquante pour l'opérande nommée"
 
 #: stmt.c:694
 #, fuzzy, gcc-internal-format
@@ -20622,7 +20554,7 @@ msgstr "Le type retourné d'une fonction ne peut être une fonction"
 #, fuzzy, gcc-internal-format
 #| msgid "array is not addressable"
 msgid "variable symbol is not variable"
-msgstr "tableau n'est pas adressable"
+msgstr "tableau n'est pas addressable"
 
 #: symtab.c:932
 #, gcc-internal-format
@@ -20911,7 +20843,7 @@ msgstr "instruction d'ordonnancement n'est pas supportée sur cette machine cibl
 #: toplev.c:1430
 #, gcc-internal-format
 msgid "this target machine does not have delayed branches"
-msgstr "cette machine cible n'a pas de branchments avec délais"
+msgstr "cette machine cible n'a pas de branchements avec délais"
 
 #: toplev.c:1444
 #, gcc-internal-format, gfc-internal-format
@@ -21339,7 +21271,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "invalid version number format"
 msgid "invalid conversion in gimple call"
-msgstr "format de numéro de verson invalide"
+msgstr "format de numéro de version invalide"
 
 #: tree-cfg.c:3368
 #, fuzzy, gcc-internal-format
@@ -21441,7 +21373,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "invalid version number format"
 msgid "non-trivial conversion in unary operation"
-msgstr "format de numéro de verson invalide"
+msgstr "format de numéro de version invalide"
 
 #: tree-cfg.c:3666
 #, gcc-internal-format
@@ -22018,7 +21950,7 @@ msgstr "fonction « %F » ne peut être enligne parce qu'elle utilise une taille
 #, fuzzy, gcc-internal-format
 #| msgid "%Jfunction '%F' can never be inlined because it uses alloca (override using the always_inline attribute)"
 msgid "function %q+F can never be inlined because it uses alloca (override using the always_inline attribute)"
-msgstr "fonction « %F » ne peut être enligne parce qu'elle utilise alloca (écrasant l'utiliastion de l'attribut always_inline)"
+msgstr "fonction « %F » ne peut être enligne parce qu'elle utilise alloca (écrasant l'utilisation de l'attribut always_inline)"
 
 #: tree-inline.c:3634
 #, fuzzy, gcc-internal-format
@@ -22964,20 +22896,20 @@ msgstr ""
 #: c-family/c-common.c:1944
 #, gcc-internal-format
 msgid "type-punning to incomplete type might break strict-aliasing rules"
-msgstr "type-punning vers un type incomplet peut briser les règles stricte d'aliases"
+msgstr "type-punning vers un type incomplet peut briser les règles stricte d'alias"
 
 # FIXME
 #: c-family/c-common.c:1959
 #, gcc-internal-format
 msgid "dereferencing type-punned pointer will break strict-aliasing rules"
-msgstr "déréférencement du pointeur type-punned brisera les strictes d'aliases"
+msgstr "déréférencement du pointeur type-punned brisera les strictes d'alias"
 
 # FIXME
 #: c-family/c-common.c:1966 c-family/c-common.c:1984
 #, fuzzy, gcc-internal-format
 #| msgid "dereferencing type-punned pointer will break strict-aliasing rules"
 msgid "dereferencing type-punned pointer might break strict-aliasing rules"
-msgstr "déréférencement du pointeur type-punned brisera les strictes d'aliases"
+msgstr "déréférencement du pointeur type-punned brisera les strictes d'alias"
 
 #: c-family/c-common.c:2118
 #, gcc-internal-format
@@ -23168,7 +23100,7 @@ msgstr "grand entier implicitement tronqué pour un type non signé"
 #: c-family/c-common.c:2934 c-family/c-common.c:2941 c-family/c-common.c:2949
 #, gcc-internal-format
 msgid "overflow in implicit constant conversion"
-msgstr "débordement dans la conversion implicte de la constante"
+msgstr "débordement dans la conversion implicite de la constante"
 
 #: c-family/c-common.c:3121
 #, fuzzy, gcc-internal-format
@@ -23330,7 +23262,7 @@ msgstr "intervalle vide spécifié"
 #: c-family/c-common.c:6199
 #, gcc-internal-format
 msgid "duplicate (or overlapping) case value"
-msgstr "valeur du « case » duppliquée (ou en chevauchant une autre)"
+msgstr "valeur du « case » dupliquée (ou en chevauchant une autre)"
 
 #: c-family/c-common.c:6201
 #, fuzzy, gcc-internal-format
@@ -23341,7 +23273,7 @@ msgstr "est la première entrée chevauchant cette valeur"
 #: c-family/c-common.c:6205
 #, gcc-internal-format
 msgid "duplicate case value"
-msgstr "valeur du « case » duppliquée"
+msgstr "valeur du « case » dupliquée"
 
 #: c-family/c-common.c:6206
 #, fuzzy, gcc-internal-format
@@ -23606,7 +23538,7 @@ msgstr "« %#D » ne peut être déclaré"
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not a string constant"
 msgid "attribute %qE argument not a string"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante chaîne"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante chaîne"
 
 #: c-family/c-common.c:7959
 #, fuzzy, gcc-internal-format
@@ -23712,7 +23644,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not an integer constant"
 msgid "assume_aligned parameter not integer constant"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante entière"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante entière"
 
 #: c-family/c-common.c:8496 c-family/c-common.c:9494
 #, fuzzy, gcc-internal-format
@@ -24532,7 +24464,7 @@ msgstr "argument de format %d inutilisé avant l'utilisation de l'argument %d da
 #: c-family/c-format.c:1374
 #, gcc-internal-format
 msgid "format not a string literal, format string not checked"
-msgstr "le format n'est pas une chaîne littérale, le format n'est pas vérifé"
+msgstr "le format n'est pas une chaîne littérale, le format n'est pas vérifié"
 
 #: c-family/c-format.c:1389 c-family/c-format.c:1392
 #, gcc-internal-format
@@ -24700,7 +24632,7 @@ msgstr "%s ne supporte par le format « %%%s%c » %s"
 #: c-family/c-format.c:2240
 #, gcc-internal-format
 msgid "operand number specified with suppressed assignment"
-msgstr "nombre d'opérandes spécifié avec des affectations suprimées"
+msgstr "nombre d'opérandes spécifié avec des affectations supprimées"
 
 #: c-family/c-format.c:2244
 #, gcc-internal-format
@@ -24903,7 +24835,7 @@ msgstr "début possible d'une chaîne de mot non terminée"
 #: c-family/c-lex.c:1180
 #, gcc-internal-format
 msgid "traditional C rejects string constant concatenation"
-msgstr "le C traditionel rejette la concaténation de chaînes de constantes"
+msgstr "le C traditionnel rejette la concaténation de chaînes de constantes"
 
 #: c-family/c-omp.c:205
 #, fuzzy, gcc-internal-format
@@ -24949,7 +24881,7 @@ msgstr "Expression de contrôle invalide"
 #, fuzzy, gcc-internal-format
 #| msgid "missing index expression"
 msgid "missing increment expression"
-msgstr "expresion d'index manquante"
+msgstr "expression d'index manquante"
 
 #: c-family/c-omp.c:663 cp/semantics.c:6395
 #, fuzzy, gcc-internal-format
@@ -26944,7 +26876,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "Insert stack checking code into the program"
 msgid "can%'t use multiple stack checking methods together"
-msgstr "Insérer du code de vérificaion de la pile dans le programme"
+msgstr "Insérer du code de vérification de la pile dans le programme"
 
 #: config/bfin/bfin.c:2404
 #, gcc-internal-format
@@ -27517,7 +27449,7 @@ msgstr "Processeur inconnu : -mcpu=%s"
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not a string constant"
 msgid "attribute %<target%> argument not a string"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante chaîne"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante chaîne"
 
 #: config/i386/i386.c:4887 config/i386/i386.c:4934
 #, gcc-internal-format, gfc-internal-format
@@ -27881,13 +27813,13 @@ msgstr "troisième argument de « __builtin_prefetch » doit être une constante
 #, fuzzy, gcc-internal-format
 #| msgid "incorrect insn:"
 msgid "incorrect comparison mode"
-msgstr "insn incoorect:"
+msgstr "insn incorrect:"
 
 #: config/i386/i386.c:37790 config/i386/i386.c:37992
 #, fuzzy, gcc-internal-format
 #| msgid "incorrect insn:"
 msgid "incorrect rounding operand"
-msgstr "insn incoorect:"
+msgstr "insn incorrect:"
 
 #: config/i386/i386.c:37974
 #, fuzzy, gcc-internal-format
@@ -27950,7 +27882,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "incorrect insn:"
 msgid "incorrect hint operand"
-msgstr "insn incoorect:"
+msgstr "insn incorrect:"
 
 #: config/i386/i386.c:40245
 #, fuzzy, gcc-internal-format
@@ -28108,7 +28040,7 @@ msgstr "l'adresse de la zone « %s » entre en conflit avec un déclaration pré
 #, fuzzy, gcc-internal-format
 #| msgid "%Jaddress area attribute cannot be specified for functions"
 msgid "address area attribute cannot be specified for functions"
-msgstr "l'attribut de la zone d'adresse ne peut pas être spécifié pour des fonctiones"
+msgstr "l'attribut de la zone d'adresse ne peut pas être spécifié pour des fonctions"
 
 #: config/ia64/ia64.c:824
 #, fuzzy, gcc-internal-format
@@ -28206,7 +28138,7 @@ msgstr "attributs de section ne sont pas supportés pour la cible"
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not an integer constant"
 msgid "%qE attribute argument not an integer constant"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante entière"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante entière"
 
 #: config/m32c/m32c.c:2991
 #, gcc-internal-format
@@ -28336,7 +28268,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "malformed #pragma ghs section"
 msgid "malformed #pragma GCC coprocessor subclass"
-msgstr "sectin mal composée #pragma ghs"
+msgstr "section mal composée #pragma ghs"
 
 #: config/mep/mep-pragma.c:347
 #, fuzzy, gcc-internal-format
@@ -28616,7 +28548,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "can not handle inconsistent calls to `%s'"
 msgid "cannot handle inconsistent calls to %qs"
-msgstr "ne peut traiter des appels inconsistents à « %s »"
+msgstr "ne peut traiter des appels inconsistants à « %s »"
 
 #: config/mips/mips.c:10332
 #, gcc-internal-format
@@ -30214,14 +30146,14 @@ msgstr "attribut « %s » s'applique seulement aux fonctions"
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not an integer constant"
 msgid "%qE attribute argument should be between 0 to 255"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante entière"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante entière"
 
 #. The argument must be a constant string.
 #: config/sh/sh.c:9833
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute argument not a string constant"
 msgid "%qE attribute argument not a string constant"
-msgstr "l'attribut « %s » de l'argument n'est pas une contante chaîne"
+msgstr "l'attribut « %s » de l'argument n'est pas une constante chaîne"
 
 #: config/sh/sh.c:12596
 #, gcc-internal-format
@@ -30411,7 +30343,7 @@ msgstr "nom de section non reconnue « %s »"
 #: config/v850/v850-c.c:194
 #, gcc-internal-format
 msgid "malformed #pragma ghs section"
-msgstr "sectin mal composée #pragma ghs"
+msgstr "section mal composée #pragma ghs"
 
 #: config/v850/v850-c.c:213
 #, gcc-internal-format
@@ -30452,7 +30384,7 @@ msgstr "rebut à la fin de #pragma ghs endzda"
 #, fuzzy, gcc-internal-format
 #| msgid "%Jdata area attributes cannot be specified for local variables"
 msgid "data area attributes cannot be specified for local variables"
-msgstr "attribut de zone de donnéées ne peut être spécifié pour des variables locales"
+msgstr "attribut de zone de données ne peut être spécifié pour des variables locales"
 
 #: config/v850/v850.c:2165
 #, fuzzy, gcc-internal-format
@@ -30464,7 +30396,7 @@ msgstr "zone de données de « %D » entre en conflit avec un déclaration préc
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "bogus JR construction: %d\n"
 msgid "bogus JR construction: %d"
-msgstr "construction JR boggé: %d\n"
+msgstr "construction JR bogué: %d\n"
 
 #: config/v850/v850.c:2314 config/v850/v850.c:2421
 #, gcc-internal-format, gfc-internal-format
@@ -30475,13 +30407,13 @@ msgstr "taille erronée pour l'enlèvement d'espace de la pile: %d"
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "bogus JARL construction: %d\n"
 msgid "bogus JARL construction: %d"
-msgstr "construction JARL boggée: %d\n"
+msgstr "construction JARL boguée: %d\n"
 
 #: config/v850/v850.c:2698
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "Bogus DISPOSE construction: %d\n"
 msgid "bogus DISPOSE construction: %d"
-msgstr "construction DISPOSE boggé: %d\n"
+msgstr "construction DISPOSE bogué: %d\n"
 
 #: config/v850/v850.c:2717
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -30493,7 +30425,7 @@ msgstr "Trop d'espace pour l'empilage pour la disposition de: %d"
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "Bogus PREPEARE construction: %d\n"
 msgid "bogus PREPEARE construction: %d"
-msgstr "construction PREPEARE boggée: %d\n"
+msgstr "construction PREPEARE boguée: %d\n"
 
 #: config/v850/v850.c:2836
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -30592,7 +30524,7 @@ msgstr "« #pragma options » mal composé, ignoré"
 #, fuzzy, gcc-internal-format
 #| msgid "invalid #pragma %s"
 msgid "invalid constant in %<#pragma %s%>"
-msgstr "#pragma %s invalde"
+msgstr "#pragma %s invalide"
 
 #: config/xtensa/xtensa.c:2213
 #, gcc-internal-format
@@ -30620,10 +30552,9 @@ msgid "non-default Scalar_Storage_Order"
 msgstr ""
 
 #: ada/gcc-interface/misc.c:158
-#, fuzzy, gcc-internal-format
-#| msgid "`-gnat' misspelled as `-gant'"
+#, gcc-internal-format
 msgid "%<-gnat%> misspelled as %<-gant%>"
-msgstr "« -gnat » mal épellé comme « -gant »"
+msgstr "%<-gnat%> mal orthographié comme %<-gant%>"
 
 #: ada/gcc-interface/misc.c:269
 #, gcc-internal-format
@@ -30660,41 +30591,38 @@ msgstr "le nombre d'arguments ne concorde pas avec celui du prototype"
 
 #: ada/gcc-interface/utils.c:5623 ada/gcc-interface/utils.c:5797
 #: ada/gcc-interface/utils.c:5859
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute ignored"
+#, gcc-internal-format
 msgid "%qs attribute ignored"
-msgstr "attribut « %s » ignoré"
+msgstr "attribut %qs ignoré"
 
 #: ada/gcc-interface/utils.c:5740
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute requires an integer constant argument"
 msgid "%qs attribute requires prototypes with named arguments"
-msgstr "l'attribut « %s » requiert un argument de type constante entière"
+msgstr "l'attribut %qs requiert un argument de type constante entière"
 
 #: ada/gcc-interface/utils.c:5749
-#, fuzzy, gcc-internal-format
-#| msgid "`%s' attribute only applies to functions"
+#, gcc-internal-format
 msgid "%qs attribute only applies to variadic functions"
-msgstr "attribut « %s » s'applique seulement aux fonctions"
+msgstr "l’attribut %qs s’applique seulement aux fonctions variadiques"
 
 #: ada/gcc-interface/utils.c:5819
-#, fuzzy, gcc-internal-format
-#| msgid "%s has no effect"
+#, gcc-internal-format
 msgid "%qE attribute has no effect"
-msgstr "%s n'a pas d'effet"
+msgstr "l’attribut %qE n'a pas d’effet"
 
 #: ada/gcc-interface/utils.c:5943
 #, fuzzy, gcc-internal-format
 #| msgid "`%s' attribute only applies to variables"
 msgid "attribute %qs applies to array types only"
-msgstr "attribut « %s » s'applique seulement aux variables"
+msgstr "attribut %qs s'applique seulement aux variables"
 
 #: c/c-array-notation.c:229 c/c-array-notation.c:258 cp/call.c:7581
 #: cp/cp-array-notation.c:264
 #, fuzzy, gcc-internal-format
 #| msgid "invalid option argument `%s'"
 msgid "Invalid builtin arguments"
-msgstr "argument de l'option invalide « %s »"
+msgstr "argument de l'option invalide"
 
 #: c/c-array-notation.c:265 cp/cp-array-notation.c:271
 #, gcc-internal-format
@@ -30851,7 +30779,7 @@ msgstr "prototype pour « %D » déclare moins d'arguments que la définition pr
 #, fuzzy, gcc-internal-format
 #| msgid "%Jprototype for '%D' declares arg %d with incompatible type"
 msgid "prototype for %q+D declares argument %d with incompatible type"
-msgstr "prototype pour « %D » déclare l'arguments %d avec un type incompatible"
+msgstr "prototype pour « %D » déclare l'argument %d avec un type incompatible"
 
 #. If we get here, no errors were found, but do issue a warning
 #. for this poor-style construct.
@@ -31002,7 +30930,7 @@ msgstr "déclaration non thread local de « %D » suit une déclaration de threa
 #, fuzzy, gcc-internal-format
 #| msgid "%Jextern declaration of '%D' follows declaration with no linkage"
 msgid "extern declaration of %q+D follows declaration with no linkage"
-msgstr "déclaration externe de « %D » suit une déclaraion sans lien"
+msgstr "déclaration externe de « %D » suit une déclaration sans lien"
 
 #: c/c-decl.c:2211
 #, fuzzy, gcc-internal-format
@@ -31032,13 +30960,13 @@ msgstr "déclaration enligne de « %D » suit la déclaration avec un attribut n
 #, fuzzy, gcc-internal-format
 #| msgid "%Jdeclaration of '%D' with attribute noinline follows inline declaration "
 msgid "declaration of %q+D with attribute noinline follows inline declaration "
-msgstr "éclaration de « %D » avec un attribut non enligne suit une déclaration enligne"
+msgstr "déclaration de « %D » avec un attribut non enligne suit une déclaration enligne"
 
 #: c/c-decl.c:2263 c/c-decl.c:2269 c/c-decl.c:2275 c/c-decl.c:2281
 #, fuzzy, gcc-internal-format
 #| msgid "%Jdeclaration of '%D' with attribute noinline follows inline declaration "
 msgid "declaration of %q+D with attribute %qs follows declaration with attribute %qs"
-msgstr "éclaration de « %D » avec un attribut non enligne suit une déclaration enligne"
+msgstr "déclaration de « %D » avec un attribut non enligne suit une déclaration enligne"
 
 #: c/c-decl.c:2299
 #, fuzzy, gcc-internal-format
@@ -32333,7 +32261,7 @@ msgstr "déclaration de paramètre d'ancien style dans la définition prototypé
 #: c/c-decl.c:8469
 #, gcc-internal-format
 msgid "traditional C rejects ISO C style function definitions"
-msgstr "le C traditionel rejette les définitions de fonction de style ISO C"
+msgstr "le C traditionnel rejette les définitions de fonction de style ISO C"
 
 #: c/c-decl.c:8485
 #, fuzzy, gcc-internal-format
@@ -32402,10 +32330,9 @@ msgid "number of arguments doesn%'t match prototype"
 msgstr "le nombre d'arguments ne concorde pas avec celui du prototype"
 
 #: c/c-decl.c:8686 c/c-decl.c:8733 c/c-decl.c:8747
-#, fuzzy, gcc-internal-format
-#| msgid "%Hprototype declaration"
+#, gcc-internal-format
 msgid "prototype declaration"
-msgstr "%Hdéclaration de prototype"
+msgstr "déclaration de prototype"
 
 #: c/c-decl.c:8725
 #, fuzzy, gcc-internal-format
@@ -32982,7 +32909,7 @@ msgstr "utilisation obsolète d'une initialisation désignée avec « : »"
 #: c/c-parser.c:4392
 #, gcc-internal-format
 msgid "ISO C forbids specifying range of elements to initialize"
-msgstr "ISO C interdit de spécifier les bornes des éléments à initaliser"
+msgstr "ISO C interdit de spécifier les bornes des éléments à initialiser"
 
 #: c/c-parser.c:4404
 #, gcc-internal-format
@@ -33389,7 +33316,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "%Jaddress area attribute cannot be specified for functions"
 msgid "the %<getter%> attribute may only be specified once"
-msgstr "l'attribut de la zone d'adresse ne peut pas être spécifié pour des fonctiones"
+msgstr "l'attribut de la zone d'adresse ne peut pas être spécifié pour des fonctions"
 
 #: c/c-parser.c:9623
 #, gcc-internal-format
@@ -33480,7 +33407,7 @@ msgstr "l'argument de « %d » n'est pas une constante"
 #, fuzzy, gcc-internal-format
 #| msgid "%s is not addressable"
 msgid "%qD is not a variable"
-msgstr "%s n'est pas adressable"
+msgstr "%s n'est pas addressable"
 
 #: c/c-parser.c:10342 cp/parser.c:28044
 #, fuzzy, gcc-internal-format
@@ -33642,7 +33569,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "invalid #pragma %s"
 msgid "invalid pragma"
-msgstr "#pragma %s invalde"
+msgstr "#pragma %s invalide"
 
 #: c/c-parser.c:12151 cp/parser.c:31654
 #, gcc-internal-format
@@ -33658,7 +33585,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "invalid #pragma %s"
 msgid "invalid form of %<#pragma omp atomic%>"
-msgstr "#pragma %s invalde"
+msgstr "#pragma %s invalide"
 
 #: c/c-parser.c:12670 cp/parser.c:29978 cp/parser.c:29994
 #, fuzzy, gcc-internal-format
@@ -34126,7 +34053,7 @@ msgstr "l'objet appelé n'est pas une fonction"
 #: c/c-typeck.c:2976
 #, gcc-internal-format
 msgid "function called through a non-compatible type"
-msgstr "fonction appellée à travers un type non compatible"
+msgstr "fonction appelée à travers un type non compatible"
 
 #: c/c-typeck.c:2981 c/c-typeck.c:3018
 #, fuzzy, gcc-internal-format
@@ -34800,7 +34727,7 @@ msgstr ""
 #: c/c-typeck.c:6449
 #, gcc-internal-format
 msgid "traditional C rejects automatic aggregate initialization"
-msgstr "le C traditionel rejette l'initialisation automatique d'agrégats"
+msgstr "le C traditionnel rejette l'initialisation automatique d'agrégats"
 
 #: c/c-typeck.c:6686 c/c-typeck.c:7577
 #, gcc-internal-format
@@ -34985,7 +34912,7 @@ msgstr "éléments en excès dans l'initialisation d'union"
 #: c/c-typeck.c:8975
 #, gcc-internal-format
 msgid "traditional C rejects initialization of unions"
-msgstr "le C traditionel rejette l'initialisation d'union"
+msgstr "le C traditionnel rejette l'initialisation d'union"
 
 #: c/c-typeck.c:9043
 #, gcc-internal-format
@@ -35018,7 +34945,7 @@ msgstr "fonction déclarée avec « noreturn» utilisant le mot-clé « return 
 #, fuzzy, gcc-internal-format
 #| msgid "comma expression used to initialize return value"
 msgid "array notation expression cannot be used as a return value"
-msgstr "expression virgule utilsée pour initialiser la valeur de retour"
+msgstr "expression virgule utilisée pour initialiser la valeur de retour"
 
 #: c/c-typeck.c:9390 cp/typeck.c:8437
 #, gcc-internal-format
@@ -35128,10 +35055,9 @@ msgid "continue statement within %<#pragma simd%> loop body"
 msgstr "mot-clé « continue » à l'extérieur de toute boucle"
 
 #: c/c-typeck.c:9927 cp/cp-gimplify.c:439
-#, fuzzy, gcc-internal-format
-#| msgid "%Hstatement with no effect"
+#, gcc-internal-format
 msgid "statement with no effect"
-msgstr "%Hdéclaration sans effet"
+msgstr "déclaration sans effet"
 
 #: c/c-typeck.c:9971
 #, gcc-internal-format
@@ -35324,7 +35250,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "type to vector delete is neither pointer or array type"
 msgid "%qE does not have pointer or array type"
-msgstr "type du vesteur delete n'est ni un pointeur ou un type tableau"
+msgstr "type du vecteur delete n'est ni un pointeur ou un type tableau"
 
 #: c/c-typeck.c:12124
 #, fuzzy, gcc-internal-format
@@ -35385,7 +35311,7 @@ msgstr "« %s » n'est pas un nom de classe valide"
 #, fuzzy, gcc-internal-format
 #| msgid "type to vector delete is neither pointer or array type"
 msgid "%qE in %<aligned%> clause is neither a pointer nor an array"
-msgstr "type du vesteur delete n'est ni un pointeur ou un type tableau"
+msgstr "type du vecteur delete n'est ni un pointeur ou un type tableau"
 
 #: c/c-typeck.c:12332
 #, gcc-internal-format
@@ -35595,7 +35521,7 @@ msgstr "appel de « (%T) (%A) » est ambiguë"
 #, fuzzy, gcc-internal-format
 #| msgid "ambiguous conversion for array subscript"
 msgid "ambiguous overload for "
-msgstr "comversion ambigue pour un sous-tableau"
+msgstr "conversion ambiguë pour un sous-tableau"
 
 #: cp/call.c:4383
 #, gcc-internal-format
@@ -35728,13 +35654,13 @@ msgstr "type énuméré et non énuméré dans l'expression conditionnelle"
 #, fuzzy, gcc-internal-format
 #| msgid "no `%D(int)' declared for postfix `%s', trying prefix operator instead"
 msgid "no %<%D(int)%> declared for postfix %qs, trying prefix operator instead"
-msgstr "pas « %D(int) » déclaré pour le postfixe « %s », essaie avec l'oprateur préfixe à la place"
+msgstr "pas « %D(int) » déclaré pour le postfixe « %s », essaie avec l'opérateur préfixe à la place"
 
 #: cp/call.c:5530
 #, fuzzy, gcc-internal-format
 #| msgid "no `%D(int)' declared for postfix `%s', trying prefix operator instead"
 msgid "no %<%D(int)%> declared for postfix %qs"
-msgstr "pas « %D(int) » déclaré pour le postfixe « %s », essaie avec l'oprateur préfixe à la place"
+msgstr "pas « %D(int) » déclaré pour le postfixe « %s », essaie avec l'opérateur préfixe à la place"
 
 #: cp/call.c:5623
 #, fuzzy, gcc-internal-format
@@ -36345,7 +36271,7 @@ msgstr "« %D » est trop petit pour contenir toutes les valeurs de « %#T »"
 #, fuzzy, gcc-internal-format
 #| msgid "member `%#D' with constructor not allowed in union"
 msgid "member %q+#D with constructor not allowed in union"
-msgstr "membre « %#D » avec consructeur n'est pas permis dans l'union"
+msgstr "membre « %#D » avec constructeur n'est pas permis dans l'union"
 
 #: cp/class.c:3535
 #, fuzzy, gcc-internal-format
@@ -36357,7 +36283,7 @@ msgstr "membre « %#D » avec destructeur n'est pas permis dans l'union"
 #, fuzzy, gcc-internal-format
 #| msgid "member `%#D' with copy assignment operator not allowed in union"
 msgid "member %q+#D with copy assignment operator not allowed in union"
-msgstr "membre « %#D » avec opérateur d,affectation par copie n'st pas permis dans l'union"
+msgstr "membre « %#D » avec opérateur d’affectation par copie n'est pas permis dans l'union"
 
 #: cp/class.c:3541
 #, gcc-internal-format
@@ -36374,7 +36300,7 @@ msgstr "champs multiples dans l'union « %T » initialisés"
 #, fuzzy, gcc-internal-format
 #| msgid "`%D' may not be static because it is a member of a union"
 msgid "in C++98 %q+D may not be static because it is a member of a union"
-msgstr "« %D » peut ne pas être statique parce qu'il est membre de l'uniont"
+msgstr "« %D » peut ne pas être statique parce qu'il est membre de l'union"
 
 #: cp/class.c:3672
 #, fuzzy, gcc-internal-format
@@ -36537,13 +36463,13 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "direct base `%T' inaccessible in `%T' due to ambiguity"
 msgid "direct base %qT inaccessible in %qT due to ambiguity"
-msgstr "base directe « %T » inaccessible dans « %T » en raison de l'ambiguité"
+msgstr "base directe « %T » inaccessible dans « %T » en raison de l'ambiguïté"
 
 #: cp/class.c:6104
 #, fuzzy, gcc-internal-format
 #| msgid "virtual base `%T' inaccessible in `%T' due to ambiguity"
 msgid "virtual base %qT inaccessible in %qT due to ambiguity"
-msgstr "base virtuelle « %T » inaccessible dans « %T » en raison de l'ambiguité"
+msgstr "base virtuelle « %T » inaccessible dans « %T » en raison de l'ambiguïté"
 
 #: cp/class.c:6331
 #, fuzzy, gcc-internal-format
@@ -37405,10 +37331,9 @@ msgid "left operand of comma operator has no effect"
 msgstr "l'opérande à gauche de la virgule n'a pas d'effet"
 
 #: cp/cvt.c:1386
-#, fuzzy, gcc-internal-format
-#| msgid "%Hstatement with no effect"
+#, gcc-internal-format
 msgid "statement has no effect"
-msgstr "%Hdéclaration sans effet"
+msgstr "déclaration sans effet"
 
 #: cp/cvt.c:1390
 #, fuzzy, gcc-internal-format
@@ -37474,7 +37399,7 @@ msgstr "déclaration de « %F » amène différentes exceptions"
 #, fuzzy, gcc-internal-format
 #| msgid "than previous declaration `%F'"
 msgid "from previous declaration %q+F"
-msgstr "qu'une précédente déclaratio « %F »"
+msgstr "qu'une précédente déclaration %q+F"
 
 #: cp/decl.c:1257
 #, gcc-internal-format
@@ -37567,7 +37492,7 @@ msgstr "déclaration précédente d'un non fonction « %#D »"
 #, fuzzy, gcc-internal-format
 #| msgid "ambiguates built-in declaration `%#D'"
 msgid "new declaration %q#D ambiguates built-in declaration %q#D"
-msgstr "ambiguités de la déclaration interne de « %#D »"
+msgstr "ambiguïtés de la déclaration interne de « %#D »"
 
 #: cp/decl.c:1551
 #, fuzzy, gcc-internal-format
@@ -37591,7 +37516,7 @@ msgstr "déclaration du patron « %#D »"
 #, fuzzy, gcc-internal-format
 #| msgid "ambiguates old declaration `%#D'"
 msgid "ambiguating new declaration %q#D"
-msgstr "ambiguités d'une vieille déclaration de « %#D »"
+msgstr "ambiguïtés d'une vieille déclaration de « %#D »"
 
 #: cp/decl.c:1592 cp/decl.c:1615
 #, fuzzy, gcc-internal-format
@@ -37609,7 +37534,7 @@ msgstr "déclaration implicite de la fonction « %#D »"
 #, fuzzy, gcc-internal-format
 #| msgid "ambiguates old declaration `%#D'"
 msgid "ambiguating new declaration of %q#D"
-msgstr "ambiguités d'une vieille déclaration de « %#D »"
+msgstr "ambiguïtés d'une vieille déclaration de « %#D »"
 
 #: cp/decl.c:1623
 #, fuzzy, gcc-internal-format
@@ -38097,7 +38022,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "declaration of `%#D' outside of class is not definition"
 msgid "declaration of %q#D outside of class is not definition"
-msgstr "déclaraion de « %#D » en dehors de la classe n'est pas une définition"
+msgstr "déclaration de « %#D » en dehors de la classe n'est pas une définition"
 
 #: cp/decl.c:4859
 #, gcc-internal-format
@@ -38327,7 +38252,7 @@ msgstr "« %D » doit être initialisé par un constructeur, non pas par « {...
 #, fuzzy, gcc-internal-format
 #| msgid "_Pragma takes a parenthesized string literal"
 msgid "array %qD initialized by parenthesized string literal %qE"
-msgstr "_Pragma prend une chaîne entourée de parenthèrese"
+msgstr "_Pragma prend une chaîne entourée de parenthèse"
 
 #: cp/decl.c:6048
 #, gcc-internal-format
@@ -38517,7 +38442,7 @@ msgstr "déclaration de « %D » n'est pas dans l'espace de noms entourant « %D
 #, fuzzy, gcc-internal-format
 #| msgid "static member function `%#D' declared with type qualifiers"
 msgid "static member function %q#D declared with type qualifiers"
-msgstr "membre de fonction statique « %#D » déclaré avec des qualificateurs de tyep"
+msgstr "membre de fonction statique « %#D » déclaré avec des qualificateurs de type"
 
 #: cp/decl.c:7710
 #, fuzzy, gcc-internal-format
@@ -38741,7 +38666,7 @@ msgstr "taille du tableau n'est pas une expression de constante de type entier"
 #, fuzzy, gcc-internal-format
 #| msgid "ISO C++ forbids variable-size array `%D'"
 msgid "ISO C++ forbids variable length array %qD"
-msgstr "ISO C++ interdit les tableaus de taille variable « %D »"
+msgstr "ISO C++ interdit les tableaux de taille variable « %D »"
 
 #: cp/decl.c:8568
 #, fuzzy, gcc-internal-format
@@ -38822,12 +38747,12 @@ msgstr "déclaration de « %s » comme un tableau de fonctions"
 #, fuzzy, gcc-internal-format
 #| msgid "declaration of `%D' as multidimensional array must have bounds for all dimensions except the first"
 msgid "declaration of %qD as multidimensional array must have bounds for all dimensions except the first"
-msgstr "déclaration de « %D » comme tableau multidimensionel doit avoir des bornes pour chaque dimension excepté pour la première"
+msgstr "déclaration de « %D » comme tableau multidimensionnel doit avoir des bornes pour chaque dimension excepté pour la première"
 
 #: cp/decl.c:8744
 #, gcc-internal-format
 msgid "multidimensional array must have bounds for all dimensions except the first"
-msgstr "tableau multidimensionel doit avoir des bornes pour chaque dimension excepté pour la première"
+msgstr "tableau multidimensionnel doit avoir des bornes pour chaque dimension excepté pour la première"
 
 #: cp/decl.c:8779
 #, gcc-internal-format
@@ -39231,7 +39156,7 @@ msgstr "ne peut déclarer un pointeur vers le membre « %#T »"
 #, fuzzy, gcc-internal-format
 #| msgid "cannot declare references to references"
 msgid "cannot declare reference to qualified function type %qT"
-msgstr "ne peut décalrer des références vers des références"
+msgstr "ne peut déclarer des références vers des références"
 
 #: cp/decl.c:9997
 #, fuzzy, gcc-internal-format
@@ -39378,7 +39303,7 @@ msgstr "ISO C++ interdit le type imbriqué « %D » avec le même nom que la cla
 #: cp/decl.c:10497
 #, gcc-internal-format
 msgid "type qualifiers specified for friend class declaration"
-msgstr "qulificateurs de types spécifiés pour la déclaration d'une classe amie"
+msgstr "qualificateurs de types spécifiés pour la déclaration d'une classe amie"
 
 #: cp/decl.c:10502
 #, fuzzy, gcc-internal-format
@@ -39497,7 +39422,7 @@ msgstr "qualificateurs ne sont pas permis dans la déclaration de « operator %T
 #, fuzzy, gcc-internal-format
 #| msgid "specialization of implicitly-declared special member function"
 msgid "specialization of variable template %qD declared as function"
-msgstr "spécialisation d'un membre spécial d'nue fonction déclaré implicitement"
+msgstr "spécialisation d'un membre spécial d'une fonction déclaré implicitement"
 
 #: cp/decl.c:10752
 #, fuzzy, gcc-internal-format
@@ -39532,7 +39457,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "static member `%D' declared `register'"
 msgid "non-static data member %qE declared %<constexpr%>"
-msgstr "mambre statique « %D» déclaré «register »"
+msgstr "membre statique « %D» déclaré «register »"
 
 #: cp/decl.c:10936
 #, fuzzy, gcc-internal-format
@@ -39628,7 +39553,7 @@ msgstr "ne peut explicitement déclarer le membre « %#D » comme ayant une liai
 #, fuzzy, gcc-internal-format
 #| msgid "declaration of `%#D' outside of class is not definition"
 msgid "declaration of constexpr variable %qD is not a definition"
-msgstr "déclaraion de « %#D » en dehors de la classe n'est pas une définition"
+msgstr "déclaration de « %#D » en dehors de la classe n'est pas une définition"
 
 #: cp/decl.c:11086
 #, fuzzy, gcc-internal-format
@@ -39804,7 +39729,7 @@ msgstr "postfixe « %D» doit prendre « int » comme argument"
 #, fuzzy, gcc-internal-format
 #| msgid "postfix `%D' must take `int' as its second argument"
 msgid "postfix %qD must take %<int%> as its second argument"
-msgstr "postfixe « %D» doit prndre « int » pour son second argument"
+msgstr "postfixe « %D» doit prendre « int » pour son second argument"
 
 #: cp/decl.c:11963
 #, fuzzy, gcc-internal-format
@@ -40123,7 +40048,7 @@ msgstr "nom manquant pour le membre d'une fonction"
 #: cp/decl2.c:420 cp/decl2.c:434
 #, gcc-internal-format
 msgid "ambiguous conversion for array subscript"
-msgstr "comversion ambigue pour un sous-tableau"
+msgstr "conversion ambiguë pour un sous-tableau"
 
 #: cp/decl2.c:428
 #, fuzzy, gcc-internal-format
@@ -40578,7 +40503,7 @@ msgstr "traitement des exceptions désactivé, utiliser -fexceptions pour l'acti
 #: cp/except.c:730
 #, gcc-internal-format
 msgid "throwing NULL, which has integral, not pointer type"
-msgstr "retounrnant NULL (par throw), lequel est entier, pas de type pointeur"
+msgstr "retournant NULL (par throw), lequel est entier, pas de type pointeur"
 
 #: cp/except.c:754 cp/init.c:2531
 #, fuzzy, gcc-internal-format
@@ -40997,7 +40922,7 @@ msgstr "répétitions d'expressions doit être une constante"
 #, fuzzy, gcc-internal-format
 #| msgid "double quoted strings not allowed in #if expressions"
 msgid "variably modified type not allowed in new-expression"
-msgstr "chaînes entre quillemets ne sont pas allouées dans les expression #if"
+msgstr "chaînes entre guillemets ne sont pas allouées dans les expression #if"
 
 #: cp/init.c:2400
 #, fuzzy, gcc-internal-format
@@ -41083,7 +41008,7 @@ msgstr "problème possible détecté dans l'invocation de l'opérateur delete:"
 #, fuzzy, gcc-internal-format
 #| msgid "neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined."
 msgid "neither the destructor nor the class-specific operator delete [] will be called, even if they are declared when the class is defined"
-msgstr "ni le destructeur ni l'opérateur « delete » spécifique à la classe ne sera appellé, même s'ils sont déclarés lorsque la classe est définie"
+msgstr "ni le destructeur ni l'opérateur « delete » spécifique à la classe ne sera appelé, même s'ils sont déclarés lorsque la classe est définie"
 
 #: cp/init.c:3682
 #, gcc-internal-format
@@ -41109,7 +41034,7 @@ msgstr "problème possible détecté dans l'invocation de l'opérateur delete:"
 #, fuzzy, gcc-internal-format
 #| msgid "neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined."
 msgid "neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined"
-msgstr "ni le destructeur ni l'opérateur « delete » spécifique à la classe ne sera appellé, même s'ils sont déclarés lorsque la classe est définie"
+msgstr "ni le destructeur ni l'opérateur « delete » spécifique à la classe ne sera appelé, même s'ils sont déclarés lorsque la classe est définie"
 
 #: cp/init.c:4019
 #, gcc-internal-format
@@ -41124,7 +41049,7 @@ msgstr ""
 #: cp/init.c:4321
 #, gcc-internal-format
 msgid "type to vector delete is neither pointer or array type"
-msgstr "type du vesteur delete n'est ni un pointeur ou un type tableau"
+msgstr "type du vecteur delete n'est ni un pointeur ou un type tableau"
 
 #: cp/lambda.c:480
 #, gcc-internal-format
@@ -41171,7 +41096,7 @@ msgstr "rebut à la fin de #pragma %s"
 #: cp/lex.c:345
 #, gcc-internal-format, gfc-internal-format
 msgid "invalid #pragma %s"
-msgstr "#pragma %s invalde"
+msgstr "#pragma %s invalide"
 
 #: cp/lex.c:353
 #, gcc-internal-format
@@ -47451,7 +47376,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "syntax error in action"
 msgid "Syntax error in array constructor at %C"
-msgstr "erreur de syntaxe dans l,action"
+msgstr "erreur de syntaxe dans l’action"
 
 #: fortran/array.c:1061
 #, gcc-internal-format, gfc-internal-format
@@ -49411,7 +49336,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "Missing first operand for binary operator at %0"
 msgid "Missing closing paren for binding label at %C"
-msgstr "première opérande manquante pour l'opérateur biunaire à %0"
+msgstr "première opérande manquante pour l'opérateur binaire à %0"
 
 #: fortran/decl.c:6016
 #, gcc-internal-format, gfc-internal-format
@@ -49498,7 +49423,7 @@ msgstr ""
 #: fortran/decl.c:6595
 #, gcc-internal-format
 msgid "Expected %<(%> at %C"
-msgstr "%<(%> atterdu à %C"
+msgstr "%<(%> attendu à %C"
 
 #: fortran/decl.c:6609 fortran/decl.c:6649
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -50847,7 +50772,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "reference `%s' is ambiguous: appears in interface `%s' and interface `%s'"
 msgid "Although not referenced, %qs has ambiguous interfaces at %L"
-msgstr "référence « %s » est ambigue: apparaît dans l'interface « %s » et l'interface « %s »"
+msgstr "référence « %s » est ambiguë : apparaît dans l'interface « %s » et l'interface « %s »"
 
 #: fortran/interface.c:1705
 #, fuzzy, gcc-internal-format
@@ -51123,7 +51048,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "Missing value at %1 for real-number exponent at %0"
 msgid "Missing actual argument for argument %qs at %L"
-msgstr "Valeur manquante à %1 pour l'exposant d'un nombre réeal à %0"
+msgstr "Valeur manquante à %1 pour l'exposant d'un nombre réel à %0"
 
 #: fortran/interface.c:3128
 #, gcc-internal-format
@@ -52244,7 +52169,7 @@ msgstr "constante sans type invalide à %1"
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "syntax error in action"
 msgid "Syntax error in FORALL iterator at %C"
-msgstr "erreur de syntaxe dans l,action"
+msgstr "erreur de syntaxe dans l’action"
 
 #: fortran/match.c:2296
 #, gcc-internal-format, gfc-internal-format
@@ -53355,7 +53280,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "underflowed virtual array %s in %s, at %s:%d"
 msgid "Assumed rank array %qs in %s clause at %L"
-msgstr "sous débordement du tableau virtuele %s dans %s, à %s:%d"
+msgstr "sous débordement du tableau virtuel %s dans %s, à %s:%d"
 
 #: fortran/openmp.c:2691
 #, gcc-internal-format
@@ -54689,7 +54614,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "syntax error in action"
 msgid "Syntax error in COMPLEX constant at %C"
-msgstr "erreur de syntaxe dans l,action"
+msgstr "erreur de syntaxe dans l’action"
 
 #: fortran/primary.c:1583
 #, gcc-internal-format
@@ -54875,7 +54800,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format
 #| msgid "%s is not addressable"
 msgid "%qs at %C is not a variable"
-msgstr "%s n'est pas adressable"
+msgstr "%s n'est pas addressable"
 
 #: fortran/resolve.c:125
 #, gcc-internal-format
@@ -55026,7 +54951,7 @@ msgstr ""
 #, fuzzy, gcc-internal-format, gfc-internal-format
 #| msgid "inconsistent instance variable specification"
 msgid "Function %s at %L has entries with mismatched array specifications"
-msgstr "spécification inconsistente avec l'instance de la vairable"
+msgstr "spécification inconsistante avec l'instance de la variable"
 
 #: fortran/resolve.c:797
 #, gcc-internal-format, gfc-internal-format
@@ -59781,25 +59706,22 @@ msgid "instance variable %qs is declared private"
 msgstr "instance de la variable « %s » est déclaré privée"
 
 #: objc/objc-act.c:9422
-#, fuzzy, gcc-internal-format
-#| msgid "local declaration of `%s' hides instance variable"
+#, gcc-internal-format
 msgid "local declaration of %qE hides instance variable"
-msgstr "la déclaration locale de « %s » masque l'instance d'une variable"
+msgstr "la déclaration locale de « %qE » masque l'instance d'une variable"
 
 #. This can happen if DECL_ARTIFICIAL (*expr_p), but
 #. should be impossible for real properties, which always
 #. have a getter.
 #: objc/objc-act.c:9468
-#, fuzzy, gcc-internal-format
-#| msgid "no symbol table found"
+#, gcc-internal-format
 msgid "no %qs getter found"
-msgstr "aucune table des symboles trouvée"
+msgstr ""
 
 #: objc/objc-act.c:9708
-#, fuzzy, gcc-internal-format
-#| msgid "this media function is only available on the fr500"
+#, gcc-internal-format
 msgid "fast enumeration is not available in Objective-C 1.0"
-msgstr "cette fonction média est seulement disponible sur le fr500"
+msgstr ""
 
 #: objc/objc-act.c:9718
 #, gcc-internal-format
@@ -59857,6 +59779,3 @@ msgstr "%<-fobjc-sjlj-exceptions%> est ignoré pour %<-fnext-runtime%> lorsque %
 #, gcc-internal-format
 msgid "creating selector for nonexistent method %qE"
 msgstr "création du sélection pour une méthode inexistante %qE"
-
-#~ msgid "ISO C++ forbids subscripting non-lvalue array"
-#~ msgstr "ISO C++ interdit le souscriptage de non lvalue de tableau"
diff --git a/gcc/po/zh_CN.po b/gcc/po/zh_CN.po
index 56686e7..e7d76c1 100644
--- a/gcc/po/zh_CN.po
+++ b/gcc/po/zh_CN.po
@@ -9,7 +9,7 @@ msgstr ""
 "Project-Id-Version: gcc 5.2.0\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2015-07-02 12:31+0000\n"
-"PO-Revision-Date: 2015-11-21 03:15-0500\n"
+"PO-Revision-Date: 2016-01-10 13:41-0500\n"
 "Last-Translator: Mingye Wang (Arthur2e5) <arthur200126@gmail.com>\n"
 "Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
 "Language: zh_CN\n"
@@ -1518,7 +1518,7 @@ msgstr "警告："
 
 #: diagnostic.def:38
 msgid "anachronism: "
-msgstr "时代错误："
+msgstr "历史遗留："
 
 #: diagnostic.def:39
 msgid "note: "
@@ -1536,7 +1536,7 @@ msgstr "保守警告："
 
 #: diagnostic.def:44
 msgid "permerror: "
-msgstr "永久性错误："
+msgstr "永久错误："
 
 #: params.def:44
 msgid "Maximal estimated outcome of branch considered predictable"
@@ -11520,14 +11520,12 @@ msgid "Allow gcc to generate the SETLB and Lcc instructions"
 msgstr "允许 gcc 生成 LIW 指令"
 
 #: config/nds32/nds32.opt:26
-#, fuzzy
 msgid "Generate code in big-endian mode."
-msgstr "生成大端在前的代码"
+msgstr "生成大端在前的代码。"
 
 #: config/nds32/nds32.opt:30
-#, fuzzy
 msgid "Generate code in little-endian mode."
-msgstr "生成小端在前的代码"
+msgstr "生成小端在前的代码。"
 
 #: config/nds32/nds32.opt:34
 #, fuzzy
@@ -11555,9 +11553,8 @@ msgid "Generate v3 push25/pop25 instructions."
 msgstr "生成加载/存储乘法指令"
 
 #: config/nds32/nds32.opt:54
-#, fuzzy
 msgid "Generate 16-bit instructions."
-msgstr "生成 isel 指令"
+msgstr "生成 16 位指令。"
 
 #: config/nds32/nds32.opt:58
 msgid "Specify the size of each interrupt vector, which must be 4 or 16."
@@ -12493,24 +12490,20 @@ msgid "Known TILE-Gx CPUs (for use with the -mcpu= option):"
 msgstr "已知 TILE-Gx 处理器 (用于 -mcpu= 选项)："
 
 #: config/tilegx/tilegx.opt:37
-#, fuzzy
 msgid "Compile with 32 bit longs and pointers."
-msgstr "为 32 位指针编译"
+msgstr "为 32 位长整形和指针编译。"
 
 #: config/tilegx/tilegx.opt:41
-#, fuzzy
 msgid "Compile with 64 bit longs and pointers."
-msgstr "为 64 位指针编译"
+msgstr "为 32 位长整形和指针编译。"
 
 #: config/tilegx/tilegx.opt:45
-#, fuzzy
 msgid "Use big-endian byte order."
-msgstr "令大端在前"
+msgstr "令大端在前。"
 
 #: config/tilegx/tilegx.opt:49
-#, fuzzy
 msgid "Use little-endian byte order."
-msgstr "令小端在前"
+msgstr "令小端在前。"
 
 #: config/tilegx/tilegx.opt:53
 #, fuzzy
@@ -12518,14 +12511,12 @@ msgid "Use given TILE-Gx code model"
 msgstr "使用给定的 SPARC-V9 代码模型"
 
 #: config/arc/arc.opt:26
-#, fuzzy
 msgid "Compile code for big endian mode"
-msgstr "生成大端在前的代码"
+msgstr "生成大端序模式的代码"
 
 #: config/arc/arc.opt:30
-#, fuzzy
 msgid "Compile code for little endian mode.  This is the default"
-msgstr "生成小端在前的代码"
+msgstr "生成笑端序模式的代码。此为默认"
 
 #: config/arc/arc.opt:34
 msgid "Disable ARCompact specific pass to generate conditional execution instructions"
@@ -12540,9 +12531,8 @@ msgid "Generate ARCompact 32-bit code for ARC600 processor"
 msgstr ""
 
 #: config/arc/arc.opt:46
-#, fuzzy
 msgid "Same as -mA6"
-msgstr "与上一次相同"
+msgstr "与 -mA6 相同"
 
 #: config/arc/arc.opt:50
 msgid "Generate ARCompact 32-bit code for ARC601 processor"
@@ -12553,9 +12543,8 @@ msgid "Generate ARCompact 32-bit code for ARC700 processor"
 msgstr ""
 
 #: config/arc/arc.opt:58
-#, fuzzy
 msgid "Same as -mA7"
-msgstr "与上一次相同"
+msgstr "与 -mA7 相同"
 
 #: config/arc/arc.opt:62
 #, fuzzy
@@ -12728,9 +12717,8 @@ msgid "Enable pre-reload use of cbranchsi pattern"
 msgstr "启用 cbranchdi4 样式"
 
 #: config/arc/arc.opt:257
-#, fuzzy
 msgid "Enable bbit peephole2"
-msgstr "启用预处理"
+msgstr "启用 bbit peephole2"
 
 #: config/arc/arc.opt:261
 msgid "Use pc-relative switch case tables - this enables case table shortening."
@@ -13407,9 +13395,8 @@ msgid "Map one directory name to another in debug information"
 msgstr "在调试信息中将一个目录名映射到另一个"
 
 #: common.opt:1054
-#, fuzzy
 msgid "Output .debug_types section when using DWARF v4 debuginfo."
-msgstr "输出.debugtypes 区段时使用 DWARF v4 debuginfo(_T)。"
+msgstr "使用 DWARF v4 debuginfo 时输出 .debug_types 区段。"
 
 #: common.opt:1060
 msgid "Defer popping functions args from stack until later"
@@ -54216,9 +54203,9 @@ msgstr "不能设置只读属性"
 #. underlying instance variable could be a bitfield, but that is
 #. a different matter.
 #: objc/objc-act.c:955
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "property can not be a bit-field"
-msgstr "不能设置只读属性"
+msgstr "属性不能是一个位段"
 
 #: objc/objc-act.c:987
 #, fuzzy, gcc-internal-format
@@ -54309,9 +54296,9 @@ msgid "class %qE is deprecated"
 msgstr "已弃用类%qE"
 
 #: objc/objc-act.c:1735
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "could not find setter/getter for %qE in class %qE"
-msgstr "找不到类%qE的接口"
+msgstr "类 %2$qE 中找不到 %1$qE 的存取器。"
 
 #: objc/objc-act.c:1771
 #, gcc-internal-format
@@ -54513,14 +54500,14 @@ msgid "%<@throw%> (rethrow) used outside of a @catch block"
 msgstr "在 @catch 块外使用%<@throw%>(rethrow)"
 
 #: objc/objc-act.c:4374
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<@throw%> argument is not an object"
-msgstr "对常量对象的写操作(实参 %d)"
+msgstr "%<@throw%> 参数不是一个对象"
 
 #: objc/objc-act.c:4395
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<@synchronized%> argument is not an object"
-msgstr "级别 2 尚未同步"
+msgstr "%<@synchronized%> 参数不是一个对象"
 
 #: objc/objc-act.c:4603
 #, gcc-internal-format
@@ -54591,9 +54578,9 @@ msgstr "也找到了%<%c%s%>"
 #. class, or cast the receiver to 'id'.  Note that
 #. rtype is an IDENTIFIER_NODE at this point.
 #: objc/objc-act.c:5428 objc/objc-act.c:5562
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "@interface of class %qE not found"
-msgstr "找不到类%qE的接口"
+msgstr "找不到类 %qE 的 @interface"
 
 #: objc/objc-act.c:5436
 #, gcc-internal-format
@@ -54892,9 +54879,9 @@ msgstr "%<@dynamic%> 在 Objective-C 1.0 里不可用"
 #. "misplaced '@dynamic' Objective-C++ construct" and skips the
 #. declaration.
 #: objc/objc-act.c:7853
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<@dynamic%> not in @implementation context"
-msgstr "实现上下文中缺少%<@end%>"
+msgstr "@implemention 上下文中缺少 %<@dynamic%>"
 
 #: objc/objc-act.c:7875
 #, fuzzy, gcc-internal-format
@@ -54958,9 +54945,9 @@ msgstr "%qE的局部声明隐藏了实例变量"
 #. should be impossible for real properties, which always
 #. have a getter.
 #: objc/objc-act.c:9468
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "no %qs getter found"
-msgstr "找不到字段%qs。"
+msgstr "找不到 %qs 的取值器"
 
 #: objc/objc-act.c:9708
 #, gcc-internal-format
@@ -54968,9 +54955,9 @@ msgid "fast enumeration is not available in Objective-C 1.0"
 msgstr "快速枚举在 Objective-C 1.0 里不可用"
 
 #: objc/objc-act.c:9718
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "iterating variable in fast enumeration is not an object"
-msgstr "迭代变量在中快速枚举类型不是对象"
+msgstr "快速枚举中的迭代变量不是对象"
 
 #: objc/objc-act.c:9724
 #, fuzzy, gcc-internal-format
@@ -54980,7 +54967,7 @@ msgstr "快速枚举在 Objective-C 1.0 里不可用"
 #: objc/objc-encoding.c:142
 #, gcc-internal-format
 msgid "type %qT does not have a known size"
-msgstr "类型%qT大小未知"
+msgstr "类型 %qT 大小未知"
 
 #: objc/objc-encoding.c:730
 #, fuzzy, gcc-internal-format
@@ -54989,9 +54976,9 @@ msgstr "未知类型 %<%T%>找到在的期间 Objective-C 编码"
 
 #. Do not do any encoding, produce an error and keep going.
 #: objc/objc-encoding.c:813
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "trying to encode non-integer type as a bitfield"
-msgstr "尝试编码 non-integer 类型作为 bitfield"
+msgstr "尝试将未整数类型编码为位段（bitfield）"
 
 #: objc/objc-gnu-runtime-abi-01.c:143
 #, gcc-internal-format
diff --git a/gcc/shrink-wrap.c b/gcc/shrink-wrap.c
index 3928f3d..63be1bd 100644
--- a/gcc/shrink-wrap.c
+++ b/gcc/shrink-wrap.c
@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "shrink-wrap.h"
 #include "regcprop.h"
 #include "rtl-iter.h"
+#include "valtrack.h"
 
 #ifdef HAVE_simple_return
 
@@ -191,7 +192,8 @@ static bool
 move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
 			   const HARD_REG_SET uses,
 			   const HARD_REG_SET defs,
-			   bool *split_p)
+			   bool *split_p,
+			   struct dead_debug_local *debug)
 {
   rtx set, src, dest;
   bitmap live_out, live_in, bb_uses, bb_defs;
@@ -200,6 +202,8 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
   unsigned int end_sregno = FIRST_PSEUDO_REGISTER;
   basic_block next_block;
   edge live_edge;
+  rtx_insn *dinsn;
+  df_ref def;
 
   /* Look for a simple register assignment.  We don't use single_set here
      because we can't deal with any CLOBBERs, USEs, or REG_UNUSED secondary
@@ -344,6 +348,20 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
      move it as far as we can.  */
   do
     {
+      if (MAY_HAVE_DEBUG_INSNS)
+	{
+	  FOR_BB_INSNS_REVERSE (bb, dinsn)
+	    if (DEBUG_INSN_P (dinsn))
+	      {
+		df_ref use;
+		FOR_EACH_INSN_USE (use, dinsn)
+		  if (refers_to_regno_p (dregno, end_dregno,
+					 DF_REF_REG (use), (rtx *) NULL))
+		    dead_debug_add (debug, use, DF_REF_REGNO (use));
+	      }
+	    else if (dinsn == insn)
+	      break;
+	}
       live_out = df_get_live_out (bb);
       live_in = df_get_live_in (next_block);
       bb = next_block;
@@ -426,6 +444,12 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
 	SET_REGNO_REG_SET (bb_uses, i);
     }
 
+  /* Insert debug temps for dead REGs used in subsequent debug insns.  */
+  if (debug->used && !bitmap_empty_p (debug->used))
+    FOR_EACH_INSN_DEF (def, insn)
+      dead_debug_insert_temp (debug, DF_REF_REGNO (def), insn,
+			      DEBUG_TEMP_BEFORE_WITH_VALUE);
+
   emit_insn_after (PATTERN (insn), bb_note (bb));
   delete_insn (insn);
   return true;
@@ -446,6 +470,8 @@ prepare_shrink_wrap (basic_block entry_block)
   HARD_REG_SET uses, defs;
   df_ref def, use;
   bool split_p = false;
+  unsigned int i;
+  struct dead_debug_local debug;
 
   if (JUMP_P (BB_END (entry_block)))
     {
@@ -456,19 +482,22 @@ prepare_shrink_wrap (basic_block entry_block)
       copyprop_hardreg_forward_bb_without_debug_insn (entry_block);
     }
 
+  dead_debug_local_init (&debug, NULL, NULL);
   CLEAR_HARD_REG_SET (uses);
   CLEAR_HARD_REG_SET (defs);
+
   FOR_BB_INSNS_REVERSE_SAFE (entry_block, insn, curr)
     if (NONDEBUG_INSN_P (insn)
 	&& !move_insn_for_shrink_wrap (entry_block, insn, uses, defs,
-				       &split_p))
+				       &split_p, &debug))
       {
 	/* Add all defined registers to DEFs.  */
 	FOR_EACH_INSN_DEF (def, insn)
 	  {
 	    x = DF_REF_REG (def);
 	    if (REG_P (x) && HARD_REGISTER_P (x))
-	      SET_HARD_REG_BIT (defs, REGNO (x));
+	      for (i = REGNO (x); i < END_REGNO (x); i++)
+		SET_HARD_REG_BIT (defs, i);
 	  }
 
 	/* Add all used registers to USESs.  */
@@ -476,9 +505,12 @@ prepare_shrink_wrap (basic_block entry_block)
 	  {
 	    x = DF_REF_REG (use);
 	    if (REG_P (x) && HARD_REGISTER_P (x))
-	      SET_HARD_REG_BIT (uses, REGNO (x));
+	      for (i = REGNO (x); i < END_REGNO (x); i++)
+		SET_HARD_REG_BIT (uses, i);
 	  }
       }
+
+  dead_debug_local_finish (&debug, NULL);
 }
 
 /* Create a copy of BB instructions and insert at BEFORE.  Redirect
diff --git a/gcc/stmt.c b/gcc/stmt.c
index 45dc45f..6c62a12 100644
--- a/gcc/stmt.c
+++ b/gcc/stmt.c
@@ -342,13 +342,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,
 	else if (insn_extra_memory_constraint (cn))
 	  *allows_mem = true;
 	else
-	  {
-	    /* Otherwise we can't assume anything about the nature of
-	       the constraint except that it isn't purely registers.
-	       Treat it like "g" and hope for the best.  */
-	    *allows_reg = true;
-	    *allows_mem = true;
-	  }
+	  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);
 	break;
       }
 
@@ -465,13 +459,7 @@ parse_input_constraint (const char **constraint_p, int input_num,
 	else if (insn_extra_memory_constraint (cn))
 	  *allows_mem = true;
 	else
-	  {
-	    /* Otherwise we can't assume anything about the nature of
-	       the constraint except that it isn't purely registers.
-	       Treat it like "g" and hope for the best.  */
-	    *allows_reg = true;
-	    *allows_mem = true;
-	  }
+	  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);
 	break;
       }
 
diff --git a/gcc/targhooks.c b/gcc/targhooks.c
index 0c14103..003e9ef 100644
--- a/gcc/targhooks.c
+++ b/gcc/targhooks.c
@@ -1312,8 +1312,12 @@ bool
 default_target_option_pragma_parse (tree ARG_UNUSED (args),
 				    tree ARG_UNUSED (pop_target))
 {
-  warning (OPT_Wpragmas,
-	   "#pragma GCC target is not supported for this machine");
+  /* If args is NULL the caller is handle_pragma_pop_options ().  In that case,
+     emit no warning because "#pragma GCC pop_target" is valid on targets that
+     do not have the "target" pragma.  */
+  if (args)
+    warning (OPT_Wpragmas,
+	     "#pragma GCC target is not supported for this machine");
 
   return false;
 }
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 8f98975..a4e1d8d 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,988 @@
+2016-03-10  Alan Modra  <amodra@gmail.com>
+
+	* gcc.dg/pr69195.c: New.
+	* gcc.dg/pr69238.c: New.
+
+2016-03-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/69423
+	* gfortran.dg/deferred_character_15.f90 : New test.
+
+2016-03-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/49630
+	* gfortran.dg/deferred_character_13.f90: New test for the fix
+	of comment 3 of the PR.
+
+	Backport from trunk.
+	PR fortran/54070
+	* gfortran.dg/deferred_character_8.f90: New test
+	* gfortran.dg/allocate_error_5.f90: New test
+
+	Backport from trunk.
+	PR fortran/60593
+	* gfortran.dg/deferred_character_10.f90: New test
+
+	Backport from trunk.
+	PR fortran/60795
+	* gfortran.dg/deferred_character_14.f90: New test
+
+	Backport from trunk.
+	PR fortran/61147
+	* gfortran.dg/deferred_character_11.f90: New test
+
+	Backport from trunk.
+	PR fortran/64324
+	* gfortran.dg/deferred_character_9.f90: New test
+
+2016-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69666
+	PR middle-end/69920
+	* gcc.dg/torture/pr69932.c: New test.
+	* gcc.dg/torture/pr69936.c: Likewise.
+
+2016-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* g++.dg/template/typename21.C: Remove c++98_only.
+
+2016-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* g++.dg/template/typename21.C: Replace c++98 with c++98_only.
+
+2016-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70059
+	* gcc.target/i386/avx512f-pr70059.c: New test.
+	* gcc.target/i386/avx512dq-pr70059.c: New test.
+
+2016-03-03  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2015-10-14  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* gcc.dg/pragma-pop_options-1.c: New test.
+
+2016-03-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/gcc-gdb-test.exp (gdb-test): Make log message match command.
+	Invoke gdb with -batch.
+	* lib/gcc-simulate-thread.exp (simulate-thread): Likewise.
+
+2016-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2015-11-25  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* g++.dg/cpp0x/constexpr-array13.C: Fix.
+
+2016-03-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/i386/pr70007.c: Tweak.
+
+2016-03-02  Markus Trippelsdorf  <markus@trippelsdorf.de>
+	    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/68087
+	* g++.dg/cpp0x/constexpr-array13.C: New.
+
+2016-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/i386/pr70007.c: New test.
+
+2016-02-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/60126
+	* gfortran.dg/pr60126.f90: New test.
+
+2016-02-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-02-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR tree-optimization/69989
+	* gcc.dg/torture/pr69989.c: New test.
+
+2016-02-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61156
+	* gfortran.dg/include_6.f90: Update test.
+
+2016-02-27  Jeff Law  <law@redhat.com>
+
+	Revert
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/69740
+	* gcc.c-torture/compile/pr69740-1.c: New test.
+	* gcc.c-torture/compile/pr69740-2.c: New test.
+
+2016-02-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61156
+	* gfortran.dg/include_6.f90: Update test.
+
+2016-02-26  Richard Biener  <rguenther@suse.de>
+	    Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-02-26  Richard Biener  <rguenther@suse.de>
+		    Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/69740
+	* gcc.c-torture/compile/pr69740-1.c: New test.
+	* gcc.c-torture/compile/pr69740-2.c: New test.
+
+2016-02-26  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	PR target/61397
+	2016-02-26  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/p8vector-ldst.c: Adjust to test desired
+	functionality for both 32-bit and 64-bit.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-23  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/md/movstr-2.c: Move and rename to ...
+	* gcc.target/s390/vector/stpcpy-1.c: ... this one.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-23  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/md/movstr-1.c: Turn into compile test.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/vector/int128-1.c: New test.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/vector/vec-vcond-1.c: New test.
+
+2016-02-25  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/md/movstr-2.c: New test.
+
+2016-02-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-19  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	PR target/69625
+	* gcc.target/s390/pr69625.c: Add test case.
+
+2016-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69776
+	* gcc.dg/torture/pr69776.c: New testcase.
+
+	2016-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69776
+	* gcc.dg/torture/pr69776-2.c: New testcase.
+
+2016-02-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69719
+	* gcc.dg/torture/pr69719.c: New testcase.
+
+	2016-02-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69783
+	* gcc.dg/vect/pr69783.c: New testcase.
+
+2016-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/65996
+	* gfortran.dg/pr65996.f90: New test.
+
+2016-02-23  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69666
+	* gcc.dg/tree-ssa/pr69666.c: New test.
+
+2016-02-21  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/57365
+	gfortran.dg/allocate_with_source_18.f03: New test.
+
+2016-02-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/52531
+	gfortran.dg/gomp/pr52531.f90: New test.
+
+2016-02-20  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2016-02-18  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR testsuite/68580
+	* c-c++-common/tsan/pr65400-1.c (v, q, o): Make 8-byte aligned.
+
+2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vec-cg.c: New test.
+
+2016-02-17  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR c/69522
+	* gcc.dg/pr69522.c: New test.
+
+2016-02-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/atomic8.adb: New test.
+
+2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR tree-optimization/69714
+	* gcc.dg/torture/pr69714.c: New test.
+
+2016-02-16  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/65932
+	* gcc.target/arm/wmul-1.c: Add -mtune=cortex-a9 to dg-options.
+	xfail the scan-assembler test.
+	* gcc.target/arm/wmul-2.c: Likewise.
+	* gcc.target/arm/wmul-3.c: Simplify test to generate a single smulbb.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* gcc.dg/lto/simd-function_0.c: New test.
+
+2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR libgfortran/69668
+	* gfortran.dg/namelist_38.f90: Update test.
+	* gfortran.dg/namelist_84.f90: Update test.
+
+2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR libgfortran/69651
+	PR libgfortran/69668
+	* gfortran.dg/read_bang.f90: New test.
+	* gfortran.dg/read_bang4.f90: New test.
+	* gfortran.dg/namelist_87.f90: New test.
+	* gfortran.dg/namelist_88.f90: New test.
+
+2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/67260
+	* gcc.target/sh/torture/pr67260.c: New.
+
+2016-02-12  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	Backported from mainline
+	2015-12-02  Tobias Burnus  <burnus@net-b.de>
+	Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>
+
+	* gfortran.dg/coarray/event_1.f90: New.
+	* gfortran.dg/coarray/event_2.f90: New.
+
+2016-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69574
+	* gcc.dg/torture/pr69574.c: New testcase.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69579
+	* gcc.dg/setjmp-6.c: New testcase.
+
+	2016-02-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69606
+	* gcc.dg/torture/pr69606.c: New testcase.
+
+	2016-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69715
+	* gcc.dg/torture/pr69715.c: New testcase.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/59627
+	* g++.dg/gomp/pr59627.C: New test.
+
+	2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/69669
+	* c-c++-common/pr69669.c: New test.
+
+	2016-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69546
+	* gcc.dg/torture/pr69546.c: New test.
+
+	2016-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69399
+	* gcc.dg/torture/pr69399.c: New test.
+
+	2016-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69432
+	* g++.dg/opt/pr69432.C: New test.
+
+	2016-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69187
+	PR target/65624
+	* gcc.target/arm/pr69187.c: New test.
+
+	PR middle-end/67653
+	* c-c++-common/pr67653.c: New test.
+	* gcc.dg/torture/pr29119.c: Add dg-warning.
+
+	2016-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/65779
+	* gcc.dg/pr65779.c: New test.
+
+	PR rtl-optimization/68955
+	PR rtl-optimization/64557
+	* gcc.dg/torture/pr68955.c: New test.
+
+	2016-01-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69214
+	* gcc.c-torture/compile/pr69214.c: New test.
+
+	2016-01-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/69128
+	* gfortran.dg/gomp/pr69128.f90: New test.
+
+	2016-01-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/69055
+	* gfortran.dg/pr69055.f90: New test.
+
+	PR target/69015
+	* gcc.dg/pr69015.c: New test.
+
+	2015-12-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/67376
+	* g++.dg/cpp0x/constexpr-67376.C: New test.
+
+	2015-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/57580
+	* c-c++-common/cpp/pr57580.c: New test.
+	* c-c++-common/gomp/pr57580.c: New test.
+
+2016-02-09  Alexander Fomin  <alexander.fomin@intel.com>
+
+	Backport from mainline
+	2016-02-09  Alexander Fomin  <alexander.fomin@intel.com>
+
+	* gcc.target/i386/avx512f-klogic-2.c: Adjust expectation.
+
+2016-02-09  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR middle-end/65702
+	* c-c++-common/pr67639.c: New test.
+
+2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69644
+	* gcc.dg/pr69644.c: New test.
+
+2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/67451
+	PR fortran/69418
+	* gfortran.dg/coarray_allocate_2.f08: New test.
+	* gfortran.dg/coarray_allocate_3.f08: New test.
+	* gfortran.dg/coarray_allocate_4.f08: New test.
+
+2016-02-02  Alan Modra  <amodra@gmail.com>
+
+	PR target/69548
+	* gcc.target/powerpc/pr69548.c: New test.
+
+2016-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+	PR target/68986
+	* gcc.target/i386/pr68986-1.c: New test.
+	* gcc.target/i386/pr68986-2.c: Likewise.
+	* gcc.target/i386/pr68986-3.c: Likewise.
+
+2016-01-30  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/66707
+	gfortran.dg/common_23.f90: New test.
+
+	Backport from trunk.
+	2015-08-08  Bud Davis  <jmdavis@link.com>
+		    Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/59746
+	* gfortran.dg/common_22.f90: New.
+
+2016-01-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/65546
+	* gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: Correct
+	condition being checked, and disable it when the target supports
+	misaligned loads and stores.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69459
+	* gcc.target/i386/pr69459.c: New test.
+
+2016-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69551
+	* gcc.target/i386/pr69551.c: New test.
+
+2016-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/69542
+	* gcc.dg/torture/pr69542.c: New test.
+
+2016-01-28  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69355
+	* gcc.dg/tree-ssa/pr69355.c: New test.
+
+2016-01-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/62536
+	* gfortran.dg/block_14.f08: New test.
+
+2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2016-01-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68062
+	* c-c++-common/vector-compare-4.c: New test.
+
+2016-01-27  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/69268
+	* gfortran.dg/allocatable_scalar_13.f90: Fixing counts of malloc/
+	free to fit the actual number of calls.
+	* gfortran.dg/allocate_with_source_16.f90: New test.
+
+2016-01-27  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/autopar/pr69110.c: Fix pass number.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* gcc.dg/autopar/pr69110.c: New test.
+
+2016-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR fortran/61831
+	* gfortran.dg/derived_constructor_comps_6.f90: Add missing } to fix
+	up dg-additional-options.
+
+2016-01-25  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/68283
+	gfortran.dg/pr68283.f90: New test.
+
+2016-01-23  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69426
+	* gcc.dg/autopar/pr69426.c: New test.
+
+2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69403
+	* gcc.c-torture/execute/pr69403.c: New test.
+
+2016-01-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/gpr2fprsavecfi.c: New test.
+
+2016-01-21  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2016-01-08  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/67781
+	* gcc.c-torture/execute/pr67781.c: New file.
+
+2016-01-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2016-01-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR testsuite/69366
+	* g++.dg/pr63995-1.C: Require non-x32 target, instead of,
+	the MPX run-time library, for compile-time MPX test.
+	* gcc.target/i386/chkp-always_inline.c: Likewise.
+	* gcc.target/i386/chkp-bndret.c: Likewise.
+	* gcc.target/i386/chkp-builtins-1.c: Likewise.
+	* gcc.target/i386/chkp-builtins-2.c: Likewise.
+	* gcc.target/i386/chkp-builtins-3.c: Likewise.
+	* gcc.target/i386/chkp-builtins-4.c: Likewise.
+	* gcc.target/i386/chkp-const-check-1.c: Likewise.
+	* gcc.target/i386/chkp-const-check-2.c: Likewise.
+	* gcc.target/i386/chkp-hidden-def.c: Likewise.
+	* gcc.target/i386/chkp-label-address.c: Likewise.
+	* gcc.target/i386/chkp-lifetime-1.c: Likewise.
+	* gcc.target/i386/chkp-narrow-bounds.c: Likewise.
+	* gcc.target/i386/chkp-remove-bndint-1.c: Likewise.
+	* gcc.target/i386/chkp-remove-bndint-2.c: Likewise.
+	* gcc.target/i386/chkp-strchr.c: Likewise.
+	* gcc.target/i386/chkp-strlen-1.c: Likewise.
+	* gcc.target/i386/chkp-strlen-2.c: Likewise.
+	* gcc.target/i386/chkp-strlen-3.c: Likewise.
+	* gcc.target/i386/chkp-strlen-4.c: Likewise.
+	* gcc.target/i386/chkp-strlen-5.c: Likewise.
+	* gcc.target/i386/chkp-stropt-1.c: Likewise.
+	* gcc.target/i386/chkp-stropt-10.c: Likewise.
+	* gcc.target/i386/chkp-stropt-11.c: Likewise.
+	* gcc.target/i386/chkp-stropt-12.c: Likewise.
+	* gcc.target/i386/chkp-stropt-13.c: Likewise.
+	* gcc.target/i386/chkp-stropt-14.c: Likewise.
+	* gcc.target/i386/chkp-stropt-15.c: Likewise.
+	* gcc.target/i386/chkp-stropt-16.c: Likewise.
+	* gcc.target/i386/chkp-stropt-2.c: Likewise.
+	* gcc.target/i386/chkp-stropt-3.c: Likewise.
+	* gcc.target/i386/chkp-stropt-4.c: Likewise.
+	* gcc.target/i386/chkp-stropt-5.c: Likewise.
+	* gcc.target/i386/chkp-stropt-6.c: Likewise.
+	* gcc.target/i386/chkp-stropt-7.c: Likewise.
+	* gcc.target/i386/chkp-stropt-8.c: Likewise.
+	* gcc.target/i386/chkp-stropt-9.c: Likewise.
+	* gcc.target/i386/pr63995-2.c: Likewise.
+	* gcc.target/i386/pr64805.c: Likewise.
+	* gcc.target/i386/pr65044.c: Likewise.
+	* gcc.target/i386/pr65167.c: Likewise.
+	* gcc.target/i386/pr65183.c: Likewise.
+	* gcc.target/i386/pr65184.c: Likewise.
+	* gcc.target/i386/thunk-retbnd.c: Likewise.
+
+2016-01-20  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68513
+	* gcc.dg/pr68513.c: New test.
+
+2016-01-19  Sergei Trofimovich <siarheit@google.com>
+
+	Backport from mainline
+	PR other/60465
+	* gcc.target/ia64/pr60465-gprel64.c: New test.
+	* gcc.target/ia64/pr60465-gprel64-c37.c: New test.
+
+2016-01-19  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2016-01-12  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/67755
+	* gcc.dg/tree-ssa/pr67755.c: New test.
+
+2016-01-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR testsuite/68820
+	* gcc.c-torture/execute/builtins/memops-asm.x: New file.
+	* gcc.c-torture/execute/builtins/strstr-asm.x: Ditto.
+	* gcc.c-torture/execute/builtins/strstr-asm.c: Remove dg-options.
+
+2016-01-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2016-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/68965
+	* g++.dg/cpp1y/parameter-pack-1.C: New test.
+	* g++.dg/cpp1y/parameter-pack-2.C: New test.
+
+2016-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69135
+	* gcc.target/arm/pr69135_1.c: New test.
+
+2016-01-18  Alexander Fomin  <alexander.fomin@intel.com>
+
+	Backport from mainline
+	2015-10-09  Alexander Fomin  <alexander.fomin@intel.com>
+
+	PR target/67895
+	* gcc.target/i386/avx512dq-vrangepd-1.c: Adjust.
+	* gcc.target/i386/avx512dq-vrangeps-1.c: Likewise.
+	* gcc.target/i386/avx512dq-vrangesd-1.c: Likewise.
+	* gcc.target/i386/avx512dq-vrangess-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtsi2sd64-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtsi2ss-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtsi2ss64-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtusi2sd64-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtusi2ss-1.c: Likewise.
+	* gcc.target/i386/avx512f-vcvtusi2ss64-1.c: Likewise.
+
+2016-01-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2016-01-06  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69140
+	* gcc.target/i386/pr69140.c: New test
+
+2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/inline12.adb: New test.
+
+2016-01-17  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/61831
+	* gfortran.dg/derived_constructor_components_6.f90: New file.
+	* gfortran.dg/allocate_with_source_14.f03: Change count of
+	__builtin_malloc from 21 to 23.
+
+2016-01-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/66082
+	* gfortran.dg/alloc_comp_auto_array_3.f90: New file. Count of
+	__builtin_malloc increased from 3 to 4, relative to trunk.
+
+2016-01-17  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2016-01-12  Kugan Vivekanandarajah  <kuganv@linaro.org>
+		    Jim Wilson  <jim.wilson@linaro.org>
+
+	PR target/69194
+	* gcc.target/arm/pr69194.c: New test.
+
+2016-01-15  Alexander Fomin  <alexander.fomin@intel.com>
+
+	Backport from mainline
+	2016-01-13  Alexander Fomin  <alexander.fomin@intel.com>
+
+	PR target/69228
+	* gcc.target/i386/avx512pf-vscatterpf0dpd-1.c: Adjust.
+	* gcc.target/i386/avx512pf-vscatterpf0dps-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf0qpd-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf0qps-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf1dpd-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf1dps-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf1qpd-1.c: Likewise.
+	* gcc.target/i386/avx512pf-vscatterpf1qps-1.c: Likewise.
+
+2016-01-12  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline r222186.
+	2015-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/65689
+	* gcc.target/aarch64/c-output-template-4.c: New test.
+
+2015-01-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline.
+	PR fortran/50221
+	* gfortran.dg/deferred_character_1.f90: New test.
+	* gfortran.dg/deferred_character_4.f90: New test for comment
+	#4 of the PR.
+
+	Backport from mainline.
+	PR fortran/68216
+	* gfortran.dg/deferred_character_2.f90: New test.
+
+	Backport from mainline.
+	PR fortran/67674
+	* gfortran.dg/deferred_character_3.f90: New test.
+
+	Backport from mainline.
+	PR fortran/63932
+	* gfortran.dg/deferred_character_5.f90: New test.
+
+	Backport from mainline.
+	PR fortran/66408
+	* gfortran.dg/deferred_character_6.f90: New test.
+
+	Backport from mainline.
+	PR fortran/49954
+	* gfortran.dg/deferred_character_7.f90: New test.
+
+	Backport from mainline.
+	PR fortran/67779
+	* gfortran.dg/actual_array_offset_1: New test.
+
+2016-01-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/68449
+	* g++.dg/pr68449.C: New.
+
+2016-01-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-12-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/68851
+	* g++.dg/ipa/pr68851.C: New test.
+
+2016-01-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68648
+	* gcc.c-torture/execute/pr68648.c: New test.
+
+2015-12-31  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	* gcc.target/i386/avx512f-vbroadcastsd-3.c: New test.
+
+2015-12-30  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/69037
+	Backport from mainline:
+
+	2015-12-07  Marek Polacek  <polacek@redhat.com>
+
+	PR c/68668
+	* gcc.dg/pr68668.c: New test.
+
+2015-12-30  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/68987
+	* gfortran.dg/error_format_2.f90: New test.
+
+2015-12-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* gfortran.dg/coarray_40.f90: Link with libatomic if available.
+	* gfortran.dg/coarray_lib_comm_1.f90: Revise to use
+	dg-additional-options.
+
+2015-12-30  Kirill Yukhin  <kirill.yukhin@intel.com>
+
+	* gcc.target/i386/avx-vextractf128-256-5.c: New test.
+	* gcc.target/i386/avx512vl-vextractf32x4-1.c: Fix scan pattern.
+	* gcc.target/i386/avx512vl-vextracti32x4-1.c: Ditto.
+
+2015-12-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	* gcc.dg/torture/pr67609.c: Add -fno-common option on hppa*-*-hpux*.
+
+2015-12-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	PR target/68872
+	* gcc.target/powerpc/pr68872.c: New test.
+
+2015-12-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20151219-1.c: New test.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/zvector/vec-splat-2.c: New test.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/vector/vec-vrepi-1.c: New test.
+
+2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/zvector/vec-splat-1.c: New test.
+
+2015-12-18  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-12-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68835
+	* gcc.dg/pr68835-1.c: New test.
+	* gcc.dg/pr68835-2.c: New test.
+
+2015-12-16  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/68162
+	* gcc.dg/pr68162-1.c: New test.
+
+2015-12-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-12-02  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/68184
+	* g++.dg/torture/pr68184.C: New testcase.
+
+2015-12-15  Alessandro Fanfarillo  <fanfarillo@gmail.com>
+
+	Backport from mainline.
+	2015-12-15
+	Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+	* gfortran.dg/coarray_critical_1.f90: New.
+
+2015-12-14  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+	Backport from mainline.
+	2015-12-09  Tobias Burnus  <burnus@net-b.de>
+	    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+	* gfortran.dg/coarray_40.f90: New.
+
+2015-12-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/66616
+	* g++.dg/ipa/pr66616.C: New test.
+
+2015-12-14  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline.
+	2015-12-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	PR rtl-optimization/67609
+	* gcc.dg/torture/pr67609.c: New.
+
+2015-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68376
+	PR rtl-optimization/68670
+	* gcc.c-torture/execute/pr68376-2.c (f5, f6, f7, f8): New
+	tests.
+	(main): Call them.
+	* gcc.dg/pr68670-1.c: New test.
+	* gcc.dg/pr68670-2.c: New test.
+
+2015-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-12-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/68701
+	* gcc.target/i386/pr68701-1.c: New test.
+	* gcc.target/i386/pr68701-2.c: Ditto.
+
+2015-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/sse4_1-roundps-1.c: Remove ASM_SUFFIX define.
+	* gcc.target/i386/sse4_1-roundps-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundps-3.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-1.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-3.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-1.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-3.c: Ditto.
+
+2015-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/sse4_1-round.h (do_round): Fix inline asm statements.
+	* gcc.target/i386/sse4_1-roundsd-4.c (do_round): Ditto.
+	* gcc.target/i386/sse4_1-roundss-4.c (do_round): Ditto.
+
+2015-12-09  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2015-12-09  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/68790
+	* gcc.dg/ipa/pr68790.c: New test.
+
+2015-12-07  Martin Liska  <mliska@suse.cz>
+
+	* g++.dg/ipa/pr66896.C: New test.
+
+2015-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2015-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68680
+	* gcc.target/i386/pr68680.c: New test.
+
+	PR tree-optimization/68671
+	* gcc.dg/pr68671.c: New test.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
@@ -328,7 +1313,7 @@
 2015-11-06  Vladimir Makarov  <vmakarov@redhat.com>
 
 	PR rtl-optimization/68106
-	* testsuite/gcc.target/aarch64/pr68106.c: New.
+	* gcc.target/aarch64/pr68106.c: New.
 
 2015-01-25  Paul Thomas  <pault@gcc.gnu.org>
 
@@ -448,8 +1433,8 @@
 	Backport from mainline
 	2015-10-09  Martin Jambor  <mjambor@suse.cz>
 
-        * gcc.dg/ipa/ipa-sra-10.c: New test.
-        * gcc.dg/torture/pr67794.c: Likewise.
+	* gcc.dg/ipa/ipa-sra-10.c: New test.
+	* gcc.dg/torture/pr67794.c: Likewise.
 
 2015-10-22  Paul Thomas  <pault@gcc.gnu.org>
 
@@ -1254,10 +2239,6 @@
 	PR fortran/66725
 	* gfortran.dg/pr66725.f90: New test.
 
-2015-07-16  Martin Liska  <mliska@suse.cz>
-
-	* g++.dg/ipa/pr66896.c: New test.
-
 2015-07-16  Marek Polacek  <polacek@redhat.com>
 
 	Backported from mainline
@@ -3574,7 +4555,7 @@
 
 2015-03-05  Martin Sebor  <msebor@redhat.com>
 
-	* PR testsuite/63175
+	PR testsuite/63175
 	* gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c (main1): Move
 	checking of results into main to prevent it from getting optimized
 	away.
diff --git a/gcc/testsuite/c-c++-common/cpp/pr57580.c b/gcc/testsuite/c-c++-common/cpp/pr57580.c
new file mode 100644
index 0000000..1039e21
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr57580.c
@@ -0,0 +1,9 @@
+/* PR preprocessor/57580 */
+/* { dg-do compile } */
+/* { dg-options "-save-temps" } */
+
+#define MSG 	\
+  _Pragma("message(\"message0\")")	\
+  _Pragma("message(\"message1\")")
+MSG	/* { dg-message "message0" } */
+/* { dg-message "message1" "" { target *-*-* } 8 } */
diff --git a/gcc/testsuite/c-c++-common/gomp/pr57580.c b/gcc/testsuite/c-c++-common/gomp/pr57580.c
new file mode 100644
index 0000000..9bbe707
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr57580.c
@@ -0,0 +1,36 @@
+/* PR preprocessor/57580 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -save-temps -fdump-tree-gimple" } */
+
+#define PS \
+  _Pragma("omp parallel num_threads(2)") \
+  { \
+    _Pragma("omp single") \
+    { \
+      ret = 0; \
+    } \
+  }
+
+int
+main ()
+{
+  int ret;
+  _Pragma("omp parallel num_threads(3)")
+  {
+    _Pragma("omp single")
+    {
+      ret = 0;
+    }
+  }
+  _Pragma("omp parallel num_threads(4)") { _Pragma("omp single") { ret = 0; } }
+  { _Pragma("omp parallel num_threads(5)") { _Pragma("omp single") { ret = 0; } } }
+  PS
+  PS
+  return ret;
+}
+
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(2\\)" 2 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(3\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(4\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(5\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp single" 5 "gimple" } } */
diff --git a/gcc/testsuite/c-c++-common/pr67639.c b/gcc/testsuite/c-c++-common/pr67639.c
new file mode 100644
index 0000000..aa19ba4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr67639.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+void
+foo (int p)
+{
+  int t; 
+  register long x asm ("rhubarb") = p; /* { dg-error "register name" } */
+  __asm ("" : "=r" (t), "=r" (t), "=r" (t), "=r" (x) : "0" (x));
+}
diff --git a/gcc/testsuite/c-c++-common/pr67653.c b/gcc/testsuite/c-c++-common/pr67653.c
new file mode 100644
index 0000000..1b9f63e
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr67653.c
@@ -0,0 +1,8 @@
+/* PR middle-end/67653 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  __asm__ ("" : : "m" (({ static int a; a; })));	/* { dg-warning "memory input 0 is not directly addressable" } */
+}
diff --git a/gcc/testsuite/c-c++-common/pr69669.c b/gcc/testsuite/c-c++-common/pr69669.c
new file mode 100644
index 0000000..9940afe
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr69669.c
@@ -0,0 +1,10 @@
+/* PR c/69669 */
+/* { dg-do compile } */
+
+enum __attribute__((mode(QI))) E { F = 1 };
+
+void
+foo (enum E *x, int y)
+{
+  *x = (enum E) y;
+}
diff --git a/gcc/testsuite/c-c++-common/tsan/pr65400-1.c b/gcc/testsuite/c-c++-common/tsan/pr65400-1.c
index 96fbbfd..d441ff8 100644
--- a/gcc/testsuite/c-c++-common/tsan/pr65400-1.c
+++ b/gcc/testsuite/c-c++-common/tsan/pr65400-1.c
@@ -7,9 +7,9 @@
 #include "tsan_barrier.h"
 
 static pthread_barrier_t barrier;
-int v;
-int q;
-int o;
+int v __attribute__((aligned(8)));
+int q __attribute__((aligned(8)));
+int o __attribute__((aligned(8)));
 extern void baz4 (int *);
 
 __attribute__((noinline, noclone)) int
diff --git a/gcc/testsuite/c-c++-common/vector-compare-4.c b/gcc/testsuite/c-c++-common/vector-compare-4.c
new file mode 100644
index 0000000..b44f474
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/vector-compare-4.c
@@ -0,0 +1,42 @@
+/* PR c/68062 */
+/* { dg-do compile } */
+/* { dg-options "-Wsign-compare" } */
+
+typedef signed char __attribute__ ((vector_size (4))) v4qi;
+typedef unsigned char __attribute__ ((vector_size (4))) uv4qi;
+typedef signed int __attribute__ ((vector_size (4 * __SIZEOF_INT__))) v4si;
+typedef unsigned int __attribute__ ((vector_size (4 * __SIZEOF_INT__))) uv4si;
+
+v4qi
+fn1 (void)
+{
+  v4qi a = { 1, 2, 3, 4 };
+  uv4qi b = { 4, 3, 2, 1 };
+  v4qi v = { 0, 0, 0, 0 };
+
+  v += (a == b); /* { dg-warning "comparison between types" } */
+  v += (a != b); /* { dg-warning "comparison between types" } */
+  v += (a >= b); /* { dg-warning "comparison between types" } */
+  v += (a <= b); /* { dg-warning "comparison between types" } */
+  v += (a > b); /* { dg-warning "comparison between types" } */
+  v += (a < b); /* { dg-warning "comparison between types" } */
+
+  return v;
+}
+
+v4si
+fn2 (void)
+{
+  v4si a = { 1, 2, 3, 4 };
+  uv4si b = { 4, 3, 2, 1 };
+  v4si v = { 0, 0, 0, 0 };
+
+  v += (a == b); /* { dg-warning "comparison between types" } */
+  v += (a != b); /* { dg-warning "comparison between types" } */
+  v += (a >= b); /* { dg-warning "comparison between types" } */
+  v += (a <= b); /* { dg-warning "comparison between types" } */
+  v += (a > b); /* { dg-warning "comparison between types" } */
+  v += (a < b); /* { dg-warning "comparison between types" } */
+
+  return v;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-pmf1.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-pmf1.C
new file mode 100644
index 0000000..d0ac27d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-pmf1.C
@@ -0,0 +1,16 @@
+// PR c++/67339
+// { dg-do compile { target c++11 } }
+
+template < typename T>
+struct A
+{
+    void foo();
+    template < typename S, typename W >
+        using N = void (T::*)(S, W) const ;
+};
+
+template < typename T>
+void A<T>::foo()
+{
+    typename A<T>::template N<int, int> fun = &T::out;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-67376.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-67376.C
new file mode 100644
index 0000000..41043c8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-67376.C
@@ -0,0 +1,17 @@
+// PR c++/67376
+// { dg-do compile { target c++11 } }
+
+struct A { int e[2]; };
+constexpr A a { { 0, 1 } };
+static_assert (a.e + 1 != a.e, "");
+static_assert (a.e != a.e + 1, "");
+static_assert (a.e + 2 != a.e, "");
+static_assert (a.e != a.e + 2, "");
+static_assert (a.e + 1 > a.e, "");
+static_assert (a.e < a.e + 1, "");
+static_assert (a.e + 2 > a.e, "");
+static_assert (a.e < a.e + 2, "");
+static_assert (a.e + 1 >= a.e, "");
+static_assert (a.e <= a.e + 1, "");
+static_assert (a.e + 2 >= a.e, "");
+static_assert (a.e <= a.e + 2, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-aggr3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-aggr3.C
new file mode 100644
index 0000000..547dec4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-aggr3.C
@@ -0,0 +1,30 @@
+// PR c++/67364
+// { dg-do compile { target c++11 } }
+
+template <typename Xn>
+struct tuple {
+  Xn storage_;
+
+  constexpr tuple(Xn const& xn)
+    : storage_(xn)
+  { }
+
+  template <typename ...dummy>
+  constexpr tuple(tuple const& other)
+    : storage_(other.storage_)
+  { }
+
+  template <typename ...dummy>
+  constexpr tuple(tuple& other)
+    : tuple(const_cast<tuple const&>(other))
+  { }
+};
+
+template <typename T>
+struct wrapper { T value; };
+
+template <typename T>
+constexpr wrapper<T> wrap(T t) { return {t}; }
+
+constexpr wrapper<tuple<int>> t = wrap(tuple<int>{2});
+static_assert(t.value.storage_ == 2, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C
new file mode 100644
index 0000000..b8eb084
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C
@@ -0,0 +1,9 @@
+// PR c++/66921
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct Holder {
+  constexpr static const int array[] = { 1, 2, 3 };
+  enum {F = array[0]};
+};
+class HI: public Holder<int> {};
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-array15.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-array15.C
new file mode 100644
index 0000000..a59e6f5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-array15.C
@@ -0,0 +1,29 @@
+// PR c++/68949
+// { dg-do run { target c++11 } }
+
+struct Sub {
+    int i;
+
+    constexpr Sub() : i(-1) {} // remove constexpr and it works as expected
+    Sub(Sub&& rhs); // remove this constructor and it works as epxected.
+};
+
+// v-- move this inline and it works as expected
+// v-- remove ': Sub()' and it works as expected
+Sub::Sub(Sub&& rhs) : Sub() { int tmp = i; i = rhs.i; rhs.i = tmp; }
+
+struct Class {
+    // v-- remove '[1]' and it works as expected
+    // v-- add '= {}' and it works as expected
+    Sub s[1];
+
+    // v-- add ': s{}' and it works as expected
+    // v-- removing this constructor makes it work as expected
+    Class() {}
+};
+
+int main() {
+    Class c;
+    if (c.s[0].i != -1)
+      __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-empty10.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty10.C
new file mode 100644
index 0000000..694ed3d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty10.C
@@ -0,0 +1,17 @@
+// PR c++/67364
+// { dg-do compile { target c++11 } }
+
+template <typename Xn>
+struct element : Xn {
+  constexpr element() : Xn() { }
+};
+
+template <typename Xn>
+struct closure {
+  element<Xn> member;
+  constexpr closure() { }
+};
+
+struct empty { };
+constexpr closure<empty> tup{};
+constexpr empty first = tup.member;
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-empty11.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty11.C
new file mode 100644
index 0000000..7437367
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty11.C
@@ -0,0 +1,17 @@
+// PR c++/67364
+// { dg-do compile { target c++11 } }
+
+template <typename Xn>
+struct element : Xn {
+  constexpr element() : Xn() { }
+};
+
+template <typename Xn>
+struct closure {
+  element<Xn> member;
+  constexpr closure() { }
+};
+
+struct empty { struct {} s; };
+constexpr closure<empty> tup{};
+constexpr empty first = tup.member;
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-initlist9.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-initlist9.C
new file mode 100644
index 0000000..239b91e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-initlist9.C
@@ -0,0 +1,41 @@
+// PR c++/68585
+// { dg-do compile { target c++11 } }
+
+template<typename T, unsigned N>
+  struct array
+  {
+    T _M_data[N];
+  };
+
+template<typename _Tp, _Tp... _Idx>
+  struct integer_sequence
+  {
+  };
+
+struct Pos
+{
+  unsigned l;
+};
+
+template<class T, T... Ints>
+constexpr array<Pos, sizeof...(Ints)> make_grid_position(integer_sequence<T, Ints...>)
+{
+  return {{ Pos{Ints}... }};
+}
+
+constexpr array<Pos, 1> make_grid_positions()
+{
+  return make_grid_position(integer_sequence<unsigned, 0>{});
+}
+
+template<class T>
+void generate_sudoku(T)
+{
+  constexpr auto positions = make_grid_positions(); // fail
+}
+
+int main()
+{
+  constexpr auto positions = make_grid_positions(); // ok
+  generate_sudoku(1);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-value5.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-value5.C
new file mode 100644
index 0000000..8928b67
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-value5.C
@@ -0,0 +1,18 @@
+// PR c++/68890
+// { dg-do compile { target c++11 } }
+
+class ptr;
+template <long _Nm> struct A { typedef ptr _Type[_Nm]; };
+template <long _Nm> struct B { typename A<_Nm>::_Type _M_elems; };
+template <long N> class FixedVector : B<N> {
+public:
+  typedef B<1> base;
+  constexpr FixedVector() : base(), size_() {}
+  char size_;
+};
+class ptr {
+public:
+  constexpr ptr() : px_(){};
+  int px_;
+};
+FixedVector<1> a;
diff --git a/gcc/testsuite/g++.dg/cpp0x/rv-cast5.C b/gcc/testsuite/g++.dg/cpp0x/rv-cast5.C
new file mode 100644
index 0000000..c2473e2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/rv-cast5.C
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct hold {
+  T value;
+  constexpr T&& operator()() && { return static_cast<T&&>(value); }
+};
+
+int main()
+{
+  hold<bool&&>{42}();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/sfinae56.C b/gcc/testsuite/g++.dg/cpp0x/sfinae56.C
new file mode 100644
index 0000000..0f95432
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/sfinae56.C
@@ -0,0 +1,26 @@
+// PR c++/68926
+// { dg-do compile { target c++11 } }
+
+struct true_type { static constexpr bool value = true; };
+struct false_type { static constexpr bool value = false; };
+
+template<bool Cond> struct enable_if { using type = void; };
+template<> struct enable_if<false> { };
+
+template<typename T, typename U> struct is_same : false_type { };
+template<typename T> struct is_same<T, T> : true_type { };
+
+template<typename T>
+typename enable_if<is_same<int, T>::value>::type
+func();
+
+template<typename T, typename = decltype(func<T>)>
+true_type test(T);
+
+false_type test(...);
+
+int main()
+{
+   decltype(test(0))::value;   // ok
+   decltype(test(0.f))::value; // error
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/union7.C b/gcc/testsuite/g++.dg/cpp0x/union7.C
new file mode 100644
index 0000000..c42d217
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/union7.C
@@ -0,0 +1,15 @@
+// PR c++/69131
+// { dg-do compile { target c++11 } }
+
+struct X
+{
+  ~X() {}
+};
+
+union U
+{
+  X x;
+  ~U() {}
+};
+
+U u;
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic167.C b/gcc/testsuite/g++.dg/cpp0x/variadic167.C
new file mode 100644
index 0000000..cada972
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic167.C
@@ -0,0 +1,18 @@
+// PR c++/69743
+// { dg-do compile { target c++11 } }
+
+template <typename D, typename... T>
+void f(int, T... d)
+{
+}
+
+template <typename D, typename... T>
+void f(T... d)
+{
+  f<D>(1, d...);
+}
+
+void g(void)
+{
+  f<long>(1.0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-array2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-array2.C
new file mode 100644
index 0000000..71b3642
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-array2.C
@@ -0,0 +1,63 @@
+// PR c++/69261
+// { dg-do run { target c++14 } }
+
+typedef __SIZE_TYPE__ size_t;
+
+template <size_t N>
+struct S
+{
+  constexpr S() = default;
+
+  template<size_t M>
+  constexpr S (char const (&d)[M]) : data { 0 }
+  {
+    static_assert (M <= N, "size!");
+    for (size_t i = 0; i != M; i++)
+      data[i] = d[i];
+  }
+  char data[N];
+};
+
+template <int N>
+constexpr S<N>
+s (char const (&d)[N])
+{
+  S<N> c {};
+  for (size_t i = 0; i != N; i++)
+    c.data[i] = d[i];
+  return c;
+}
+
+template <size_t N, size_t M>
+constexpr auto
+concat (S<N> const& s1, S<M> const& s2)
+{
+  S<N+M-1> s (s1.data);
+  for (size_t i = 0; i != M; i++)
+    s.data[N + i - 1] = s2.data[i];
+  return s;
+}
+
+template <size_t N, size_t M>
+constexpr auto
+concat (char const (&x)[N], char const (&y)[M])
+{
+  S<N+M-1> tmp { x };
+  for (size_t i = 0; i != M; i++)
+    tmp.data[N+i-1] = y[i];
+  return tmp;
+}
+
+int
+main ()
+{
+  auto constexpr s1 = s ("bla");
+  auto constexpr s2 = s ("blub");
+  S<8> constexpr s1s2 = concat (s1, s2);
+  auto constexpr c = concat ("bla", "blub");
+  if (__builtin_strcmp (s1.data, "bla")
+      || __builtin_strcmp (s2.data, "blub")
+      || __builtin_strcmp (s1s2.data, "blablub")
+      || __builtin_strcmp (c.data, "blablub"))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-array3.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-array3.C
new file mode 100644
index 0000000..8cea41a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-array3.C
@@ -0,0 +1,43 @@
+// PR c++/69995
+// { dg-do compile { target c++14 } }
+
+#define assert(X) static_assert((X),#X)
+
+#define CONSTEXPR constexpr
+
+template <typename T, unsigned long Size>
+struct array {
+    T elems_[Size];
+
+    constexpr T const& operator[](unsigned long n) const
+    { return elems_[n]; }
+
+    constexpr T& operator[](unsigned long n)
+    { return elems_[n]; }
+};
+
+template <typename T>
+CONSTEXPR void my_swap(T& a, T& b) {
+    T tmp = a;
+    a = b;
+    b = tmp;
+}
+
+CONSTEXPR auto rotate2() {
+    array<array<int, 2>, 2> result{};
+    array<int, 2> a{{0, 1}};
+
+    result[0] = a;
+    my_swap(a[0], a[1]);
+    result[1] = a;
+
+    return result;
+}
+
+int main() {
+    CONSTEXPR auto indices = rotate2();
+    assert(indices[0][0] == 0);
+    assert(indices[0][1] == 1);
+    assert(indices[1][0] == 1);
+    assert(indices[1][1] == 0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-array4.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-array4.C
new file mode 100644
index 0000000..fc01047
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-array4.C
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++14 } }
+
+constexpr bool g()
+{
+  int ar[4] = { 1, 2, 3, 4 };
+  auto e1 = ar;
+  auto e4 = ar+3;
+  return (e4-e1) == 3;
+}
+
+#define SA(X) static_assert((X),#X)
+SA(g());
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-assert2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-assert2.C
new file mode 100644
index 0000000..a329101
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-assert2.C
@@ -0,0 +1,31 @@
+// PR c++/65985
+// { dg-do compile { target c++14 } }
+
+#include <cassert>
+
+class Angle
+{
+  int degrees = 0;
+
+  constexpr auto invariant() const noexcept
+  {
+    return 0 <= degrees && degrees < 360;
+  }
+
+public:
+  explicit constexpr Angle(int n) noexcept
+    : degrees{n % 360}
+  {
+    assert(invariant());
+  }
+
+  /* implicit */ constexpr operator auto() const noexcept
+  {
+    return degrees;
+  }
+};
+
+int main()
+{
+  static_assert(Angle{360} == 0, "");
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-copy2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-copy2.C
new file mode 100644
index 0000000..6707975
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-copy2.C
@@ -0,0 +1,24 @@
+// PR c++/69995
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int i;
+};
+
+constexpr int f(A a)
+{
+  ++a.i;
+  return a.i;
+}
+
+constexpr bool g()
+{
+  A a = { 42 };
+  if (f(a) != 43) return false;
+  if (a.i != 42) return false;
+  return true;
+}
+
+#define SA(X) static_assert((X),#X)
+SA(g());
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-copy3.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-copy3.C
new file mode 100644
index 0000000..cce4b54
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-copy3.C
@@ -0,0 +1,26 @@
+// PR c++/69995
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int i;
+};
+
+constexpr int f(A a)
+{
+  ++a.i;
+  return a.i;
+}
+
+constexpr bool g()
+{
+  A a = { 42 };
+  A b = a;
+  ++b.i;
+  if (b.i != 43) return false;
+  if (a.i != 42) return false;
+  return true;
+}
+
+#define SA(X) static_assert((X),#X)
+SA(g());
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
new file mode 100644
index 0000000..2acfa98
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
@@ -0,0 +1,27 @@
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  constexpr A(int) { }
+};
+
+struct B: A {
+  constexpr B(int i): A(i) { }
+  constexpr B(const B& b): A(b) { }
+};
+
+struct C {
+  B b;
+  constexpr C(int i): b(i) { }
+  constexpr C(const C&c): b(c.b) {}
+};
+
+constexpr int f()
+{
+  C b1{42};
+  C b2{b1};
+  b2.b;
+  return 42;
+}
+
+constexpr int i = f();
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-const1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-const1.C
new file mode 100644
index 0000000..8b54578
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-const1.C
@@ -0,0 +1,18 @@
+// PR c++/67411
+// { dg-do compile { target c++14 } }
+
+template <class T>
+void f()
+{
+  int i = 42;
+  [x = i] {
+    [&](auto) {
+      [=] { return x; }();
+    }(1);
+  }();
+}
+
+int main()
+{
+  f<int>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic3.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic3.C
new file mode 100644
index 0000000..9b3455a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic3.C
@@ -0,0 +1,15 @@
+// PR c++/63628
+// { dg-do compile { target c++14 } }
+
+auto const pack = [](auto&&... t)
+{
+  return [&](auto&& f)->decltype(auto)
+  {
+    return f(static_cast<decltype(t)>(t)...);
+  };
+};
+
+int main(int argc, char** argv) {
+  pack(1)([](int){});
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr4.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr4.C
new file mode 100644
index 0000000..71830cd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr4.C
@@ -0,0 +1,13 @@
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  A(int);
+};
+
+struct B
+{
+  A a{42};
+};
+
+B f() { return {}; }
diff --git a/gcc/testsuite/g++.dg/cpp1y/parameter-pack-1.C b/gcc/testsuite/g++.dg/cpp1y/parameter-pack-1.C
new file mode 100644
index 0000000..27a6bf9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/parameter-pack-1.C
@@ -0,0 +1,23 @@
+// PR c++/68965
+// { dg-do compile { target c++14 } }
+// { dg-options "-Wall -Wextra" }
+
+auto count = [](auto&&... xs)
+{
+    return sizeof...(xs);
+};
+
+struct count_struct
+{
+    template<typename... Ts>
+    auto operator()(Ts&&... xs)
+    {
+        return sizeof...(xs);
+    }
+};
+
+int main()
+{
+    count(1,2,3);
+    count_struct{}(1,2,3);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/parameter-pack-2.C b/gcc/testsuite/g++.dg/cpp1y/parameter-pack-2.C
new file mode 100644
index 0000000..9520875
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/parameter-pack-2.C
@@ -0,0 +1,21 @@
+// PR c++/68965
+// { dg-do compile { target c++14 } }
+// { dg-options "-Wall -Wextra" }
+
+auto count = [](auto&&... xs) // { dg-warning "unused parameter" }
+{
+};
+
+struct count_struct
+{
+    template<typename... Ts>
+    auto operator()(Ts&&... xs) // { dg-warning "unused parameter" }
+    {
+    }
+};
+
+int main()
+{
+    count(1,2,3);
+    count_struct{}(1,2,3);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ47.C b/gcc/testsuite/g++.dg/cpp1y/var-templ47.C
new file mode 100644
index 0000000..a40ec57
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ47.C
@@ -0,0 +1,19 @@
+// PR c++/69009
+// { dg-do compile { target c++14 } }
+
+using _uchar = char;
+using _size_t = decltype(sizeof(_uchar));
+using size_t = _size_t;
+template <class T, T> struct integral_constant;
+template <bool b> using bool_constant = integral_constant<bool, b>;
+template <class> constexpr auto tuple_size_v = 0;
+template <class T> auto const tuple_size_v<T const volatile> = tuple_size_v<T>;
+template <class T>
+using tuple_size = integral_constant<size_t, tuple_size_v<T>>;
+template <typename Base, typename Deriv>
+using is_base_of = bool_constant<__is_base_of(Base, Deriv)>;
+template <class T, size_t N> void test() {
+  is_base_of<integral_constant<size_t, N>, tuple_size<T>> value(
+      is_base_of<integral_constant<size_t, N>, tuple_size<const volatile T>>);
+}
+void foo() { test<int, 0>; }
diff --git a/gcc/testsuite/g++.dg/ext/attribute-may-alias-3.C b/gcc/testsuite/g++.dg/ext/attribute-may-alias-3.C
new file mode 100644
index 0000000..ba6091b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attribute-may-alias-3.C
@@ -0,0 +1,22 @@
+// PR c++/68049
+// { dg-do compile { target c++11 } }
+
+template <typename T> struct Bar
+{
+    using type = T;
+};
+template <typename T> struct Foo
+{
+    typedef typename Bar<T>::type alias_type [[gnu::may_alias]];
+
+    alias_type operator()() { return {}; }
+};
+
+template <typename T> void print(T) {}
+
+int main()
+{
+    print(Foo<int>()());
+    print(0);
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr59627.C b/gcc/testsuite/g++.dg/gomp/pr59627.C
new file mode 100644
index 0000000..ab6f44d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr59627.C
@@ -0,0 +1,14 @@
+// PR c++/59627
+// { dg-do compile { target lto } }
+// { dg-options "-fopenmp -flto" }
+
+struct A { A () : i (0) {} int i; };
+
+void
+foo ()
+{
+  A a;
+  #pragma omp declare reduction (+: A: omp_out.i += omp_in.i)
+  #pragma omp parallel reduction (+: a)
+  ;
+}
diff --git a/gcc/testsuite/g++.dg/init/aggr13.C b/gcc/testsuite/g++.dg/init/aggr13.C
new file mode 100644
index 0000000..08248a6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/aggr13.C
@@ -0,0 +1,17 @@
+// PR c++/67550
+// { dg-do run }
+
+struct S {
+  int x;
+  int y;
+};
+int foo() { return 1; }
+
+int main() {
+  S const data[] = {{0, foo()}};
+
+  S data2[] = {data[0]};
+
+  if (!data2[0].y)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/init/elide4.C b/gcc/testsuite/g++.dg/init/elide4.C
new file mode 100644
index 0000000..f85d6ee
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/elide4.C
@@ -0,0 +1,13 @@
+// PR c++/67557
+
+class A {
+public:
+  A m_fn1();
+  A(A const &);
+  int *L;
+  int ref;
+};
+struct B : A {
+  B();
+};
+B::B() : A((0, m_fn1())) {}
diff --git a/gcc/testsuite/g++.dg/ipa/pr66616.C b/gcc/testsuite/g++.dg/ipa/pr66616.C
new file mode 100644
index 0000000..440ea6c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr66616.C
@@ -0,0 +1,54 @@
+// { dg-do run }
+// { dg-options "-O2 -fipa-cp-clone" }
+
+struct Distraction
+{
+  char fc[8];
+  virtual Distraction * return_self ()
+  { return this; }
+};
+
+static int go;
+
+struct A;
+
+struct A
+{
+  int fi;
+
+  A () : fi(0) {}
+  A (int pi) : fi (pi) {}
+  virtual void foo (int p) = 0;
+};
+
+struct B;
+
+struct B : public Distraction, A
+{
+  B () : Distraction(), A() { }
+  B (int pi) : Distraction (), A (pi) {}
+  virtual void foo (int p)
+  {
+    int o = fi;
+    for (int i = 0; i < p; i++)
+      o += i + i * i;
+    go = o;
+  }
+};
+
+struct B gb2 (2);
+
+extern "C" void abort (void);
+
+int
+main (void)
+{
+  for (int i = 0; i < 2; i++)
+    {
+      struct A *p = &gb2;
+      p->foo (0);
+      if (go != 2)
+	abort ();
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr66896.C b/gcc/testsuite/g++.dg/ipa/pr66896.C
new file mode 100644
index 0000000..236537a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr66896.C
@@ -0,0 +1,22 @@
+// PR ipa/66896
+// { dg-do compile }
+
+void f2 (void *);
+void f3 ();
+
+struct A
+{
+  int *a;
+  A ();
+  ~A () { a3 (); }
+  int a1 (int * p) { if (!p) f3 (); f2 (p); }
+  void a3 () { if (*a) a1 (a); }
+};
+
+struct B : A {~B () { a3 ();}};
+
+struct F {};
+
+struct G : F {B g;};
+
+void foo () {G g;}
diff --git a/gcc/testsuite/g++.dg/ipa/pr68851.C b/gcc/testsuite/g++.dg/ipa/pr68851.C
new file mode 100644
index 0000000..659e4cd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr68851.C
@@ -0,0 +1,29 @@
+// { dg-do compile }
+// { dg-options "-O3" }
+
+class A;
+class B {
+public:
+  operator A *() const;
+};
+class A {
+public:
+  virtual bool isFormControlElement() const {}
+};
+class C {
+  struct D {
+    B element;
+  };
+  bool checkPseudoClass(const D &, int &) const;
+};
+class F {
+  virtual bool isFormControlElement() const;
+};
+class G : A, F {
+  bool isFormControlElement() const {}
+};
+bool C::checkPseudoClass(const D &p1, int &) const {
+  A &a = *p1.element;
+  a.isFormControlElement();
+  a.isFormControlElement() || a.isFormControlElement();
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr69432.C b/gcc/testsuite/g++.dg/opt/pr69432.C
new file mode 100644
index 0000000..1f23f2c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr69432.C
@@ -0,0 +1,62 @@
+// PR target/69432
+// { dg-do compile }
+// { dg-options "-O3" }
+// { dg-additional-options "-minline-stringops-dynamically" { target i?86-*-* x86_64-*-* } }
+
+template <typename S, typename T, typename U>
+void
+f1 (S x, T y, U z)
+{
+  for (; y; --y, ++x)
+    *x = z;
+}
+
+template <typename S, typename T, typename U>
+void f2 (S x, T y, U z)
+{
+  f1 (x, y, z);
+}
+
+struct A {};
+struct B { static char f3 (A, unsigned); };
+
+template <typename S, typename U>
+void f4 (S, U);
+
+struct C
+{
+  template <typename S, typename T, typename U>
+  static S f5 (S x, T y, U z) { f2 (x, y, z); }
+};
+
+template <typename S, typename T, typename U>
+void f6 (S x, T y, U z) { C::f5 (x, y, z); }
+
+template <typename S, typename T, typename U, typename V>
+void f7 (S x, T y, U z, V) { f6 (x, y, z); }
+
+struct E
+{
+  struct D : A { char e; D (A); };
+  A f;
+  E (int x) : g(f) { f8 (x); }
+  ~E ();
+  D g;
+  void f9 (int x) { x ? B::f3 (g, x) : char (); }
+  void f8 (int x) { f9 (x); }
+};
+
+struct F : E
+{
+  F (int x) : E(x) { f10 (x); f4 (this, 0); }
+  char h;
+  void f10 (int x) { f7 (&g.e, x, h, 0); }
+};
+
+long a;
+
+void
+test ()
+{
+  F b(a);
+}
diff --git a/gcc/testsuite/g++.dg/other/anon8.C b/gcc/testsuite/g++.dg/other/anon8.C
new file mode 100644
index 0000000..1fdd4c1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/anon8.C
@@ -0,0 +1,9 @@
+// PR c++/68679
+
+typedef struct {
+  struct {
+    unsigned d[4];
+    template<typename T>
+    unsigned operator[] (T i) const { return d[i]; }
+  } c;
+} A;
diff --git a/gcc/testsuite/g++.dg/pr63995-1.C b/gcc/testsuite/g++.dg/pr63995-1.C
index 82e7606..41a1c01 100644
--- a/gcc/testsuite/g++.dg/pr63995-1.C
+++ b/gcc/testsuite/g++.dg/pr63995-1.C
@@ -1,5 +1,4 @@
-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ! x32 } } } } */
 /* { dg-options "-O2 -g -fcheck-pointer-bounds -mmpx" } */
 
 int test1 (int i)
diff --git a/gcc/testsuite/g++.dg/pr68449.C b/gcc/testsuite/g++.dg/pr68449.C
new file mode 100644
index 0000000..7d86fe9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr68449.C
@@ -0,0 +1,9 @@
+// PR c++/68449
+// { dg-do compile }
+// { dg-options "-Wsign-compare" }
+
+int
+foo (int a)
+{
+  return __extension__ ({ int b; b; }) < 0;
+}
diff --git a/gcc/testsuite/g++.dg/rtti/typeid11.C b/gcc/testsuite/g++.dg/rtti/typeid11.C
new file mode 100644
index 0000000..384b0f4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/rtti/typeid11.C
@@ -0,0 +1,16 @@
+// { dg-do run }
+
+#include <typeinfo>
+
+struct Base { virtual void foo() {} }; // polymorphic
+
+int main()
+{
+  Base b;
+  Base *ary[] = { &b, &b, &b};
+
+  int iter = 0;
+  typeid(*ary[iter++]);
+  if (iter != 1)	// should be 1
+    __builtin_abort();	// but 2
+}
diff --git a/gcc/testsuite/g++.dg/template/friend61.C b/gcc/testsuite/g++.dg/template/friend61.C
new file mode 100644
index 0000000..1604f5c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend61.C
@@ -0,0 +1,12 @@
+// PR c++/69323
+
+template<int VALUE>
+struct Outer
+{
+  struct StupidValueTrick
+  {
+    template<int VAL> friend struct Outer<VAL>::StupidValueTrick;
+  };
+};
+typedef Outer<42>::StupidValueTrick GoodValue;
+GoodValue good;
diff --git a/gcc/testsuite/g++.dg/template/pr67337.C b/gcc/testsuite/g++.dg/template/pr67337.C
new file mode 100644
index 0000000..df2651b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/pr67337.C
@@ -0,0 +1,25 @@
+template <class> class A
+{
+  void m_fn1 (int *, int);
+};
+
+template <class> class B
+{
+public:
+  typedef int Type;
+};
+
+template <class> class C
+{
+public:
+  C (int);
+  template <template <class> class T> void m_fn2 (typename T<void>::Type);
+};
+
+template <>
+void
+A<int>::m_fn1 (int *, int)
+{
+  C<int> a (0);
+  a.m_fn2<B> (0);
+}
diff --git a/gcc/testsuite/g++.dg/template/typename21.C b/gcc/testsuite/g++.dg/template/typename21.C
new file mode 100644
index 0000000..a76f133
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/typename21.C
@@ -0,0 +1,11 @@
+// PR c++/70067
+// { dg-do compile }
+
+template <class> struct A;
+template <class T> struct B { struct N { }; };
+template <class T> struct D: B<T> {
+  typedef typename D::N N;
+  A<N> *a;
+};
+
+D<int> d;
diff --git a/gcc/testsuite/g++.dg/torture/pr68184.C b/gcc/testsuite/g++.dg/torture/pr68184.C
new file mode 100644
index 0000000..d0c7c84
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr68184.C
@@ -0,0 +1,31 @@
+// { dg-do run }
+namespace {
+struct IFoo { virtual void foo() = 0; };
+struct IBar { virtual void bar() = 0; };
+
+struct FooBar : private IBar, private IFoo
+{
+    void call_foo()
+    {
+        try
+        {
+            static_cast<IFoo*>(this)->foo();
+        }
+        catch( ... ) {}
+    }
+    void foo() { throw 1; }
+    void bar()  {}
+};
+
+void test()
+{
+    FooBar foobar;
+    foobar.call_foo();
+}
+}
+int main()
+{
+    test();
+    return 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr69214.c b/gcc/testsuite/gcc.c-torture/compile/pr69214.c
new file mode 100644
index 0000000..61728f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr69214.c
@@ -0,0 +1,17 @@
+/* PR tree-optimization/69214 */
+
+extern void bar (void);
+extern int __setjmp (char *);
+
+void
+foo (char *p)
+{
+  int d = 0;
+  bar ();
+  if (__setjmp (p))
+    return;
+  long a = d;
+  d = 8;
+  if (!a)
+    bar ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x b/gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x
new file mode 100644
index 0000000..031049d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x
@@ -0,0 +1,10 @@
+# Different translation units may have different user name overrides
+# and we do not preserve enough context to known which one we want.
+
+set torture_eval_before_compile {
+  if {[string match {*-flto*} "$option"]} {
+    continue
+  }
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c b/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c
index 4167841..3c3e45d 100644
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c
@@ -2,7 +2,6 @@
 
    Ensure all expected transformations of builtin strstr occur and
    perform correctly in presence of redirect.  */
-/* { dg-options "-ffat-lto-objects" } */
 
 #define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
 #define ASMNAME2(prefix, cname) STRING (prefix) cname
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x b/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x
new file mode 100644
index 0000000..031049d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x
@@ -0,0 +1,10 @@
+# Different translation units may have different user name overrides
+# and we do not preserve enough context to known which one we want.
+
+set torture_eval_before_compile {
+  if {[string match {*-flto*} "$option"]} {
+    continue
+  }
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr67781.c b/gcc/testsuite/gcc.c-torture/execute/pr67781.c
new file mode 100644
index 0000000..bf50aa2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr67781.c
@@ -0,0 +1,34 @@
+#ifdef __UINT32_TYPE__
+typedef __UINT32_TYPE__ uint32_t;
+#else
+typedef unsigned uint32_t;
+#endif
+
+#ifdef __UINT8_TYPE__
+typedef __UINT8_TYPE__ uint8_t;
+#else
+typedef unsigned char uint8_t;
+#endif
+
+struct
+{
+  uint32_t a;
+  uint8_t b;
+} s = { 0x123456, 0x78 };
+
+int pr67781()
+{
+  uint32_t c = (s.a << 8) | s.b;
+  return c;
+}
+
+int
+main ()
+{
+  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
+    return 0;
+
+  if (pr67781 () != 0x12345678)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c b/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c
index 884571a..963d441 100644
--- a/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c
+++ b/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c
@@ -26,6 +26,30 @@ f4 (int x)
   return x <= 0 ? x : ~x;
 }
 
+__attribute__((noinline, noclone)) int
+f5 (int x)
+{
+  return x >= 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f6 (int x)
+{
+  return x >= 0 ? x : ~x;
+}
+
+__attribute__((noinline, noclone)) int
+f7 (int x)
+{
+  return x > 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f8 (int x)
+{
+  return x > 0 ? x : ~x;
+}
+
 int
 main ()
 {
@@ -37,5 +61,13 @@ main ()
     abort ();
   if (f4 (5) != -6 || f4 (-5) != -5 || f4 (0) != 0)
     abort ();
+  if (f5 (5) != -6 || f5 (-5) != -5 || f5 (0) != -1)
+    abort ();
+  if (f6 (5) != 5 || f6 (-5) != 4 || f6 (0) != 0)
+    abort ();
+  if (f7 (5) != -6 || f7 (-5) != -5 || f7 (0) != 0)
+    abort ();
+  if (f8 (5) != 5 || f8 (-5) != 4 || f8 (0) != -1)
+    abort ();
   return 0;
 }
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr68648.c b/gcc/testsuite/gcc.c-torture/execute/pr68648.c
new file mode 100644
index 0000000..fc66806
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr68648.c
@@ -0,0 +1,20 @@
+int __attribute__ ((noinline))
+foo (void)
+{
+  return 123;
+}
+
+int __attribute__ ((noinline))
+bar (void)
+{
+  int c = 1;
+  c |= 4294967295 ^ (foo () | 4073709551608);
+  return c;
+}
+
+int
+main ()
+{
+  if (bar () != 0x83fd4005)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr69403.c b/gcc/testsuite/gcc.c-torture/execute/pr69403.c
new file mode 100644
index 0000000..097d366
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr69403.c
@@ -0,0 +1,20 @@
+/* PR target/69403.  */
+
+int a, b, c;
+
+__attribute__ ((__noinline__)) int
+fn1 ()
+{
+  if ((b | (a != (a & c))) == 1)
+    __builtin_abort ();
+  return 0;
+}
+
+int
+main (void)
+{
+  a = 5;
+  c = 1;
+  b = 6;
+  return fn1 ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr69447.c b/gcc/testsuite/gcc.c-torture/execute/pr69447.c
new file mode 100644
index 0000000..b6d8591
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr69447.c
@@ -0,0 +1,26 @@
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+
+u64 __attribute__((noinline, noclone))
+foo(u8 u8_0, u16 u16_0, u64 u64_0, u8 u8_1, u16 u16_1, u64 u64_1, u64 u64_2, u8 u8_3, u64 u64_3)
+{
+	u64_1 *= 0x7730;
+	u64_3 *= u64_3;
+	u16_1 |= u64_3;
+	u64_3 -= 2;
+	u8_3 /= u64_2;
+	u8_0 |= 3;
+	u64_3 %= u8_0;
+	u8_0 -= 1;
+	return u8_0 + u16_0 + u64_0 + u8_1 + u16_1 + u64_1 + u8_3 + u64_3;
+}
+
+int main()
+{
+	unsigned x = foo(1, 1, 1, 1, 1, 1, 1, 1, 1);
+	if (x != 0x7737)
+		__builtin_abort();
+	return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/autopar/pr69110.c b/gcc/testsuite/gcc.dg/autopar/pr69110.c
new file mode 100644
index 0000000..438281d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/autopar/pr69110.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftree-parallelize-loops=2 -fno-tree-loop-im -fdump-tree-parloops-details" } */
+
+#define N 1000
+
+unsigned int i = 0;
+
+void
+foo (void)
+{
+  unsigned int z;
+  for (z = 0; z < N; ++z)
+    ++i;
+}
+
+/* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
+/* { dg-final { scan-tree-dump-times "FAILED: data dependencies exist across iterations" 1 "parloops" } } */
diff --git a/gcc/testsuite/gcc.dg/autopar/pr69426.c b/gcc/testsuite/gcc.dg/autopar/pr69426.c
new file mode 100644
index 0000000..e91421c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/autopar/pr69426.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-parallelize-loops=2" } */
+
+int iq;
+
+void
+mr(void)
+{
+  unsigned int i8;
+
+  for (i8 = 0; i8 != 1; i8 += 3) {
+    void *f0[] = { f0 };
+    int hv;
+
+    for (; hv < 1; ++hv)
+      iq = 0;
+  }
+  ++iq;
+}
diff --git a/gcc/testsuite/gcc.dg/ipa/pr68790.c b/gcc/testsuite/gcc.dg/ipa/pr68790.c
new file mode 100644
index 0000000..a93aa64
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr68790.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O0 -fipa-icf -fdump-ipa-icf"  } */
+
+struct S
+{
+  int a;
+};
+
+int
+foo3 (struct S x, struct S y, struct S z)
+{
+  if (z.a != 9)
+    __builtin_abort ();
+  return 0;
+}
+
+int
+bar3 (struct S x, struct S y, struct S z)
+{
+  return foo3 (y, x, z);
+}
+
+int
+baz3 (struct S x, struct S y, struct S z)
+{
+  return foo3 (y, z, x);
+}
+
+int
+main (void)
+{
+  struct S
+    a = { 3 },
+    b = { 6 },
+    c = { 9 };
+
+  return bar3 (b, a, c);
+}
+
+/* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
+/* { dg-final { cleanup-ipa-dump "icf" } } */
diff --git a/gcc/testsuite/gcc.dg/lto/simd-function_0.c b/gcc/testsuite/gcc.dg/lto/simd-function_0.c
new file mode 100644
index 0000000..cda31aa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/simd-function_0.c
@@ -0,0 +1,34 @@
+/* { dg-lto-do link } */
+/* { dg-require-effective-target avx2 } */
+/* { dg-lto-options { { -fopenmp-simd -O3 -ffast-math -mavx2 -flto -flto-partition=max } } } */
+
+#define SIZE 4096
+float x[SIZE];
+
+
+#pragma omp declare simd
+float
+__attribute__ ((noinline))
+my_mul (float x, float y) {
+  return x * y;
+}
+
+__attribute__ ((noinline))
+int foo ()
+{
+  int i = 0;
+#pragma omp simd safelen (16)
+  for (i = 0; i < SIZE; i++)
+    x[i] = my_mul ((float)i, 9932.3323);
+  return (int)x[0];
+}
+
+int main ()
+{
+  int i = 0;
+  for (i = 0; i < SIZE; i++)
+    x[i] = my_mul ((float) i, 9932.3323);
+  foo ();
+  return (int)x[0];
+}
+
diff --git a/gcc/testsuite/gcc.dg/pr65779.c b/gcc/testsuite/gcc.dg/pr65779.c
new file mode 100644
index 0000000..7d5c522
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr65779.c
@@ -0,0 +1,42 @@
+/* PR debug/65779 */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+unsigned long
+foo (unsigned long x, unsigned char *y, unsigned int z)
+{
+  unsigned long a = x & 0xffff;
+  unsigned long b = (x >> 16) & 0xffff;
+  int k;
+  if (y == 0) return 1L;
+  while (z > 0)
+    {
+      k = z < 5552 ? z : 5552;
+      z -= k;
+      while (k >= 16)
+	{
+          a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  a += *y++; b += a;
+	  k -= 16;
+        }
+      if (k != 0)
+	do { a += *y++; b += a; } while (--k);
+      a %= 65521L;
+      b %= 65521L;
+    }
+  return (b << 16) | a;
+}
diff --git a/gcc/testsuite/gcc.dg/pr68162-1.c b/gcc/testsuite/gcc.dg/pr68162-1.c
new file mode 100644
index 0000000..a2c4953
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68162-1.c
@@ -0,0 +1,6 @@
+/* Test handling of pointers to arrays of const elements involving a
+   typedef.  PR c/68162.  */
+
+typedef const double cd;
+void f (const double (*)[]);
+void g (void) { f ((cd (*)[]) 0); }
diff --git a/gcc/testsuite/gcc.dg/pr68513.c b/gcc/testsuite/gcc.dg/pr68513.c
new file mode 100644
index 0000000..86f878d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68513.c
@@ -0,0 +1,125 @@
+/* PR c/68513 */
+/* { dg-do compile } */
+/* { dg-options "-funsafe-math-optimizations -fno-math-errno -O -Wno-div-by-zero" } */
+
+int i;
+unsigned u;
+volatile int *e;
+
+#define E (i ? *e : 0)
+
+/* Can't trigger some of them because operand_equal_p will return false
+   for side-effects.  */
+
+/* (x & ~m) | (y & m) -> ((x ^ y) & m) ^ x */
+int
+fn1 (void)
+{
+  int r = 0;
+  r += (short) (E & ~u | i & u);
+  r += -(short) (E & ~u | i & u);
+  r += (short) -(E & ~u | i & u);
+  return r;
+}
+
+/* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */
+double
+fn2 (void)
+{
+  double r;
+  r = __builtin_sqrt (E) < __builtin_inf ();
+  return r;
+}
+
+/* sqrt(x) < c is the same as x >= 0 && x < c*c.  */
+double
+fn3 (void)
+{
+  double r;
+  r = __builtin_sqrt (E) < 1.3;
+  return r;
+}
+
+/* copysign(x,y)*copysign(x,y) -> x*x.  */
+double
+fn4 (double y, double x)
+{
+  return __builtin_copysign (E, y) * __builtin_copysign (E, y);
+}
+
+/* x <= +Inf is the same as x == x, i.e. !isnan(x).  */
+int
+fn5 (void)
+{
+  return E <= __builtin_inf ();
+}
+
+/* Fold (A & ~B) - (A & B) into (A ^ B) - B.  */
+int
+fn6 (void)
+{
+  return (i & ~E) - (i & E);
+}
+
+/* Fold (A & B) - (A & ~B) into B - (A ^ B).  */
+int
+fn7 (void)
+{
+  return (i & E) - (i & ~E);
+}
+
+/* x + (x & 1) -> (x + 1) & ~1 */
+int
+fn8 (void)
+{
+  return E + (E & 1);
+}
+
+/* Simplify comparison of something with itself.  */
+int
+fn9 (void)
+{
+  return E <= E | E >= E;
+}
+
+/* Fold (A & ~B) - (A & B) into (A ^ B) - B.  */
+int
+fn10 (void)
+{
+  return (i & ~E) - (i & E);
+}
+
+/* abs(x)*abs(x) -> x*x.  Should be valid for all types.  */
+int
+fn11 (void)
+{
+  return __builtin_abs (E) * __builtin_abs (E);
+}
+
+/* (x | CST1) & CST2 -> (x & CST2) | (CST1 & CST2) */
+int
+fn12 (void)
+{
+  return (E | 11) & 12;
+}
+
+/* fold_range_test */
+int
+fn13 (const char *s)
+{
+  return s[E] != '\0' && s[E] != '/';
+}
+
+/* fold_comparison */
+int
+fn14 (void)
+{
+  return (!!i ? : (u *= E / 0)) >= (u = E);
+}
+
+/* fold_mult_zconjz */
+_Complex int
+fn15 (_Complex volatile int *z)
+{
+  return *z * ~*z;
+}
diff --git a/gcc/testsuite/gcc.dg/pr68668.c b/gcc/testsuite/gcc.dg/pr68668.c
new file mode 100644
index 0000000..d013aa9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68668.c
@@ -0,0 +1,53 @@
+/* PR c/68668 */
+/* { dg-do compile } */
+
+typedef const int T[];
+typedef const int U[1];
+
+int
+fn1 (T p)
+{
+  return p[0];
+}
+
+int
+fn2 (U p[2])
+{
+  return p[0][0];
+}
+
+int
+fn3 (U p[2][3])
+{
+  return p[0][0][0];
+}
+
+int
+fn4 (U *p)
+{
+  return p[0][0];
+}
+
+int
+fn5 (U (*p)[1])
+{
+  return (*p)[0][0];
+}
+
+int
+fn6 (U (*p)[1][2])
+{
+  return (*p)[0][0][0];
+}
+
+int
+fn7 (U **p)
+{
+  return p[0][0][0];
+}
+
+int
+fn8 (U (**p)[1])
+{
+  return (*p)[0][0][0];
+}
diff --git a/gcc/testsuite/gcc.dg/pr68670-1.c b/gcc/testsuite/gcc.dg/pr68670-1.c
new file mode 100644
index 0000000..92c28a0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68670-1.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/68670 */
+/* { dg-do run } */
+/* { dg-options "-O2 -ftracer" } */
+
+#include "../gcc.c-torture/execute/pr68376-1.c"
diff --git a/gcc/testsuite/gcc.dg/pr68670-2.c b/gcc/testsuite/gcc.dg/pr68670-2.c
new file mode 100644
index 0000000..903e33e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68670-2.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/68670 */
+/* { dg-do run } */
+/* { dg-options "-O2 -ftracer" } */
+
+#include "../gcc.c-torture/execute/pr68376-2.c"
diff --git a/gcc/testsuite/gcc.dg/pr68671.c b/gcc/testsuite/gcc.dg/pr68671.c
new file mode 100644
index 0000000..bec4639
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68671.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/68671 */
+/* { dg-do run } */
+/* { dg-options " -O2 -fno-tree-dce" } */
+
+volatile int a = -1;
+volatile int b;
+
+static inline int
+fn1 (signed char p1, int p2)
+{
+  return (p1 < 0) || (p1 > (1 >> p2)) ? 0 : (p1 << 1);
+}
+
+int
+main ()
+{
+  signed char c = a;
+  b = fn1 (c, 1);
+  c = ((128 | c) < 0 ? 1 : 0);
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr68835-1.c b/gcc/testsuite/gcc.dg/pr68835-1.c
new file mode 100644
index 0000000..47aebe3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68835-1.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/68835 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2" } */
+
+unsigned __int128
+foo (unsigned long a, unsigned long b)
+{
+  unsigned __int128 x = (unsigned __int128) a * b;
+  struct { unsigned __int128 a : 96; } w;
+  w.a = x;
+  return w.a;
+}
diff --git a/gcc/testsuite/gcc.dg/pr68835-2.c b/gcc/testsuite/gcc.dg/pr68835-2.c
new file mode 100644
index 0000000..dd355b1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr68835-2.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/68835 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2" } */
+
+__attribute__((noinline, noclone)) unsigned __int128
+foo (void)
+{
+  unsigned __int128 x = (unsigned __int128) 0xffffffffffffffffULL;
+  struct { unsigned __int128 a : 65; } w;
+  w.a = x;
+  w.a += x;
+  return w.a;
+}
+
+int
+main ()
+{
+  unsigned __int128 x = foo ();
+  if ((unsigned long long) x != 0xfffffffffffffffeULL
+      || (unsigned long long) (x >> 64) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr69015.c b/gcc/testsuite/gcc.dg/pr69015.c
new file mode 100644
index 0000000..9e75db9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr69015.c
@@ -0,0 +1,10 @@
+/* PR target/69015 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-if-conversion" } */
+
+void
+foo (int c)
+{
+  if (c)
+    __builtin_trap ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr69195.c b/gcc/testsuite/gcc.dg/pr69195.c
new file mode 100644
index 0000000..af373a1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr69195.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-dce -fno-forward-propagate" } */
+
+void __attribute__ ((noinline, noclone))
+foo (int *a, int n)
+{
+  int *lasta = a + n;
+  for (; a != lasta; a++)
+    {
+      *a *= 2;
+      a[1] = a[-1] + a[-2];
+    }
+}
+
+int
+main ()
+{
+  int a[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
+  int r[16] = { 1, 2, 6, 6, 16, 24, 44, 80,
+		136, 248, 432, 768, 1360, 2400, 4256, 3760 };
+  unsigned i;
+  foo (&a[2], 13);
+  for (i = 0; i < 8; ++i)
+    if (a[i] != r[i])
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr69238.c b/gcc/testsuite/gcc.dg/pr69238.c
new file mode 100644
index 0000000..3538e63
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr69238.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-dce -fno-forward-propagate -fno-rerun-cse-after-loop -funroll-loops" } */
+
+
+#define N 32
+
+short sa[N];
+short sb[N];
+int ia[N];
+int ib[N];
+
+int __attribute__ ((noinline, noclone))
+main1 (int n)
+{
+  int i;
+  for (i = 0; i < n; i++)
+    {
+      sa[i+7] = sb[i];
+      ia[i+3] = ib[i+1];
+    }
+  return 0;
+}
+
+int
+main (void)
+{ 
+  return main1 (N-7);
+}
diff --git a/gcc/testsuite/gcc.dg/pr69522.c b/gcc/testsuite/gcc.dg/pr69522.c
new file mode 100644
index 0000000..820168d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr69522.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "" } */
+struct str {};
+struct {
+  struct str b;
+  float c[1];
+  int d[1];
+  float e[2];
+  int f[1];
+} a = {{}, 0, {0.5}, 0, 0, {0}};
diff --git a/gcc/testsuite/gcc.dg/pr69644.c b/gcc/testsuite/gcc.dg/pr69644.c
new file mode 100644
index 0000000..c60b191
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr69644.c
@@ -0,0 +1,11 @@
+/* PR target/69644 */
+/* { dg-do compile } */
+
+int
+main ()
+{
+  unsigned short x = 0x8000;
+  if (!__sync_bool_compare_and_swap (&x, 0x8000, 0) || x)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pragma-pop_options-1.c b/gcc/testsuite/gcc.dg/pragma-pop_options-1.c
new file mode 100644
index 0000000..4e969de
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pragma-pop_options-1.c
@@ -0,0 +1,7 @@
+/* Check warnings produced by #pragma GCC push/pop/reset_options.  */
+/* { dg-do assemble } */
+
+#pragma push_options
+#pragma pop_options
+
+int foo;
diff --git a/gcc/testsuite/gcc.dg/setjmp-6.c b/gcc/testsuite/gcc.dg/setjmp-6.c
new file mode 100644
index 0000000..0781f05
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/setjmp-6.c
@@ -0,0 +1,25 @@
+/* PR69569 */
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+#include <setjmp.h>
+
+jmp_buf buf;
+
+struct str {
+    int Count;
+};
+int fun2(struct str *p1)
+{
+    int i = 1;
+    while (1) {
+	setjmp(buf);
+	break;
+    }
+    for (; i;) {
+	i = 0;
+	for (; i < (p1 ? p1->Count : 1); i++)
+	  fun2(p1);
+    }
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr29119.c b/gcc/testsuite/gcc.dg/torture/pr29119.c
index 63e5d86..d4f02f1 100644
--- a/gcc/testsuite/gcc.dg/torture/pr29119.c
+++ b/gcc/testsuite/gcc.dg/torture/pr29119.c
@@ -2,6 +2,5 @@
 
 void ldt_add_entry(void)
 {
-   __asm__ ("" :: "m"(({unsigned __v; __v;})));
+   __asm__ ("" :: "m"(({unsigned __v; __v;})));	/* { dg-warning "memory input 0 is not directly addressable" } */
 }
-
diff --git a/gcc/testsuite/gcc.dg/torture/pr67609.c b/gcc/testsuite/gcc.dg/torture/pr67609.c
new file mode 100644
index 0000000..bd60610
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr67609.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-fno-common" { target hppa*-*-hpux* } } */
+
+typedef union
+{
+  double v[2];
+  double s __attribute__ ((vector_size (16)));
+} data;
+
+data reg;
+
+void __attribute__ ((noinline))
+set_lower (double b)
+{
+  data stack_var;
+  double __attribute__ ((vector_size (16))) one = { 1.0, 1.0 };
+  stack_var.s = reg.s;
+  stack_var.s += one;
+  stack_var.v[0] += b;
+  reg.s = stack_var.s;
+}
+
+int
+main (int argc, char ** argv)
+{
+  reg.v[0] = 1.0;
+  reg.v[1] = 1.0;
+  /* reg should contain { 1.0, 1.0 }.  */
+  set_lower (2.0);
+  /* reg should contain { 4.0, 2.0 }.  */
+  if ((int) reg.v[0] != 4 || (int) reg.v[1] != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr68955.c b/gcc/testsuite/gcc.dg/torture/pr68955.c
new file mode 100644
index 0000000..e9da003
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr68955.c
@@ -0,0 +1,41 @@
+/* PR rtl-optimization/68955 */
+/* { dg-do run } */
+/* { dg-output "ONE1ONE" } */
+
+int a, b, c, d, g, m;
+int i[7][7][5] = { { { 5 } }, { { 5 } },
+		   { { 5 }, { 5 }, { 5 }, { 5 }, { 5 }, { -1 } } };
+static int j = 11;
+short e, f, h, k, l;
+
+static void
+foo ()
+{
+  for (; e < 5; e++)
+    for (h = 3; h; h--)
+      {
+	for (g = 1; g < 6; g++)
+	  {
+	    m = c == 0 ? b : b / c;
+	    i[e][1][e] = i[1][1][1] | (m & l) && f;
+	  }
+	for (k = 0; k < 6; k++)
+	  {
+	    for (d = 0; d < 6; d++)
+	      i[1][e][h] = i[h][k][e] >= l;
+	    i[e + 2][h + 3][e] = 6 & l;
+	    i[2][1][2] = a;
+	    for (; j < 5;)
+	      for (;;)
+		;
+	  }
+      }
+}
+
+int
+main ()
+{
+  foo ();
+  __builtin_printf ("ONE%dONE\n", i[1][0][2]);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69399.c b/gcc/testsuite/gcc.dg/torture/pr69399.c
new file mode 100644
index 0000000..24fa48c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69399.c
@@ -0,0 +1,18 @@
+/* { dg-do run { target int128 } } */
+
+static unsigned __attribute__((noinline, noclone))
+foo (unsigned long long u)
+{
+  unsigned __int128 v = u | 0xffffff81U;
+  v >>= 64;
+  return v;
+}
+
+int
+main ()
+{
+  unsigned x = foo (27);
+  if (x != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69542.c b/gcc/testsuite/gcc.dg/torture/pr69542.c
new file mode 100644
index 0000000..ced5c32
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69542.c
@@ -0,0 +1,37 @@
+/* PR middle-end/69542 */
+/* { dg-do compile } */
+/* { dg-additional-options "-fcompare-debug" } */
+
+typedef struct A *B;
+extern int *a[];
+struct C { B b; struct D *d; };
+struct A { struct { struct C e[1]; long long f[1]; } u; };
+struct D { int g; B h[100]; };
+int b, c, e, g;
+B d, f;
+void foo (void) __attribute__ ((__noreturn__));
+int bar (void)
+{
+  int i = 0;
+  do
+    {
+      if ('E' && a[e][0] != 'V')
+        foo ();
+      struct D *k = d->u.e[0].d;
+      B x = k->h[i], o = f->u.e[0].b;
+      if (b)
+        return 0;
+      if (a[g][0] != 'E' && a[g][0] != 'V')
+        foo ();
+      struct D *n = o->u.e[0].d;
+      int r = x->u.f[0];
+      (void) r;
+      if (c)
+        foo ();
+      B y = n->h[x->u.f[0]];
+      if (i != y->u.f[0])
+        return 0;
+      i++;
+    }
+  while (1);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69546-1.c b/gcc/testsuite/gcc.dg/torture/pr69546-1.c
new file mode 100644
index 0000000..39db179
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69546-1.c
@@ -0,0 +1,26 @@
+/* PR tree-optimization/69546 */
+/* { dg-do run { target int128 } } */
+
+unsigned __int128 __attribute__ ((noinline, noclone))
+foo (unsigned long long x)
+{
+  unsigned __int128 y = ~0ULL;
+  x >>= 63;
+  return y / (x | 1);
+}
+
+unsigned __int128 __attribute__ ((noinline, noclone))
+bar (unsigned long long x)
+{
+  unsigned __int128 y = ~33ULL;
+  x >>= 63;
+  return y / (x | 1);
+}
+
+int
+main ()
+{
+  if (foo (1) != ~0ULL || bar (17) != ~33ULL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69546-2.c b/gcc/testsuite/gcc.dg/torture/pr69546-2.c
new file mode 100644
index 0000000..f004310
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69546-2.c
@@ -0,0 +1,18 @@
+/* PR tree-optimization/69546 */
+/* { dg-do run { target int128 } } */
+
+unsigned __int128
+foo (void)
+{
+  unsigned __int128 a = 0xfffffffffffffffeULL;
+  unsigned __int128 b = 0xffffffffffffffffULL;
+  return a % b;
+}
+
+int
+main ()
+{
+  if (foo () != 0xfffffffffffffffeULL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69574.c b/gcc/testsuite/gcc.dg/torture/pr69574.c
new file mode 100644
index 0000000..feaac24
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69574.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+typedef unsigned mytype;
+
+struct S {
+    mytype *pu;
+};
+
+mytype f(struct S *e)
+{
+  mytype x;
+  if(&x != e->pu)
+    __builtin_memcpy(&x, e->pu, sizeof(unsigned));
+  return x;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69606.c b/gcc/testsuite/gcc.dg/torture/pr69606.c
new file mode 100644
index 0000000..84a0e1a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69606.c
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+char a;
+unsigned short b;
+int c, d;
+unsigned char e;
+
+int
+main ()
+{
+  int f = 1, g = ~a;
+  if (b > f)
+    {
+      e = b; 
+      d = b | e; 
+      g = 0;
+    }
+  c = 1 % g;
+  return 0; 
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69714.c b/gcc/testsuite/gcc.dg/torture/pr69714.c
new file mode 100644
index 0000000..229b7ad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69714.c
@@ -0,0 +1,156 @@
+/* { dg-do run } */
+/* { dg-options "-fno-strict-aliasing" } */
+
+#include <stdint.h>
+#include <stdio.h>
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define av_le2ne32(x) (x)
+#else
+#define av_le2ne32(x) av_bswap32(x)
+#endif
+
+static __attribute__((always_inline)) inline __attribute__((const)) uint32_t av_bswap32(uint32_t x)
+{
+    return ((((x) << 8 & 0xff00) | ((x) >> 8 & 0x00ff)) << 16 | ((((x) >> 16) << 8 & 0xff00) | (((x) >> 16) >> 8 & 0x00ff)));
+}
+
+typedef uint32_t AVCRC;
+
+typedef enum {
+    AV_CRC_8_ATM,
+    AV_CRC_16_ANSI,
+    AV_CRC_16_CCITT,
+    AV_CRC_32_IEEE,
+    AV_CRC_32_IEEE_LE,
+    AV_CRC_16_ANSI_LE,
+    AV_CRC_24_IEEE = 12,
+    AV_CRC_MAX,
+} AVCRCId;
+
+int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);
+
+
+
+
+
+
+uint32_t av_crc(const AVCRC *ctx, uint32_t crc,
+                const uint8_t *buffer, size_t length) __attribute__((pure));
+static struct {
+    uint8_t le;
+    uint8_t bits;
+    uint32_t poly;
+} av_crc_table_params[AV_CRC_MAX] = {
+    [AV_CRC_8_ATM] = { 0, 8, 0x07 },
+    [AV_CRC_16_ANSI] = { 0, 16, 0x8005 },
+    [AV_CRC_16_CCITT] = { 0, 16, 0x1021 },
+    [AV_CRC_24_IEEE] = { 0, 24, 0x864CFB },
+    [AV_CRC_32_IEEE] = { 0, 32, 0x04C11DB7 },
+    [AV_CRC_32_IEEE_LE] = { 1, 32, 0xEDB88320 },
+    [AV_CRC_16_ANSI_LE] = { 1, 16, 0xA001 },
+};
+static AVCRC av_crc_table[AV_CRC_MAX][1024];
+
+
+int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size)
+{
+    unsigned i, j;
+    uint32_t c;
+
+    if (bits < 8 || bits > 32 || poly >= (1LL << bits))
+        return -1;
+    if (ctx_size != sizeof(AVCRC) * 257 && ctx_size != sizeof(AVCRC) * 1024)
+        return -1;
+
+    for (i = 0; i < 256; i++) {
+        if (le) {
+            for (c = i, j = 0; j < 8; j++)
+                c = (c >> 1) ^ (poly & (-(c & 1)));
+            ctx[i] = c;
+        } else {
+            for (c = i << 24, j = 0; j < 8; j++)
+                c = (c << 1) ^ ((poly << (32 - bits)) & (((int32_t) c) >> 31));
+            ctx[i] = av_bswap32(c);
+        }
+    }
+    ctx[256] = 1;
+
+    if (ctx_size >= sizeof(AVCRC) * 1024)
+        for (i = 0; i < 256; i++)
+            for (j = 0; j < 3; j++)
+                ctx[256 *(j + 1) + i] =
+                    (ctx[256 * j + i] >> 8) ^ ctx[ctx[256 * j + i] & 0xFF];
+
+
+    return 0;
+}
+
+const AVCRC *av_crc_get_table(AVCRCId crc_id)
+{
+    if (!av_crc_table[crc_id][(sizeof(av_crc_table[crc_id]) / sizeof((av_crc_table[crc_id])[0])) - 1])
+        if (av_crc_init(av_crc_table[crc_id],
+                        av_crc_table_params[crc_id].le,
+                        av_crc_table_params[crc_id].bits,
+                        av_crc_table_params[crc_id].poly,
+                        sizeof(av_crc_table[crc_id])) < 0)
+            return ((void *)0);
+
+    return av_crc_table[crc_id];
+}
+
+uint32_t av_crc(const AVCRC *ctx, uint32_t crc,
+                const uint8_t *buffer, size_t length)
+{
+    const uint8_t *end = buffer + length;
+
+
+    if (!ctx[256]) {
+        while (((intptr_t) buffer & 3) && buffer < end)
+            crc = ctx[((uint8_t) crc) ^ *buffer++] ^ (crc >> 8);
+
+        while (buffer < end - 3) {
+            crc ^= av_le2ne32(*(const uint32_t *) buffer); buffer += 4;
+            crc = ctx[3 * 256 + ( crc & 0xFF)] ^
+                  ctx[2 * 256 + ((crc >> 8 ) & 0xFF)] ^
+                  ctx[1 * 256 + ((crc >> 16) & 0xFF)] ^
+                  ctx[0 * 256 + ((crc >> 24) )];
+        }
+    }
+
+    while (buffer < end)
+        crc = ctx[((uint8_t) crc) ^ *buffer++] ^ (crc >> 8);
+
+    return crc;
+}
+
+
+int main(void)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    uint8_t buf[1999];
+    int i;
+    unsigned
+      p[6][3] = { { AV_CRC_32_IEEE_LE, 0xEDB88320, 0x3D5CDD04 },
+		  { AV_CRC_32_IEEE , 0x04C11DB7, 0xE0BAF5C0 },
+		  { AV_CRC_24_IEEE , 0x864CFB , 0x326039 },
+		  { AV_CRC_16_ANSI_LE, 0xA001 , 0xBFD8 },
+		  { AV_CRC_16_ANSI , 0x8005 , 0xBB1F },
+		  { AV_CRC_8_ATM , 0x07 , 0xE3 }
+    };
+    const AVCRC *ctx;
+
+    for (i = 0; i < sizeof(buf); i++)
+        buf[i] = i + i * i;
+
+    for (i = 0; i < 6; i++) {
+        int id = p[i][0];
+	uint32_t result;
+        ctx = av_crc_get_table (id);
+	result = av_crc(ctx, 0, buf, sizeof(buf));
+	if (result != p[i][2])
+	  __builtin_abort ();
+    }
+#endif
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69715.c b/gcc/testsuite/gcc.dg/torture/pr69715.c
new file mode 100644
index 0000000..cecc82c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69715.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+
+struct __attribute__((may_alias)) S { long long low; int high; };
+struct S foo (void);
+long double
+bar (void)
+{
+  long double a;
+  *(struct S *)&a = foo ();
+  return a;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69719.c b/gcc/testsuite/gcc.dg/torture/pr69719.c
new file mode 100644
index 0000000..d7489e7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69719.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+
+int b, c = 1, e, f; 
+int a[6][5] = { {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 0, 0, 0} };
+
+void  __attribute__((noinline))
+fn1 ()
+{
+  int d;
+  for (b = 0; b < 5; b++)
+    for (d = 4; d; d--)
+      a[c + 1][b] = a[d + 1][d];
+}
+
+int
+main ()
+{
+  fn1 ();
+
+  if (a[2][1] != 0) 
+    __builtin_abort (); 
+
+  return 0; 
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69776-2.c b/gcc/testsuite/gcc.dg/torture/pr69776-2.c
new file mode 100644
index 0000000..e5bb28d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69776-2.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fstrict-aliasing" } */
+
+extern void *malloc (__SIZE_TYPE__);
+extern void abort (void);
+
+__attribute__((noinline,noclone))
+void f(int *qi, double *qd)
+{
+  int i = *qi;
+  *qd = 0;
+  *qi = i;
+}
+
+int main()
+{
+  int *p = malloc(sizeof(double));
+
+  *p = 1;
+  f(p, (double *)p);
+  if (*p != 1)
+    abort();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.dg/torture/pr69776.c b/gcc/testsuite/gcc.dg/torture/pr69776.c
new file mode 100644
index 0000000..f2d971c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69776.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fstrict-aliasing" } */
+
+extern void *malloc (__SIZE_TYPE__);
+extern void abort (void);
+
+void __attribute__((noinline,noclone))
+foo (int *pi)
+{
+  if (*pi != 1)
+    abort ();
+}
+
+int
+main()
+{
+  void *p = malloc(sizeof (double));
+  int *pi = p;
+  double *pd = p;
+
+  *pi = 1;
+  int a = *pi;
+  *pd = 0;
+  *pi = a;
+  foo (pi);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69932.c b/gcc/testsuite/gcc.dg/torture/pr69932.c
new file mode 100644
index 0000000..4b82130
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69932.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+int a;
+void fn1() {
+  int b = 4;
+  short c[4];
+  c[b] = c[a];
+  if (c[2]) {}
+
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr69936.c b/gcc/testsuite/gcc.dg/torture/pr69936.c
new file mode 100644
index 0000000..3023bbb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69936.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+
+int a;
+char b;
+void fn1(int p1) {}
+
+int fn2() { return 5; }
+
+void fn3() {
+  if (fn2())
+    ;
+  else {
+    char c[5];
+    c[0] = 5;
+  lbl_608:
+    fn1(c[9]);
+    int d = c[9];
+    c[2] | a;
+    d = c[b];
+  }
+  goto lbl_608;
+}
+
+int main() { return 0; }
diff --git a/gcc/testsuite/gcc.dg/torture/pr69989.c b/gcc/testsuite/gcc.dg/torture/pr69989.c
new file mode 100644
index 0000000..ada99f1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr69989.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+
+extern int a, b, d;
+extern char c[];
+void
+fn1 (void)
+{
+  for (;;)
+    {
+      if (b)
+	{
+LABEL_T5T5T:
+	  for (; d < a; d++)
+	    c[d] = 6;
+	}
+      break;
+    }
+  if (a > 6)
+    {
+      a = 4;
+      goto LABEL_T5T5T;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr67755.c b/gcc/testsuite/gcc.dg/tree-ssa/pr67755.c
new file mode 100644
index 0000000..64ffd0b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr67755.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-tree-dom2-details-blocks" } */
+/* We want to verify no outgoing edge from a conditional
+   has a probability of 100%.  */
+/* { dg-final { scan-tree-dump-not "succ:\[ \]+. .100.0%.  .\(TRUE|FALSE\)_VALUE" "dom2"} } */
+
+
+void (*zend_block_interruptions) (void);
+
+int * _zend_mm_alloc_int (int * heap, long int size)
+{
+  int *best_fit;
+  long int true_size = (size < 15 ? 32 : size);
+
+  if (zend_block_interruptions)
+    zend_block_interruptions ();
+
+  if (__builtin_expect ((true_size < 543), 1))
+    best_fit = heap + 2;
+  else
+    best_fit = heap;
+
+  return best_fit;
+}
+
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr69355.c b/gcc/testsuite/gcc.dg/tree-ssa/pr69355.c
new file mode 100644
index 0000000..f515c21
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr69355.c
@@ -0,0 +1,44 @@
+/* { dg-do run } */
+/* { dg-options "-O -fno-strict-aliasing" } */
+
+struct S
+{
+  void *a;
+  long double b;
+};
+
+struct Z
+{
+  long long l;
+  short s;
+} __attribute__((packed));
+
+struct S __attribute__((noclone, noinline))
+foo (void *v, struct Z *z)
+{
+  struct S t;
+  t.a = v;
+  *(struct Z *) &t.b = *z;
+  return t;
+}
+
+struct Z gz;
+
+int
+main (int argc, char **argv)
+{
+  struct S s;
+
+  if (sizeof (long double) < sizeof (struct Z))
+    return 0;
+
+  gz.l = 0xbeef;
+  gz.s = 0xab;
+
+  s = foo ((void *) 0, &gz);
+
+  if ((((struct Z *) &s.b)->l != gz.l)
+      || (((struct Z *) &s.b)->s != gz.s))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr69666.c b/gcc/testsuite/gcc.dg/tree-ssa/pr69666.c
new file mode 100644
index 0000000..9be77ea
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr69666.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -w" } */
+
+int a, c, d;
+float b;
+void *memcpy();
+int fun1(int p1, unsigned char *p2) {
+  p2[p1] = b;
+  return a;
+}
+void fun2() {
+  unsigned char e[16];
+  fun1(16, e);
+  d = e[d];
+  memcpy(&c, e, sizeof(e));
+}
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
index 161497f..27bb6ca 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -46,6 +46,6 @@ int main (void)
   return main1 ();
 } 
 
-/* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 1 "vect" { target { ! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr69783.c b/gcc/testsuite/gcc.dg/vect/pr69783.c
new file mode 100644
index 0000000..5df95d0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr69783.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_float } */
+/* { dg-additional-options "-Ofast -funroll-loops" } */
+
+#define NXX 516
+#define NYY 516
+#define IND(x,y) ((x) + (y)*NXX)
+float **In, **Out, **V;
+
+void foo(int I, int J, int K1, int K2, int L1, int L2 )
+{
+  for(int i=0; i < I; i++)
+    {
+      float *v = V[i];
+
+      for(int j=0; j < J; j++)
+	{
+	  float *in = In[j];
+	  float *out = Out[j];
+	  for(int l=L1; l<L2; l++)
+	    {
+	      for(int k=K1; k<K2; k++)
+		{
+		  float sum = 0;
+		  int offset = 0;
+		  for(int m=-2; m<=2; m++)
+		    {
+		      for(int n=-2; n<=2; n++, offset++)
+			sum += in[IND((k+n), (l+m))] * v[offset];
+		    }
+		  out[IND(k,l)] = sum;
+		}
+	    }
+
+	}
+    }
+}
+
+/* { dg-final { scan-tree-dump "improved number of alias checks from \[0-9\]* to 2" "vect" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/c-output-template-4.c b/gcc/testsuite/gcc.target/aarch64/c-output-template-4.c
new file mode 100644
index 0000000..c5a9391
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/c-output-template-4.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+void
+test (void)
+{
+    __asm__ ("@ %c0" : : "S" (&test + 4));
+}
+
+/* { dg-final { scan-assembler "@ test\\+4" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr69135_1.c b/gcc/testsuite/gcc.target/arm/pr69135_1.c
new file mode 100644
index 0000000..6fb9e06
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr69135_1.c
@@ -0,0 +1,44 @@
+/* { dg-do assemble } */
+/* { dg-require-effective-target arm_v8_vfp_ok } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2 -ffast-math" } */
+/* { dg-add-options arm_v8_vfp } */
+/* { dg-add-options arm_arch_v8a } */
+
+int global;
+
+void
+lceil_float (float x, int b)
+{
+  if (b) global = __builtin_lceilf (x);
+}
+
+void
+lceil_double (double x, int b)
+{
+  if (b) global = __builtin_lceil (x);
+}
+
+void
+lfloor_float (float x, int b)
+{
+  if (b) global =  __builtin_lfloorf (x);
+}
+
+void
+lfloor_double (double x, int b)
+{
+  if (b) global = __builtin_lfloor (x);
+}
+
+void
+lround_float (float x, int b)
+{
+  if (b) global = __builtin_lroundf (x);
+}
+
+void
+lround_double (double x, int b)
+{
+  if (b) global = __builtin_lround (x);
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr69187.c b/gcc/testsuite/gcc.target/arm/pr69187.c
new file mode 100644
index 0000000..9992a69
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr69187.c
@@ -0,0 +1,19 @@
+/* PR target/69187 */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon } */
+/* { dg-options "-O0" }  */
+/* { dg-add-options arm_neon }  */
+
+#include <arm_neon.h>
+
+int32x4_t
+foo (void)
+{
+  int32x4_t vector_int32x4;
+  int16x4_t vector3_int16x4;
+  int16x4_t vector4_int16x4;
+  static int32_t buffer_int32x4[32];
+
+  vector_int32x4 = vld1q_s32(buffer_int32x4);
+  return vqdmlsl_lane_s16(vector_int32x4, vector3_int16x4, vector4_int16x4, 0);
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr69194.c b/gcc/testsuite/gcc.target/arm/pr69194.c
new file mode 100644
index 0000000..477d5f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr69194.c
@@ -0,0 +1,13 @@
+/* PR target/69194 */
+/* { dg-do-compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+typedef __simd128_float32_t float32x4_t;
+
+float32x4_t
+sub (float32x4_t a, float32x4_t b, float32x4_t c, float32x4_t d, float32x4_t e)
+{
+  return __builtin_neon_vld1v4sf((const float *)&e);
+}
diff --git a/gcc/testsuite/gcc.target/arm/wmul-1.c b/gcc/testsuite/gcc.target/arm/wmul-1.c
index ddddd50..ce14769 100644
--- a/gcc/testsuite/gcc.target/arm/wmul-1.c
+++ b/gcc/testsuite/gcc.target/arm/wmul-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O1 -fexpensive-optimizations" } */
+/* { dg-options "-O1 -fexpensive-optimizations -mtune=cortex-a9" } */
 
 int mac(const short *a, const short *b, int sqr, int *sum)
 {
@@ -16,4 +16,4 @@ int mac(const short *a, const short *b, int sqr, int *sum)
   return sqr;
 }
 
-/* { dg-final { scan-assembler-times "smlabb" 2 } } */
+/* { dg-final { scan-assembler-times "smlabb" 2  { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/arm/wmul-2.c b/gcc/testsuite/gcc.target/arm/wmul-2.c
index 2ea55f9..a74d81b 100644
--- a/gcc/testsuite/gcc.target/arm/wmul-2.c
+++ b/gcc/testsuite/gcc.target/arm/wmul-2.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O1 -fexpensive-optimizations" } */
+/* { dg-options "-O1 -fexpensive-optimizations -mtune=cortex-a9" } */
 
 void vec_mpy(int y[], const short x[], short scaler)
 {
@@ -10,4 +10,4 @@ void vec_mpy(int y[], const short x[], short scaler)
    y[i] += ((scaler * x[i]) >> 31);
 }
 
-/* { dg-final { scan-assembler-times "smulbb" 1 } } */
+/* { dg-final { scan-assembler-times "smulbb" 1 { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/arm/wmul-3.c b/gcc/testsuite/gcc.target/arm/wmul-3.c
index 144b553..87eba74 100644
--- a/gcc/testsuite/gcc.target/arm/wmul-3.c
+++ b/gcc/testsuite/gcc.target/arm/wmul-3.c
@@ -1,19 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O1 -fexpensive-optimizations" } */
+/* { dg-options "-O" } */
 
-int mac(const short *a, const short *b, int sqr, int *sum)
+int
+foo (int a, int b)
 {
-  int i;
-  int dotp = *sum;
-
-  for (i = 0; i < 150; i++) {
-    dotp -= b[i] * a[i];
-    sqr -= b[i] * b[i];
-  }
-
-  *sum = dotp;
-  return sqr;
+  return (short) a * (short) b;
 }
 
-/* { dg-final { scan-assembler-times "smulbb" 2 } } */
+/* { dg-final { scan-assembler-times "smulbb" 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx-vextractf128-256-5.c b/gcc/testsuite/gcc.target/i386/avx-vextractf128-256-5.c
new file mode 100644
index 0000000..5359eb7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx-vextractf128-256-5.c
@@ -0,0 +1,12 @@
+/* { dg-require-effective-target avx512f } */
+/* { dg-do assemble { target { ! ia32 } } } */
+/* { dg-options "-O2 -mavx512f" } */
+
+#include <immintrin.h>
+
+register __m512d z asm ("zmm16"); /* { dg-warning "call-clobbered register used for global register variable" } */
+
+__m128d foo ()
+{
+  return _mm256_extractf128_pd (_mm512_extractf64x4_pd(z, 0), 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-pr70059.c b/gcc/testsuite/gcc.target/i386/avx512dq-pr70059.c
new file mode 100644
index 0000000..932ff6a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-pr70059.c
@@ -0,0 +1,33 @@
+/* PR target/70059 */
+/* { dg-do run } */
+/* { dg-require-effective-target avx512dq } */
+/* { dg-options "-O2 -mavx512dq" } */
+
+#include "avx512dq-check.h"
+
+__attribute__((noinline, noclone)) __m512i
+foo (__m256i a, __m256i b)
+{
+  __m512i r = _mm512_undefined_si512 ();
+  r = _mm512_inserti32x8 (r, a, 0);
+  r = _mm512_inserti32x8 (r, b, 1);
+  return r;
+}
+
+static void
+avx512dq_test (void)
+{
+  union256i_q a, b;
+  union512i_q r;
+  long long r_ref[8];
+  int i;
+  for (i = 0; i < 4; i++)
+    {
+      a.a[i] = 0x0101010101010101ULL * i;
+      b.a[i] = 0x1010101010101010ULL * i;
+      r_ref[i] = a.a[i];
+      r_ref[i + 4] = b.a[i];
+    }
+  r.x = foo (a.x, b.x);
+  check_union512i_q (r, r_ref);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vextractf64x2-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vextractf64x2-1.c
index c8cce51..dd7e30b 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vextractf64x2-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vextractf64x2-1.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
-/* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
+/* { dg-final { scan-assembler-times "vextractf(?:128|64x2)\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextractf64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vextracti64x2-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vextracti64x2-1.c
index d49b0c0..a3f3224 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vextracti64x2-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vextracti64x2-1.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+.{7}\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
-/* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
+/* { dg-final { scan-assembler-times "vextracti(?:128|64x2)\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vextracti64x2\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+.{7}\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vrangepd-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vrangepd-1.c
index 034c233..7e5a9cb 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vrangepd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vrangepd-1.c
@@ -1,15 +1,15 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512dq -mavx512vl -O2" } */
-/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
+/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
-/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
-/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangepd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vrangeps-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vrangeps-1.c
index 47f974b..a376dc1 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vrangeps-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vrangeps-1.c
@@ -3,15 +3,15 @@
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
-/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
+/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"  1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangeps\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vrangesd-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vrangesd-1.c
index 6f320c0..4f7d635 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vrangesd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vrangesd-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512dq -O2" } */
 /* { dg-final { scan-assembler-times "vrangesd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vrangesd\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangesd\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-vrangess-1.c b/gcc/testsuite/gcc.target/i386/avx512dq-vrangess-1.c
index 8be0032..b0ed86d 100644
--- a/gcc/testsuite/gcc.target/i386/avx512dq-vrangess-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-vrangess-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512dq -O2" } */
 /* { dg-final { scan-assembler-times "vrangess\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vrangess\[ \\t\]+\[^\{\n\]*\{sae\}\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vrangess\[ \\t\]+\[^\$\n\]*\\$\[^\{\n\]*\{sae\}\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-klogic-2.c b/gcc/testsuite/gcc.target/i386/avx512f-klogic-2.c
index 48d4d84..feff955 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-klogic-2.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-klogic-2.c
@@ -51,7 +51,7 @@ avx512f_test (void)
 
   dst = _mm512_kunpackb (src1, src2);
   x = _mm512_mask_add_ps (x, dst, x, x);
-  dst_ref = 0xFF0F;
+  dst_ref = ((src2 << 8) | src1) & 0xFFFF;
 
   if (dst != dst_ref)
     abort ();
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr70059.c b/gcc/testsuite/gcc.target/i386/avx512f-pr70059.c
new file mode 100644
index 0000000..95c8915
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr70059.c
@@ -0,0 +1,33 @@
+/* PR target/70059 */
+/* { dg-do run } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-options "-O2 -mavx512f" } */
+
+#include "avx512f-check.h"
+
+__attribute__((noinline, noclone)) __m512i
+foo (__m256i a, __m256i b)
+{
+  __m512i r = _mm512_undefined_si512 ();
+  r = _mm512_inserti64x4 (r, a, 0);
+  r = _mm512_inserti64x4 (r, b, 1);
+  return r;
+}
+
+static void
+avx512f_test (void)
+{
+  union256i_q a, b;
+  union512i_q r;
+  long long r_ref[8];
+  int i;
+  for (i = 0; i < 4; i++)
+    {
+      a.a[i] = 0x0101010101010101ULL * i;
+      b.a[i] = 0x1010101010101010ULL * i;
+      r_ref[i] = a.a[i];
+      r_ref[i + 4] = b.a[i];
+    }
+  r.x = foo (a.x, b.x);
+  check_union512i_q (r, r_ref);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vbroadcastsd-3.c b/gcc/testsuite/gcc.target/i386/avx512f-vbroadcastsd-3.c
new file mode 100644
index 0000000..9e44513
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vbroadcastsd-3.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -O2 -ftree-vectorize  -ffixed-xmm0 -ffixed-xmm1 -ffixed-xmm2 -ffixed-xmm3 -ffixed-xmm4 -ffixed-xmm5 -ffixed-xmm6 -ffixed-xmm7 -ffixed-xmm8 -ffixed-xmm9 -ffixed-xmm10 -ffixed-xmm11 -ffixed-xmm12 -ffixed-xmm13 -ffixed-xmm14" } */
+/* { dg-final { scan-assembler-times "vbroadcastsd\[ \\t\]+(?:%xmm(?:\[0-9\]|1\[0-5\]),\[ \\t\]*%ymm(?:\[0-9\]|1\[0-5\])|%xmm\[0-9\]+,\[ \\t\]*%zmm)" 1 } } */
+
+#include <immintrin.h>
+
+register __m512d z asm ("zmm16"); /* { dg-warning "call-clobbered register used for global register variable" } */
+
+double a[10000];
+
+void foo (unsigned N)
+{
+  double d;
+  _mm_store_sd(&d,  _mm256_extractf128_pd (_mm512_extractf64x4_pd (z, 0), 0));
+
+  for (int i=0; i<N; i++)
+    {
+      a[i] = d;
+      a[i] += a[i-4];
+    }
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2sd64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2sd64-1.c
index cceaf59..7e8bcc0 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2sd64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2sd64-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile { target { ! { ia32 } } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtsi2sdq\[ \\t\]+\[^\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtsi2sdq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss-1.c
index 832f636..179ab64 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtsi2ss\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtsi2ss\[ \\t\]+\[^%\n\]*%e\[^\{\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss64-1.c
index 0619240..114a687 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtsi2ss64-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile { target { ! { ia32 } } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtsi2ssq\[ \\t\]+\[^\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtsi2ssq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
index 4eea866..fcdfcac 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! { ia32 } } } } */
 /* { dg-options "-mavx512f -O2" } */
 /* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss-1.c
index 3a62173..cbd5d3f 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512f -O2" } */
 /* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^%\n\]*%e\[^\{\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
index 11f0969..6b9368f 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! { ia32 } } } } */
 /* { dg-options "-mavx512f -O2" } */
 /* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dpd-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dpd-1.c
index ace50de..5a153ea 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dpd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dpd-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf0dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf0dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf0dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 #include <immintrin.h>
 
 volatile __m256i idx;
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dps-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dps-1.c
index d648b2ee9..d1173a2 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dps-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0dps-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf0dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf0dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf0dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qpd-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qpd-1.c
index d32345c..67529e7 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qpd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qpd-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf0qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf0qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf0qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qps-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qps-1.c
index 44c908f..9ff580f 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qps-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf0qps-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf0qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf0qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf0qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dpd-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dpd-1.c
index ff38338..73a029d 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dpd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dpd-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf1dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf1dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf1dpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c
index 8ec3388..439bc85 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf1dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf1dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf1dps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qpd-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qpd-1.c
index 2c4eb2a..3ae16cd 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qpd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qpd-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf1qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf1qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf1qpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qps-1.c b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qps-1.c
index 34bcb65..35cd7d3 100644
--- a/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qps-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1qps-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512pf -O2" } */
-/* { dg-final { scan-assembler-times "vscatterpf1qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vscatterpf1qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vscatterpf1qps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 2 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/chkp-always_inline.c b/gcc/testsuite/gcc.target/i386/chkp-always_inline.c
index 26e80fe..c10d131 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-always_inline.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-always_inline.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -Wno-attributes" } */
 
 static __attribute__((always_inline)) int f1 (int *p)
diff --git a/gcc/testsuite/gcc.target/i386/chkp-bndret.c b/gcc/testsuite/gcc.target/i386/chkp-bndret.c
index 3498058..22db87c 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-bndret.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-bndret.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bndret" "chkp" } } */
 /* { dg-final { cleanup-tree-dump "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c b/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c
index 299d0b0..c07bce1 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_init_ptr_bounds" "chkp" } } */
 /* { dg-final { cleanup-tree-dump "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c b/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c
index a8b3754..b504d71 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_copy_ptr_bounds" "chkp" } } */
 /* { dg-final { cleanup-tree-dump "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c b/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c
index 6f084ee..b52cd92 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_set_ptr_bounds" "chkp" } } */
 /* { dg-final { cleanup-tree-dump "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c b/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c
index 21fb36f..0d89b26 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_null_ptr_bounds" "chkp" } } */
 /* { dg-final { cleanup-tree-dump "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c b/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c
index abbbd43..049de83 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt" } */
 /* { dg-final { scan-tree-dump-not "bndcl" "chkpopt" } } */
 /* { dg-final { scan-tree-dump-not "bndcu" "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-const-check-2.c b/gcc/testsuite/gcc.target/i386/chkp-const-check-2.c
index 18e497a..683c21d 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-const-check-2.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-const-check-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -Wchkp" } */
 
 int test (int *p)
diff --git a/gcc/testsuite/gcc.target/i386/chkp-hidden-def.c b/gcc/testsuite/gcc.target/i386/chkp-hidden-def.c
index 8d2b228..ca7e9d2 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-hidden-def.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-hidden-def.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2" } */
 /* { dg-final { scan-assembler-not "test.chkp" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/chkp-label-address.c b/gcc/testsuite/gcc.target/i386/chkp-label-address.c
index 05963e2..979c33e 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-label-address.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-label-address.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -Wchkp" } */
 
 #include <stdio.h>
diff --git a/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c b/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c
index c1becf7..dfa0a28 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt-details" } */
 /* { dg-final { scan-tree-dump "Moving creation of \[^ \]+ down to its use" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c b/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c
index 28bc622..c8eb688 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump "bndcl" "chkp" } } */
 /* { dg-final { scan-tree-dump "bndcu" "chkp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c b/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c
index 47cc735..b888820 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-not "bndint" "optimized" } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c b/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c
index b34de88..c4ea1a2 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized -Wchkp" } */
 /* { dg-final { scan-tree-dump-not "bndint" "optimized" } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strchr.c b/gcc/testsuite/gcc.target/i386/chkp-strchr.c
index 94a5eaa..01ee619 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strchr.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strchr.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2" } */
 
 #include "string.h"
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c b/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c
index ffb4f16..f5fee2c 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump "memcpy.chkp" "strlen" } } */
 /* { dg-final { cleanup-tree-dump "strlen" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c b/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c
index 67691ee..2d8e0e4 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target stpcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-not "strlen" "strlen" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c b/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c
index 447b9be..5b71eb4 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-times "strlen" 1 "strlen" } } */
 /* { dg-final { cleanup-tree-dump "strlen" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c b/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c
index 2da762a..c4e7f15 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump-times "strlen" 1 "strlen" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c b/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c
index 37b664e..b408a78 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-times "strlen" 2 "strlen" } } */
 /* { dg-final { scan-tree-dump "memcpy" "strlen" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c
index c005041..95e0b96 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c
index 9b3c15f..c701b67 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memset_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c
index 7ef079c..a36424b 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memmove_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c
index 01a5159..5945ade 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump-not "mempcpy_nobnd" "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c
index f6d38c8..ee5a7ed 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nobnd_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c
index a7f43cb..2fa0c77 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nobnd_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c
index 041e885..153be55 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nobnd_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c
index f925ef9..b71cf86 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nobnd_nochk" "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c
index c56656e..cde12b9 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c
index a91f007..c1b322c 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nochk" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c
index 3ae6bf5..e09ea0d 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nochk" "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c
index 8d08ee6..54239ba 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c
index 92f187e..2a05701 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c
index eb1e61c..250193e 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c
index 6d6d55e..14e9c4c 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nobnd" "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c b/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c
index da54c9c..13d0383 100644
--- a/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c
+++ b/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memcpy_nobnd" "chkpopt" } } */
 /* { dg-final { cleanup-tree-dump "chkpopt" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr63995-2.c b/gcc/testsuite/gcc.target/i386/pr63995-2.c
index 7c22e62..89b429e 100644
--- a/gcc/testsuite/gcc.target/i386/pr63995-2.c
+++ b/gcc/testsuite/gcc.target/i386/pr63995-2.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O2 -g -fcheck-pointer-bounds -mmpx -fcompare-debug" } */
 
 struct ts
diff --git a/gcc/testsuite/gcc.target/i386/pr64805.c b/gcc/testsuite/gcc.target/i386/pr64805.c
index 8ba0a97..3c8d666 100644
--- a/gcc/testsuite/gcc.target/i386/pr64805.c
+++ b/gcc/testsuite/gcc.target/i386/pr64805.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx" } */
 
 #include <stdio.h>
diff --git a/gcc/testsuite/gcc.target/i386/pr65044.c b/gcc/testsuite/gcc.target/i386/pr65044.c
index 4f318d6..3b12986 100644
--- a/gcc/testsuite/gcc.target/i386/pr65044.c
+++ b/gcc/testsuite/gcc.target/i386/pr65044.c
@@ -1,6 +1,5 @@
 /* { dg-error "-fcheck-pointer-bounds is not supported with Address Sanitizer" } */
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fsanitize=address" } */
 
 extern int x[];
diff --git a/gcc/testsuite/gcc.target/i386/pr65167.c b/gcc/testsuite/gcc.target/i386/pr65167.c
index 35f3d6b..64cc7ae 100644
--- a/gcc/testsuite/gcc.target/i386/pr65167.c
+++ b/gcc/testsuite/gcc.target/i386/pr65167.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O -fschedule-insns -fcheck-pointer-bounds -mmpx" } */
 
 void bar(int *a, int *b, int *c, int *d, int *e, int *f);
diff --git a/gcc/testsuite/gcc.target/i386/pr65183.c b/gcc/testsuite/gcc.target/i386/pr65183.c
index 069a543..4d62267 100644
--- a/gcc/testsuite/gcc.target/i386/pr65183.c
+++ b/gcc/testsuite/gcc.target/i386/pr65183.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O -fcheck-pointer-bounds -fchkp-use-nochk-string-functions -mmpx" } */
 
 extern void bar(void *);
diff --git a/gcc/testsuite/gcc.target/i386/pr65184.c b/gcc/testsuite/gcc.target/i386/pr65184.c
index 0355f29..e12b8a9 100644
--- a/gcc/testsuite/gcc.target/i386/pr65184.c
+++ b/gcc/testsuite/gcc.target/i386/pr65184.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O2 -mabi=ms -fcheck-pointer-bounds -mmpx" } */
 
 void
diff --git a/gcc/testsuite/gcc.target/i386/pr68680.c b/gcc/testsuite/gcc.target/i386/pr68680.c
new file mode 100644
index 0000000..5524e15
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68680.c
@@ -0,0 +1,15 @@
+/* PR tree-optimization/68680 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-protector-strong" } */
+
+int foo (char *);
+
+int
+bar (unsigned long x)
+{
+  char a[x];
+  return foo (a);
+}
+
+/* Verify that this function is stack protected.  */
+/* { dg-final { scan-assembler "stack_chk_fail" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr68701-1.c b/gcc/testsuite/gcc.target/i386/pr68701-1.c
new file mode 100644
index 0000000..008eb6b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68701-1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ffixed-ebp -mno-accumulate-outgoing-args" } */
+
+/* { dg-warning "fixed ebp register requires" "" { target *-*-* } 0 } */
+
+void foo (void);
+
+int
+main (int argc, char *argv[])
+{
+  foo ();
+  return argc - 1;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr68701-2.c b/gcc/testsuite/gcc.target/i386/pr68701-2.c
new file mode 100644
index 0000000..bfe592e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68701-2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ffixed-ebp -mno-accumulate-outgoing-args -mstackrealign -msse" } */
+
+/* { dg-warning "fixed ebp register requires" "" { target *-*-* } 0 } */
+
+typedef float V __attribute__((vector_size(16)));
+
+void bar (V a)
+{
+  volatile V b = a;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr68986-1.c b/gcc/testsuite/gcc.target/i386/pr68986-1.c
new file mode 100644
index 0000000..998f34f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68986-1.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fPIC -mno-accumulate-outgoing-args -mpreferred-stack-boundary=5 -mincoming-stack-boundary=4" } */
+
+extern __thread int msgdata;
+int
+foo ()
+{
+  return msgdata;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr68986-2.c b/gcc/testsuite/gcc.target/i386/pr68986-2.c
new file mode 100644
index 0000000..c3a366c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68986-2.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target ia32 } } */
+/* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fPIC -mno-accumulate-outgoing-args -mpreferred-stack-boundary=2" } */
+
+extern __thread int msgdata;
+int
+foo ()
+{
+  return msgdata;
+}
+
+/* { dg-final { scan-assembler "andl\[\\t \]*\\$-16,\[\\t \]*%esp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr68986-3.c b/gcc/testsuite/gcc.target/i386/pr68986-3.c
new file mode 100644
index 0000000..5744cf2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr68986-3.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fPIC -mno-sse -mpreferred-stack-boundary=3 -mincoming-stack-boundary=3" } */
+
+extern __thread int msgdata;
+int
+foo ()
+{
+  return msgdata;
+}
+
+/* { dg-final { scan-assembler "and\[lq\]\[\\t \]*\\$-16,\[\\t \]*%\[re\]?sp" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr69140.c b/gcc/testsuite/gcc.target/i386/pr69140.c
new file mode 100644
index 0000000..2c345dd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr69140.c
@@ -0,0 +1,24 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -mincoming-stack-boundary=3" } */
+
+typedef struct {
+  unsigned int buf[4];
+  unsigned char in[64];
+} MD4_CTX;
+
+static void
+MD4Transform (unsigned int buf[4], const unsigned int in[16])
+{
+  unsigned int a, b, c, d;
+  (b) += ((((c)) & ((d))) | ((~(c)) & ((a)))) + (in[7]);
+  (a) += ((((b)) & ((c))) | ((~(b)) & ((d)))) + (in[8]);
+  (d) += ((((a)) & ((b))) | ((~(a)) & ((c)))) + (in[9]);
+  buf[3] += d;
+}
+
+void __attribute__((ms_abi))
+MD4Update (MD4_CTX *ctx, const unsigned char *buf)
+{
+  MD4Transform( ctx->buf, (unsigned int *)ctx->in);
+  MD4Transform( ctx->buf, (unsigned int *)ctx->in);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr69459.c b/gcc/testsuite/gcc.target/i386/pr69459.c
new file mode 100644
index 0000000..2d0bbbc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr69459.c
@@ -0,0 +1,42 @@
+/* PR target/69549 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-options "-O2 -msse2" } */
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef unsigned char v16u8 __attribute__ ((vector_size (16)));
+typedef unsigned short v16u16 __attribute__ ((vector_size (16)));
+typedef unsigned int v16u32 __attribute__ ((vector_size (16)));
+typedef unsigned long long v16u64 __attribute__ ((vector_size (16)));
+
+u64 __attribute__((noinline, noclone))
+foo (u8 u8_0, u16 u16_3, v16u8 v16u8_0, v16u16 v16u16_0, v16u32 v16u32_0, v16u64 v16u64_0, v16u8 v16u8_1, v16u16 v16u16_1, v16u32 v16u32_1, v16u64 v16u64_1, v16u8 v16u8_2, v16u16 v16u16_2, v16u32 v16u32_2, v16u64 v16u64_2, v16u8 v16u8_3, v16u16 v16u16_3, v16u32 v16u32_3, v16u64 v16u64_3)
+{
+  v16u64_0 /= (v16u64){u16_3, ((0))} | 1;
+  v16u64_1 += (v16u64)~v16u32_0;
+  v16u16_1 /= (v16u16){-v16u64_3[1]} | 1;
+  v16u64_3[1] -= 0x1fffffff;
+  v16u32_2 /= (v16u32)-v16u64_0 | 1;
+  v16u32_1 += ~v16u32_1;
+  v16u16_3 %= (v16u16){0xfff, v16u32_2[3], v16u8_0[14]} | 1;
+  v16u64_3 -= (v16u64)v16u32_2;
+  if (v16u64_1[1] >= 1) {
+    v16u64_0 %= (v16u64){v16u32_0[1]} | 1;
+    v16u32_1[1] %= 0x5fb856;
+    v16u64_1 |= -v16u64_0;
+  }
+  v16u8_0 *= (v16u8)v16u32_1;
+  return u8_0 + v16u8_0 [12] + v16u8_0 [13] + v16u8_0 [14] + v16u8_0 [15] + v16u16_0 [0] + v16u16_0 [1] + v16u32_0 [0] + v16u32_0 [1] + v16u32_0 [2] + v16u32_0 [3] + v16u64_0 [0] + v16u64_0 [1] + v16u8_1 [9] + v16u8_1 [10] + v16u8_1 [11] + v16u8_1 [15] + v16u16_1 [0] + v16u16_1 [1] + v16u16_1 [3] + v16u64_1 [0] + v16u64_1 [1] + v16u8_2 [3] + v16u8_2 [4] + v16u8_2 [5] + v16u8_2 [0] + v16u32_2 [1] + v16u32_2 [2] + v16u32_2 [3] + v16u64_2 [0] + v16u64_2 [1] + v16u8_3 [0] + v16u16_3 [6] + v16u16_3[7] + v16u32_3[1] + v16u32_3[2] + v16u64_3[0] + v16u64_3[1];
+}
+
+int
+main ()
+{
+  u64 x = foo(1, 1, (v16u8){1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, (v16u16){1, 1}, (v16u32){1}, (v16u64){1}, (v16u8){1}, (v16u16){1, 1}, (v16u32){1}, (v16u64){1}, (v16u8){1, 1, 1, 1, 1}, (v16u16){1}, (v16u32){1}, (v16u64){1}, (v16u8){1}, (v16u16){1}, (v16u32){1}, (v16u64){1});
+
+  if (x != 0xffffffffe0000209)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr69551.c b/gcc/testsuite/gcc.target/i386/pr69551.c
new file mode 100644
index 0000000..1505fc2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr69551.c
@@ -0,0 +1,23 @@
+/* PR target/69551 */
+/* { dg-do run { target sse_runtime } } */
+/* { dg-options "-O2 -mno-sse2 -msse" } */
+
+typedef unsigned char v16qi __attribute__ ((vector_size (16)));
+typedef unsigned int v4si __attribute__ ((vector_size (16)));
+
+char __attribute__ ((noinline, noclone))
+test (v4si vec)
+{
+  vec[1] = 0x5fb856;
+  return ((v16qi) vec)[0];
+}
+
+int
+main ()
+{
+  char z = test ((v4si) { -1, -1, -1, -1 });
+
+  if (z != -1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr70007.c b/gcc/testsuite/gcc.target/i386/pr70007.c
new file mode 100644
index 0000000..ff58d17
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr70007.c
@@ -0,0 +1,30 @@
+/* PR rtl-optimization/70007 */
+/* { dg-do run { target bmi2 } } */
+/* { dg-options "-O -fgcse -mbmi2 -Wno-psabi" } */
+/* { dg-require-effective-target int128 } */
+
+#include "bmi2-check.h"
+
+typedef unsigned short v32u16 __attribute__ ((vector_size (32)));
+typedef unsigned long long v32u64 __attribute__ ((vector_size (32)));
+typedef unsigned __int128 u128;
+typedef unsigned __int128 v32u128 __attribute__ ((vector_size (32)));
+
+u128
+foo (v32u16 v32u16_0, v32u64 v32u64_0, v32u64 v32u64_1)
+{
+  do {
+    v32u16_0[13] |= v32u64_1[3] = (v32u64_1[3] >> 19) | (v32u64_1[3] << 45);
+    v32u64_1 %= ~v32u64_1;
+    v32u64_0 *= (v32u64) v32u16_0;
+  } while (v32u64_0[0]);
+  return v32u64_1[3];
+}
+
+static void
+bmi2_test ()
+{
+  u128 x = foo((v32u16){(unsigned short) ~0xba31, 0x47c6}, (v32u64){64}, (v32u64){0, 0x8b217e2514d23242, 0xac569b6dff9f82, 0x9d4cffe03c139c});
+  if (x != 0x3c74da5ca328d09)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-round.h b/gcc/testsuite/gcc.target/i386/sse4_1-round.h
index 0210ac1..dfb0b77 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-round.h
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-round.h
@@ -28,7 +28,7 @@ init_round (FP_T *src)
 static FP_T
 do_round (FP_T f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   FP_T ret;
 
   if ((type & 4))
@@ -42,16 +42,15 @@ do_round (FP_T f, int type)
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("fld" ASM_SUFFIX " %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstp" ASM_SUFFIX " %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c
index 71bc51b..fab2278 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_ps(x)
 #define ROUND_MODE _MM_FROUND_CEIL
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c
index 672e920..405c55d 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN _mm_round_ps
 #define ROUND_MODE _MM_FROUND_NINT
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c
index 4bfc1ca..97485b9 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_ps(x)
 #define ROUND_MODE _MM_FROUND_FLOOR
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c
index ae8881c..e6cec0b 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_sd(x, x)
 #define ROUND_MODE _MM_FROUND_CEIL
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c
index 70679bb..54ca21f 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_round_sd(x, x, mode)
 #define ROUND_MODE _MM_FROUND_NINT
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c
index 81a3f76..a59d6f8 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_sd(x, x)
 #define ROUND_MODE _MM_FROUND_FLOOR
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c
index 124f825..ff8b09e 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c
@@ -36,7 +36,7 @@ init_round (double *src)
 static double
 do_round (double f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   double ret;
 
   if ((type & 4))
@@ -50,16 +50,15 @@ do_round (double f, int type)
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("fldl %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstpl %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c
index 96dd8a6..9c20b90a 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_ss(x, x)
 #define ROUND_MODE _MM_FROUND_CEIL
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c
index f052c02..072664e 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_round_ss(x, x, mode)
 #define ROUND_MODE _MM_FROUND_NINT
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c
index 0a696b1..97c69fd 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_ss(x, x)
 #define ROUND_MODE _MM_FROUND_FLOOR
diff --git a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c
index 71042d1..9548890 100644
--- a/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c
+++ b/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c
@@ -36,7 +36,7 @@ init_round (float *src)
 static float
 do_round (float f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   float ret;
 
   if ((type & 4))
@@ -50,16 +50,15 @@ do_round (float f, int type)
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("flds %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstps %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
diff --git a/gcc/testsuite/gcc.target/i386/thunk-retbnd.c b/gcc/testsuite/gcc.target/i386/thunk-retbnd.c
index d9bd031..ddb8a62 100644
--- a/gcc/testsuite/gcc.target/i386/thunk-retbnd.c
+++ b/gcc/testsuite/gcc.target/i386/thunk-retbnd.c
@@ -1,5 +1,4 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target mpx } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O2 -fcheck-pointer-bounds -mmpx -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "return &glob," 2 "optimized" } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c b/gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c
new file mode 100644
index 0000000..a7e6809
--- /dev/null
+++ b/gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target ia64-*-* } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler-not "@ltoffx" } } */
+
+/* A bit of https://bugzilla.redhat.com/show_bug.cgi?id=33354
+   where many stores to static variables overflow .sdata */
+
+static const char *s90;
+void f() { s90 = "string 90"; }
+const char * g() { return s90; }
diff --git a/gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c b/gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c
new file mode 100644
index 0000000..c00ecc9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c
@@ -0,0 +1,27 @@
+/* { dg-do compile { target ia64-*-* } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler-not "@ltoffx" } } */
+
+/* Test imitates early ld.so setup in glibc
+   where no dynamic relocations must be present. */
+
+struct rtld_global
+{
+    long *p[77];
+};
+
+struct rtld_global _rtld_local __attribute__ ((visibility ("hidden"), section (".sdata")));
+
+static void __attribute__ ((unused, noinline))
+elf_get_dynamic_info (struct rtld_global * g, long * dyn)
+{
+  long **info = g->p;
+
+  info[(0x6ffffeff - *dyn) + 66] = dyn;
+}
+
+void __attribute__ ((unused, noinline))
+_dl_start (long * dyn)
+{
+  elf_get_dynamic_info(&_rtld_local, dyn);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c b/gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c
index 5da7388..de3f1b4 100644
--- a/gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c
+++ b/gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c
@@ -1,4 +1,4 @@
-/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
@@ -51,13 +51,14 @@ load_store_sf (unsigned long num,
   float value37	= 0.0f;
   float value38	= 0.0f;
   float value39	= 0.0f;
-  unsigned long in_mask;
-  unsigned long out_mask;
+  unsigned long in_mask, in_mask2;
+  unsigned long out_mask, out_mask2;
   unsigned long i;
 
   for (i = 0; i < num; i++)
     {
       in_mask = *in_mask_ptr++;
+      in_mask2 = *in_mask_ptr++;
       if ((in_mask & (1L <<  0)) != 0L)
 	value00 = *from_ptr++;
 
@@ -118,67 +119,68 @@ load_store_sf (unsigned long num,
       if ((in_mask & (1L << 19)) != 0L)
 	value19 = *from_ptr++;
 
-      if ((in_mask & (1L << 20)) != 0L)
+      if ((in_mask2 & (1L << 0)) != 0L)
 	value20 = *from_ptr++;
 
-      if ((in_mask & (1L << 21)) != 0L)
+      if ((in_mask2 & (1L << 1)) != 0L)
 	value21 = *from_ptr++;
 
-      if ((in_mask & (1L << 22)) != 0L)
+      if ((in_mask2 & (1L << 2)) != 0L)
 	value22 = *from_ptr++;
 
-      if ((in_mask & (1L << 23)) != 0L)
+      if ((in_mask2 & (1L << 3)) != 0L)
 	value23 = *from_ptr++;
 
-      if ((in_mask & (1L << 24)) != 0L)
+      if ((in_mask2 & (1L << 4)) != 0L)
 	value24 = *from_ptr++;
 
-      if ((in_mask & (1L << 25)) != 0L)
+      if ((in_mask2 & (1L << 5)) != 0L)
 	value25 = *from_ptr++;
 
-      if ((in_mask & (1L << 26)) != 0L)
+      if ((in_mask2 & (1L << 6)) != 0L)
 	value26 = *from_ptr++;
 
-      if ((in_mask & (1L << 27)) != 0L)
+      if ((in_mask2 & (1L << 7)) != 0L)
 	value27 = *from_ptr++;
 
-      if ((in_mask & (1L << 28)) != 0L)
+      if ((in_mask2 & (1L << 8)) != 0L)
 	value28 = *from_ptr++;
 
-      if ((in_mask & (1L << 29)) != 0L)
+      if ((in_mask2 & (1L << 9)) != 0L)
 	value29 = *from_ptr++;
 
-      if ((in_mask & (1L << 30)) != 0L)
+      if ((in_mask2 & (1L << 10)) != 0L)
 	value30 = *from_ptr++;
 
-      if ((in_mask & (1L << 31)) != 0L)
+      if ((in_mask2 & (1L << 11)) != 0L)
 	value31 = *from_ptr++;
 
-      if ((in_mask & (1L << 32)) != 0L)
+      if ((in_mask2 & (1L << 12)) != 0L)
 	value32 = *from_ptr++;
 
-      if ((in_mask & (1L << 33)) != 0L)
+      if ((in_mask2 & (1L << 13)) != 0L)
 	value33 = *from_ptr++;
 
-      if ((in_mask & (1L << 34)) != 0L)
+      if ((in_mask2 & (1L << 14)) != 0L)
 	value34 = *from_ptr++;
 
-      if ((in_mask & (1L << 35)) != 0L)
+      if ((in_mask2 & (1L << 15)) != 0L)
 	value35 = *from_ptr++;
 
-      if ((in_mask & (1L << 36)) != 0L)
+      if ((in_mask2 & (1L << 16)) != 0L)
 	value36 = *from_ptr++;
 
-      if ((in_mask & (1L << 37)) != 0L)
+      if ((in_mask2 & (1L << 17)) != 0L)
 	value37 = *from_ptr++;
 
-      if ((in_mask & (1L << 38)) != 0L)
+      if ((in_mask2 & (1L << 18)) != 0L)
 	value38 = *from_ptr++;
 
-      if ((in_mask & (1L << 39)) != 0L)
+      if ((in_mask2 & (1L << 19)) != 0L)
 	value39 = *from_ptr++;
 
       out_mask = *out_mask_ptr++;
+      out_mask2 = *out_mask_ptr++;
       if ((out_mask & (1L <<  0)) != 0L)
 	*to_ptr++ = value00;
 
@@ -239,64 +241,64 @@ load_store_sf (unsigned long num,
       if ((out_mask & (1L << 19)) != 0L)
 	*to_ptr++ = value19;
 
-      if ((out_mask & (1L << 20)) != 0L)
+      if ((out_mask2 & (1L << 0)) != 0L)
 	*to_ptr++ = value20;
 
-      if ((out_mask & (1L << 21)) != 0L)
+      if ((out_mask2 & (1L << 1)) != 0L)
 	*to_ptr++ = value21;
 
-      if ((out_mask & (1L << 22)) != 0L)
+      if ((out_mask2 & (1L << 2)) != 0L)
 	*to_ptr++ = value22;
 
-      if ((out_mask & (1L << 23)) != 0L)
+      if ((out_mask2 & (1L << 3)) != 0L)
 	*to_ptr++ = value23;
 
-      if ((out_mask & (1L << 24)) != 0L)
+      if ((out_mask2 & (1L << 4)) != 0L)
 	*to_ptr++ = value24;
 
-      if ((out_mask & (1L << 25)) != 0L)
+      if ((out_mask2 & (1L << 5)) != 0L)
 	*to_ptr++ = value25;
 
-      if ((out_mask & (1L << 26)) != 0L)
+      if ((out_mask2 & (1L << 6)) != 0L)
 	*to_ptr++ = value26;
 
-      if ((out_mask & (1L << 27)) != 0L)
+      if ((out_mask2 & (1L << 7)) != 0L)
 	*to_ptr++ = value27;
 
-      if ((out_mask & (1L << 28)) != 0L)
+      if ((out_mask2 & (1L << 8)) != 0L)
 	*to_ptr++ = value28;
 
-      if ((out_mask & (1L << 29)) != 0L)
+      if ((out_mask2 & (1L << 9)) != 0L)
 	*to_ptr++ = value29;
 
-      if ((out_mask & (1L << 30)) != 0L)
+      if ((out_mask2 & (1L << 10)) != 0L)
 	*to_ptr++ = value30;
 
-      if ((out_mask & (1L << 31)) != 0L)
+      if ((out_mask2 & (1L << 11)) != 0L)
 	*to_ptr++ = value31;
 
-      if ((out_mask & (1L << 32)) != 0L)
+      if ((out_mask2 & (1L << 12)) != 0L)
 	*to_ptr++ = value32;
 
-      if ((out_mask & (1L << 33)) != 0L)
+      if ((out_mask2 & (1L << 13)) != 0L)
 	*to_ptr++ = value33;
 
-      if ((out_mask & (1L << 34)) != 0L)
+      if ((out_mask2 & (1L << 14)) != 0L)
 	*to_ptr++ = value34;
 
-      if ((out_mask & (1L << 35)) != 0L)
+      if ((out_mask2 & (1L << 15)) != 0L)
 	*to_ptr++ = value35;
 
-      if ((out_mask & (1L << 36)) != 0L)
+      if ((out_mask2 & (1L << 16)) != 0L)
 	*to_ptr++ = value36;
 
-      if ((out_mask & (1L << 37)) != 0L)
+      if ((out_mask2 & (1L << 17)) != 0L)
 	*to_ptr++ = value37;
 
-      if ((out_mask & (1L << 38)) != 0L)
+      if ((out_mask2 & (1L << 18)) != 0L)
 	*to_ptr++ = value38;
 
-      if ((out_mask & (1L << 39)) != 0L)
+      if ((out_mask2 & (1L << 19)) != 0L)
 	*to_ptr++ = value39;
     }
 
@@ -357,13 +359,14 @@ load_store_df (unsigned long num,
   double value37	= 0.0;
   double value38	= 0.0;
   double value39	= 0.0;
-  unsigned long in_mask;
-  unsigned long out_mask;
+  unsigned long in_mask, in_mask2;
+  unsigned long out_mask, out_mask2;
   unsigned long i;
 
   for (i = 0; i < num; i++)
     {
       in_mask = *in_mask_ptr++;
+      in_mask2 = *in_mask_ptr++;
       if ((in_mask & (1L <<  0)) != 0L)
 	value00 = *from_ptr++;
 
@@ -424,67 +427,68 @@ load_store_df (unsigned long num,
       if ((in_mask & (1L << 19)) != 0L)
 	value19 = *from_ptr++;
 
-      if ((in_mask & (1L << 20)) != 0L)
+      if ((in_mask2 & (1L << 0)) != 0L)
 	value20 = *from_ptr++;
 
-      if ((in_mask & (1L << 21)) != 0L)
+      if ((in_mask2 & (1L << 1)) != 0L)
 	value21 = *from_ptr++;
 
-      if ((in_mask & (1L << 22)) != 0L)
+      if ((in_mask2 & (1L << 2)) != 0L)
 	value22 = *from_ptr++;
 
-      if ((in_mask & (1L << 23)) != 0L)
+      if ((in_mask2 & (1L << 3)) != 0L)
 	value23 = *from_ptr++;
 
-      if ((in_mask & (1L << 24)) != 0L)
+      if ((in_mask2 & (1L << 4)) != 0L)
 	value24 = *from_ptr++;
 
-      if ((in_mask & (1L << 25)) != 0L)
+      if ((in_mask2 & (1L << 5)) != 0L)
 	value25 = *from_ptr++;
 
-      if ((in_mask & (1L << 26)) != 0L)
+      if ((in_mask2 & (1L << 6)) != 0L)
 	value26 = *from_ptr++;
 
-      if ((in_mask & (1L << 27)) != 0L)
+      if ((in_mask2 & (1L << 7)) != 0L)
 	value27 = *from_ptr++;
 
-      if ((in_mask & (1L << 28)) != 0L)
+      if ((in_mask2 & (1L << 8)) != 0L)
 	value28 = *from_ptr++;
 
-      if ((in_mask & (1L << 29)) != 0L)
+      if ((in_mask2 & (1L << 9)) != 0L)
 	value29 = *from_ptr++;
 
-      if ((in_mask & (1L << 30)) != 0L)
+      if ((in_mask2 & (1L << 10)) != 0L)
 	value30 = *from_ptr++;
 
-      if ((in_mask & (1L << 31)) != 0L)
+      if ((in_mask2 & (1L << 11)) != 0L)
 	value31 = *from_ptr++;
 
-      if ((in_mask & (1L << 32)) != 0L)
+      if ((in_mask2 & (1L << 12)) != 0L)
 	value32 = *from_ptr++;
 
-      if ((in_mask & (1L << 33)) != 0L)
+      if ((in_mask2 & (1L << 13)) != 0L)
 	value33 = *from_ptr++;
 
-      if ((in_mask & (1L << 34)) != 0L)
+      if ((in_mask2 & (1L << 14)) != 0L)
 	value34 = *from_ptr++;
 
-      if ((in_mask & (1L << 35)) != 0L)
+      if ((in_mask2 & (1L << 15)) != 0L)
 	value35 = *from_ptr++;
 
-      if ((in_mask & (1L << 36)) != 0L)
+      if ((in_mask2 & (1L << 16)) != 0L)
 	value36 = *from_ptr++;
 
-      if ((in_mask & (1L << 37)) != 0L)
+      if ((in_mask2 & (1L << 17)) != 0L)
 	value37 = *from_ptr++;
 
-      if ((in_mask & (1L << 38)) != 0L)
+      if ((in_mask2 & (1L << 18)) != 0L)
 	value38 = *from_ptr++;
 
-      if ((in_mask & (1L << 39)) != 0L)
+      if ((in_mask2 & (1L << 19)) != 0L)
 	value39 = *from_ptr++;
 
       out_mask = *out_mask_ptr++;
+      out_mask2 = *out_mask_ptr++;
       if ((out_mask & (1L <<  0)) != 0L)
 	*to_ptr++ = value00;
 
@@ -545,64 +549,64 @@ load_store_df (unsigned long num,
       if ((out_mask & (1L << 19)) != 0L)
 	*to_ptr++ = value19;
 
-      if ((out_mask & (1L << 20)) != 0L)
+      if ((out_mask2 & (1L << 0)) != 0L)
 	*to_ptr++ = value20;
 
-      if ((out_mask & (1L << 21)) != 0L)
+      if ((out_mask2 & (1L << 1)) != 0L)
 	*to_ptr++ = value21;
 
-      if ((out_mask & (1L << 22)) != 0L)
+      if ((out_mask2 & (1L << 2)) != 0L)
 	*to_ptr++ = value22;
 
-      if ((out_mask & (1L << 23)) != 0L)
+      if ((out_mask2 & (1L << 3)) != 0L)
 	*to_ptr++ = value23;
 
-      if ((out_mask & (1L << 24)) != 0L)
+      if ((out_mask2 & (1L << 4)) != 0L)
 	*to_ptr++ = value24;
 
-      if ((out_mask & (1L << 25)) != 0L)
+      if ((out_mask2 & (1L << 5)) != 0L)
 	*to_ptr++ = value25;
 
-      if ((out_mask & (1L << 26)) != 0L)
+      if ((out_mask2 & (1L << 6)) != 0L)
 	*to_ptr++ = value26;
 
-      if ((out_mask & (1L << 27)) != 0L)
+      if ((out_mask2 & (1L << 7)) != 0L)
 	*to_ptr++ = value27;
 
-      if ((out_mask & (1L << 28)) != 0L)
+      if ((out_mask2 & (1L << 8)) != 0L)
 	*to_ptr++ = value28;
 
-      if ((out_mask & (1L << 29)) != 0L)
+      if ((out_mask2 & (1L << 9)) != 0L)
 	*to_ptr++ = value29;
 
-      if ((out_mask & (1L << 30)) != 0L)
+      if ((out_mask2 & (1L << 10)) != 0L)
 	*to_ptr++ = value30;
 
-      if ((out_mask & (1L << 31)) != 0L)
+      if ((out_mask2 & (1L << 11)) != 0L)
 	*to_ptr++ = value31;
 
-      if ((out_mask & (1L << 32)) != 0L)
+      if ((out_mask2 & (1L << 12)) != 0L)
 	*to_ptr++ = value32;
 
-      if ((out_mask & (1L << 33)) != 0L)
+      if ((out_mask2 & (1L << 13)) != 0L)
 	*to_ptr++ = value33;
 
-      if ((out_mask & (1L << 34)) != 0L)
+      if ((out_mask2 & (1L << 14)) != 0L)
 	*to_ptr++ = value34;
 
-      if ((out_mask & (1L << 35)) != 0L)
+      if ((out_mask2 & (1L << 15)) != 0L)
 	*to_ptr++ = value35;
 
-      if ((out_mask & (1L << 36)) != 0L)
+      if ((out_mask2 & (1L << 16)) != 0L)
 	*to_ptr++ = value36;
 
-      if ((out_mask & (1L << 37)) != 0L)
+      if ((out_mask2 & (1L << 17)) != 0L)
 	*to_ptr++ = value37;
 
-      if ((out_mask & (1L << 38)) != 0L)
+      if ((out_mask2 & (1L << 18)) != 0L)
 	*to_ptr++ = value38;
 
-      if ((out_mask & (1L << 39)) != 0L)
+      if ((out_mask2 & (1L << 19)) != 0L)
 	*to_ptr++ = value39;
     }
 
diff --git a/gcc/testsuite/gcc.target/powerpc/pr68872.c b/gcc/testsuite/gcc.target/powerpc/pr68872.c
new file mode 100644
index 0000000..68f388e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr68872.c
@@ -0,0 +1,14 @@
+/* PR target/68872 */
+/* { dg-do assemble { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=powerpc64le" } */
+
+/* Verify that -mcpu=powerpc64le passes -mpower8/-mpwr8 to the assembler.  */
+
+long
+bar (unsigned char *ptr, unsigned char val)
+{
+  long ret;
+  asm volatile ("stbcx. %0,0,%1" :: "r" (val), "r" (ptr));
+  asm volatile ("mfcr %0,8" : "=r" (ret) ::);
+  return ret;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr69548.c b/gcc/testsuite/gcc.target/powerpc/pr69548.c
new file mode 100644
index 0000000..439f588
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr69548.c
@@ -0,0 +1,11 @@
+/* { dg-do assemble { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -Os -mbig" } */
+
+__int128
+quad_exchange (__int128 *ptr, __int128 newval)
+{
+  return __atomic_exchange_n (ptr, newval, __ATOMIC_RELAXED);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-cg.c b/gcc/testsuite/gcc.target/powerpc/vec-cg.c
new file mode 100644
index 0000000..c31d217
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-cg.c
@@ -0,0 +1,22 @@
+/* Test code generation of vector built-ins.  We don't have this for
+   most of ours today.  As new built-ins are added, please add to this
+   test case.  Update as necessary to add VSX, P8-vector, P9-vector,
+   etc. */
+
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -O0" } */
+
+#include <altivec.h>
+
+static vector signed int i, *pi;
+static int int1;
+
+void
+b()
+{
+  i = __builtin_altivec_lvxl (int1, pi);
+  i = vec_lvxl (int1, pi);
+}
+
+/* { dg-final { scan-assembler-times "lvxl" 2 } } */
diff --git a/gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c b/gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c
new file mode 100644
index 0000000..92a0d3a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 -mzarch -fdwarf2-cfi-asm" } */
+
+char *gl[100];
+
+long
+foo ()
+{
+  long r = 0;
+  char bla[100];
+  int i;
+
+  __builtin_memcpy (bla, gl, 100);
+
+  for (i = 0; i < 100; i++)
+    r += bla[i];
+
+  return r;
+}
+
+/* { dg-final { scan-assembler-not "cfi_def_cfa_register" } } */
+/* { dg-final { scan-assembler "cfi_register" } } */
+/* { dg-final { scan-assembler "cfi_def_cfa_offset" } } */
diff --git a/gcc/testsuite/gcc.target/s390/md/movstr-1.c b/gcc/testsuite/gcc.target/s390/md/movstr-1.c
new file mode 100644
index 0000000..b83ed6d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/md/movstr-1.c
@@ -0,0 +1,12 @@
+/* Machine description pattern tests.  */
+
+/* { dg-do compile } */
+/* { dg-options "-dP" } */
+
+__attribute__ ((noinline))
+void test(char *dest, const char *src)
+{
+  __builtin_stpcpy (dest, src);
+}
+
+/* { dg-final { scan-assembler-times {{[*]movstr}|{vec_vfenesv16qi}} 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/pr69625.c b/gcc/testsuite/gcc.target/s390/pr69625.c
new file mode 100644
index 0000000..f717183
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr69625.c
@@ -0,0 +1,37 @@
+/* Test for PR 69625; make sure that a leaf vararg function does not overwrite
+   the caller's r6.  */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+
+__attribute__ ((noinline))
+int
+foo (int x, ...)
+{
+  __builtin_va_list vl;
+  int i;
+
+  __asm__ __volatile__ ("lhi %%r6,1" : : : "r6");
+  __builtin_va_start(vl, x);
+  for (i = 2; i <= 6; i++)
+    x += __builtin_va_arg(vl, int);
+  __builtin_va_end (vl);
+
+  return x;
+}
+
+__attribute__ ((noinline))
+void
+bar (int r2, int r3, int r4, int r5, int r6)
+{
+  foo (r2, r3, r4, r5, r6);
+  if (r6 != 6)
+    abort ();
+}
+
+int
+main (void)
+{
+  bar (2, 3, 4, 5, 6);
+}
diff --git a/gcc/testsuite/gcc.target/s390/vector/int128-1.c b/gcc/testsuite/gcc.target/s390/vector/int128-1.c
new file mode 100644
index 0000000..b4a16b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/vector/int128-1.c
@@ -0,0 +1,47 @@
+/* Check that vaq/vsq are used for int128 operations.  */
+
+/* { dg-do compile { target { lp64 } } } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
+
+
+const __int128 c = (__int128)0x0123456789abcd55 + ((__int128)7 << 64);
+
+
+__int128
+addreg(__int128 a, __int128 b)
+{
+  return a + b;
+}
+
+__int128
+addconst(__int128 a)
+{
+  return a + c;
+}
+
+__int128
+addmem(__int128 *a, __int128_t *b)
+{
+  return *a + *b;
+}
+
+__int128
+subreg(__int128 a, __int128 b)
+{
+  return a - b;
+}
+
+__int128
+subconst(__int128 a)
+{
+  return a - c; /* This becomes vaq as well.  */
+}
+
+__int128
+submem(__int128 *a, __int128_t *b)
+{
+  return *a - *b;
+}
+
+/* { dg-final { scan-assembler-times "vaq" 4 } } */
+/* { dg-final { scan-assembler-times "vsq" 2 } } */
diff --git a/gcc/testsuite/gcc.target/s390/vector/stpcpy-1.c b/gcc/testsuite/gcc.target/s390/vector/stpcpy-1.c
new file mode 100644
index 0000000..91c1f7c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/vector/stpcpy-1.c
@@ -0,0 +1,100 @@
+/* The z13 stpcpy implementation plays some alignment tricks for good
+   performance.  This test tries to make sure it works correctly and
+   does not access bytes beyond the source and destination
+   strings.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target vector } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
+
+#include <stdio.h>
+#include <sys/mman.h>
+
+#define PAGE_SIZE 4096
+
+struct {
+  char unused[PAGE_SIZE - 32];
+  char m32[15]; /* page bndry - 32 */
+  char m17[1];
+  char m16[1];
+  char m15[14];
+  char m1[1];
+  char next_page[PAGE_SIZE];
+} s, d __attribute__((aligned(PAGE_SIZE)));
+
+char *__attribute__((noinline))
+my_stpcpy(char *dest, const char *src)
+{
+  return __builtin_stpcpy (dest, src);
+}
+
+void __attribute__ ((noinline))
+check (char *dest, char *src, size_t len)
+{
+  char *result;
+
+  result = my_stpcpy (dest, src);
+  if (result != dest + len)
+    __builtin_abort ();
+  if (__builtin_memcmp (src, dest, len) != 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  char *src[5] = { s.m32, s.m17, s.m16, s.m15, s.m1 };
+  char *dst[5] = { d.m32, d.m17, d.m16, d.m15, d.m1 };
+  int len[8] = { 33, 32, 31, 17, 16, 15, 1, 0 };
+  int i, j, k;
+  char backup;
+
+  for (i = 0; i < sizeof (s); i++)
+    ((char*)&s)[i] = i % 26 + 97;
+
+  for (i = 0; i < 5; i++)
+    for (j = 0; j < 5; j++)
+      for (k = 0; k < 8; k++)
+	{
+	  backup = src[j][len[k]];
+	  src[j][len[k]] = 0;
+	  __builtin_memset (&d, 0, sizeof (d));
+	  check (dst[i], src[j], len[k]);
+	  src[j][len[k]] = backup;
+	}
+
+  /* Make all source strings end before the page boundary.  */
+  backup = s.m1[0];
+  s.m1[0] = 0;
+
+  if (mprotect (&s.next_page, PAGE_SIZE, PROT_NONE) == -1)
+    perror ("mprotect src");
+
+  for (i = 0; i < 5; i++)
+    for (j = 0; j < 5; j++)
+      check (dst[i], src[j],
+	     PAGE_SIZE - ((unsigned long)src[j] & ((1UL << 12) - 1)) - 1);
+
+  if (mprotect (&s.next_page, PAGE_SIZE, PROT_READ | PROT_WRITE) == -1)
+    perror ("mprotect src");
+
+  s.m1[0] = backup;
+
+  if (mprotect (&d.next_page, PAGE_SIZE, PROT_NONE) == -1)
+    perror ("mprotect dst");
+
+  for (i = 0; i < 5; i++)
+    for (j = 0; j < 5; j++)
+      {
+	int len = PAGE_SIZE - ((unsigned long)dst[i] & ((1UL << 12) - 1)) - 1;
+	char backup = src[j][len];
+
+	src[j][len] = 0;
+	__builtin_memset (&d, 0,
+			  (unsigned long)&d.next_page - (unsigned long)&d);
+	check (dst[i], src[j], len);
+	src[j][len] = backup;
+      }
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/s390/vector/vec-vcond-1.c b/gcc/testsuite/gcc.target/s390/vector/vec-vcond-1.c
new file mode 100644
index 0000000..ec65c6f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/vector/vec-vcond-1.c
@@ -0,0 +1,23 @@
+/* A const vector operand is forced into a register in
+   s390_expand_vcond.
+   This testcase once failed because the target mode (v2di) was picked
+   for the reg instead of the mode of the other comparison
+   operand.  */
+
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
+
+typedef __attribute__((vector_size(16))) long   v2di;
+typedef __attribute__((vector_size(16))) double v2df;
+
+v2di
+foo (v2df a)
+{
+  return a == (v2df){ 0.0, 0.0 };
+}
+
+v2di
+bar (v2df a)
+{
+  return (v2df){ 1.0, 1.0 } == (v2df){ 0.0, 0.0 };
+}
diff --git a/gcc/testsuite/gcc.target/s390/vector/vec-vrepi-1.c b/gcc/testsuite/gcc.target/s390/vector/vec-vrepi-1.c
new file mode 100644
index 0000000..27bf39e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/vector/vec-vrepi-1.c
@@ -0,0 +1,58 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
+/* { dg-require-effective-target vector } */
+
+typedef unsigned char     uv16qi __attribute__((vector_size(16)));
+typedef unsigned short     uv8hi __attribute__((vector_size(16)));
+typedef unsigned int       uv4si __attribute__((vector_size(16)));
+typedef unsigned long long uv2di __attribute__((vector_size(16)));
+
+uv2di __attribute__((noinline))
+foo1 ()
+{
+  return (uv2di){ 0x7f0f, 0x7f0f };
+}
+/* { dg-final { scan-assembler-times "vrepig\t%v24,32527" 1 } } */
+
+uv4si __attribute__((noinline))
+foo2 ()
+{
+  return (uv4si){ 0x7f0f, 0x7f0f, 0x7f0f, 0x7f0f };
+}
+/* { dg-final { scan-assembler-times "vrepif\t%v24,32527" 1 } } */
+
+uv8hi __attribute__((noinline))
+foo3 ()
+{
+  return (uv8hi){ 0x7f0f, 0x7f0f, 0x7f0f, 0x7f0f,
+      0x7f0f, 0x7f0f, 0x7f0f, 0x7f0f };
+}
+/* { dg-final { scan-assembler-times "vrepih\t%v24,32527" 1 } } */
+
+uv16qi __attribute__((noinline))
+foo4 ()
+{
+  return (uv16qi){ 0x77, 0x77, 0x77, 0x77,
+      0x77, 0x77, 0x77, 0x77,
+      0x77, 0x77, 0x77, 0x77,
+      0x77, 0x77, 0x77, 0x77 };
+}
+/* { dg-final { scan-assembler-times "vrepib\t%v24,119" 1 } } */
+
+int
+main ()
+{
+  if (foo1()[1] != 0x7f0f)
+    __builtin_abort ();
+
+  if (foo2()[1] != 0x7f0f)
+    __builtin_abort ();
+
+  if (foo3()[1] != 0x7f0f)
+    __builtin_abort ();
+
+  if (foo4()[1] != 0x77)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-splat-1.c b/gcc/testsuite/gcc.target/s390/zvector/vec-splat-1.c
new file mode 100644
index 0000000..bab2e2d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-splat-1.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector signed char v16qi;
+vector short       v8hi;
+vector int         v4si;
+vector long long   v2di;
+
+vector unsigned char      uv16qi;
+vector unsigned short     uv8hi;
+vector unsigned int       uv4si;
+vector unsigned long long uv2di;
+
+int
+foo ()
+{
+  v16qi  = vec_splats ((signed char)0x77);
+  uv16qi = vec_splats ((unsigned char)0x77);
+
+  v8hi  = vec_splats ((short int)0x7f0f);
+  uv8hi = vec_splats ((unsigned short int)0x7f0f);
+
+  v4si  = vec_splats ((int)0x7f0f);
+  uv4si = vec_splats ((unsigned int)0x7f0f);
+
+  v2di  = vec_splats ((long long)0x7f0f);
+  uv2di = vec_splats ((unsigned long long)0x7f0f);
+}
+
+/* { dg-final { scan-assembler-times "vrepib\t%v.*,119" 1 } } */
+/* { dg-final { scan-assembler-times "vrepib\t%v.*,119" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepih\t%v.*,32527" 1 } } */
+/* { dg-final { scan-assembler-times "vrepih\t%v.*,32527" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepif\t%v.*,32527" 1 } } */
+/* { dg-final { scan-assembler-times "vrepif\t%v.*,32527" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepig\t%v.*,32527" 1 } } */
+/* { dg-final { scan-assembler-times "vrepig\t%v.*,32527" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-splat-2.c b/gcc/testsuite/gcc.target/s390/zvector/vec-splat-2.c
new file mode 100644
index 0000000..7ad090b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-splat-2.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector signed char v16qi;
+vector short       v8hi;
+vector int         v4si;
+vector long long   v2di;
+
+vector unsigned char      uv16qi;
+vector unsigned short     uv8hi;
+vector unsigned int       uv4si;
+vector unsigned long long uv2di;
+
+int
+foo ()
+{
+  v16qi  = vec_splat_s8 (-112);
+  uv16qi = vec_splat_u8 (215);
+
+  v8hi  = vec_splat_s16 (-32000);
+  uv8hi = vec_splat_u16 (64000);
+
+  v4si  = vec_splat_s32 (-32000);
+  uv4si = vec_splat_u32 (64000);
+
+  v2di  = vec_splat_s64 (-32000);
+  uv2di = vec_splat_u64 (64000);
+}
+
+/* { dg-final { scan-assembler-times "vrepib\t%v.*,-112" 1 } } */
+/* { dg-final { scan-assembler-times "vrepib\t%v.*,-41" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepih\t%v.*,-32000" 1 } } */
+/* { dg-final { scan-assembler-times "vrepih\t%v.*,-1536" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepif\t%v.*,-32000" 1 } } */
+/* { dg-final { scan-assembler-times "vrepif\t%v.*,-1536" 1 } } */
+
+/* { dg-final { scan-assembler-times "vrepig\t%v.*,-32000" 1 } } */
+/* { dg-final { scan-assembler-times "vrepig\t%v.*,-1536" 1 } } */
diff --git a/gcc/testsuite/gcc.target/sh/torture/pr67260.c b/gcc/testsuite/gcc.target/sh/torture/pr67260.c
new file mode 100644
index 0000000..a7b70f0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sh/torture/pr67260.c
@@ -0,0 +1,12 @@
+/* { dg-additional-options "-std=gnu99 -fPIC" }  */
+/* { dg-do compile }  */
+
+#pragma GCC visibility push(hidden)
+
+double _Complex foo (double _Complex arg);
+
+double _Complex
+bar (double _Complex arg)
+{
+  return foo (arg);
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20151219-1.c b/gcc/testsuite/gcc.target/sparc/20151219-1.c
new file mode 100644
index 0000000..efe720a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20151219-1.c
@@ -0,0 +1,39 @@
+/* PR rtl-optimization/68910 */
+/* Reported by Sebastian Huber <sebastian.huber@embedded-brains.de> */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -mtune=supersparc" } */
+
+typedef unsigned int size_t;
+typedef long long unsigned int uint64_t;
+
+extern void *memcpy (void *, const void *, size_t);
+
+void
+SHA512_Transform(uint64_t * state, const unsigned char block[128])
+{
+  uint64_t W[80];
+  uint64_t S[8];
+  uint64_t t0, t1;
+  int i;
+
+  memcpy ((void *)W, (const void *)block, (size_t)128);
+
+  for (i = 16; i < 80; i++)
+    W[i] = (((W[i - 2] >> 19) | (W[i - 2] << (64 - 19))) ^ ((W[i - 2] >> 61) | (W[i - 2] << (64 - 61))) ^ (W[i - 2] >> 6)) + W[i - 7] + (((W[i - 15] >> 1) | (W[i - 15] << (64 - 1))) ^ ((W[i - 15] >> 8) | (W[i - 15] << (64 - 8))) ^ (W[i - 15] >> 7)) + W[i - 16];
+
+  memcpy (S, state, 64);
+
+  t0 = S[(87 - 0) % 8] + (((S[(84 - 0) % 8] >> 14) | (S[(84 - 0) % 8] << (64 - 14))) ^ ((S[(84 - 0) % 8] >> 18) | (S[(84 - 0) % 8] << (64 - 18))) ^ ((S[(84 - 0) % 8] >> 41) | (S[(84 - 0) % 8] << (64 - 41)))) + ((S[(84 - 0) % 8] & (S[(85 - 0) % 8] ^ S[(86 - 0) % 8])) ^ S[(86 - 0) % 8]) + W[0] + 0x428a2f98d728ae22ULL; t1 = (((S[(80 - 0) % 8] >> 28) | (S[(80 - 0) % 8] << (64 - 28))) ^ ((S[(80 - 0) % 8] >> 34) | (S[(80 - 0) % 8] << (64 - 34))) ^ ((S[(80 - 0) % 8] >> 39) | (S[(80 - 0) % 8] << (64 - 39)))) + ((S[(80 - 0) % 8] & (S[(81 - 0) % 8] | S[(82 - 0) % 8])) | (S[(81 - 0) % 8] & S[(82 - 0) % 8])); S[(83 - 0) % 8] += t0; S[(87 - 0) % 8] = t0 + t1;
+
+  t0 = S[(87 - 1) % 8] + (((S[(84 - 1) % 8] >> 14) | (S[(84 - 1) % 8] << (64 - 14))) ^ ((S[(84 - 1) % 8] >> 18) | (S[(84 - 1) % 8] << (64 - 18))) ^ ((S[(84 - 1) % 8] >> 41) | (S[(84 - 1) % 8] << (64 - 41)))) + ((S[(84 - 1) % 8] & (S[(85 - 1) % 8] ^ S[(86 - 1) % 8])) ^ S[(86 - 1) % 8]) + W[1] + 0x7137449123ef65cdULL; t1 = (((S[(80 - 1) % 8] >> 28) | (S[(80 - 1) % 8] << (64 - 28))) ^ ((S[(80 - 1) % 8] >> 34) | (S[(80 - 1) % 8] << (64 - 34))) ^ ((S[(80 - 1) % 8] >> 39) | (S[(80 - 1) % 8] << (64 - 39)))) + ((S[(80 - 1) % 8] & (S[(81 - 1) % 8] | S[(82 - 1) % 8])) | (S[(81 - 1) % 8] & S[(82 - 1) % 8])); S[(83 - 1) % 8] += t0; S[(87 - 1) % 8] = t0 + t1;
+
+  t0 = S[(87 - 2) % 8] + (((S[(84 - 2) % 8] >> 14) | (S[(84 - 2) % 8] << (64 - 14))) ^ ((S[(84 - 2) % 8] >> 18) | (S[(84 - 2) % 8] << (64 - 18))) ^ ((S[(84 - 2) % 8] >> 41) | (S[(84 - 2) % 8] << (64 - 41)))) + ((S[(84 - 2) % 8] & (S[(85 - 2) % 8] ^ S[(86 - 2) % 8])) ^ S[(86 - 2) % 8]) + W[2] + 0xb5c0fbcfec4d3b2fULL; t1 = (((S[(80 - 2) % 8] >> 28) | (S[(80 - 2) % 8] << (64 - 28))) ^ ((S[(80 - 2) % 8] >> 34) | (S[(80 - 2) % 8] << (64 - 34))) ^ ((S[(80 - 2) % 8] >> 39) | (S[(80 - 2) % 8] << (64 - 39)))) + ((S[(80 - 2) % 8] & (S[(81 - 2) % 8] | S[(82 - 2) % 8])) | (S[(81 - 2) % 8] & S[(82 - 2) % 8])); S[(83 - 2) % 8] += t0; S[(87 - 2) % 8] = t0 + t1;
+
+  t0 = S[(87 - 3) % 8] + (((S[(84 - 3) % 8] >> 14) | (S[(84 - 3) % 8] << (64 - 14))) ^ ((S[(84 - 3) % 8] >> 18) | (S[(84 - 3) % 8] << (64 - 18))) ^ ((S[(84 - 3) % 8] >> 41) | (S[(84 - 3) % 8] << (64 - 41)))) + ((S[(84 - 3) % 8] & (S[(85 - 3) % 8] ^ S[(86 - 3) % 8])) ^ S[(86 - 3) % 8]) + W[3] + 0xe9b5dba58189dbbcULL; t1 = (((S[(80 - 3) % 8] >> 28) | (S[(80 - 3) % 8] << (64 - 28))) ^ ((S[(80 - 3) % 8] >> 34) | (S[(80 - 3) % 8] << (64 - 34))) ^ ((S[(80 - 3) % 8] >> 39) | (S[(80 - 3) % 8] << (64 - 39)))) + ((S[(80 - 3) % 8] & (S[(81 - 3) % 8] | S[(82 - 3) % 8])) | (S[(81 - 3) % 8] & S[(82 - 3) % 8])); S[(83 - 3) % 8] += t0; S[(87 - 3) % 8] = t0 + t1;
+
+  for (i = 0; i < 8; i++)
+    state[i] += S[i];
+}
+
+/* { dg-final { scan-assembler-not "stx\t%" } } */
diff --git a/gcc/testsuite/gfortran.dg/actual_array_offset_1.f90 b/gcc/testsuite/gfortran.dg/actual_array_offset_1.f90
new file mode 100644
index 0000000..f67bcfd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/actual_array_offset_1.f90
@@ -0,0 +1,167 @@
+! { dg-do run }
+!
+! Check the fix for PR67779, in which array sections passed in the
+! recursive calls to 'quicksort' had an incorrect offset.
+!
+! Contributed by Arjen Markus  <arjen.markus895@gmail.com>
+!
+! NOTE: This is the version of the testcase in comment #16 (from Thomas Koenig)
+!
+module myclass_def
+    implicit none
+
+    type, abstract :: myclass
+    contains
+        procedure(assign_object), deferred        :: copy
+        procedure(one_lower_than_two), deferred   :: lower
+        procedure(print_object), deferred         :: print
+        procedure, nopass                         :: quicksort  ! without nopass, it does not work
+    end type myclass
+
+    abstract interface
+        subroutine assign_object( left, right )
+            import                        :: myclass
+            class(myclass), intent(inout) :: left
+            class(myclass), intent(in)    :: right
+        end subroutine assign_object
+    end interface
+
+    abstract interface
+        logical function one_lower_than_two( op1, op2 )
+            import                     :: myclass
+            class(myclass), intent(in) :: op1, op2
+        end function one_lower_than_two
+    end interface
+
+    abstract interface
+        subroutine print_object( obj )
+            import                     :: myclass
+            class(myclass), intent(in) :: obj
+        end subroutine print_object
+    end interface
+
+    !
+    ! Type containing a real
+    !
+
+    type, extends(myclass) :: mysortable
+        integer :: value
+    contains
+        procedure :: copy    => copy_sortable
+        procedure :: lower   => lower_sortable
+        procedure :: print   => print_sortable
+    end type mysortable
+
+contains
+!
+! Generic part
+!
+recursive subroutine quicksort( array )
+    class(myclass), dimension(:) :: array
+
+    class(myclass), allocatable :: v, tmp
+    integer                     :: i, j
+
+    integer :: k
+
+    i = 1
+    j = size(array)
+
+    allocate( v,   source = array(1) )
+    allocate( tmp, source = array(1) )
+
+    call v%copy( array((j+i)/2) ) ! Use the middle element
+
+    do
+        do while ( array(i)%lower(v) )
+            i = i + 1
+        enddo
+        do while ( v%lower(array(j)) )
+            j = j - 1
+        enddo
+
+        if ( i <= j ) then
+            call tmp%copy( array(i) )
+            call array(i)%copy( array(j) )
+            call array(j)%copy( tmp )
+            i        = i + 1
+            j        = j - 1
+        endif
+
+        if ( i > j ) then
+            exit
+        endif
+    enddo
+
+    if ( 1 < j ) then
+        call quicksort( array(1:j) ) ! Problem here
+    endif
+
+    if ( i < size(array) ) then
+        call quicksort( array(i:) )  ! ....and here
+    endif
+end subroutine quicksort
+
+!
+! Specific part
+!
+subroutine copy_sortable( left, right )
+    class(mysortable), intent(inout) :: left
+    class(myclass), intent(in)       :: right
+
+    select type (right)
+        type is (mysortable)
+            select type (left)
+                type is (mysortable)
+                    left = right
+            end select
+    end select
+end subroutine copy_sortable
+
+logical function lower_sortable( op1, op2 )
+    class(mysortable), intent(in) :: op1
+    class(myclass),    intent(in) :: op2
+
+    select type (op2)
+        type is (mysortable)
+            lower_sortable = op1%value < op2%value
+    end select
+end function lower_sortable
+
+subroutine print_sortable( obj )
+    class(mysortable), intent(in) :: obj
+
+    write(*,'(G0," ")', advance="no") obj%value
+end subroutine print_sortable
+
+end module myclass_def
+
+
+! test program
+program test_quicksort
+    use myclass_def
+
+    implicit none
+
+    type(mysortable), dimension(20) :: array
+    real, dimension(20) :: values
+
+    call random_number(values)
+
+    array%value = int (1000000 * values)
+
+! It would be pretty perverse if this failed!
+    if (check (array)) call abort
+
+    call quicksort( array )
+
+! Check the the array is correctly ordered
+    if (.not.check (array)) call abort
+contains
+     logical function check (arg)
+         type(mysortable), dimension(:) :: arg
+         integer                        :: s
+         s = size (arg, 1)
+         check = all (arg(2 : s)%value .ge. arg(1 : s - 1)%value)
+     end function check
+end program test_quicksort
diff --git a/gcc/testsuite/gfortran.dg/alloc_comp_auto_array_3.f90 b/gcc/testsuite/gfortran.dg/alloc_comp_auto_array_3.f90
new file mode 100644
index 0000000..c96a4df
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/alloc_comp_auto_array_3.f90
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR66082. The original problem was with the first
+! call foo_1d.
+!
+! Reported by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  type foo_t
+    real, allocatable :: bigarr
+  end type
+  block
+    type(foo_t) :: foo
+    allocate(foo%bigarr)
+    call foo_1d (1,[foo]) ! was lost
+    call foo_1d (1,bar_1d()) ! Check that this is OK
+  end block
+contains
+  subroutine foo_1d (n,foo)
+    integer n
+    type(foo_t) :: foo(n)
+  end subroutine
+  function bar_1d () result (array)
+    type(foo_t) :: array(1)
+    allocate (array(1)%bigarr)
+  end function
+end
+! { dg-final { scan-tree-dump-times "builtin_malloc" 4 "original" } }
+! { dg-final { scan-tree-dump-times "builtin_free" 4 "original" } }
+! { dg-final { scan-tree-dump-times "while \\(1\\)" 4 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90 b/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
index 532f364..1d60154 100644
--- a/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
+++ b/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
@@ -67,6 +67,6 @@ contains
 !    allocate(res, source = arg) ! Caused an ICE
 !  end subroutine
 end
-! { dg-final { scan-tree-dump-times "builtin_malloc" 15 "original" } }
-! { dg-final { scan-tree-dump-times "builtin_free" 17 "original" } }
+! { dg-final { scan-tree-dump-times "builtin_malloc" 16 "original" } }
+! { dg-final { scan-tree-dump-times "builtin_free" 16 "original" } }
 ! { dg-final { cleanup-tree-dump "original" } }
diff --git a/gcc/testsuite/gfortran.dg/allocate_error_5.f90 b/gcc/testsuite/gfortran.dg/allocate_error_5.f90
new file mode 100644
index 0000000..4e5f4bd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_error_5.f90
@@ -0,0 +1,23 @@
+! { dg-do run }
+! { dg-additional-options "-fcheck=mem" }
+! { dg-shouldfail "Fortran runtime error: Assignment of scalar to unallocated array" }
+!
+! This omission was encountered in the course of fixing PR54070. Whilst this is a
+! very specific case, others such as allocatable components have been tested.
+!
+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>
+!
+function g(a) result (res)
+  character(len=*) :: a
+  character(len=:),allocatable :: res(:)
+  res = a  ! Since 'res' is not allocated, a runtime error should occur.
+end function
+
+  interface
+    function g(a) result(res)
+      character(len=*) :: a
+      character(len=:),allocatable :: res(:)
+    end function
+  end interface
+  print *, g("ABC")
+end
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_source_14.f03 b/gcc/testsuite/gfortran.dg/allocate_with_source_14.f03
index 5ca47a6..36c1245 100644
--- a/gcc/testsuite/gfortran.dg/allocate_with_source_14.f03
+++ b/gcc/testsuite/gfortran.dg/allocate_with_source_14.f03
@@ -210,5 +210,5 @@ program main
   call v%free()
   deallocate(av)
 end program
-! { dg-final { scan-tree-dump-times "__builtin_malloc" 21 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 23 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_free" 29 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_source_16.f90 b/gcc/testsuite/gfortran.dg/allocate_with_source_16.f90
new file mode 100644
index 0000000..977202d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_with_source_16.f90
@@ -0,0 +1,26 @@
+!{ dg-do compile }
+! PR69268
+!
+! Contributed by Rich Townsend  <townsend@astro.wisc.edu>
+
+program test_sourced_alloc
+
+  implicit none
+ 
+  type :: foo_t
+  end type foo_t
+
+  class(foo_t), allocatable :: f
+
+  allocate(f, SOURCE=f_func())
+
+contains
+
+  function f_func () result (f)
+    type(foo_t) :: f
+    integer, save :: c = 0
+    c = c + 1
+    if (c .gt. 1) call abort()
+  end function f_func
+
+end program test_sourced_alloc 
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_source_18.f03 b/gcc/testsuite/gfortran.dg/allocate_with_source_18.f03
new file mode 100644
index 0000000..746bd0d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_with_source_18.f03
@@ -0,0 +1,31 @@
+! { dg-do run }
+!
+! PR fortran/57365
+! [OOP] Sourced allocation fails with unlimited polymorphism
+! Contributed by <rxs@hotmail.de>
+!
+program bug
+
+    implicit none
+    character(len=:), allocatable :: test
+
+    test = "A test case"
+    call allocate_test(test)
+    deallocate(test)
+
+contains
+
+    subroutine allocate_test(var)
+        class(*) :: var
+        class(*), pointer :: copyofvar
+        allocate(copyofvar, source=var)
+        select type (copyofvar)
+            type is (character(len=*))
+!                print*, len(copyofvar), copyofvar
+                if (len(copyofvar) /= 11) call abort ()
+                if (copyofvar /= "A test case") call abort ()
+        end select
+        deallocate(copyofvar)
+    end subroutine
+
+end program bug
diff --git a/gcc/testsuite/gfortran.dg/coarray/event_1.f90 b/gcc/testsuite/gfortran.dg/coarray/event_1.f90
new file mode 100644
index 0000000..b4385f3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/event_1.f90
@@ -0,0 +1,51 @@
+! { dg-do run }
+!
+! Run-time test for EVENT_TYPE
+!
+use iso_fortran_env, only: event_type
+implicit none
+
+type(event_type), save :: var[*]
+integer :: count, stat
+
+count = -42
+call event_query (var, count)
+if (count /= 0) call abort()
+
+stat = 99
+event post (var, stat=stat)
+if (stat /= 0) call abort()
+call event_query(var, count, stat=stat)
+if (count /= 1 .or. stat /= 0) call abort()
+
+stat = 99
+event post (var[this_image()])
+call event_query(var, count)
+if (count /= 2) call abort()
+
+stat = 99
+event wait (var)
+call event_query(var, count)
+if (count /= 1) call abort()
+
+stat = 99
+event post (var)
+call event_query(var, count)
+if (count /= 2) call abort()
+
+stat = 99
+event post (var)
+call event_query(var, count)
+if (count /= 3) call abort()
+
+stat = 99
+event wait (var, until_count=2)
+call event_query(var, count)
+if (count /= 1) call abort()
+
+stat = 99
+event wait (var, stat=stat, until_count=1)
+if (stat /= 0) call abort()
+call event_query(event=var, stat=stat, count=count)
+if (count /= 0 .or. stat /= 0) call abort()
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray/event_2.f90 b/gcc/testsuite/gfortran.dg/coarray/event_2.f90
new file mode 100644
index 0000000..2d451a5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/event_2.f90
@@ -0,0 +1,89 @@
+! { dg-do run }
+!
+! Run-time test for EVENT_TYPE
+!
+use iso_fortran_env, only: event_type
+implicit none
+
+type(event_type), save, allocatable :: var(:)[:]
+integer :: count, stat
+
+allocate(var(3)[*])
+
+count = -42
+call event_query (var(1), count)
+if (count /= 0) call abort()
+call event_query (var(1), count)
+if (count /= 0) call abort()
+call event_query (var(2), count)
+if (count /= 0) call abort()
+call event_query (var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event post (var(2), stat=stat)
+if (stat /= 0) call abort()
+call event_query (var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count, stat=stat)
+if (count /= 1 .or. stat /= 0) call abort()
+call event_query (var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event post (var(2)[this_image()])
+call event_query(var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count)
+if (count /= 2) call abort()
+call event_query(var(2), count)
+if (count /= 2) call abort()
+call event_query(var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event wait (var(2))
+call event_query(var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count)
+if (count /= 1) call abort()
+call event_query(var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event post (var(2))
+call event_query(var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count)
+if (count /= 2) call abort()
+call event_query(var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event post (var(2))
+call event_query(var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count)
+if (count /= 3) call abort()
+call event_query(var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event wait (var(2), until_count=2)
+call event_query(var(1), count)
+if (count /= 0) call abort()
+call event_query(var(2), count)
+if (count /= 1) call abort()
+call event_query(var(3), count)
+if (count /= 0) call abort()
+
+stat = 99
+event wait (var(2), stat=stat, until_count=1)
+if (stat /= 0) call abort()
+call event_query(event=var(1), stat=stat, count=count)
+if (count /= 0 .or. stat /= 0) call abort()
+call event_query(event=var(2), stat=stat, count=count)
+if (count /= 0 .or. stat /= 0) call abort()
+call event_query(event=var(3), stat=stat, count=count)
+if (count /= 0 .or. stat /= 0) call abort()
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_40.f90 b/gcc/testsuite/gfortran.dg/coarray_40.f90
new file mode 100644
index 0000000..d40a65a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_40.f90
@@ -0,0 +1,26 @@
+! { dg-do run }
+! { dg-options "-fcoarray=lib -lcaf_single" }
+! { dg-additional-options "-latomic" { target libatomic_available } }
+!
+! Run-time test for memory consistency
+!
+! Contributed by Deepak Eachempati
+
+program cp_bug
+    implicit none
+    integer :: v1, v2, u[*]
+    integer :: me
+
+    me = this_image()
+
+    u = 0
+    v1 = 10
+
+    v1 = u[me]
+
+    ! v2 should get value in u (0)
+    v2 = v1
+
+    if(v2 /= u) call abort()
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_2.f08 b/gcc/testsuite/gfortran.dg/coarray_allocate_2.f08
new file mode 100644
index 0000000..7a712a9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_2.f08
@@ -0,0 +1,26 @@
+! { dg-do run }
+! { dg-options "-fcoarray=single" }
+!
+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>
+! Extended by Andre Vehreschild  <vehre@gcc.gnu.org>
+! to test that coarray references in allocate work now
+! PR fortran/67451
+
+  program main
+    implicit none
+    type foo
+      integer :: bar = 99
+    end type
+    class(foo), allocatable :: foobar[:]
+    class(foo), allocatable :: some_local_object
+    allocate(foobar[*])
+
+    allocate(some_local_object, source=foobar)
+
+    if (.not. allocated(foobar)) call abort()
+    if (.not. allocated(some_local_object)) call abort()
+
+    deallocate(some_local_object)
+    deallocate(foobar)
+  end program
+
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_3.f08 b/gcc/testsuite/gfortran.dg/coarray_allocate_3.f08
new file mode 100644
index 0000000..b9413b6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_3.f08
@@ -0,0 +1,28 @@
+! { dg-do run }
+! { dg-options "-fcoarray=single" }
+!
+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>
+! Extended by Andre Vehreschild  <vehre@gcc.gnu.org>
+! to test that coarray references in allocate work now
+! PR fortran/67451
+
+  program main
+    implicit none
+    type foo
+      integer :: bar = 99
+    end type
+    class(foo), dimension(:), allocatable :: foobar[:]
+    class(foo), dimension(:), allocatable :: some_local_object
+    allocate(foobar(10)[*])
+
+    allocate(some_local_object(10), source=foobar)
+
+    if (.not. allocated(foobar)) call abort()
+    if (lbound(foobar, 1) /= 1 .OR. ubound(foobar, 1) /= 10) call abort()
+    if (.not. allocated(some_local_object)) call abort()
+    if (any(some_local_object(:)%bar /= [99, 99,  99, 99, 99, 99, 99, 99, 99, 99])) call abort()
+
+    deallocate(some_local_object)
+    deallocate(foobar)
+  end program
+
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_4.f08 b/gcc/testsuite/gfortran.dg/coarray_allocate_4.f08
new file mode 100644
index 0000000..a36d796
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_4.f08
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-options "-fcoarray=single" }
+!
+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>
+!               Andre Vehreschild <vehre@gcc.gnu.org>
+! Check that PR fortran/69451 is fixed.
+
+program main
+
+implicit none
+
+type foo
+end type
+
+class(foo), allocatable :: p[:]
+class(foo), pointer :: r
+class(*), allocatable, target :: z
+
+allocate(p[*])
+
+call s(p, z)
+select type (z)
+  class is (foo) 
+        r => z
+  class default
+     call abort()
+end select
+
+if (.not. associated(r)) call abort()
+
+deallocate(r)
+deallocate(p)
+
+contains
+
+subroutine s(x, z) 
+   class(*) :: x[*]
+   class(*), allocatable:: z
+   allocate (z, source=x)
+end
+
+end
+
diff --git a/gcc/testsuite/gfortran.dg/coarray_critical_1.f90 b/gcc/testsuite/gfortran.dg/coarray_critical_1.f90
new file mode 100644
index 0000000..4d93bf6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_critical_1.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+
+module m
+ contains
+   subroutine f()
+     critical
+     end critical
+   end subroutine f
+ end module m
+end program
diff --git a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90 b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
index e57b328..a0ea533 100644
--- a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
+++ b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
@@ -1,6 +1,6 @@
 ! { dg-do run }
-! { dg-options "-fdump-tree-original -fcoarray=lib -lcaf_single -latomic" { target libatomic_available } }
-! { dg-options "-fdump-tree-original -fcoarray=lib -lcaf_single" { target { ! libatomic_available } } }
+! { dg-options "-fdump-tree-original -fcoarray=lib -lcaf_single" }
+! { dg-additional-options "-latomic" { target libatomic_available } }
 !
 ! Some dependency-analysis check for coarray communication
 !
diff --git a/gcc/testsuite/gfortran.dg/common_22.f90 b/gcc/testsuite/gfortran.dg/common_22.f90
new file mode 100644
index 0000000..e225409
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/common_22.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+!
+! PR fortran/59746
+! Check that symbols present in common block are properly cleaned up
+! upon error.
+!
+! Contributed by Bud Davis  <jmdavis@link.com>
+
+      CALL RCCFL (NVE,IR,NU3,VE (1,1,1,I))
+      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+      COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+!  the PR only contained the two above.
+!  success is no segfaults or infinite loops.
+!  let's check some combinations
+     CALL ABC (INTG)
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     CALL DEF (NT1)
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     CALL GHI (NRESL)
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     COMMON /CCFILE/ INTG,NT1,NT2,NT3,NVM,NVE,NFRLE,NRESF,NRESL !{ dg-error "Unexpected COMMON" }
+     END
diff --git a/gcc/testsuite/gfortran.dg/common_23.f90 b/gcc/testsuite/gfortran.dg/common_23.f90
new file mode 100644
index 0000000..3f1f005
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/common_23.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/66707
+! Check the compilation on wrong usage of common
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+program p
+   integer, pointer :: a
+   common a, a ! { dg-error "is already in a COMMON block" }
+   common a
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_1.f90 b/gcc/testsuite/gfortran.dg/deferred_character_1.f90
new file mode 100644
index 0000000..0772c70
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_1.f90
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! Tests the fix for PR50221
+!
+! Contributed by Clive Page  <clivegpage@gmail.com>
+!            and Tobias Burnus  <burnus@gcc.gnu.org>
+!
+! This is from comment #2 by Tobias Burnus.
+!
+module m
+  character(len=:), save, allocatable :: str(:)
+  character(len=2), parameter :: const(3) = ["a1", "b2", "c3"]
+end
+
+  use m
+  call test()
+  if(allocated(str)) deallocate(str)
+  call foo
+contains
+  subroutine test()
+    call doit()
+!    print *, 'strlen=',len(str),' / array size =',size(str)
+!    print '(3a)', '>',str(1),'<'
+!    print '(3a)', '>',str(2),'<'
+!    print '(3a)', '>',str(3),'<'
+    if (any (str .ne. const)) call abort
+  end subroutine test
+  subroutine doit()
+    str = const
+  end subroutine doit
+  subroutine foo
+!
+! This is the original PR from Clive Page
+!
+    character(:), allocatable, dimension(:) :: array
+    array = (/'xx', 'yy', 'zz'/)
+!    print *, 'array=', array, len(array(1)), size(array)
+    if (any (array .ne. ["xx", "yy", "zz"])) call abort
+  end subroutine
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_10.f90 b/gcc/testsuite/gfortran.dg/deferred_character_10.f90
new file mode 100644
index 0000000..6a36741
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_10.f90
@@ -0,0 +1,52 @@
+! { dg-do run }
+!
+! Checks that PR60593 is fixed (Revision: 214757)
+!
+! Contributed by Steve Kargl  <kargl@gcc.gnu.org>
+!
+! Main program added for this test.
+!
+module stringhelper_m
+
+  implicit none
+
+  type :: string_t
+     character(:), allocatable :: string
+  end type
+
+  interface len
+     function strlen(s) bind(c,name='strlen')
+       use iso_c_binding
+       implicit none
+       type(c_ptr), intent(in), value :: s
+       integer(c_size_t) :: strlen
+     end function
+  end interface
+
+  contains
+
+    function C2FChar(c_charptr) result(res)
+      use iso_c_binding
+      type(c_ptr), intent(in) :: c_charptr
+      character(:), allocatable :: res
+      character(kind=c_char,len=1), pointer :: string_p(:)
+      integer i, c_str_len
+      c_str_len = int(len(c_charptr))
+      call c_f_pointer(c_charptr, string_p, [c_str_len])
+      allocate(character(c_str_len) :: res)
+      forall (i = 1:c_str_len) res(i:i) = string_p(i)
+    end function
+
+end module
+
+  use stringhelper_m
+  use iso_c_binding
+  implicit none
+  type(c_ptr) :: cptr
+  character(20), target :: str
+
+  str = "abcdefghij"//char(0)
+  cptr = c_loc (str)
+  if (len (C2FChar (cptr)) .ne. 10) call abort
+  if (C2FChar (cptr) .ne. "abcdefghij") call abort
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_11.f90 b/gcc/testsuite/gfortran.dg/deferred_character_11.f90
new file mode 100644
index 0000000..454cf47
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_11.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! Test the fix for PR61147.
+!
+! Contributed by Thomas Clune  <Thomas.L.Clune@nasa.gov>
+!
+module B_mod
+
+   type :: B
+      character(:), allocatable :: string
+   end type B
+
+contains
+
+   function toPointer(this) result(ptr)
+      character(:), pointer :: ptr
+      class (B), intent(in), target :: this
+
+         ptr => this%string
+
+   end function toPointer
+
+end module B_mod
+
+program main
+   use B_mod
+
+   type (B) :: obj
+   character(:), pointer :: p
+
+   obj%string = 'foo'
+   p => toPointer(obj)
+
+   If (len (p) .ne. 3) call abort
+   If (p .ne. "foo") call abort
+
+end program main
+
+
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_12.f90 b/gcc/testsuite/gfortran.dg/deferred_character_12.f90
new file mode 100644
index 0000000..cdb6c89
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_12.f90
@@ -0,0 +1,37 @@
+! { dg-do run }
+!
+! Tests the fix for PR63232
+!
+! Contributed by Balint Aradi  <baradi09@gmail.com>
+!
+module mymod
+  implicit none
+
+  type :: wrapper
+    character(:), allocatable :: string
+  end type wrapper
+
+contains
+
+
+  subroutine sub2(mystring)
+    character(:), allocatable, intent(out) :: mystring
+
+    mystring = "test"
+
+  end subroutine sub2
+
+end module mymod
+
+
+program test
+  use mymod
+  implicit none
+
+  type(wrapper) :: mywrapper
+
+  call sub2(mywrapper%string)
+  if (.not. allocated(mywrapper%string)) call abort
+  if (trim(mywrapper%string) .ne. "test") call abort
+
+end program test
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_13.f90 b/gcc/testsuite/gfortran.dg/deferred_character_13.f90
new file mode 100644
index 0000000..822cc5d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_13.f90
@@ -0,0 +1,34 @@
+! { dg-do run }
+!
+! Tests the fix for PR49630 comment #3.
+!
+! Contributed by Janus Weil  <janus@gcc.gnu.org>
+!
+module abc
+  implicit none
+
+  type::abc_type
+   contains
+     procedure::abc_function
+  end type abc_type
+
+contains
+
+  function abc_function(this)
+    class(abc_type),intent(in)::this
+    character(:),allocatable::abc_function
+    allocate(abc_function,source="hello")
+  end function abc_function
+
+  subroutine do_something(this)
+    class(abc_type),intent(in)::this
+    if (this%abc_function() .ne. "hello") call abort
+  end subroutine do_something
+
+end module abc
+
+
+  use abc
+  type(abc_type) :: a
+  call do_something(a)
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_14.f90 b/gcc/testsuite/gfortran.dg/deferred_character_14.f90
new file mode 100644
index 0000000..3c4163e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_14.f90
@@ -0,0 +1,30 @@
+! { dg-do run }
+!
+! Test fix for PR60795 comments #1 and  #4
+!
+! Contributed by Kergonath  <kergonath@me.com>
+!
+module m
+contains
+    subroutine allocate_array(s_array)
+        character(:), dimension(:), allocatable, intent(out) :: s_array
+
+        allocate(character(2) :: s_array(2))
+        s_array = ["ab","cd"]
+    end subroutine
+end module
+
+program stringtest
+    use m
+    character(:), dimension(:), allocatable :: s4
+    character(:), dimension(:), allocatable :: s
+! Comment #1
+    allocate(character(1) :: s(10))
+    if (size (s) .ne. 10) call abort
+    if (len (s) .ne. 1) call abort
+! Comment #4
+    call allocate_array(s4)
+    if (size (s4) .ne. 2) call abort
+    if (len (s4) .ne. 2) call abort
+    if (any (s4 .ne. ["ab", "cd"])) call abort
+ end program
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_15.f90 b/gcc/testsuite/gfortran.dg/deferred_character_15.f90
new file mode 100644
index 0000000..c641c1f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_15.f90
@@ -0,0 +1,44 @@
+! { dg-do run }
+!
+! Test the fix for PR69423.
+!
+! Contributed by Antony Lewis  <antony@cosmologist.info>
+!
+program tester
+  character(LEN=:), allocatable :: S
+  S= test(2)
+  if (len(S) .ne. 4) call abort
+  if (S .ne. "test") call abort
+  if (allocated (S)) deallocate (S)
+
+  S= test2(2)
+  if (len(S) .ne. 4) call abort
+  if (S .ne. "test") call abort
+  if (allocated (S)) deallocate (S)
+contains
+  function test(alen)
+    character(LEN=:), allocatable :: test
+    integer alen, i
+    do i = alen, 1, -1
+      test = 'test'
+      exit
+    end do
+!       This line would print nothing when compiled with -O1 and higher.
+!       print *, len(test),test
+    if (len(test) .ne. 4) call abort
+    if (test .ne. "test") call abort
+  end function test
+
+  function test2(alen) result (test)
+    character(LEN=:), allocatable :: test
+    integer alen, i
+    do i = alen, 1, -1
+      test = 'test'
+      exit
+    end do
+!       This worked before the fix.
+!       print *, len(test),test
+    if (len(test) .ne. 4) call abort
+    if (test .ne. "test") call abort
+  end function test2
+end program tester
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_2.f90 b/gcc/testsuite/gfortran.dg/deferred_character_2.f90
new file mode 100644
index 0000000..bac738b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_2.f90
@@ -0,0 +1,89 @@
+! { dg-do run }
+!
+! Tests the fix for PR68216
+!
+! Reported on clf: https://groups.google.com/forum/#!topic/comp.lang.fortran/eWQTKfqKLZc
+!
+PROGRAM hello
+!
+! This is based on the first testcase, from Francisco (Ayyy LMAO). Original
+! lines are commented out. The second testcase from this thread is acalled
+! at the end of the program.
+!
+    IMPLICIT NONE
+
+    CHARACTER(LEN=:),DIMENSION(:),ALLOCATABLE :: array_lineas
+    CHARACTER(LEN=:),DIMENSION(:),ALLOCATABLE :: array_copia
+    character (3), dimension (2) :: array_fijo = ["abc","def"]
+    character (100) :: buffer
+    INTEGER :: largo , cant_lineas , i
+
+    write (buffer, "(2a3)") array_fijo
+
+!    WRITE(*,*) ' Escriba un numero para el largo de cada linea'
+!    READ(*,*) largo
+    largo = LEN (array_fijo)
+
+!    WRITE(*,*) ' Escriba la cantidad de lineas'
+!    READ(*,*) cant_lineas
+    cant_lineas = size (array_fijo, 1)
+
+    ALLOCATE(CHARACTER(LEN=largo) :: array_lineas(cant_lineas))
+
+!    WRITE(*,*) 'Escriba el array', len(array_lineas), size(array_lineas)
+    READ(buffer,"(2a3)") (array_lineas(i),i=1,cant_lineas)
+
+!    WRITE(*,*) 'Array guardado: '
+!    DO i=1,cant_lineas
+!    WRITE(*,*) array_lineas(i)
+!    ENDDO
+     if (any (array_lineas .ne. array_fijo)) call abort
+
+! The following are additional tests beyond that of the original.
+! NOTE: These tests all work in 6 branch but those involving deferred length
+! SOURCE or MOLD do not work correctly in 5 branch because the requisite
+! patches to gfc_trans_allocate have not been backported.
+!
+! Check that allocation with source = another deferred length is OK
+!     allocate (array_copia(size (array_lineas, 1)), source = array_lineas)
+!     if (any (array_copia .ne. array_fijo)) call abort
+!     deallocate (array_lineas, array_copia)
+     deallocate (array_lineas)
+
+! Check that allocation with source = a non-deferred length is OK
+     allocate (array_lineas(size (array_fijo, 1)), source = array_fijo)
+     if (any (array_lineas .ne. array_fijo)) call abort
+     deallocate (array_lineas)
+
+! Check that allocation with MOLD = a non-deferred length is OK
+     allocate (array_copia(4), mold = [array_fijo(:)(1:2), array_fijo(:)(1:2)])
+     if (size (array_copia, 1) .ne. 4) call abort
+     if (LEN (array_copia) .ne. 2) call abort
+
+! Check that allocation with MOLD = another deferred length is OK
+!     allocate (array_lineas(4), mold = array_copia)
+!     if (size (array_lineas, 1) .ne. 4) call abort
+!     if (LEN (array_lineas) .ne. 2) call abort
+!     deallocate (array_lineas, array_copia)
+
+!    READ(*,*)
+     call testdefchar
+contains
+     subroutine testdefchar
+!
+! This is the testcase in the above thread from Blokbuster
+!
+          implicit none
+          character(:), allocatable :: test(:)
+
+          allocate(character(3) :: test(2))
+          test(1) = 'abc'
+          test(2) = 'def'
+          if (any (test .ne. ['abc', 'def'])) call abort
+
+          test = ['aa','bb','cc']
+          if (any (test .ne. ['aa', 'bb', 'cc'])) call abort
+
+     end subroutine testdefchar
+
+END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_3.f90 b/gcc/testsuite/gfortran.dg/deferred_character_3.f90
new file mode 100644
index 0000000..8f29337
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_3.f90
@@ -0,0 +1,46 @@
+! {dg_do run }
+!
+! Tests the fix for PR67674
+!
+! Contributed by Kristopher Kuhlman  <kristopher.kuhlman@gmail.com>
+!
+program test
+  implicit none
+
+  type string_type
+    character(len=:), allocatable :: name
+  end type string_type
+  type(string_type), allocatable :: my_string_type
+
+  allocate(my_string_type)
+  allocate(character(len=0) :: my_string_type%name)
+
+!  print *, 'length main program before',len(my_string_type%name)
+
+  call inputreadword1(my_string_type%name)
+
+!  print *, 'length main program after',len(my_string_type%name)
+!  print *, 'final result:',my_string_type%name
+  if (my_string_type%name .ne. 'here the word is finally set') call abort
+
+contains
+  subroutine inputreadword1(word_intermediate)
+    character(len=:), allocatable :: word_intermediate
+
+!    print *, 'length intermediate before',len(word_intermediate)
+    call inputreadword2(word_intermediate)
+!    print *, 'length intermediate after',len(word_intermediate)
+!    print *, word_intermediate
+
+  end subroutine inputreadword1
+
+  subroutine inputreadword2(word)
+    character(len=:), allocatable :: word
+
+!    print *, 'length inner before',len(word)
+    word = 'here the word is finally set' ! want automatic reallocation to happen here
+!    print *, 'length inner after',len(word)
+!    print *, word
+
+  end subroutine inputreadword2
+end program test
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_4.f90 b/gcc/testsuite/gfortran.dg/deferred_character_4.f90
new file mode 100644
index 0000000..5bb8658
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_4.f90
@@ -0,0 +1,30 @@
+! { dg-do run }
+!
+! Check that PR50221 comment #4 is fixed.
+!
+! Contributed by Arjen Makus  <arjen.markus895@gmail.com>
+!
+program chk_alloc_string
+    implicit none
+
+    character(len=:), dimension(:), allocatable :: strings
+    character(20) :: buffer
+    integer :: i
+
+    allocate( character(10):: strings(1:3) )
+
+    strings = [ "A   ", "C   ", "ABCD", "V   " ]
+
+    if (len(strings) .ne. 4) call abort
+    if (size(strings, 1) .ne. 4) call abort
+    if (any (strings .ne. [character(len=4) :: "A", "C", "ABCD", "V"])) call abort
+
+    strings = [character(len=4) :: "A", "C", "ABCDE", "V", "zzzz"]
+
+    if (len(strings) .ne. 4) call abort
+    if (size(strings, 1) .ne. 5) call abort
+    if (any (strings .ne. [character(len=4) :: "A", "C", "ABCD", "V", "zzzz"])) call abort
+
+    write (buffer, "(5a4)") strings
+    if (buffer .ne. "A   C   ABCDV   zzzz") call abort
+end program chk_alloc_string
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_5.f90 b/gcc/testsuite/gfortran.dg/deferred_character_5.f90
new file mode 100644
index 0000000..b5d64b4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_5.f90
@@ -0,0 +1,32 @@
+! { dg-do run }
+!
+! Tests that PR63932 stays fixed.
+!
+! Contributed by Valery Weber  <valeryweber@hotmail.com>
+!
+module mod
+  type :: t
+     character(:), allocatable :: c
+     integer :: i
+   contains
+     procedure, pass :: get
+  end type t
+  type :: u
+     character(:), allocatable :: c
+  end type u
+contains
+  subroutine get(this, a)
+    class(t), intent(in) :: this
+    character(:), allocatable, intent(out), optional :: a
+    if (present (a)) a = this%c
+  end subroutine get
+end module mod
+
+program test
+  use mod
+  type(t) :: a
+  type(u) :: b
+  a%c = 'something'
+  call a%get (a = b%c)
+  if (b%c .ne. 'something') call abort
+end program test
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_6.f90 b/gcc/testsuite/gfortran.dg/deferred_character_6.f90
new file mode 100644
index 0000000..94afa0c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_6.f90
@@ -0,0 +1,54 @@
+! { dg-do run }
+!
+! Tests that PR66408 stays fixed.
+!
+! Contributed by <werner.blokbuster@gmail.com>
+!
+module mytest
+
+    implicit none
+
+    type vary
+        character(:), allocatable :: string
+    end type vary
+
+    interface assignment(=)
+        module procedure char_eq_vary
+    end interface assignment(=)
+
+contains
+
+    subroutine char_eq_vary(my_char,my_vary)
+        character(:), allocatable, intent(out) :: my_char
+        type(vary), intent(in) :: my_vary
+        my_char = my_vary%string
+    end subroutine char_eq_vary
+
+end module mytest
+
+
+program thistest
+
+    use mytest, only: vary, assignment(=)
+    implicit none
+
+    character(:), allocatable :: test_char
+    character(14), parameter :: str = 'example string'
+    type(vary) :: test_vary
+    type(vary) :: my_stuff
+
+
+    test_vary%string = str
+    if (test_vary%string .ne. str) call abort
+
+! This previously gave a blank string.
+    my_stuff%string = test_vary
+    if (my_stuff%string .ne. str) call abort
+
+    test_char = test_vary
+    if (test_char .ne. str) call abort
+
+    my_stuff = test_vary
+    if (my_stuff%string .ne. str) call abort
+
+end program thistest
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_7.f90 b/gcc/testsuite/gfortran.dg/deferred_character_7.f90
new file mode 100644
index 0000000..64b03ab
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_7.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! Tests the fix for pr49954, in which concatenation to deferred length character
+! arrays, at best, did not work correctly.
+!
+!
+!
+implicit none
+  character(len=:), allocatable :: a1(:)
+  character(len=:), allocatable :: a2(:), a3(:)
+  character(len=:), allocatable :: b1
+  character(len=:), allocatable :: b2
+  character(8) :: chr = "IJKLMNOP"
+  character(48) :: buffer
+
+  a1 = ["ABCDEFGH","abcdefgh"]
+  a2 = "_"//a1//chr//"_"
+  if (any (a2 .ne. ["_ABCDEFGHIJKLMNOP_","_abcdefghIJKLMNOP_"])) call abort
+
+! Check that the descriptor dtype is OK - the array write needs it.
+  write (buffer, "(2a18)") a2
+  if (trim (buffer) .ne. "_ABCDEFGHIJKLMNOP__abcdefghIJKLMNOP_") call abort
+
+! Make sure scalars survived the fix!
+  b1 = "ABCDEFGH"
+  b2 = "_"//b1//chr//"_"
+  if (b2 .ne. "_ABCDEFGHIJKLMNOP_") call abort
+
+! Check the dependency is detected and dealt with by generation of a temporary.
+  a1 = "?"//a1//"?"
+  if (any (a1 .ne. ["?ABCDEFGH?","?abcdefgh?"])) call abort
+! With an array reference...
+  a1 = "?"//a1(1:2)//"?"
+  if (any (a1 .ne. ["??ABCDEFGH??","??abcdefgh??"])) call abort
+!... together with a substring.
+  a1 = "?"//a1(1:1)(2:4)//"?"
+  if (any (a1 .ne. ["??AB?"])) call abort
+contains
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_8.f90 b/gcc/testsuite/gfortran.dg/deferred_character_8.f90
new file mode 100644
index 0000000..009acc1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_8.f90
@@ -0,0 +1,84 @@
+! { dg-do run }
+!
+! Test the fix for all the remaining issues in PR54070. These were all
+! concerned with deferred length characters being returned as function results,
+! except for comment #23 where the descriptor dtype was not correctly set and
+! array IO failed in consequence.
+!
+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>
+!
+! The original comment #1 with an allocate statement.
+! Allocatable, deferred length scalar resul.
+function f()
+  character(len=:),allocatable :: f
+  allocate (f, source = "abc")
+  f ="ABC"
+end function
+!
+! Allocatable, deferred length, explicit, array result
+function g(a) result (res)
+  character(len=*) :: a(:)
+  character(len (a)) :: b(size (a))
+  character(len=:),allocatable :: res(:)
+  integer :: i
+  allocate (character(len(a)) :: res(2*size(a)))
+  do i = 1, len (a)
+    b(:)(i:i) = char (ichar (a(:)(i:i)) + 4)
+  end do
+  res = [a, b]
+end function
+!
+! Allocatable, deferred length, array result
+function h(a)
+  character(len=*) :: a(:)
+  character(len(a)) :: b (size(a))
+  character(len=:),allocatable :: h(:)
+  integer :: i
+  allocate (character(len(a)) :: h(size(a)))
+  do i = 1, len (a)
+    b(:)(i:i) = char (ichar (a(:)(i:i)) + 32)
+  end do
+  h = b
+end function
+
+module deferred_length_char_array
+contains
+  function return_string(argument)
+    character(*) :: argument
+    character(:), dimension(:), allocatable :: return_string
+    allocate (character (len(argument)) :: return_string(2))
+    return_string = argument
+  end function
+end module
+
+  use deferred_length_char_array
+  character(len=3) :: chr(3)
+  character(:), pointer :: s(:)
+  character(6) :: buffer
+  interface
+    function f()
+      character(len=:),allocatable :: f
+    end function
+    function g(a) result(res)
+      character(len=*) :: a(:)
+      character(len=:),allocatable :: res(:)
+    end function
+    function h(a)
+      character(len=*) :: a(:)
+      character(len=:),allocatable :: h(:)
+    end function
+  end interface
+
+  if (f () .ne. "ABC") call abort
+  if (any (g (["ab","cd"]) .ne. ["ab","cd","ef","gh"])) call abort
+  chr = h (["ABC","DEF","GHI"])
+  if (any (chr .ne. ["abc","def","ghi"])) call abort
+  if (any (return_string ("abcdefg") .ne. ["abcdefg","abcdefg"])) call abort
+
+! Comment #23
+  allocate(character(3)::s(2))
+  s(1) = 'foo'
+  s(2) = 'bar'
+  write (buffer, '(2A3)') s
+  if (buffer .ne. 'foobar') call abort
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_9.f90 b/gcc/testsuite/gfortran.dg/deferred_character_9.f90
new file mode 100644
index 0000000..f88de7a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_9.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR64324 in which deferred length user ops
+! were being mistaken as assumed length and so rejected.
+!
+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>
+!
+MODULE m
+  IMPLICIT NONE
+  INTERFACE OPERATOR(.ToString.)
+    MODULE PROCEDURE tostring
+  END INTERFACE OPERATOR(.ToString.)
+CONTAINS
+  FUNCTION tostring(arg)
+    INTEGER, INTENT(IN) :: arg
+    CHARACTER(:), ALLOCATABLE :: tostring
+    allocate (character(5) :: tostring)
+    write (tostring, "(I5)") arg
+  END FUNCTION tostring
+END MODULE m
+
+  use m
+  character(:), allocatable :: str
+  integer :: i = 999
+  str = .ToString. i
+  if (str .ne. "  999") call abort
+end
+
diff --git a/gcc/testsuite/gfortran.dg/derived_constructor_comps_6.f90 b/gcc/testsuite/gfortran.dg/derived_constructor_comps_6.f90
new file mode 100644
index 0000000..9cdb81a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/derived_constructor_comps_6.f90
@@ -0,0 +1,133 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/61831
+! The deallocation of components of array constructor elements
+! used to have the side effect of also deallocating some other
+! variable's components from which they were copied.
+
+program main
+  implicit none
+
+  integer, parameter :: n = 2
+
+  type :: string_t
+     character(LEN=1), dimension(:), allocatable :: chars
+  end type string_t
+
+  type :: string_container_t
+     type(string_t) :: comp
+  end type string_container_t
+
+  type :: string_array_container_t
+     type(string_t) :: comp(n)
+  end type string_array_container_t
+
+  type(string_t) :: prt_in, tmp, tmpa(n)
+  type(string_container_t) :: tmpc, tmpca(n)
+  type(string_array_container_t) :: tmpac, tmpaca(n)
+  integer :: i, j, k
+
+  do i=1,16
+
+     ! Test without intermediary function
+     prt_in = string_t(["A"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "A")) call abort
+     deallocate (prt_in%chars)
+
+     ! scalar elemental function
+     prt_in = string_t(["B"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "B")) call abort
+     tmp = new_prt_spec (prt_in)
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "B")) call abort
+     deallocate (prt_in%chars)
+     deallocate (tmp%chars)
+
+     ! array elemental function with array constructor
+     prt_in = string_t(["C"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "C")) call abort
+     tmpa = new_prt_spec ([(prt_in, i=1,2)])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "C")) call abort
+     deallocate (prt_in%chars)
+     do j=1,n
+        deallocate (tmpa(j)%chars)
+     end do
+
+     ! scalar elemental function with structure constructor
+     prt_in = string_t(["D"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "D")) call abort
+     tmpc = new_prt_spec2 (string_container_t(prt_in))
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "D")) call abort
+     deallocate (prt_in%chars)
+     deallocate(tmpc%comp%chars)
+
+     ! array elemental function of an array constructor of structure constructors
+     prt_in = string_t(["E"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "E")) call abort
+     tmpca = new_prt_spec2 ([ (string_container_t(prt_in), i=1,2) ])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "E")) call abort
+     deallocate (prt_in%chars)
+     do j=1,n
+        deallocate (tmpca(j)%comp%chars)
+     end do
+
+     ! scalar elemental function with a structure constructor and a nested array constructor
+     prt_in = string_t(["F"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "F")) call abort
+     tmpac = new_prt_spec3 (string_array_container_t([ (prt_in, i=1,2) ]))
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "F")) call abort
+     deallocate (prt_in%chars)
+     do j=1,n
+        deallocate (tmpac%comp(j)%chars)
+     end do
+
+     ! array elemental function with an array constructor nested inside
+     ! a structure constructor nested inside  an array constructor
+     prt_in = string_t(["G"])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "G")) call abort
+     tmpaca = new_prt_spec3 ([ (string_array_container_t([ (prt_in, i=1,2) ]), j=1,2) ])
+     if (.not. allocated(prt_in%chars)) call abort
+     if (any(prt_in%chars .ne. "G")) call abort
+     deallocate (prt_in%chars)
+     do j=1,n
+        do k=1,n
+           deallocate (tmpaca(j)%comp(k)%chars)
+        end do
+     end do
+
+  end do
+
+contains
+
+  elemental function new_prt_spec (name) result (prt_spec)
+    type(string_t), intent(in) :: name
+    type(string_t) :: prt_spec
+    prt_spec = name
+  end function new_prt_spec
+
+  elemental function new_prt_spec2 (name) result (prt_spec)
+    type(string_container_t), intent(in) :: name
+    type(string_container_t) :: prt_spec
+    prt_spec = name
+  end function new_prt_spec2
+
+  elemental function new_prt_spec3 (name) result (prt_spec)
+    type(string_array_container_t), intent(in) :: name
+    type(string_array_container_t) :: prt_spec
+    prt_spec = name
+  end function new_prt_spec3
+end program main
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 15 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 33 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/error_format_2.f90 b/gcc/testsuite/gfortran.dg/error_format_2.f90
new file mode 100644
index 0000000..421da9a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/error_format_2.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR68987, this test case failed on a memory double free
+program foo
+  call s('(foo)')
+end program
+subroutine s(fmt)
+  character (*) :: fmt
+  character (1) :: c
+  integer :: i
+  write (c, fmt, iostat=i) 42
+ ! print *, i
+  if (i==0) call abort()
+  write (c, fmt, err=100) 42
+  call abort()
+100 continue
+end subroutine
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr52531.f90 b/gcc/testsuite/gfortran.dg/gomp/pr52531.f90
new file mode 100644
index 0000000..e39d359
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr52531.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! PR fortran/52531
+module test_mod
+  type, public :: test_type
+  end type
+contains
+  subroutine foo(bar)
+    type(test_type) :: bar
+!$omp parallel default(none) shared(bar) ! Compiles if one removes default(none)
+    call question(bar)
+!$omp end parallel
+  end subroutine
+  subroutine question(var)
+    class(test_type), intent(in) :: var ! Compiles if one replaces class by type
+  end subroutine
+end module
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr69128.f90 b/gcc/testsuite/gfortran.dg/gomp/pr69128.f90
new file mode 100644
index 0000000..248c404
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr69128.f90
@@ -0,0 +1,23 @@
+! PR fortran/69128
+! { dg-do compile }
+
+program test
+  implicit none
+  interface
+    subroutine use(b, c)
+      real, allocatable :: b(:), c(:)
+    end subroutine
+  end interface
+  real, allocatable :: a(:,:), b(:), c(:)
+  integer :: dim1, dim2, i,j
+  dim1=10000
+  dim2=500
+  allocate(a(dim1,dim2),b(dim1),c(dim1))
+  call random_number(a)
+
+!$omp parallel workshare
+  b(:) = maxval(a(:,:), dim=2)
+  c(:) = sum(a(:,:), dim=2)
+!$omp end parallel workshare
+  call use(b, c)
+end program
diff --git a/gcc/testsuite/gfortran.dg/include_6.f90 b/gcc/testsuite/gfortran.dg/include_6.f90
index 0bac390..f5bb085 100644
--- a/gcc/testsuite/gfortran.dg/include_6.f90
+++ b/gcc/testsuite/gfortran.dg/include_6.f90
@@ -1,5 +1,6 @@
 ! { dg-do compile }
 ! { dg-options "-I gfortran.log" }
-! { dg-warning "is not a directory" "" { target *-*-* } 0 }
+! { dg-error "is not a directory" "" { target *-*-* } 0 }
+! { dg-prune-output "compilation terminated." }
 end 
 
diff --git a/gcc/testsuite/gfortran.dg/namelist_38.f90 b/gcc/testsuite/gfortran.dg/namelist_38.f90
index 5578654..b51463c 100644
--- a/gcc/testsuite/gfortran.dg/namelist_38.f90
+++ b/gcc/testsuite/gfortran.dg/namelist_38.f90
@@ -5,6 +5,7 @@
 program main
   implicit none
   character(len=3) :: a
+  character(25) :: b
   namelist /foo/ a
 
   open(10, status="scratch", delim="quote")
@@ -28,9 +29,12 @@ program main
   open(10, status="scratch", delim="none")
   a = "a'a"
   write(10,foo) 
-  rewind 10
-  a = ""
-  read (10,foo)
-  if (a.ne."a'a") call abort
-  close (10)
+  rewind (10)
+  read(10,"(a)") b
+  if (b .ne. "&FOO") call abort
+  read(10,"(a)") b
+  if (b .ne. " A=a'a") call abort
+  read(10,"(a)") b
+  if (b .ne. " /") call abort
+  close(10)
 end program main
diff --git a/gcc/testsuite/gfortran.dg/namelist_84.f90 b/gcc/testsuite/gfortran.dg/namelist_84.f90
index af139d9..14b68a4 100644
--- a/gcc/testsuite/gfortran.dg/namelist_84.f90
+++ b/gcc/testsuite/gfortran.dg/namelist_84.f90
@@ -17,12 +17,11 @@ program namelist_delim_none
    write(10, mylist)
    rewind(10)
    mystring = "xxxxx"
-   read(10,mylist)
-   if (any(mystring /= (/ 'mon', 'tue', 'wed', 'thu', 'fri' /))) call abort
    rewind(10)
    do i=1,5
      read(10,'(a)') internal_unit
-     if (scan(internal_unit,"""'").ne.0) call abort
+     if (i.eq.2 .and. internal_unit .ne. " MYSTRING=mon  tue  wed  thu  fri  ,") call abort
+     if (scan(internal_unit,"""'").ne.0) print *, internal_unit
    end do
    close(10)
 end program
diff --git a/gcc/testsuite/gfortran.dg/namelist_87.f90 b/gcc/testsuite/gfortran.dg/namelist_87.f90
new file mode 100644
index 0000000..c19d106
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/namelist_87.f90
@@ -0,0 +1,63 @@
+! { dg-do run }
+! { dg-add-options ieee }
+!
+! PR fortran/56743
+!
+! Contributed by Kai Gallmeister
+!
+! Note that Fortran 2008 (Section 10.11.3.6) requires that there is
+! a value separator between the value and the "!".  Thus, all examples
+! in this file are invalid; they should either be accepted as vendor
+! extension or lead to a run-time error (iostat /=0).
+!
+! For the c1 and c2 character example, please note that the Fortran
+! standard (F2008, 10.11.3.3) requires delimiters; accepting
+! a single word (in spirit of list-directed I/O) would be possible
+! as vendor extension. But the current run-time failure is fine as well.
+!
+! Note: After fixing this, warning or error is given with -pedantic -std=xxx
+implicit none
+integer :: i = -1
+real :: r1 = -2
+real :: r2 = -3
+real :: r3 = -4
+real :: r4 = -5
+real :: r5 = -6
+complex :: c = (-7,-7)
+logical :: ll = .false.
+character :: c1 = 'X'
+character(3) :: c2 = 'YYY'
+character(3) :: c3 = 'ZZZ'
+namelist /nml/ i, r1,r2,r3,r4,r5,c,ll,c1,c2,c3
+
+open (99, file='nml_87.dat', status="replace")
+write(99,*) "&nml"
+write(99,*) "  i=42!11"         ! Fixed BUG: wrong result: Unmodified, no error
+write(99,*) "  r1=43!11"        ! Fixed BUG: wrong result: Unmodified, no error
+write(99,*) "  r2=43.!11"       ! Fixed BUG: wrong result: Unmodified, no error
+write(99,*) "  r3=inf!11"       ! OK:  run-time error (Cannot match namelist object)
+write(99,*) "  r4=NaN(0x33)!11" ! OK:  run-time error (Cannot match namelist object)
+write(99,*) "  r5=3.e5!11"      ! Fixed BUG: wrong result: Unmodified, no error
+write(99,*) "  c=(4,2)!11"      ! OK:  value accepted as vendor extension
+write(99,*) "  ll=.true.!11"    ! OK:  value accepted as vendor extension
+write(99,*) "  c1='a'!11"       ! OK:  without quotes, run-time error (Cannot match namelist object)
+write(99,*) "  c2='bc'!11"      ! OK:  without quotes, run-time error (Cannot match namelist object)
+write(99,*) "  c3='ax'!11"      ! OK:  without quotes, run-time error (Cannot match namelist object)
+write(99,*) "/"
+
+rewind(99)
+read (99, nml=nml)
+!write (*, nml=nml)
+close (99, status="delete")
+
+  if (r1 /= 43) call abort ()
+  if (r2 /= 43) call abort ()
+  if (r3 /= r3 .or. r3 <= huge(r3)) call abort ()
+  if (r4 == r4) call abort ()
+  if (r5 /= 300000) call abort ()
+  if (c /= cmplx(4,2)) call abort ()
+  if (.not. ll) call abort ()
+  if (c1 /= "a") call abort ()
+  if (c2 /= "bc") call abort ()
+  if (c3 /= "ax") call abort ()
+end
diff --git a/gcc/testsuite/gfortran.dg/namelist_88.f90 b/gcc/testsuite/gfortran.dg/namelist_88.f90
new file mode 100644
index 0000000..0a6ac9b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/namelist_88.f90
@@ -0,0 +1,29 @@
+! { dg-do run }
+! PR69668 Error reading namelist opened with DELIM='NONE' 
+program namelist
+  implicit none
+
+  integer,parameter :: tabsz=10
+  integer :: i
+  character(len=10),dimension(tabsz) :: tab
+  namelist/tab_nml/tab
+
+  tab(:)='invalid'
+
+  ! Create a temporary test namelist file
+  open(unit=23,status='scratch',delim='none')
+  write(23,*) "&tab_nml"
+  write(23,*) "tab(1)='in1',"
+  write(23,*) "tab(2)='in2'"
+  write(23,*) "/"
+  rewind(23)
+
+  read(unit=23,nml=tab_nml)
+
+  close(unit=23)
+
+  if (tab(1).ne.'in1') call abort
+  if (tab(2).ne.'in2') call abort
+  if (any(tab(3:tabsz).ne.'invalid')) call abort
+
+end program namelist
diff --git a/gcc/testsuite/gfortran.dg/pr60126.f90 b/gcc/testsuite/gfortran.dg/pr60126.f90
new file mode 100644
index 0000000..038f544
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr60126.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/60126 - ICE on pointer rank remapping
+! Based on testcase by Michel Valin <mfvalin at gmail dot com>
+
+subroutine simple_bug_demo
+  implicit none
+  interface
+     function offset_ptr_R4(nelements) result (dest)
+       implicit none
+       real, pointer, dimension(:) :: dest
+       integer, intent(IN) :: nelements
+     end function offset_ptr_R4
+  end interface
+
+  real, dimension(:,:), pointer :: R2D
+
+  R2D(-2:2,-3:3) => offset_ptr_R4(100)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr65996.f90 b/gcc/testsuite/gfortran.dg/pr65996.f90
new file mode 100644
index 0000000..754a3bc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr65996.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-additional-options "-dH" }
+! PR 65996.f90. before patch compiler aborted on this program.
+program foo
+  implicit none
+  character(len=16) :: a,b,c
+  a="XXX"
+  b="&
+    &XXX"
+  c="XXX &
+    & XXX"
+  write(0,*) 'a=',a,' b=',b,' c=',c 
+endprogram foo
diff --git a/gcc/testsuite/gfortran.dg/pr68283.f90 b/gcc/testsuite/gfortran.dg/pr68283.f90
new file mode 100644
index 0000000..81f7412
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr68283.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+MODULE neb_utils
+  IMPLICIT NONE
+  INTEGER, PARAMETER :: dp=8
+  TYPE neb_var_type
+     REAL(KIND=dp), DIMENSION(:, :),  POINTER  :: xyz, int, wrk
+  END TYPE neb_var_type
+CONTAINS
+  SUBROUTINE get_neb_force()
+    INTEGER                                  :: i
+    TYPE(neb_var_type), POINTER              :: forces
+    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: dtmp1, wrk
+    dtmp1 = forces%wrk(:,i)-dot_product_band ! { dg-error "Symbol 'dot_product_band' at .1. has no IMPLICIT type" }
+  END SUBROUTINE get_neb_force
+END MODULE neb_utils
diff --git a/gcc/testsuite/gfortran.dg/pr69055.f90 b/gcc/testsuite/gfortran.dg/pr69055.f90
new file mode 100644
index 0000000..48b3442
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr69055.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-fsanitize=float-cast-overflow" }
+
+subroutine pr69055
+  implicit none
+  integer :: n
+  real(8) :: b
+  b = huge(1.0D0)
+  n = b
+end subroutine pr69055
diff --git a/gcc/testsuite/gfortran.dg/read_bang.f90 b/gcc/testsuite/gfortran.dg/read_bang.f90
new file mode 100644
index 0000000..7806ca7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/read_bang.f90
@@ -0,0 +1,38 @@
+! { dg-do run }
+! PR69651 Usage of unitialized pointer io/list_read.c 
+! Note: The uninitialized pointer was not the cause of the problem
+!       observed with this test case. The problem was mishandling '!'
+!       See also test case read_bang4.f90.
+program test
+  implicit none
+  integer :: i, j, ios
+  real ::  r, s
+  complex :: c, d
+  character(20) :: str1, str2
+  
+  i = -5
+  j = -6
+  r = -3.14
+  s = -2.71
+  c = (-1.1,-2.2)
+  d = (-3.3,-4.4)
+  str1 = "candy"
+  str2 = "peppermint"
+  open(15, status='scratch')
+  write(15,*) "10  1!2"
+  write(15,*) "  23.5! 34.5"
+  write(15,*) "  (67.50,69.25)  (51.25,87.75)!"
+  write(15,*) "  'abcdefgh!' '  !klmnopq!'"
+  rewind(15)
+  read(15,*,iostat=ios) i, j
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) r, s
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) c, d
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) str1, str2
+  if (ios.ne.0) call abort
+  if (str1.ne."abcdefgh!") print *, str1
+  if (str2.ne."  !klmnopq!") print *, str2
+  close(15)
+end program
diff --git a/gcc/testsuite/gfortran.dg/read_bang4.f90 b/gcc/testsuite/gfortran.dg/read_bang4.f90
new file mode 100644
index 0000000..78101fc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/read_bang4.f90
@@ -0,0 +1,47 @@
+! { dg-do run }
+! PR69651 Usage of unitialized pointer io/list_read.c 
+! Note: The uninitialized pointer was not the cause of the problem
+!       observed with this test case. This tests the case with UTF-8
+!       files. The large string test the realloc use in push_char4 of
+!       list_read.c
+program test
+  implicit none
+  integer :: i, j, k, ios
+  integer, parameter :: big = 600
+  real ::  r, s
+  complex :: c, d
+  character(kind=4,len=big) :: str1, str2, str3
+
+  do i=1,big, 10
+    do j = 0, 9
+      k = i + j
+      str2(k:k) = char(65+j)
+    end do
+  end do
+  i = -5
+  j = -6
+  r = -3.14
+  s = -2.71
+  c = (-1.1,-2.2)
+  d = (-3.3,-4.4)
+  str3 = str2
+  open(15, status='scratch', encoding="utf-8")
+  write(15,*) "10  1!2"
+  write(15,*) "  23.5! 34.5"
+  write(15,*) "  (67.50,69.25)  (51.25,87.75)!"
+  write(15,*) "  'abcdefgh!'", " ", str2
+  rewind(15)
+  str1 = 4_"candy"
+  str2 = 4_"peppermint"
+  read(15,*,iostat=ios) i, j
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) r, s
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) c, d
+  if (ios.ne.5010) call abort
+  read(15,*,iostat=ios) str1, str2
+  if (ios.ne.0) call abort
+  if (str1.ne.4_"abcdefgh!") call abort
+  if (str2.ne.str3) call abort
+  close(15)
+end program
diff --git a/gcc/testsuite/gnat.dg/atomic8.adb b/gcc/testsuite/gnat.dg/atomic8.adb
new file mode 100644
index 0000000..76a110d
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/atomic8.adb
@@ -0,0 +1,33 @@
+-- { dg-do run }
+
+procedure Atomic8 is
+
+   V : array (1 .. 2) of Natural := (0,0) with Atomic_Components;
+
+   task type TT1;
+   task body TT1 is
+   begin
+      while V (1) + V (2) < 1_000_000 loop
+         V (1) := V (1) + 1;
+      end loop;
+   end TT1;
+
+   task type TT2;
+   task body TT2 is
+   begin
+      while V (1) + V (2) < 1_000_000 loop
+         V (2) := V (2) + 1;
+      end loop;
+   end TT2;
+
+begin
+   declare
+      T1 : TT1;
+      T2 : TT2;
+   begin
+      null;
+   end;
+   if V (1) + V (2) not in 1_000_000 | 1_000_001 then
+      raise Program_Error;
+   end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/inline12.adb b/gcc/testsuite/gnat.dg/inline12.adb
new file mode 100644
index 0000000..e73f3c1
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/inline12.adb
@@ -0,0 +1,23 @@
+-- PR ada/69219
+-- Testcae by yuta tomino <demoonlit@panathenaia.halfmoon.jp> */
+
+-- { dg-do compile }
+
+procedure Inline12 is
+
+   procedure NI;
+
+   procedure IA;
+   pragma Convention (Intrinsic, IA);
+   pragma Inline_Always (IA);
+
+   procedure IA is
+   begin
+      NI;
+   end;
+
+   procedure NI is null;
+
+begin
+  IA;
+end;
diff --git a/gcc/testsuite/lib/gcc-gdb-test.exp b/gcc/testsuite/lib/gcc-gdb-test.exp
index d3ba6e4..a8714bc 100644
--- a/gcc/testsuite/lib/gcc-gdb-test.exp
+++ b/gcc/testsuite/lib/gcc-gdb-test.exp
@@ -73,8 +73,8 @@ proc gdb-test { args } {
     puts $fd "quit"
     close $fd
 
-    send_log "Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\n"
-    set res [remote_spawn target "$gdb_name -nx -nw -quiet -x $cmd_file ./$output_file"]
+    send_log "Spawning: $gdb_name -nx -nw -quiet -batch -x $cmd_file ./$output_file\n"
+    set res [remote_spawn target "$gdb_name -nx -nw -quiet -batch -x $cmd_file ./$output_file"]
     if { $res < 0 || $res == "" } {
 	unsupported "$testname"
 	file delete $cmd_file
diff --git a/gcc/testsuite/lib/gcc-simulate-thread.exp b/gcc/testsuite/lib/gcc-simulate-thread.exp
index f4275d7..69c028b 100644
--- a/gcc/testsuite/lib/gcc-simulate-thread.exp
+++ b/gcc/testsuite/lib/gcc-simulate-thread.exp
@@ -49,8 +49,8 @@ proc simulate-thread { args } {
 
     set message "thread simulation test"
 
-    send_log "Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$exec_file\n"
-    set res [remote_spawn target "$gdb_name -nx -nw  -x $cmd_file ./$exec_file"]
+    send_log "Spawning: $gdb_name -nx -nw -batch -x $cmd_file ./$exec_file\n"
+    set res [remote_spawn target "$gdb_name -nx -nw -batch -x $cmd_file ./$exec_file"]
     if { $res < 0 || $res == "" } {
 	unsupported "$testcase $message"
 	return
diff --git a/gcc/tree-chrec.c b/gcc/tree-chrec.c
index b599c2c..4f1b6bc 100644
--- a/gcc/tree-chrec.c
+++ b/gcc/tree-chrec.c
@@ -746,12 +746,12 @@ hide_evolution_in_other_loops_than_loop (tree chrec,
 	/* There is no evolution in this loop.  */
 	return initial_condition (chrec);
 
+      else if (flow_loop_nested_p (loop, chloop))
+	return hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec),
+							loop_num);
+
       else
-	{
-	  gcc_assert (flow_loop_nested_p (loop, chloop));
-	  return hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec),
-							  loop_num);
-	}
+	return chrec_dont_know;
 
     default:
       return chrec;
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 57e26d1..410fd53 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -1534,13 +1534,14 @@ initialize_data_dependence_relation (struct data_reference *a,
   /* The case where the references are exactly the same.  */
   if (operand_equal_p (DR_REF (a), DR_REF (b), 0))
     {
-     if (loop_nest.exists ()
-        && !object_address_invariant_in_loop_p (loop_nest[0],
-       					        DR_BASE_OBJECT (a)))
-      {
-        DDR_ARE_DEPENDENT (res) = chrec_dont_know;
-        return res;
-      }
+      if ((loop_nest.exists ()
+	   && !object_address_invariant_in_loop_p (loop_nest[0],
+						   DR_BASE_OBJECT (a)))
+	  || DR_NUM_DIMENSIONS (a) == 0)
+	{
+	  DDR_ARE_DEPENDENT (res) = chrec_dont_know;
+	  return res;
+	}
       DDR_AFFINE_P (res) = true;
       DDR_ARE_DEPENDENT (res) = NULL_TREE;
       DDR_SUBSCRIPTS (res).create (DR_NUM_DIMENSIONS (a));
@@ -1572,9 +1573,9 @@ initialize_data_dependence_relation (struct data_reference *a,
   /* If the base of the object is not invariant in the loop nest, we cannot
      analyze it.  TODO -- in fact, it would suffice to record that there may
      be arbitrary dependences in the loops where the base object varies.  */
-  if (loop_nest.exists ()
-      && !object_address_invariant_in_loop_p (loop_nest[0],
-     					      DR_BASE_OBJECT (a)))
+  if ((loop_nest.exists ()
+       && !object_address_invariant_in_loop_p (loop_nest[0], DR_BASE_OBJECT (a)))
+      || DR_NUM_DIMENSIONS (a) == 0)
     {
       DDR_ARE_DEPENDENT (res) = chrec_dont_know;
       return res;
diff --git a/gcc/tree-parloops.c b/gcc/tree-parloops.c
index 62a6444..c3929a1 100644
--- a/gcc/tree-parloops.c
+++ b/gcc/tree-parloops.c
@@ -741,6 +741,7 @@ eliminate_local_variables_stmt (edge entry, gimple_stmt_iterator *gsi,
     }
   else if (gimple_clobber_p (stmt))
     {
+      unlink_stmt_vdef (stmt);
       stmt = gimple_build_nop ();
       gsi_replace (gsi, stmt, false);
       dta.changed = true;
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 7d713c6..3457aac 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -2329,7 +2329,7 @@ analyze_access_subtree (struct access *root, struct access *parent,
 
       if (covered_to < limit)
 	hole = true;
-      if (scalar)
+      if (scalar || !allow_replacements)
 	root->grp_total_scalarization = 0;
     }
 
@@ -3242,6 +3242,7 @@ sra_modify_assign (gimple stmt, gimple_stmt_iterator *gsi)
     }
   else if (racc
 	   && !racc->grp_unscalarized_data
+	   && !racc->grp_unscalarizable_region
 	   && TREE_CODE (lhs) == SSA_NAME
 	   && !access_has_replacements_p (racc))
     {
@@ -3405,7 +3406,8 @@ sra_modify_assign (gimple stmt, gimple_stmt_iterator *gsi)
       else
 	{
 	  if (access_has_children_p (racc)
-	      && !racc->grp_unscalarized_data)
+	      && !racc->grp_unscalarized_data
+	      && TREE_CODE (lhs) != SSA_NAME)
 	    {
 	      if (dump_file)
 		{
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index 82160d2..f783ad5 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -1109,12 +1109,8 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,
   ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));
 
   /* If the alias set for a pointer access is zero all bets are off.  */
-  if (base1_alias_set == -1)
-    base1_alias_set = get_deref_alias_set (ptrtype1);
   if (base1_alias_set == 0)
     return true;
-  if (base2_alias_set == -1)
-    base2_alias_set = get_alias_set (base2);
 
   /* When we are trying to disambiguate an access with a pointer dereference
      as base versus one with a decl as base we can use both the size
@@ -1281,13 +1277,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,
   ptrtype2 = TREE_TYPE (TREE_OPERAND (base2, 1));
 
   /* If the alias set for a pointer access is zero all bets are off.  */
-  if (base1_alias_set == -1)
-    base1_alias_set = get_deref_alias_set (ptrtype1);
-  if (base1_alias_set == 0)
-    return true;
-  if (base2_alias_set == -1)
-    base2_alias_set = get_deref_alias_set (ptrtype2);
-  if (base2_alias_set == 0)
+  if (base1_alias_set == 0
+      || base2_alias_set == 0)
     return true;
 
   /* If both references are through the same type, they do not alias
@@ -1462,7 +1453,8 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)
   if (var1_p && ind2_p)
     return indirect_ref_may_alias_decl_p (ref2->ref, base2,
 					  offset2, max_size2,
-					  ao_ref_alias_set (ref2), -1,
+					  ao_ref_alias_set (ref2),
+					  ao_ref_base_alias_set (ref2),
 					  ref1->ref, base1,
 					  offset1, max_size1,
 					  ao_ref_alias_set (ref1),
@@ -1471,10 +1463,12 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)
   else if (ind1_p && ind2_p)
     return indirect_refs_may_alias_p (ref1->ref, base1,
 				      offset1, max_size1,
-				      ao_ref_alias_set (ref1), -1,
+				      ao_ref_alias_set (ref1),
+				      ao_ref_base_alias_set (ref1),
 				      ref2->ref, base2,
 				      offset2, max_size2,
-				      ao_ref_alias_set (ref2), -1,
+				      ao_ref_alias_set (ref2),
+				      ao_ref_base_alias_set (ref2),
 				      tbaa_p);
 
   /* We really do not want to end up here, but returning true is safe.  */
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index 9690004..f33ca0e0 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -263,7 +263,7 @@ static struct opt_stats_d opt_stats;
 
 /* Local functions.  */
 static void optimize_stmt (basic_block, gimple_stmt_iterator);
-static tree lookup_avail_expr (gimple, bool);
+static tree lookup_avail_expr (gimple, bool, bool = true);
 static hashval_t avail_expr_hash (const void *);
 static void htab_statistics (FILE *,
 			     const hash_table<expr_elt_hasher> &);
@@ -2496,7 +2496,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)
 	  else
 	    new_stmt = gimple_build_assign (rhs, lhs);
 	  gimple_set_vuse (new_stmt, gimple_vuse (stmt));
-	  cached_lhs = lookup_avail_expr (new_stmt, false);
+	  cached_lhs = lookup_avail_expr (new_stmt, false, false);
 	  if (cached_lhs
 	      && rhs == cached_lhs)
 	    {
@@ -2603,7 +2603,7 @@ vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)
    we finish processing this block and its children.  */
 
 static tree
-lookup_avail_expr (gimple stmt, bool insert)
+lookup_avail_expr (gimple stmt, bool insert, bool tbaa_p)
 {
   expr_hash_elt **slot;
   tree lhs;
@@ -2671,7 +2671,8 @@ lookup_avail_expr (gimple stmt, bool insert)
       if (!(vuse1 && vuse2
 	    && gimple_assign_single_p (stmt)
 	    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME
-	    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)), true)
+	    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),
+		ref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)
 	    && walk_non_aliased_vuses (&ref, vuse2,
 				       vuse_eq, NULL, NULL, vuse1) != NULL))
 	{
diff --git a/gcc/tree-ssa-loop-ivcanon.c b/gcc/tree-ssa-loop-ivcanon.c
index 251b35f..138468d3 100644
--- a/gcc/tree-ssa-loop-ivcanon.c
+++ b/gcc/tree-ssa-loop-ivcanon.c
@@ -1237,7 +1237,9 @@ propagate_constants_for_unrolling (basic_block bb)
       tree result = gimple_phi_result (phi);
       tree arg = gimple_phi_arg_def (phi, 0);
 
-      if (gimple_phi_num_args (phi) == 1 && TREE_CODE (arg) == INTEGER_CST)
+      if (! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (result)
+	  && gimple_phi_num_args (phi) == 1
+	  && TREE_CODE (arg) == INTEGER_CST)
 	{
 	  propagate_into_all_uses (result, arg);
 	  gsi_remove (&gsi, true);
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index c699dcadb..a3df677 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -2141,9 +2141,9 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)
 static gimple
 find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)
 {
-/* The number which the find_bswap_or_nop_1 result should match in order
-   to have a full byte swap.  The number is shifted to the right
-   according to the size of the symbolic number before using it.  */
+  /* The number which the find_bswap_or_nop_1 result should match in order
+     to have a full byte swap.  The number is shifted to the right
+     according to the size of the symbolic number before using it.  */
   uint64_t cmpxchg = CMPXCHG;
   uint64_t cmpnop = CMPNOP;
 
@@ -2165,10 +2165,14 @@ find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)
   /* Find real size of result (highest non-zero byte).  */
   if (n->base_addr)
     {
-      int rsize;
+      unsigned HOST_WIDE_INT rsize;
       uint64_t tmpn;
 
       for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);
+      if (BYTES_BIG_ENDIAN && n->range != rsize)
+	/* This implies an offset, which is currently not handled by
+	   bswap_replace.  */
+	return NULL;
       n->range = rsize;
     }
 
@@ -2297,6 +2301,8 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,
       /* Move cur_stmt just before  one of the load of the original
 	 to ensure it has the same VUSE.  See PR61517 for what could
 	 go wrong.  */
+      if (gimple_bb (cur_stmt) != gimple_bb (src_stmt))
+	reset_flow_sensitive_info (gimple_assign_lhs (cur_stmt));
       gsi_move_before (&gsi, &gsi_ins);
       gsi = gsi_for_stmt (cur_stmt);
 
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 805cc21..1537451 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -3847,7 +3847,7 @@ compute_avail (void)
 		      vn_reference_t ref;
 		      vn_reference_lookup (gimple_assign_rhs1 (stmt),
 					   gimple_vuse (stmt),
-					   VN_WALK, &ref);
+					   VN_WALK, &ref, true);
 		      if (!ref)
 			continue;
 
@@ -4308,7 +4308,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)
           tree val;
 	  tree rhs = gimple_assign_rhs1 (stmt);
           val = vn_reference_lookup (gimple_assign_lhs (stmt),
-                                     gimple_vuse (stmt), VN_WALK, NULL);
+                                     gimple_vuse (stmt), VN_WALK, NULL, false);
           if (TREE_CODE (rhs) == SSA_NAME)
             rhs = VN_INFO (rhs)->valnum;
           if (val
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 8f24eed..03faec5 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -3286,7 +3286,7 @@ maybe_optimize_range_tests (gimple stmt)
     any_changes = optimize_range_tests (ERROR_MARK, &ops);
   if (any_changes)
     {
-      unsigned int idx;
+      unsigned int idx, max_idx = 0;
       /* update_ops relies on has_single_use predicates returning the
 	 same values as it did during get_ops earlier.  Additionally it
 	 never removes statements, only adds new ones and it should walk
@@ -3302,6 +3302,7 @@ maybe_optimize_range_tests (gimple stmt)
 	    {
 	      tree new_op;
 
+	      max_idx = idx;
 	      stmt = last_stmt (bb);
 	      new_op = update_ops (bbinfo[idx].op,
 				   (enum tree_code)
@@ -3371,6 +3372,10 @@ maybe_optimize_range_tests (gimple stmt)
 	      && ops[bbinfo[idx].first_idx]->op != NULL_TREE)
 	    {
 	      gcond *cond_stmt = as_a <gcond *> (last_stmt (bb));
+
+	      if (idx > max_idx)
+		max_idx = idx;
+
 	      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))
 		gimple_cond_make_false (cond_stmt);
 	      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))
@@ -3387,6 +3392,17 @@ maybe_optimize_range_tests (gimple stmt)
 	  if (bb == first_bb)
 	    break;
 	}
+
+      /* The above changes could result in basic blocks after the first
+	 modified one, up to and including last_bb, to be executed even if
+	 they would not be in the original program.  If the value ranges of
+	 assignment lhs' in those bbs were dependent on the conditions
+	 guarding those basic blocks which now can change, the VRs might
+	 be incorrect.  As no_side_effect_bb should ensure those SSA_NAMEs
+	 are only used within the same bb, it should be not a big deal if
+	 we just reset all the VRs in those bbs.  See PR68671.  */
+      for (bb = last_bb, idx = 0; idx < max_idx; bb = single_pred (bb), idx++)
+	reset_flow_sensitive_info_in_bb (bb);
     }
 }
 
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index a99a28f..db554d6 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -2199,11 +2199,12 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,
    number if it exists in the hash table.  Return NULL_TREE if it does
    not exist in the hash table or if the result field of the structure
    was NULL..  VNRESULT will be filled in with the vn_reference_t
-   stored in the hashtable if one exists.  */
+   stored in the hashtable if one exists.  When TBAA_P is false assume
+   we are looking up a store and treat it as having alias-set zero.  */
 
 tree
 vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
-		     vn_reference_t *vnresult)
+		     vn_reference_t *vnresult, bool tbaa_p)
 {
   vec<vn_reference_op_s> operands;
   struct vn_reference_s vr1;
@@ -2217,7 +2218,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
   vr1.operands = operands
     = valueize_shared_reference_ops_from_ref (op, &valuezied_anything);
   vr1.type = TREE_TYPE (op);
-  vr1.set = get_alias_set (op);
+  vr1.set = tbaa_p ? get_alias_set (op) : 0;
   vr1.hashcode = vn_reference_compute_hash (&vr1);
   if ((cst = fully_constant_vn_reference_p (&vr1)))
     return cst;
@@ -2233,6 +2234,8 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
 	  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.type,
 					     vr1.operands))
 	ao_ref_init (&r, op);
+      if (! tbaa_p)
+	r.ref_alias_set = r.base_alias_set = 0;
       vn_walk_kind = kind;
       wvnresult =
 	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
@@ -3030,7 +3033,7 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)
   last_vuse = gimple_vuse (stmt);
   last_vuse_ptr = &last_vuse;
   result = vn_reference_lookup (op, gimple_vuse (stmt),
-				default_vn_walk_kind, NULL);
+				default_vn_walk_kind, NULL, true);
   last_vuse_ptr = NULL;
 
   /* We handle type-punning through unions by value-numbering based
@@ -3149,7 +3152,7 @@ visit_reference_op_store (tree lhs, tree op, gimple stmt)
      Otherwise, the vdefs for the store are used when inserting into
      the table, since the store generates a new memory state.  */
 
-  result = vn_reference_lookup (lhs, vuse, VN_NOWALK, NULL);
+  result = vn_reference_lookup (lhs, vuse, VN_NOWALK, NULL, false);
 
   if (result)
     {
@@ -3164,7 +3167,7 @@ visit_reference_op_store (tree lhs, tree op, gimple stmt)
       && default_vn_walk_kind == VN_WALK)
     {
       assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);
-      vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult);
+      vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult, false);
       if (vnresult)
 	{
 	  VN_INFO (vdef)->use_processed = true;
diff --git a/gcc/tree-ssa-sccvn.h b/gcc/tree-ssa-sccvn.h
index 717fc28..36c6b81 100644
--- a/gcc/tree-ssa-sccvn.h
+++ b/gcc/tree-ssa-sccvn.h
@@ -211,7 +211,7 @@ bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,
 tree vn_reference_lookup_pieces (tree, alias_set_type, tree,
 				 vec<vn_reference_op_s> ,
 				 vn_reference_t *, vn_lookup_kind);
-tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *);
+tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool);
 void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);
 vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,
 					   vec<vn_reference_op_s> ,
diff --git a/gcc/tree-ssa-threadupdate.c b/gcc/tree-ssa-threadupdate.c
index 610e807..72fc5f8 100644
--- a/gcc/tree-ssa-threadupdate.c
+++ b/gcc/tree-ssa-threadupdate.c
@@ -254,6 +254,11 @@ struct ssa_local_info_t
 
   /* Blocks duplicated for the thread.  */
   bitmap duplicate_blocks;
+
+  /* When we have multiple paths through a joiner which reach different
+     final destinations, then we may need to correct for potential
+     profile insanities.  */
+  bool need_profile_correction;
 };
 
 /* Passes which use the jump threading code register jump threading
@@ -827,7 +832,8 @@ compute_path_counts (struct redirection_data *rd,
      So ensure that this path's path_out_count is at least the
      difference between elast->count and nonpath_count.  Otherwise the edge
      counts after threading will not be sane.  */
-  if (has_joiner && path_out_count < elast->count - nonpath_count)
+  if (local_info->need_profile_correction
+      && has_joiner && path_out_count < elast->count - nonpath_count)
   {
     path_out_count = elast->count - nonpath_count;
     /* But neither can we go above the minimum count along the path
@@ -1496,6 +1502,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
   ssa_local_info_t local_info;
 
   local_info.duplicate_blocks = BITMAP_ALLOC (NULL);
+  local_info.need_profile_correction = false;
 
   /* To avoid scanning a linear array for the element we need we instead
      use a hash table.  For normal code there should be no noticeable
@@ -1506,6 +1513,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
 
   /* Record each unique threaded destination into a hash table for
      efficient lookups.  */
+  edge last = NULL;
   FOR_EACH_EDGE (e, ei, bb->preds)
     {
       if (e->aux == NULL)
@@ -1559,6 +1567,17 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
       /* Insert the outgoing edge into the hash table if it is not
 	 already in the hash table.  */
       lookup_redirection_data (e, INSERT);
+
+      /* When we have thread paths through a common joiner with different
+	 final destinations, then we may need corrections to deal with
+	 profile insanities.  See the big comment before compute_path_counts.  */
+      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)
+	{
+	  if (!last)
+	    last = e2;
+	  else if (e2 != last)
+	    local_info.need_profile_correction = true;
+	}
     }
 
   /* We do not update dominance info.  */
diff --git a/gcc/tree-ssa-uninit.c b/gcc/tree-ssa-uninit.c
index fb2f3b3..96f1aaf 100644
--- a/gcc/tree-ssa-uninit.c
+++ b/gcc/tree-ssa-uninit.c
@@ -1118,14 +1118,16 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,
               edge opnd_edge;
               unsigned uninit_opnds2
                   = compute_uninit_opnds_pos (opnd_def_phi);
-              gcc_assert (!MASK_EMPTY (uninit_opnds2));
-              opnd_edge = gimple_phi_arg_edge (phi, i);
-              if (!is_use_properly_guarded (phi,
-                                            opnd_edge->src,
-                                            opnd_def_phi,
-                                            uninit_opnds2,
-                                            visited_phis))
-                  return false;
+              if (!MASK_EMPTY (uninit_opnds2))
+		{
+		  opnd_edge = gimple_phi_arg_edge (phi, i);
+		  if (!is_use_properly_guarded (phi,
+						opnd_edge->src,
+						opnd_def_phi,
+						uninit_opnds2,
+						visited_phis))
+		    return false;
+		}
             }
           else
             return false;
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
index 10d3314..68ce43a 100644
--- a/gcc/tree-ssa.c
+++ b/gcc/tree-ssa.c
@@ -1448,7 +1448,8 @@ execute_update_addresses_taken (void)
               tree lhs = gimple_get_lhs (stmt);
               if (lhs
 		  && TREE_CODE (lhs) != SSA_NAME
-		  && non_rewritable_lvalue_p (lhs))
+		  && ((code == GIMPLE_CALL && ! DECL_P (lhs))
+		      || non_rewritable_lvalue_p (lhs)))
 		{
 		  decl = get_base_address (lhs);
 		  if (DECL_P (decl))
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index 8085d20..e912f07 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -2905,10 +2905,38 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
 	      || !tree_fits_shwi_p (dr_a2->offset))
 	    continue;
 
-	  HOST_WIDE_INT diff = (tree_to_shwi (dr_a2->offset)
-				- tree_to_shwi (dr_a1->offset));
+	  /* Make sure dr_a1 starts left of dr_a2.  */
+	  if (tree_int_cst_lt (dr_a2->offset, dr_a1->offset))
+	    std::swap (*dr_a1, *dr_a2);
 
+	  unsigned HOST_WIDE_INT diff
+	    = tree_to_shwi (dr_a2->offset) - tree_to_shwi (dr_a1->offset);
 
+
+	  bool do_remove = false;
+
+	  /* If the left segment does not extend beyond the start of the
+	     right segment the new segment length is that of the right
+	     plus the segment distance.  */
+	  if (tree_fits_uhwi_p (dr_a1->seg_len)
+	      && compare_tree_int (dr_a1->seg_len, diff) <= 0)
+	    {
+	      dr_a1->seg_len = size_binop (PLUS_EXPR, dr_a2->seg_len,
+					   size_int (diff));
+	      do_remove = true;
+	    }
+	  /* Generally the new segment length is the maximum of the
+	     left segment size and the right segment size plus the distance.
+	     ???  We can also build tree MAX_EXPR here but it's not clear this
+	     is profitable.  */
+	  else if (tree_fits_uhwi_p (dr_a1->seg_len)
+		   && tree_fits_uhwi_p (dr_a2->seg_len))
+	    {
+	      unsigned HOST_WIDE_INT seg_len_a1 = tree_to_uhwi (dr_a1->seg_len);
+	      unsigned HOST_WIDE_INT seg_len_a2 = tree_to_uhwi (dr_a2->seg_len);
+	      dr_a1->seg_len = size_int (MAX (seg_len_a1, diff + seg_len_a2));
+	      do_remove = true;
+	    }
 	  /* Now we check if the following condition is satisfied:
 
 	     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B
@@ -2921,38 +2949,39 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
 	     one above:
 
 	     1: DIFF <= MIN_SEG_LEN_B
-	     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B
-
-	     */
-
-	  HOST_WIDE_INT  min_seg_len_b = (tree_fits_shwi_p (dr_b1->seg_len)
-					  ? tree_to_shwi (dr_b1->seg_len)
-					  : vect_factor);
+	     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B  */
+	  else
+	    {
+	      unsigned HOST_WIDE_INT min_seg_len_b
+		= (tree_fits_uhwi_p (dr_b1->seg_len)
+		   ? tree_to_uhwi (dr_b1->seg_len)
+		   : vect_factor);
+
+	      if (diff <= min_seg_len_b
+		  || (tree_fits_uhwi_p (dr_a1->seg_len)
+		      && diff - tree_to_uhwi (dr_a1->seg_len) < min_seg_len_b))
+		{
+		  dr_a1->seg_len = size_binop (PLUS_EXPR,
+					       dr_a2->seg_len, size_int (diff));
+		  do_remove = true;
+		}
+	    }
 
-	  if (diff <= min_seg_len_b
-	      || (tree_fits_shwi_p (dr_a1->seg_len)
-		  && diff - tree_to_shwi (dr_a1->seg_len) < min_seg_len_b))
+	  if (do_remove)
 	    {
 	      if (dump_enabled_p ())
 		{
 		  dump_printf_loc (MSG_NOTE, vect_location,
 				   "merging ranges for ");
-		  dump_generic_expr (MSG_NOTE, TDF_SLIM,
-				     DR_REF (dr_a1->dr));
+		  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));
 		  dump_printf (MSG_NOTE,  ", ");
-		  dump_generic_expr (MSG_NOTE, TDF_SLIM,
-				     DR_REF (dr_b1->dr));
+		  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));
 		  dump_printf (MSG_NOTE,  " and ");
-		  dump_generic_expr (MSG_NOTE, TDF_SLIM,
-				     DR_REF (dr_a2->dr));
+		  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));
 		  dump_printf (MSG_NOTE,  ", ");
-		  dump_generic_expr (MSG_NOTE, TDF_SLIM,
-				     DR_REF (dr_b2->dr));
+		  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));
 		  dump_printf (MSG_NOTE, "\n");
 		}
-
-	      dr_a1->seg_len = size_binop (PLUS_EXPR,
-					   dr_a2->seg_len, size_int (diff));
 	      comp_alias_ddrs.ordered_remove (i--);
 	    }
 	}
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index d5db875..4c13283 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -9534,7 +9534,8 @@ simplify_cond_using_ranges (gcond *stmt)
       innerop = gimple_assign_rhs1 (def_stmt);
 
       if (TREE_CODE (innerop) == SSA_NAME
-	  && !POINTER_TYPE_P (TREE_TYPE (innerop)))
+	  && !POINTER_TYPE_P (TREE_TYPE (innerop))
+	  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop))
 	{
 	  value_range_t *vr = get_value_range (innerop);
 
@@ -9565,8 +9566,8 @@ simplify_cond_using_ranges (gcond *stmt)
 		  else
 		    location = gimple_location (stmt);
 		  warning_at (location, OPT_Wstrict_overflow,
-		      "assuming signed overflow does not occur when "
-		      "simplifying conditional");
+			      "assuming signed overflow does not occur when "
+			      "simplifying conditional");
 		}
 
 	      tree newconst = fold_convert (TREE_TYPE (innerop), op1);
diff --git a/gcc/tree.c b/gcc/tree.c
index 6f07d3d..6651437 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -1221,11 +1221,9 @@ static unsigned int
 get_int_cst_ext_nunits (tree type, const wide_int &cst)
 {
   gcc_checking_assert (cst.get_precision () == TYPE_PRECISION (type));
-  /* We need an extra zero HWI if CST is an unsigned integer with its
-     upper bit set, and if CST occupies a whole number of HWIs.  */
-  if (TYPE_UNSIGNED (type)
-      && wi::neg_p (cst)
-      && (cst.get_precision () % HOST_BITS_PER_WIDE_INT) == 0)
+  /* We need extra HWIs if CST is an unsigned integer with its
+     upper bit set.  */
+  if (TYPE_UNSIGNED (type) && wi::neg_p (cst))
     return cst.get_precision () / HOST_BITS_PER_WIDE_INT + 1;
   return cst.get_len ();
 }
@@ -1242,7 +1240,8 @@ build_new_int_cst (tree type, const wide_int &cst)
   if (len < ext_len)
     {
       --ext_len;
-      TREE_INT_CST_ELT (nt, ext_len) = 0;
+      TREE_INT_CST_ELT (nt, ext_len)
+	= zext_hwi (-1, cst.get_precision () % HOST_BITS_PER_WIDE_INT);
       for (unsigned int i = len; i < ext_len; ++i)
 	TREE_INT_CST_ELT (nt, i) = -1;
     }
diff --git a/gcc/ubsan.c b/gcc/ubsan.c
index 96536c5..c56864d 100644
--- a/gcc/ubsan.c
+++ b/gcc/ubsan.c
@@ -1611,6 +1611,7 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr, tree arg)
     fn = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);
   else
     {
+      initialize_sanitizer_builtins ();
       /* Create the __ubsan_handle_float_cast_overflow fn call.  */
       tree data = ubsan_create_data ("__ubsan_float_cast_overflow_data", 0,
 				     NULL, ubsan_type_descriptor (expr_type),
diff --git a/gcc/var-tracking.c b/gcc/var-tracking.c
index 18eff20..6128948 100644
--- a/gcc/var-tracking.c
+++ b/gcc/var-tracking.c
@@ -5833,11 +5833,6 @@ reverse_op (rtx val, const_rtx expr, rtx_insn *insn)
 	    return;
 	}
       ret = simplify_gen_binary (code, GET_MODE (val), val, arg);
-      if (ret == val)
-	/* Ensure ret isn't VALUE itself (which can happen e.g. for
-	   (plus (reg1) (reg2)) when reg2 is known to be 0), as that
-	   breaks a lot of routines during var-tracking.  */
-	ret = gen_rtx_fmt_ee (PLUS, GET_MODE (val), val, const0_rtx);
       break;
     default:
       gcc_unreachable ();
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 89151ac..a62d02f 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1434,6 +1434,9 @@ make_decl_rtl (tree decl)
 	 specifications.  */
       SET_DECL_ASSEMBLER_NAME (decl, NULL_TREE);
       DECL_HARD_REGISTER (decl) = 0;
+      /* Also avoid SSA inconsistencies by pretending this is an external
+	 decl now.  */
+      DECL_EXTERNAL (decl) = 1;
       return;
     }
   /* Now handle ordinary static variables and functions (in memory).
diff --git a/gcc/wide-int.cc b/gcc/wide-int.cc
index 4e02d2f..7bf87f4 100644
--- a/gcc/wide-int.cc
+++ b/gcc/wide-int.cc
@@ -1808,15 +1808,32 @@ wi::divmod_internal (HOST_WIDE_INT *quotient, unsigned int *remainder_len,
     {
       unsigned HOST_WIDE_INT o0 = dividend.to_uhwi ();
       unsigned HOST_WIDE_INT o1 = divisor.to_uhwi ();
+      unsigned int quotient_len = 1;
 
       if (quotient)
-	quotient[0] = o0 / o1;
+	{
+	  quotient[0] = o0 / o1;
+	  if (o1 == 1
+	      && (HOST_WIDE_INT) o0 < 0
+	      && dividend_prec > HOST_BITS_PER_WIDE_INT)
+	    {
+	      quotient[1] = 0;
+	      quotient_len = 2;
+	    }
+	}
       if (remainder)
 	{
 	  remainder[0] = o0 % o1;
-	  *remainder_len = 1;
+	  if ((HOST_WIDE_INT) remainder[0] < 0
+	      && dividend_prec > HOST_BITS_PER_WIDE_INT)
+	    {
+	      remainder[1] = 0;
+	      *remainder_len = 2;
+	    }
+	  else
+	    *remainder_len = 1;
 	}
-      return 1;
+      return quotient_len;
     }
 
   /* Make the divisor and dividend positive and remember what we
diff --git a/gcc/wide-int.h b/gcc/wide-int.h
index 9a71c4f..18b5e20 100644
--- a/gcc/wide-int.h
+++ b/gcc/wide-int.h
@@ -2892,7 +2892,9 @@ wi::lrshift (const T1 &x, const T2 &y)
 	 For variable-precision integers like wide_int, handle HWI
 	 and sub-HWI integers inline.  */
       if (STATIC_CONSTANT_P (xi.precision > HOST_BITS_PER_WIDE_INT)
-	  ? xi.len == 1 && xi.val[0] >= 0
+	  ? (shift < HOST_BITS_PER_WIDE_INT
+	     && xi.len == 1
+	     && xi.val[0] >= 0)
 	  : xi.precision <= HOST_BITS_PER_WIDE_INT)
 	{
 	  val[0] = xi.to_uhwi () >> shift;
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
index 25ff7c3..282831d 100644
--- a/libatomic/ChangeLog
+++ b/libatomic/ChangeLog
@@ -1,3 +1,12 @@
+2016-01-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline:
+	2016-01-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR other/67627
+	* Makefile.am (all-multi): Add dependency.
+	* Makefile.in: Regenerate.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libatomic/Makefile.am b/libatomic/Makefile.am
index 3d8ab62..d1a2954 100644
--- a/libatomic/Makefile.am
+++ b/libatomic/Makefile.am
@@ -139,3 +139,10 @@ endif
 
 libatomic_convenience_la_SOURCES = $(libatomic_la_SOURCES)
 libatomic_convenience_la_LIBADD = $(libatomic_la_LIBADD)
+
+# Override the automake generated all-multi rule to guarantee that all-multi
+# is not run in parallel with the %_.lo rules which generate $(DEPDIR)/*.Ppo
+# makefile fragments to avoid broken *.Ppo getting included into the Makefile
+# when it is reloaded during the build of all-multi.
+all-multi: $(libatomic_la_LIBADD)
+	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
diff --git a/libatomic/Makefile.in b/libatomic/Makefile.in
index 9288652..76ba1f7 100644
--- a/libatomic/Makefile.in
+++ b/libatomic/Makefile.in
@@ -494,12 +494,6 @@ clean-libtool:
 
 distclean-libtool:
 	-rm -f libtool config.lt
-
-# GNU Make needs to see an explicit $(MAKE) variable in the command it
-# runs to enable its job server during parallel builds.  Hence the
-# comments below.
-all-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
 install-multi:
 	$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)
 
@@ -798,6 +792,13 @@ vpath % $(strip $(search_path))
 %_.lo: Makefile
 	$(LTCOMPILE) $(M_DEPS) $(M_SIZE) $(M_IFUNC) -c -o $@ $(M_SRC)
 
+# Override the automake generated all-multi rule to guarantee that all-multi
+# is not run in parallel with the %_.lo rules which generate $(DEPDIR)/*.Ppo
+# makefile fragments to avoid broken *.Ppo getting included into the Makefile
+# when it is reloaded during the build of all-multi.
+all-multi: $(libatomic_la_LIBADD)
+	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 23e05cc..7754af8 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,12 @@
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/68176
+	* files.c (_cpp_find_file): Set file->implicit_preinclude even if
+	included from file->implicit_preinclude header.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libcpp/files.c b/libcpp/files.c
index 9f28b9e..ea2cc23 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -522,7 +522,10 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,
     return entry->u.file;
 
   file = make_cpp_file (pfile, start_dir, fname);
-  file->implicit_preinclude = implicit_preinclude;
+  file->implicit_preinclude
+    = (implicit_preinclude
+       || (pfile->buffer
+	   && pfile->buffer->file->implicit_preinclude));
 
   /* Try each path in the include chain.  */
   for (; !fake ;)
diff --git a/libcpp/po/ChangeLog b/libcpp/po/ChangeLog
index 4699154..0e70b57 100644
--- a/libcpp/po/ChangeLog
+++ b/libcpp/po/ChangeLog
@@ -1,3 +1,7 @@
+2016-01-31  Joseph Myers  <joseph@codesourcery.com>
+
+	* fi.po: Update.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libcpp/po/fi.po b/libcpp/po/fi.po
index c1614fe..c4d27fd 100644
--- a/libcpp/po/fi.po
+++ b/libcpp/po/fi.po
@@ -1,26 +1,28 @@
 # Finnish messages for cpplib.
-# Copyright © 2010, 2012, 2013, 2014, 2015 Free Software Foundation, Inc.
+# Copyright © 2010, 2012, 2013, 2014, 2015, 2016 Free Software Foundation, Inc.
 # This file is distributed under the same license as the gcc package.
 # Jorma Karvonen <karvonen.jorma@gmail.com>, 2010, 2012-2015.
+# Lauri Nurmi <lanurmi@iki.fi>, 2016.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: cpplib 5.1-b20150208\n"
+"Project-Id-Version: cpplib 5.2.0\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2015-04-13 20:12+0000\n"
-"PO-Revision-Date: 2015-02-10 00:32+0200\n"
-"Last-Translator: Jorma Karvonen <karvonen.jorma@gmail.com>\n"
+"PO-Revision-Date: 2016-01-30 23:09+0200\n"
+"Last-Translator: Lauri Nurmi <lanurmi@iki.fi>\n"
 "Language-Team: Finnish <translation-team-fi@lists.sourceforge.net>\n"
 "Language: fi\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Poedit 1.8.6\n"
 
 #: charset.c:674
 #, c-format
 msgid "conversion from %s to %s not supported by iconv"
-msgstr "iconv ei tue muunnosta kohteesta %s kohteeseen %s"
+msgstr "iconv ei tue muunnosta %s -> %s"
 
 #: charset.c:677
 msgid "iconv_open"
@@ -29,118 +31,118 @@ msgstr "iconv_open"
 #: charset.c:685
 #, c-format
 msgid "no iconv implementation, cannot convert from %s to %s"
-msgstr "ei iconv-toteutusta, muuntaminen kohteesta %s kohteeseen %s epäonnistui"
+msgstr "ei iconv-toteutusta, muunnosta %s -> %s ei voida suorittaa"
 
 #: charset.c:781
 #, c-format
 msgid "character 0x%lx is not in the basic source character set\n"
-msgstr "merkki 0x%lx ei ole peruslähdemerkkien joukossa\n"
+msgstr "merkki 0x%lx ei ole peruslähdemerkistössä\n"
 
 #: charset.c:798 charset.c:1452
 msgid "converting to execution character set"
-msgstr "muunnetaan suoritusmerkkijoukkoon"
+msgstr "muunnetaan suoritusmerkistöön"
 
 #: charset.c:804
 #, c-format
 msgid "character 0x%lx is not unibyte in execution character set"
-msgstr "merkki 0x%lx ei ole yksitavumerkki suoritusmerkkijoukossa"
+msgstr "merkki 0x%lx ei ole yksitavuinen suoritusmerkistössä"
 
 #: charset.c:998
 msgid "universal character names are only valid in C++ and C99"
-msgstr "yleispätevät merkkinimet ovat kelvollisia vai C++:ssa ja C99:ssä"
+msgstr "universaalit merkkinimet ovat kelvollisia vai C++:ssa ja C99:ssä"
 
 #: charset.c:1002
 msgid "C99's universal character names are incompatible with C90"
-msgstr "C99:n yleispätevät merkkinimet eivät ole yhteensopivia C90:n kanssa"
+msgstr "C99:n universaalit merkkinimet ovat epäyhteensopivia C90:n kanssa"
 
 #: charset.c:1005
 #, c-format
 msgid "the meaning of '\\%c' is different in traditional C"
-msgstr "’\\%c’-merkitys on erilainen perinteisessä C:ssä"
+msgstr "’\\%c’:lla on eri merkitys perinteisessä C:ssä"
 
 #  UCN tarkoittaa Universal Character Names ja se sallii minkä tahansa kirjaimen käyttämisen C-lähdekielessä, ei vain englanninkielen kirjainten käytön. Merkki voidaan ilmaista joko kenoviivalla, sitä seuraavalla pienellä u-kirjaimella ja nelinumeroisella heksadesimaaliluvulla tai kenoviivaa seuraavalla suurella U-kirjaimella ja kahdeksannumeroisella heksadesimaaliluvulla.
 #: charset.c:1014
 msgid "In _cpp_valid_ucn but not a UCN"
-msgstr "Kohteessa _cpp_valid_ucn mutta ei UCN"
+msgstr "Funktiossa _cpp_valid_ucn mutta ei ole UCN"
 
 #: charset.c:1039
 #, c-format
 msgid "incomplete universal character name %.*s"
-msgstr "vaillinainen yleispätevä merkkinimi %.*s"
+msgstr "vaillinainen universaali merkkinimi %.*s"
 
 #: charset.c:1054
 #, c-format
 msgid "%.*s is not a valid universal character"
-msgstr "%.*s ei ole kelvollinen yleispätevä merkki"
+msgstr "%.*s ei ole kelvollinen universaali merkki"
 
 #: charset.c:1064 lex.c:1218
 msgid "'$' in identifier or number"
-msgstr "’$’ tunnisteessa tai numerossa"
+msgstr "’$’ tunnisteessa tai lukuarvossa"
 
 #: charset.c:1074
 #, c-format
 msgid "universal character %.*s is not valid in an identifier"
-msgstr "yleispätevä merkki %.*s ei ole kelvollinen tunniste"
+msgstr "universaali merkki %.*s ei ole kelvollinen tunniste"
 
 #: charset.c:1078
 #, c-format
 msgid "universal character %.*s is not valid at the start of an identifier"
-msgstr "yleispätevä merkki %.*s ei ole kelvollien tunnisteen alussa"
+msgstr "universaali merkki %.*s ei ole kelvollinen tunnisteen alussa"
 
 #: charset.c:1110 charset.c:1682
 msgid "converting UCN to source character set"
-msgstr "muunnetaan UCN lähdemerkkijoukoksi"
+msgstr "muunnetaan UCN lähdemerkistöön"
 
 #: charset.c:1114
 msgid "converting UCN to execution character set"
-msgstr "muunnetaan UCN suoritusmerkkijoukoksi"
+msgstr "muunnetaan UCN suoritusmerkistöön"
 
 #: charset.c:1186
 msgid "the meaning of '\\x' is different in traditional C"
-msgstr "merkin ’\\x’ merkitys on erilainen perinteisessä C:ssä"
+msgstr "’\\%x’:lla on eri merkitys perinteisessä C:ssä"
 
 #: charset.c:1203
 msgid "\\x used with no following hex digits"
-msgstr "\\x käytetty ilman seuraavia heksadesimaalinumeroita"
+msgstr "\\x:ää käytetty ilman seuraavia heksenumeroita"
 
 #: charset.c:1210
 msgid "hex escape sequence out of range"
-msgstr "heksadesimaali koodinvaihtosekvenssi lukualueen ulkopuolella"
+msgstr "heksadesimaalinen ohjaussaraj sallitun välin ulkopuolella"
 
 #: charset.c:1248
 msgid "octal escape sequence out of range"
-msgstr "oktaaliluku koodinvaihtosekvenssi lukualueen ulkopuolella"
+msgstr "oktaalinen ohjaussarja sallitun välin ulkopuolella"
 
 #: charset.c:1314
 msgid "the meaning of '\\a' is different in traditional C"
-msgstr "merkin ’\\a’ merkitys on erilainen perinteisessä C:ssä"
+msgstr "’\\a’:lla on eri merkitys perinteisessä C:ssä"
 
 #: charset.c:1321
 #, c-format
 msgid "non-ISO-standard escape sequence, '\\%c'"
-msgstr "ei-ISO-standardi koodinvaihtosekvenssi ’\\%c’"
+msgstr "ISO-standardiin kuulumaton ohjaussarja ’\\%c’"
 
 #: charset.c:1329
 #, c-format
 msgid "unknown escape sequence: '\\%c'"
-msgstr "tuntematon koodinvaihtosekvenssi ’\\%c’"
+msgstr "tuntematon ohjaussarja ’\\%c’"
 
 #: charset.c:1337
 #, c-format
 msgid "unknown escape sequence: '\\%s'"
-msgstr "tuntematon koodinvaihtosekvenssi ’\\%s’"
+msgstr "tuntematon ohjaussarja ’\\%s’"
 
 #: charset.c:1344
 msgid "converting escape sequence to execution character set"
-msgstr "muunnetaan koodinvaihtosekvenssi suoritusmerkkijoukoksi"
+msgstr "muunnetaan ohjaussarja suoritusmerkistöön"
 
 #: charset.c:1517 charset.c:1581
 msgid "character constant too long for its type"
-msgstr "merkkivakio on liian pitkä tälle tyypille"
+msgstr "merkkivakio on liian pitkä tyypilleen"
 
 #: charset.c:1520
 msgid "multi-character character constant"
-msgstr "monimerkkikirjainvakio"
+msgstr "monimerkkinen merkkivakio"
 
 #: charset.c:1620
 msgid "empty character constant"
@@ -149,94 +151,94 @@ msgstr "tyhjä merkkivakio"
 #: charset.c:1729
 #, c-format
 msgid "failure to convert %s to %s"
-msgstr "virhe muuntaa kohde %s kohteeksi %s"
+msgstr "muunnos %s -> %s epäonnistui"
 
 #: directives.c:224 directives.c:267
 #, c-format
 msgid "extra tokens at end of #%s directive"
-msgstr "direktiivin #%s lopussa ylimääräisiä merkkejä"
+msgstr "ylimääräisiä merkkejä #%s-direktiivin lopussa"
 
 #: directives.c:374
 #, c-format
 msgid "#%s is a GCC extension"
-msgstr "#%s on GCC-laajennus"
+msgstr "#%s on GCC-laajennos"
 
 #: directives.c:379
 #, c-format
 msgid "#%s is a deprecated GCC extension"
-msgstr "#%s on vanhentunut GCC-laajennus"
+msgstr "#%s on vanhentunut GCC-laajennos"
 
 #: directives.c:392
 msgid "suggest not using #elif in traditional C"
-msgstr "ei suositella #elif-käyttöä perinteisessä C:ssä"
+msgstr "ehdotetaan #elif:in käytön välttämistä perinteisessä C:ssä"
 
 #: directives.c:395
 #, c-format
 msgid "traditional C ignores #%s with the # indented"
-msgstr "perinteinen C ohittaa #%s merkillä # sisennettynä"
+msgstr "#%s ohitetaan perinteisessä C:ssä, kun # on sisennetty"
 
 #: directives.c:399
 #, c-format
 msgid "suggest hiding #%s from traditional C with an indented #"
-msgstr "suosittelee piilottamaan #%s perinteisestä C:stä sisennetyllä #-merkillä"
+msgstr "ehdotetaan #%s:n piilottamista perinteiseltä C:ltä sisentämällä #"
 
 #: directives.c:425
 msgid "embedding a directive within macro arguments is not portable"
-msgstr "direktiivin upottaminen makroargumenttien sisälle ei ole siirrettävä"
+msgstr "direktiivin upottaminen makroargumenttien sisälle ei ole siirrettävää"
 
 #: directives.c:445
 msgid "style of line directive is a GCC extension"
-msgstr "rividirektiivin tyyli on GCC-laajennus"
+msgstr "rividirektiivin tyyli on GCC-laajennos"
 
 #: directives.c:500
 #, c-format
 msgid "invalid preprocessing directive #%s"
-msgstr "virheellinen esikäsittelijädirektiivi #%s"
+msgstr "virheellinen esikääntäjän direktiivi #%s"
 
 #: directives.c:568
 msgid "\"defined\" cannot be used as a macro name"
-msgstr "”defined” ei voida käyttää makronimenä"
+msgstr "”defined” ei ole kelvollinen makron nimi"
 
 #: directives.c:573
 msgid "\"__has_include__\" cannot be used as a macro name"
-msgstr "”__has_include__” ei voida käyttää makronimenä"
+msgstr "”__has_include__” ei ole kelvollinen makron nimi"
 
 #: directives.c:579
 #, c-format
 msgid "\"%s\" cannot be used as a macro name as it is an operator in C++"
-msgstr "”%s” ei voida käyttää makronimenä, koska se on operaattori C++:ssa"
+msgstr "”%s” ei ole kelvollinen makron nimi, sillä se on C++:n operaattori"
 
 #: directives.c:582
 #, c-format
 msgid "no macro name given in #%s directive"
-msgstr "makronimeä ei ole annettu #%s-direktiivissä"
+msgstr "makron nimeä ei ole annettu #%s-direktiivissä"
 
 #: directives.c:585
 msgid "macro names must be identifiers"
-msgstr "makronimien on oltava tunnisteita"
+msgstr "makrojen nimien on oltava tunnisteita"
 
 #: directives.c:634 directives.c:639
 #, c-format
 msgid "undefining \"%s\""
-msgstr "määrittelemätön ”%s”"
+msgstr "kumotaan määrittely ”%s”"
 
 #: directives.c:694
 msgid "missing terminating > character"
-msgstr "puuttuva päättymismerkki >"
+msgstr "päättävä >-merkki puuttuu"
 
 #: directives.c:753
 #, c-format
 msgid "#%s expects \"FILENAME\" or <FILENAME>"
-msgstr "#%s odottaa ”TIEDOSTONIMI” tai <TIEDOSTONIMI>"
+msgstr "#%s odottaa argumenttia \"TIEDOSTONIMI\" tai <TIEDOSTONIMI>"
 
 #: directives.c:799
 #, c-format
 msgid "empty filename in #%s"
-msgstr "tyhjä tiedostonimi kohteessa #%s"
+msgstr "tyhjä tiedostonimi direktiivissä #%s"
 
 #: directives.c:809
 msgid "#include nested too deeply"
-msgstr "#include sisäkkäinen liian syvälle"
+msgstr "liikaa sisäkkäisiä #include:ja"
 
 #: directives.c:850
 msgid "#include_next in primary source file"
@@ -249,16 +251,16 @@ msgstr "virheellinen lippu ”%s” rividirektiivissä"
 
 #: directives.c:936
 msgid "unexpected end of file after #line"
-msgstr "tiedoston odottamaton loppu #line-direktiivin jälkeen"
+msgstr "odottamaton tiedoston loppu #line-direktiivin jälkeen"
 
 #: directives.c:939
 #, c-format
 msgid "\"%s\" after #line is not a positive integer"
-msgstr "”%s” direktiivin #line jälkeen ei ole positiivinen kokonaisluku"
+msgstr "#line:n jälkeinen ”%s”  ei ole positiivinen kokonaisluku"
 
 #: directives.c:945 directives.c:947
 msgid "line number out of range"
-msgstr "rivinumero lukualueen ulkopuolella"
+msgstr "rivinumero sallitun välin ulkopuolella"
 
 #: directives.c:960 directives.c:1040
 #, c-format
@@ -268,7 +270,7 @@ msgstr "”%s” ei ole kelvollinen tiedostonimi"
 #: directives.c:1000
 #, c-format
 msgid "\"%s\" after # is not a positive integer"
-msgstr "”%s” merkin # jälkeen ei ole positiivinen kokonaisluku"
+msgstr "#:n jälkeinen ”%s” ei ole positiivinen kokonaisluku"
 
 #: directives.c:1095 directives.c:1097 directives.c:1099 directives.c:1685
 #, c-format
@@ -283,17 +285,17 @@ msgstr "virheellinen #%s-direktiivi"
 #: directives.c:1186
 #, c-format
 msgid "registering pragmas in namespace \"%s\" with mismatched name expansion"
-msgstr "rekisteröidään pragmat nimiavaruudessa ”%s” täsmäämättömällä nimilaajennuksella"
+msgstr "rekisteröidään pragmat nimiavaruudessa ”%s” epäsopivalla nimenlavennuksella"
 
 #: directives.c:1195
 #, c-format
 msgid "registering pragma \"%s\" with name expansion and no namespace"
-msgstr "rekisteröidään pragma ”%s” nimilaajennuksella ja ilman nimiavaruutta"
+msgstr "rekisteröidään pragma ”%s” nimenlavennuksella ja ilman nimiavaruutta"
 
 #: directives.c:1213
 #, c-format
 msgid "registering \"%s\" as both a pragma and a pragma namespace"
-msgstr "rekisteröidään ”%s” sekä pragmana ja pragma-nimiavaruutena"
+msgstr "rekisteröidään ”%s” sekä pragmana että pragma-nimiavaruutena"
 
 #: directives.c:1216
 #, c-format
@@ -311,82 +313,80 @@ msgstr "rekisteröidään pragma NULL-käsittelijällä"
 
 #: directives.c:1466
 msgid "#pragma once in main file"
-msgstr "#pragma once main-tiedostossa"
+msgstr "#pragma once päätiedostossa"
 
 #: directives.c:1489
 msgid "invalid #pragma push_macro directive"
-msgstr "virheellinen #pragma push_macro-direktiivi"
+msgstr "virheellinen #pragma push_macro -direktiivi"
 
 #: directives.c:1544
 msgid "invalid #pragma pop_macro directive"
-msgstr "virheellinen #pragma pop_macro-direktiivi"
+msgstr "virheellinen #pragma pop_macro -direktiivi"
 
 #  poison tarkoittaa, että makroa tai direktiiviä ei koskaan määritellä tai käytetä
 #: directives.c:1599
 msgid "invalid #pragma GCC poison directive"
-msgstr "virheellinen #pragma GCC poison-direktiivi"
+msgstr "virheellinen #pragma GCC poison -direktiivi"
 
-#  poison tarkoittaa, että makroa tai direktiiviä ei koskaan määritellä tai käytetä
 #: directives.c:1608
 #, c-format
 msgid "poisoning existing macro \"%s\""
-msgstr "kielletään olemassaoleva makro ”%s”"
+msgstr "myrkytetään olemassa oleva makro ”%s”"
 
 #: directives.c:1627
 msgid "#pragma system_header ignored outside include file"
-msgstr "#pragma system_header ohitetaan include-tiedoston ulkopuolella"
+msgstr "#pragma system_header ohitetaan otsaketiedoston ulkopuolella"
 
 #: directives.c:1652
 #, c-format
 msgid "cannot find source file %s"
-msgstr "lähdetiedoston %s löytäminen epäonnistui"
+msgstr "lähdetiedostoa %s ei löydy"
 
 #: directives.c:1656
 #, c-format
 msgid "current file is older than %s"
 msgstr "nykyinen tiedosto on vanhempi kuin %s"
 
-#  poison tarkoittaa, että makroa tai direktiiviä ei koskaan määritellä tai käytetä
 #: directives.c:1680
 #, c-format
 msgid "invalid \"#pragma GCC %s\" directive"
-msgstr "virheellinen ”#pragma GCC %s”-direktiivi"
+msgstr "virheellinen ”#pragma GCC %s” -direktiivi"
 
 #: directives.c:1874
 msgid "_Pragma takes a parenthesized string literal"
-msgstr "_Pragma ottaa sulkumerkkeillä ympäröidyn merkkijonoliteraalin"
+msgstr "_Pragma ottaa sulkeilla ympäröidyn merkkijonoliteraalin"
 
 #: directives.c:1995
 msgid "#else without #if"
-msgstr "#else ilman #if"
+msgstr "#else ilman #if:iä"
 
 #: directives.c:2000
 msgid "#else after #else"
-msgstr "#else jälkeen #else"
+msgstr "#else #else:n jälkeen"
 
 #: directives.c:2002 directives.c:2035
 msgid "the conditional began here"
-msgstr "ehdollinen alkoi tässä"
+msgstr "ehtolause alkoi tästä"
 
 #: directives.c:2028
 msgid "#elif without #if"
-msgstr "#elif ilman #if"
+msgstr "#elif ilman #if:iä"
 
 #: directives.c:2033
 msgid "#elif after #else"
-msgstr "#elif jälkeen #else"
+msgstr "#elif #else:n jälkeen"
 
 #: directives.c:2064
 msgid "#endif without #if"
-msgstr "#endif ilman #if"
+msgstr "#endif ilman #if:iä"
 
 #: directives.c:2144
 msgid "missing '(' after predicate"
-msgstr "merkki ’(’ puuttuu predikaatin jälkeen"
+msgstr "’(’ puuttuu predikaatin jäljestä"
 
 #: directives.c:2159
 msgid "missing ')' to complete answer"
-msgstr "merkki ’)’ puuttuu täydelliseen vastaukseen"
+msgstr "’)’ puuttuu vastauksen täydentämisestä"
 
 #: directives.c:2179
 msgid "predicate's answer is empty"
@@ -394,7 +394,7 @@ msgstr "predikaatin vastaus on tyhjä"
 
 #: directives.c:2206
 msgid "assertion without predicate"
-msgstr "assertion-toiminto ilman predikaattia"
+msgstr "väite ilman predikaattia"
 
 #: directives.c:2209
 msgid "predicate must be an identifier"
@@ -403,7 +403,7 @@ msgstr "predikaatin on oltava tunniste"
 #: directives.c:2295
 #, c-format
 msgid "\"%s\" re-asserted"
-msgstr "”%s” uudelleen assert-toimintoon"
+msgstr "”%s” väitetty uudelleen"
 
 #: directives.c:2587
 #, c-format
@@ -425,7 +425,7 @@ msgstr "%s: %s"
 
 #: expr.c:512 expr.c:629
 msgid "fixed-point constants are a GCC extension"
-msgstr "kiintopistevakiot ovat GCC-laajennus"
+msgstr "kiintopistevakiot ovat GCC-laajennos"
 
 #: expr.c:537
 msgid "invalid prefix \"0b\" for floating constant"
@@ -433,71 +433,71 @@ msgstr "virheellinen etuliite ”0b” liukulukuvakiolle"
 
 #: expr.c:550
 msgid "use of C++11 hexadecimal floating constant"
-msgstr "käytä C++11 heksadesimaaliliukulukuvakiota"
+msgstr "C++11:n heksadesimaaliliukulukuvakion käyttö"
 
 #: expr.c:553
 msgid "use of C99 hexadecimal floating constant"
-msgstr "käytä C99 heksadesimaaliliukulukuvakiota"
+msgstr "C99:n heksadesimaaliliukulukuvakion käyttö"
 
 #: expr.c:597
 #, c-format
 msgid "invalid suffix \"%.*s\" on floating constant"
-msgstr "virheellinen loppuliite ”%.*s” liukulukuvakiossa"
+msgstr "virheellinen loppuliite ”%.*s” liukulukuvakiolla"
 
 #: expr.c:608 expr.c:668
 #, c-format
 msgid "traditional C rejects the \"%.*s\" suffix"
-msgstr "perinteinen C hylkää ”%.*s”-loppuliitteen"
+msgstr "perinteinen C ei salli ”%.*s”-loppuliitettä"
 
 #: expr.c:616
 msgid "suffix for double constant is a GCC extension"
-msgstr "loppuliite double-vakiolle on GCC-laajennus"
+msgstr "loppuliite double-vakiolle on GCC-laajennos"
 
 #: expr.c:622
 #, c-format
 msgid "invalid suffix \"%.*s\" with hexadecimal floating constant"
-msgstr "virheellinen loppuliite ”%.*s” heksadesimaalisessa liukulukuvakiossa"
+msgstr "virheellinen loppuliite ”%.*s” heksadesimaalisella liukulukuvakiolla"
 
 #: expr.c:633
 msgid "decimal float constants are a GCC extension"
-msgstr "desimaaliliukulukuvakiot ovat GCC-laajennus"
+msgstr "desimaali-float-vakiot ovat GCC-laajennos"
 
 #: expr.c:651
 #, c-format
 msgid "invalid suffix \"%.*s\" on integer constant"
-msgstr "virheellinen loppuliite ”%.*s” kokonaislukuvakiossa"
+msgstr "virheellinen loppuliite ”%.*s” kokonaislukuvakiolla"
 
 #: expr.c:676
 msgid "use of C++11 long long integer constant"
-msgstr "käytä ”C++11 long long”-kokonaislukuvakiota"
+msgstr "C++11:n long long -kokonaislukuvakion käyttö"
 
 #: expr.c:677
 msgid "use of C99 long long integer constant"
-msgstr "käytä ”C99 long long”-kokonaislukuvakiota"
+msgstr "C99:n long long -kokonaislukuvakion käyttö"
 
 #: expr.c:693
 msgid "imaginary constants are a GCC extension"
-msgstr "imaginaarivakiot ovat GCC-laajennus"
+msgstr "imaginäärivakiot ovat GCC-laajennos"
 
 #: expr.c:699
 msgid "binary constants are a C++14 feature or GCC extension"
-msgstr "binäärivakiot ovat C++14-ominaisuus tai GCC-laajennus"
+msgstr "binäärivakiot ovat C++14-ominaisuus tai GCC-laajennos"
 
 #: expr.c:701
 msgid "binary constants are a GCC extension"
-msgstr "binäärivakiot ovat GCC-laajennus"
+msgstr "binäärivakiot ovat GCC-laajennos"
 
 #: expr.c:796
 msgid "integer constant is too large for its type"
-msgstr "kokonaislukuvakio on liian iso sen tyypiksi"
+msgstr "kokonaislukuvakio on liian suuri tyypilleen"
 
 #: expr.c:827
 msgid "integer constant is so large that it is unsigned"
-msgstr "kokonaislukuvakio on niin iso, että se on etumerkitön"
+msgstr "kokonaislukuvakio on niin suuri, että se on etumerkitön"
 
 #: expr.c:922
 msgid "missing ')' after \"defined\""
-msgstr "merkki ’)’ puuttuu ”defined”-merkkijonon jäljestä"
+msgstr "’)’ puuttuu ”defined”-sanan jäljestä"
 
 #: expr.c:929
 msgid "operator \"defined\" requires an identifier"
@@ -506,41 +506,42 @@ msgstr "operaattori ”defined” vaatii tunnisteen"
 #: expr.c:937
 #, c-format
 msgid "(\"%s\" is an alternative token for \"%s\" in C++)"
-msgstr "(”%s” on vaihtoehtoinen merkkijono ”%s” C++:ssa)"
+msgstr "(”%s” on vaihtoehtoinen symboli ”%s”:lle C++:ssa)"
 
 #: expr.c:947
 msgid "this use of \"defined\" may not be portable"
-msgstr "tämä ”defined”-käyttö ei ehkä ole siirrettävä"
+msgstr "tämä ”defined”-sanan käyttö ei ehkä ole siirrettävää"
 
 #: expr.c:1007
 msgid "user-defined literal in preprocessor expression"
-msgstr "käyttäjämääritelty literaali esikääntäjälausekkeessa"
+msgstr "käyttäjän määrittelemä literaali esikääntäjän lausekkeessa"
 
 #: expr.c:1012
 msgid "floating constant in preprocessor expression"
-msgstr "liukulukuvakio esikäsittelijälausekkeessa"
+msgstr "liukulukuvakio esikääntäjän lausekkeessa"
 
 #: expr.c:1018
 msgid "imaginary number in preprocessor expression"
-msgstr "imaginaariluku esikääntäjälausekkeessa"
+msgstr "imaginääriluku esikääntäjän lausekkeessa"
 
 #: expr.c:1070
 #, c-format
 msgid "\"%s\" is not defined"
-msgstr "”%s” ei ole määritelty"
+msgstr "”%s” on määrittelemättä"
 
 #: expr.c:1083
 msgid "assertions are a GCC extension"
-msgstr "assertion-toiminnot ovat GCC-laajennus"
+msgstr "väitteet ovat GCC-laajennos"
 
 #: expr.c:1086
 msgid "assertions are a deprecated extension"
-msgstr "assertion-toiminnot ovat vanhentunut laajennus"
+msgstr "väitteet ovat vanhentunut laajennos"
 
+# %s on #if tai #elif
 #: expr.c:1331
 #, c-format
 msgid "unbalanced stack in %s"
-msgstr "tasapainoton pino kohteessa %s"
+msgstr "tasapainoton pino %s:ssä"
 
 #: expr.c:1351
 #, c-format
@@ -549,41 +550,41 @@ msgstr "mahdoton operaattori ’%u’"
 
 #: expr.c:1452
 msgid "missing ')' in expression"
-msgstr "merkki ’)’ puuttuu lausekkeessa"
+msgstr "’)’ puuttuu lausekkeesta"
 
 #: expr.c:1481
 msgid "'?' without following ':'"
-msgstr "’?’ ilman seuraavaa ’:’"
+msgstr "’?’ ilman sitä seuraavaa ’:’-merkkiä"
 
 #: expr.c:1491
 msgid "integer overflow in preprocessor expression"
-msgstr "kokonaislukuylivuoto esikääntäjälausekkeessa"
+msgstr "kokonaislukuylivuoto esikääntäjän lausekkeessa"
 
 #: expr.c:1496
 msgid "missing '(' in expression"
-msgstr "merkki ’(’ puuttuu lausekkeessa"
+msgstr "’(’ puuttuu lausekkeesta"
 
 #: expr.c:1528
 #, c-format
 msgid "the left operand of \"%s\" changes sign when promoted"
-msgstr "vasen ”%s”-operandi vaihtaa merkkiä, kun korotettiin"
+msgstr "”%s”:n vasen operandi vaihtaa ylennettäessä etumerkkiään"
 
 #: expr.c:1533
 #, c-format
 msgid "the right operand of \"%s\" changes sign when promoted"
-msgstr "oikea ”%s”-operandi vaihtaa merkkiä, kun korotettiin"
+msgstr "”%s”:n oikea operandi vaihtaa ylennettäessä etumerkkiään"
 
 #: expr.c:1792
 msgid "traditional C rejects the unary plus operator"
-msgstr "perinteinen C hylkää unaariplus-operaattorin"
+msgstr "perinteinen C ei salli unaarista plus-operaattoria"
 
 #: expr.c:1890
 msgid "comma operator in operand of #if"
-msgstr "pilkkuoperaattori #if-operandissa"
+msgstr "pilkkuoperaattori #if:in operandissa"
 
 #: expr.c:2026
 msgid "division by zero in #if"
-msgstr "jako nollalla #if-lauseessa"
+msgstr "jako nollalla #if-ehdossa"
 
 #: expr.c:2123
 msgid "operator \"__has_include__\" requires a header string"
@@ -591,11 +592,11 @@ msgstr "operaattori ”__has_include__” vaatii otsakemerkkijonon"
 
 #: expr.c:2139
 msgid "missing ')' after \"__has_include__\""
-msgstr "merkki ’)’ puuttuu ”__has_include__”-merkkijonon jäljestä"
+msgstr "’)’ puuttuu ”__has_include__”-sanan jäljestä"
 
 #: files.c:513
 msgid "NULL directory in find_file"
-msgstr "NULL-hakemistto kohteessa find_file"
+msgstr "NULL-hakemisto funktiossa find_file"
 
 #: files.c:561
 msgid "one or more PCH files were found, but they were invalid"
@@ -603,7 +604,7 @@ msgstr "yksi tai useampia PCH-tiedostoja löytyi, mutta ne olivat virheellisiä"
 
 #: files.c:564
 msgid "use -Winvalid-pch for more information"
-msgstr "käytä lisätietoja varten valitsinta -Winvalid-pch"
+msgstr "käytä -Winvalid-pch saadaksesi lisätietoja"
 
 #: files.c:668
 #, c-format
@@ -613,38 +614,38 @@ msgstr "%s on lohkolaite"
 #: files.c:685
 #, c-format
 msgid "%s is too large"
-msgstr "%s on liian laaja"
+msgstr "%s on liian suuri"
 
 #: files.c:725
 #, c-format
 msgid "%s is shorter than expected"
-msgstr "%s on lyhyempi kuin otaksuttiin"
+msgstr "%s on odotettua lyhyempi"
 
 #: files.c:961
 #, c-format
 msgid "no include path in which to search for %s"
-msgstr "ei include-polkua, jossa etsiä kohdetta %s"
+msgstr "ei include-polkua, josta etsiä tiedostoa %s"
 
 #: files.c:1411
 msgid "Multiple include guards may be useful for:\n"
-msgstr "Useat include-vartijat saattavat olla hyödyllisiä kohteelle:\n"
+msgstr "Monen includen estimet voivat olla hyödyllisiä tiedostoille:\n"
 
 #: init.c:546
 msgid "cppchar_t must be an unsigned type"
-msgstr "cppchar_t on oltava etumerkitön tyyppi"
+msgstr "cppchar_t:n on oltava etumerkitön tyyppi"
 
 #: init.c:550
 #, c-format
 msgid "preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits"
-msgstr "esikääntäjäaritmetiikan maksimitarkkuus on %lu bittiä; kohde vaatii %lu bittiä"
+msgstr "esikääntäjäaritmetiikan enimmäistarkkuus on %lu bittiä; kohde vaatii %lu bittiä"
 
 #: init.c:557
 msgid "CPP arithmetic must be at least as precise as a target int"
-msgstr "CPP-aritmetiikan on oltava vähintään yhtä tarkkaa kuin kohteen int-tyypin"
+msgstr "CPP-aritmetiikan on oltava vähintään yhtä tarkka kuin kohteen int-tyypin"
 
 #: init.c:560
 msgid "target char is less than 8 bits wide"
-msgstr "kohdemerkki on pienempi kuin 8 bittiä leveä"
+msgstr "kohteen char-tyyppi on alle 8 bittiä leveä"
 
 #: init.c:564
 msgid "target wchar_t is narrower than target char"
@@ -652,7 +653,7 @@ msgstr "kohteen wchar_t-tyyppi on kapeampi kuin kohteen char-tyyppi"
 
 #: init.c:568
 msgid "target int is narrower than target char"
-msgstr "kohteen kokonaislukutyyppi on kapeampi kuin kohteen char-tyyppi"
+msgstr "kohteen int-tyyppi on kapeampi kuin kohteen char-tyyppi"
 
 #: init.c:573
 msgid "CPP half-integer narrower than CPP character"
@@ -661,11 +662,11 @@ msgstr "CPP-puolikokonaisluku on kapeampi kuin CPP-merkki"
 #: init.c:577
 #, c-format
 msgid "CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits"
-msgstr "CPP tällä tietokoneella ei voi käsitellä wide-merkkivakioita, jotka ovat yli %lu bittiä, mutta kohde vaatii %lu bittiä"
+msgstr "CPP tällä koneella ei pysty käsittelemään yli %lu-bittisiä leveämerkkivakioita, mutta kohde vaatii %lu bittiä"
 
 #: lex.c:1011
 msgid "backslash and newline separated by space"
-msgstr "kenoviiva ja rivinvaihtomerkki eroteltu välilyönnillä"
+msgstr "kenoviiva ja rivinvaihto erotettu välilyönnillä"
 
 #: lex.c:1016
 msgid "backslash-newline at end of file"
@@ -674,75 +675,76 @@ msgstr "kenoviiva-rivinvaihto tiedoston lopussa"
 #: lex.c:1032
 #, c-format
 msgid "trigraph ??%c converted to %c"
-msgstr "trigraph-merkki ??%c muunnettu merkiksi %c"
+msgstr "kolmoismerkki ??%c muunnettu merkiksi %c"
 
 #: lex.c:1040
 #, c-format
 msgid "trigraph ??%c ignored, use -trigraphs to enable"
-msgstr "trigraph-merkki ??%c ohitettiin, käytä valitsinta -trigraphs merkkien käyttöönottamiseksi"
+msgstr "kolmoismerkki ??%c ohitettiin, ota käyttöön valitsimella -trigraphs"
 
 #: lex.c:1089
 msgid "\"/*\" within comment"
 msgstr "”/*” kommentin sisällä"
 
+# Mahdolliset arvot: "form feed", "vertical tab", eivät käännettäviä.
 #: lex.c:1147
 #, c-format
 msgid "%s in preprocessing directive"
-msgstr "%s esikäsittelijädirektiivissä"
+msgstr "%s esikääntäjän direktiivissä"
 
 #: lex.c:1156
 msgid "null character(s) ignored"
-msgstr "null-merkkejä ei oteta huomioon"
+msgstr "null-merkit ohitetaan"
 
 #  NFKC-muodossa Unicode-merkki ilmaistaan nelinumeroisella heksadesimaaliluvulla
 #: lex.c:1193
 #, c-format
 msgid "`%.*s' is not in NFKC"
-msgstr "”%.*s” ei ole Unicode-normalisointimerkkijonomuodossa NFKC"
+msgstr "”%.*s” ei ole NFKC-muodossa"
 
 #  NFC-muodossa Unicode-merkki ilmaistaan nelinumeroisella heksadesimaaliluvulla
 #: lex.c:1196
 #, c-format
 msgid "`%.*s' is not in NFC"
-msgstr "”%.*s” ei ole Unicode-normalisointimerkkijonomuodossa NFC"
+msgstr "”%.*s” ei ole  NFC-muodossa"
 
 #  poison tarkoittaa, että makroa tai direktiiviä ei koskaan määritellä tai käytetä
 #: lex.c:1265 lex.c:1354
 #, c-format
 msgid "attempt to use poisoned \"%s\""
-msgstr "yritys käyttää poison-kiellettyä makroa ”%s”"
+msgstr "myrkytetyn makron ”%s” käyttöyritys"
 
 #  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: lex.c:1275 lex.c:1364
 msgid "__VA_ARGS__ can only appear in the expansion of a C++11 variadic macro"
-msgstr "__VA_ARGS__ voi vain esiintyä C++11 variadic-makrolaajennuksessa"
+msgstr "__VA_ARGS__ voi vain esiintyä C++11:n variadisen makron lavennoksessa"
 
 #  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: lex.c:1279 lex.c:1368
 msgid "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro"
-msgstr "__VA_ARGS__ voi vain esiintyä C99 variadic-makrolaajennuksessa"
+msgstr "__VA_ARGS__ voi vain esiintyä C99:n variadisen makron lavennoksessa"
 
 #: lex.c:1286 lex.c:1375
 #, c-format
 msgid "identifier \"%s\" is a special operator name in C++"
-msgstr "tunniste ”%s” on erikoisoperaattorinimi C++:ssa"
+msgstr "tunniste ”%s” on operaattorin nimi C++:ssa"
 
 #: lex.c:1665
 msgid "raw string delimiter longer than 16 characters"
-msgstr "raakamerkkijonoerotin pitempi kuin 16 merkkiä"
+msgstr "raa’an merkkijonon erotin pitempi kuin 16 merkkiä"
 
 #: lex.c:1669
 msgid "invalid new-line in raw string delimiter"
-msgstr "virheellinen rivinvaihtomerkki raakamerkkijonoerottimessa"
+msgstr "virheellinen rivinvaihto raa’an merkkijonon erottimessa"
 
 #: lex.c:1673
 #, c-format
 msgid "invalid character '%c' in raw string delimiter"
-msgstr "virheellinen merkki ’%c’ raakamerkkijonoerottimessa"
+msgstr "virheellinen merkki ’%c’ raa’an merkkijonon erottimessa"
 
 #: lex.c:1722 lex.c:1744
 msgid "unterminated raw string"
-msgstr "päättämätön raakamerkkijono"
+msgstr "päättämätön raaka merkkijono"
 
 #: lex.c:1765 lex.c:1894
 msgid "invalid suffix on literal; C++11 requires a space between literal and string macro"
@@ -750,24 +752,24 @@ msgstr "literaalissa virheellinen loppuliite; C++11 vaatii välilyönnin literaa
 
 #: lex.c:1876
 msgid "null character(s) preserved in literal"
-msgstr "null-merkit säilytetään literaaleissa"
+msgstr "null-merkit säilytetään literaalissa"
 
 #: lex.c:1879
 #, c-format
 msgid "missing terminating %c character"
-msgstr "puuttuva päättymismerkki %c"
+msgstr "päättävä merkki %c puuttuu"
 
 #: lex.c:2447 lex.c:2481
 msgid "C++ style comments are not allowed in ISO C90"
-msgstr "C++-tyyliset kommentit eivät ole sallittuja ISO C90-standardissa"
+msgstr "C++-tyyliset kommentit eivät ole sallittuja ISO C90:ssä"
 
 #: lex.c:2449 lex.c:2460 lex.c:2483
 msgid "(this will be reported only once per input file)"
-msgstr "(tästä ilmoitetaan vain kerran per syötetiedosto)"
+msgstr "(tästä ilmoitetaan vain kerran syötetiedostoa kohden)"
 
 #: lex.c:2458
 msgid "C++ style comments are incompatible with C90"
-msgstr "C++-tyyliset kommentit ovat yhteensopimattomia C90:n kanssa"
+msgstr "C++-tyyliset kommentit ovat epäyhteensopivia C90:n kanssa"
 
 #: lex.c:2489
 msgid "multi-line comment"
@@ -776,12 +778,12 @@ msgstr "monirivinen kommentti"
 #: lex.c:2833
 #, c-format
 msgid "unspellable token %s"
-msgstr "tavaamaton merkkijono %s"
+msgstr "kirjoitusasuton symboli %s"
 
 #: macro.c:200
 #, c-format
 msgid "macro \"%s\" is not used"
-msgstr "makroa ”%s” ei ole käytetty"
+msgstr "makroa ”%s” ei käytetä"
 
 #: macro.c:238 macro.c:470
 #, c-format
@@ -791,38 +793,38 @@ msgstr "virheellinen sisäinen makro ”%s”"
 #: macro.c:245 macro.c:342
 #, c-format
 msgid "macro \"%s\" might prevent reproducible builds"
-msgstr "makro ”%s” saattaisi estää toistettavat rakentamiset"
+msgstr "makro ”%s” saattaa estää toistettavat käännökset"
 
 #: macro.c:276
 msgid "could not determine file timestamp"
-msgstr "ei voitu ottaa selvää tiedoston aikaleimasta"
+msgstr "ei voitu selvittää tiedoston aikaleimaa"
 
 #: macro.c:377
 msgid "could not determine date and time"
-msgstr "ei voitu ottaa selvää päivämäärästä ja ajasta"
+msgstr "ei voitu selvittää päivämäärää ja aikaa"
 
 #: macro.c:393
 msgid "__COUNTER__ expanded inside directive with -fdirectives-only"
-msgstr "__COUNTER__ laajennettu direktiivin sisällä valitsimella -fdirectives-only"
+msgstr "__COUNTER__ lavennettu direktiivin sisällä valitsimella -fdirectives-only"
 
 #: macro.c:581
 msgid "invalid string literal, ignoring final '\\'"
-msgstr "virheellinen merkijonoliteraali, ei oteta huomioon lopun ’\\’ merkkejä"
+msgstr "virheellinen merkijonoliteraali, ohitetaan viimeinen ’\\’"
 
 #: macro.c:643
 #, c-format
 msgid "pasting \"%s\" and \"%s\" does not give a valid preprocessing token"
-msgstr "liittämällä ”%s” ja ”%s” ei anneta kelvollista esikääntäjämerkkijonoa"
+msgstr "liittämällä ”%s” ja ”%s” ei saada kelvollista esikääntäjän symbolia"
 
 #  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: macro.c:767
 msgid "ISO C++11 requires at least one argument for the \"...\" in a variadic macro"
-msgstr "ISO C++11 vaatii vähintään yhden argumentin kohteelle ”...” variadic-makrossa"
+msgstr "ISO C++11 vaatii vähintään yhden argumentin variadisen makron ”...”:lle"
 
 #  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: macro.c:771
 msgid "ISO C99 requires at least one argument for the \"...\" in a variadic macro"
-msgstr "ISO C99 vaatii vähintään yhden argumentin kohteelle ”...” variadic-makrossa"
+msgstr "ISO C99 vaatii vähintään yhden argumentin variadisen makron ”...”:lle"
 
 #: macro.c:778
 #, c-format
@@ -832,17 +834,17 @@ msgstr "makro ”%s” vaatii %u argumenttia, mutta vain %u on annettu"
 #: macro.c:783
 #, c-format
 msgid "macro \"%s\" passed %u arguments, but takes just %u"
-msgstr "makrolle ”%s” välitetty %u argumenttia, mutta se ottaa vain %u"
+msgstr "makrolle ”%s” annettu %u argumenttia, mutta se ottaa vain %u"
 
 #: macro.c:977 traditional.c:819
 #, c-format
 msgid "unterminated argument list invoking macro \"%s\""
-msgstr "päättämätön argumenttiluettelo kutsuttaessa makroa ”%s”"
+msgstr "päättämätön argumenttiluettelo kutsuttaessa ”%s”-makroa"
 
 #: macro.c:1128
 #, c-format
 msgid "function-like macro \"%s\" must be used with arguments in traditional C"
-msgstr "funktion kaltaista makroa ”%s” on käytettävä argumenteilla perinteisessä C:ssä"
+msgstr "funktion kaltaista makroa ”%s” on käytettävä argumenttien kanssa perinteisessä C:ssä"
 
 #: macro.c:1814
 #, c-format
@@ -857,69 +859,66 @@ msgstr "kutsutaan makron %s argumenttia %d: tyhjät makroargumentit ovat määri
 #: macro.c:2800
 #, c-format
 msgid "duplicate macro parameter \"%s\""
-msgstr "kaksoiskappale makroparametri ”%s”"
+msgstr "kahdenkertainen makroparametri ”%s”"
 
 #: macro.c:2849
 #, c-format
 msgid "\"%s\" may not appear in macro parameter list"
-msgstr "”%s” ei ehkä ilmene makroparametriluettelossa"
+msgstr "”%s” ei saa esiintyä makron parametriluettelossa"
 
 #: macro.c:2857
 msgid "macro parameters must be comma-separated"
-msgstr "makroparametrien on oltava pilkulla eroteltuja"
+msgstr "makron parametrien on oltava pilkuin eroteltuja"
 
 #: macro.c:2875
 msgid "parameter name missing"
-msgstr "parametrinimi puuttuu"
+msgstr "parametrin nimi puuttuu"
 
-#  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: macro.c:2896
 msgid "anonymous variadic macros were introduced in C++11"
-msgstr "anonyymit variadic-makrot esiteltiin C++11:ssä"
+msgstr "anonyymit variadiset makrot esiteltiin C++11:ssä"
 
 #  Variadic-makro on sellainen makro, jonka argumenttien lukumäärä voi vaihdella.
 #: macro.c:2900 macro.c:2905
 msgid "anonymous variadic macros were introduced in C99"
-msgstr "anonyymit variadic-makrot esiteltiin C99:ssä"
+msgstr "anonyymit variadiset makrot esiteltiin C99:ssä"
 
-#  Variadic-makro on sellainen makro, joka hyväksyy vaihtelevan määrän argumentteja.
 #: macro.c:2912
 msgid "ISO C++ does not permit named variadic macros"
-msgstr "ISO C++ ei salli nimettyjä variadic-makroja"
+msgstr "ISO C++ ei salli nimettyjä variadisia makroja"
 
-#  Variadic-makro on sellainen makro, joka hyväksyy vaihtelevan määrän argumentteja.
 #: macro.c:2915
 msgid "ISO C does not permit named variadic macros"
-msgstr "ISO C ei salli nimettyjä variadic-makroja"
+msgstr "ISO C ei salli nimettyjä variadisia makroja"
 
 #: macro.c:2925
 msgid "missing ')' in macro parameter list"
-msgstr "puuttuu ’)’ makroparametriluettelosta"
+msgstr "’)’ puuttuu makron parametriluettelosta"
 
 #: macro.c:2976
 msgid "'##' cannot appear at either end of a macro expansion"
-msgstr "’##’ ei voi esiintyä makrolaajennuksen kummassakaan päässä"
+msgstr "’##’ ei voi esiintyä makrolavennuksen kummassakaan päässä"
 
 #: macro.c:3013
 msgid "ISO C++11 requires whitespace after the macro name"
-msgstr "ISO C++11 vaatii tyhjemerkin makronimen jälkeen"
+msgstr "ISO C++11 vaatii tyhjemerkin makron nimen jälkeen"
 
 #: macro.c:3016
 msgid "ISO C99 requires whitespace after the macro name"
-msgstr "ISO C99 vaatii tyhjemerkin makronimen jälkeen"
+msgstr "ISO C99 vaatii tyhjemerkin makron nimen jälkeen"
 
 #: macro.c:3041
 msgid "missing whitespace after the macro name"
-msgstr "puuttuu tyhjemerkki makronimen jälkeen"
+msgstr "tyhjemerkki puuttuu makron nimen jäljestä"
 
 #: macro.c:3075
 msgid "'#' is not followed by a macro parameter"
-msgstr "’#’-merkkiä seuraa makroparametri"
+msgstr "’#’ ilman sitä seuraavaa makroparametria"
 
 #: macro.c:3236
 #, c-format
 msgid "\"%s\" redefined"
-msgstr "”%s” on määritelty uudelleen"
+msgstr "”%s” määritelty uudelleen"
 
 #: macro.c:3241
 msgid "this is the location of the previous definition"
@@ -928,32 +927,31 @@ msgstr "tämä on edellisen määrittelyn sijainti"
 #: macro.c:3302
 #, c-format
 msgid "macro argument \"%s\" would be stringified in traditional C"
-msgstr "makroargumentti ”%s” muunnettaisiin merkkijonoksi perinteisessä C:ssä"
+msgstr "makron argumentti ”%s” merkkijonostettaisiin perinteisessä C:ssä"
 
 #: macro.c:3329
 #, c-format
 msgid "invalid hash type %d in cpp_macro_definition"
-msgstr "virheellinen hash-tyyppi %d kohteessa cpp_macro_definition"
+msgstr "virheellinen hash-tyyppi %d funktiossa cpp_macro_definition"
 
 #: pch.c:87 pch.c:345 pch.c:359 pch.c:377 pch.c:383 pch.c:392 pch.c:399
 msgid "while writing precompiled header"
-msgstr "kirjoitettaessa esikäännettyjä otsaketiedostoja"
+msgstr "kirjoitettaessa esikäännettyä otsaketiedostoa"
 
-#  poison tarkoittaa, että makroa tai direktiiviä ei koskaan määritellä tai käytetä
 #: pch.c:619
 #, c-format
 msgid "%s: not used because `%.*s' is poisoned"
-msgstr "%s: ei käytetä, koska ”%.*s” on poison-kielletty"
+msgstr "%s: ei käytetä, koska ”%.*s” on myrkytetty"
 
 #: pch.c:641
 #, c-format
 msgid "%s: not used because `%.*s' not defined"
-msgstr "%s: ei käytetä, koska ”%.*s” ei ole määritelty"
+msgstr "%s: ei käytetä, koska ”%.*s” on määrittelemättä"
 
 #: pch.c:653
 #, c-format
 msgid "%s: not used because `%.*s' defined as `%s' not `%.*s'"
-msgstr "%s: ei käytetä, koska ”%.*s” on määritelty nimellä ”%s” ei nimellä ”%.*s”"
+msgstr "%s: ei käytetä, koska ”%.*s” on määritelty arvoon ”%s” eikä ”%.*s”"
 
 #: pch.c:694
 #, c-format
@@ -963,20 +961,20 @@ msgstr "%s: ei käytetä, koska ”%s” on määritelty"
 #: pch.c:714
 #, c-format
 msgid "%s: not used because `__COUNTER__' is invalid"
-msgstr "%s: ei käytetty, koska ”__COUNTER__” on virheellinen"
+msgstr "%s: ei käytetä, koska ”__COUNTER__” on virheellinen"
 
 #: pch.c:723 pch.c:900
 msgid "while reading precompiled header"
-msgstr "luettaessa esikäännettyjä otsaketiedostoja"
+msgstr "luettaessa esikäännettyä otsaketiedostoa"
 
 #: traditional.c:889
 #, c-format
 msgid "detected recursion whilst expanding macro \"%s\""
-msgstr "havaittu rekursio laajennettaessa makroa ”%s”"
+msgstr "havaittiin rekursio lavennettaessa makroa ”%s”"
 
 #: traditional.c:1108
 msgid "syntax error in macro parameter list"
-msgstr "syntaksivirhe makroparameteriluettelossa"
+msgstr "syntaksivirhe makron parameteriluettelossa"
 
 #  NFKC-muodossa Unicode-merkki ilmaistaan nelinumeroisella heksadesimaaliluvulla
 #~ msgid "Character %x might not be NFKC"
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index b6f3a76..22a63ec 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,23 @@
+2016-02-10  Ian Lance Taylor  <iant@google.com>
+
+	PR go/68562
+	* config/i386/morestack.S (__stack_split_initialize): Align
+	stack.
+
+2015-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (__canonicalize_funcptr_for_compare): Remove code
+	to initialize call to __dl_fixup once.
+
+2015-12-05  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline:
+	2015-12-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (__canonicalize_funcptr_for_compare): Initialize
+	fixup values if saved GOT address doesn't match runtime address.
+	(fixup_branch_offset): Reorder list.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libgcc/config/i386/morestack.S b/libgcc/config/i386/morestack.S
index 6ac9a51..1f607e0 100644
--- a/libgcc/config/i386/morestack.S
+++ b/libgcc/config/i386/morestack.S
@@ -732,6 +732,7 @@ __stack_split_initialize:
 
 	leal	-16000(%esp),%eax	# We should have at least 16K.
 	movl	%eax,%gs:0x30
+	subl	$4,%esp			# Align stack.
 	pushl	$16000
 	pushl	%esp
 #ifdef __PIC__
@@ -739,13 +740,14 @@ __stack_split_initialize:
 #else
 	call	__generic_morestack_set_initial_sp
 #endif
-	addl	$8,%esp
+	addl	$12,%esp
 	ret
 
 #else /* defined(__x86_64__) */
 
 	leaq	-16000(%rsp),%rax	# We should have at least 16K.
 	X86_64_SAVE_NEW_STACK_BOUNDARY (ax)
+	subq	$8,%rsp			# Align stack.
 	movq	%rsp,%rdi
 	movq	$16000,%rsi
 #ifdef __PIC__
@@ -753,6 +755,7 @@ __stack_split_initialize:
 #else
 	call	__generic_morestack_set_initial_sp
 #endif
+	addq	$8,%rsp
 	ret
 
 #endif /* defined(__x86_64__) */
diff --git a/libgcc/config/pa/fptr.c b/libgcc/config/pa/fptr.c
index 3036727..77d0db4 100644
--- a/libgcc/config/pa/fptr.c
+++ b/libgcc/config/pa/fptr.c
@@ -40,7 +40,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    the template should it be necessary to change the current branch
    position.  */
 #define NOFFSETS 2
-static int fixup_branch_offset[NOFFSETS] = { 32, -4 };
+static int fixup_branch_offset[NOFFSETS] = { -4, 32 };
 
 #define GET_FIELD(X, FROM, TO) \
   ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))
@@ -64,9 +64,10 @@ unsigned int __canonicalize_funcptr_for_compare (fptr_t)
 unsigned int
 __canonicalize_funcptr_for_compare (fptr_t fptr)
 {
-  static unsigned int fixup_plabel[2];
-  static fixup_t fixup;
-  unsigned int *plabel, *got;
+  static unsigned int fixup_plabel[2] __attribute__((used));
+  fixup_t fixup;
+  unsigned int *got, *iptr, *plabel;
+  int i;
 
   /* -1 and page 0 are special.  -1 is used in crtend to mark the end of
      a list of function pointers.  Also return immediately if the plabel
@@ -87,42 +88,33 @@ __canonicalize_funcptr_for_compare (fptr_t fptr)
   if (got !=  &_GLOBAL_OFFSET_TABLE_)
     return plabel[0];
 
-  /* Initialize our plabel for calling fixup if we haven't done so already.
-     This code needs to be thread safe but we don't have to be too careful
-     as the result is invariant.  */
-  if (!fixup)
+  /* Find the first "bl" branch in the offset search list.  This is a
+     call to _dl_fixup or a magic branch to fixup at the beginning of the
+     trampoline template.  The fixup function does the actual runtime
+     resolution of function descriptors.  We only look for "bl" branches
+     with a 17-bit pc-relative displacement.  */
+  for (i = 0; i < NOFFSETS; i++)
     {
-      int i;
-      unsigned int *iptr;
-
-      /* Find the first "bl" branch in the offset search list.  This is a
-	 call to fixup or a magic branch to fixup at the beginning of the
-	 trampoline template.  The fixup function does the actual runtime
-	 resolution of function descriptors.  We only look for "bl" branches
-	 with a 17-bit pc-relative displacement.  */
-      for (i = 0; i < NOFFSETS; i++)
-	{
-	  iptr = (unsigned int *) (got[-2] + fixup_branch_offset[i]);
-	  if ((*iptr & 0xfc00e000) == 0xe8000000)
-	    break;
-	}
-
-      /* This should not happen... */
-      if (i == NOFFSETS)
-	return ~0;
-
-      /* Extract the 17-bit displacement from the instruction.  */
-      iptr += SIGN_EXTEND (GET_FIELD (*iptr, 19, 28) |
-			   GET_FIELD (*iptr, 29, 29) << 10 |
-			   GET_FIELD (*iptr, 11, 15) << 11 |
-			   GET_FIELD (*iptr, 31, 31) << 16, 17);
-
-      /* Build a plabel for an indirect call to fixup.  */
-      fixup_plabel[0] = (unsigned int) iptr + 8;  /* address of fixup */
-      fixup_plabel[1] = got[-1];		  /* ltp for fixup */
-      fixup = (fixup_t) ((int) fixup_plabel | 3);
+      iptr = (unsigned int *) (got[-2] + fixup_branch_offset[i]);
+      if ((*iptr & 0xfc00e000) == 0xe8000000)
+	break;
     }
 
+  /* This should not happen... */
+  if (i == NOFFSETS)
+    return ~0;
+
+  /* Extract the 17-bit displacement from the instruction.  */
+  iptr += SIGN_EXTEND (GET_FIELD (*iptr, 19, 28) |
+		       GET_FIELD (*iptr, 29, 29) << 10 |
+		       GET_FIELD (*iptr, 11, 15) << 11 |
+		       GET_FIELD (*iptr, 31, 31) << 16, 17);
+
+  /* Build a plabel for an indirect call to _dl_fixup.  */
+  fixup_plabel[0] = (unsigned int) iptr + 8;	/* address of fixup */
+  fixup_plabel[1] = got[-1];			/* ltp for fixup */
+  fixup = (fixup_t) ((int) fixup_plabel | 3);
+
   /* Call fixup to resolve the function address.  got[1] contains the
      link_map pointer and plabel[1] the relocation offset.  */
   fixup ((struct link_map *) got[1], plabel[1]);
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index c231c76..f53de38 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,37 @@
+2016-02-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/69651
+	* io/list_read.c (push_char4): Fix the pointer usage for xrealloc.
+
+2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/69651
+	PR libgfortran/69668
+	* io/list_read.c: Entire file trailing spaces removed.
+	(CASE_SEPARATORS): Remove '!'.
+	(is_separator): Add namelist mode as condition with '!'.
+	(push_char): Remove un-needed memset. (push_char4): Likewise and remove
+	'new' pointer. (eat_separator): Remove un-needed use of notify_std.
+	(read_logical): If '!' bang encountered when not in namelist mode got
+	bad_logical to give an error. (read_integer): Likewise reject '!'.
+	(read_character): Remove condition testing c = '!' which is now inside
+	the is_separator macro. Remove code related to DELIM_NONE.
+	(parse_real): Reject '!' unless in namelist mode. (read_complex): Reject
+	'!' unless in namelist mode. (read_real): Likewise reject '!'. 
+
+2015-12-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/68987
+	io/format.c (format_error): Remove unneeded memory cleanup.
+
+2015-12-05  Juoko Orava <jouko.orava@iki.fi>
+
+	PR fortran/50201
+	* io/write_float.def: Avoid marking quadmath_snprintf as an untyped
+	weak reference, which fixing linking with -static.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libgfortran/caf/libcaf.h b/libgfortran/caf/libcaf.h
index 660bd7c..ebda579 100644
--- a/libgfortran/caf/libcaf.h
+++ b/libgfortran/caf/libcaf.h
@@ -57,7 +57,9 @@ typedef enum caf_register_t {
   CAF_REGTYPE_COARRAY_ALLOC,
   CAF_REGTYPE_LOCK_STATIC,
   CAF_REGTYPE_LOCK_ALLOC,
-  CAF_REGTYPE_CRITICAL
+  CAF_REGTYPE_CRITICAL,
+  CAF_REGTYPE_EVENT_STATIC,
+  CAF_REGTYPE_EVENT_ALLOC
 }
 caf_register_t;
 
@@ -133,5 +135,8 @@ void _gfortran_caf_atomic_op (int, caf_token_t, size_t, int, void *, void *,
 
 void _gfortran_caf_lock (caf_token_t, size_t, int, int *, int *, char *, int);
 void _gfortran_caf_unlock (caf_token_t, size_t, int, int *, char *, int);
+void _gfortran_caf_event_post (caf_token_t, size_t, int, int *, char *, int);
+void _gfortran_caf_event_wait (caf_token_t, size_t, int, int *, char *, int);
+void _gfortran_caf_event_query (caf_token_t, size_t, int, int *, int *);
 
 #endif  /* LIBCAF_H  */
diff --git a/libgfortran/caf/single.c b/libgfortran/caf/single.c
index 6c58286..9c4b343 100644
--- a/libgfortran/caf/single.c
+++ b/libgfortran/caf/single.c
@@ -101,7 +101,8 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,
   void *local;
 
   if (type == CAF_REGTYPE_LOCK_STATIC || type == CAF_REGTYPE_LOCK_ALLOC
-      || type == CAF_REGTYPE_CRITICAL)
+      || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC
+      || type == CAF_REGTYPE_EVENT_ALLOC)
     local = calloc (size, sizeof (bool));
   else
     local = malloc (size);
@@ -133,7 +134,8 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,
     *stat = 0;
 
   if (type == CAF_REGTYPE_COARRAY_STATIC || type == CAF_REGTYPE_LOCK_STATIC
-      || type == CAF_REGTYPE_CRITICAL)
+      || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC
+      || type == CAF_REGTYPE_EVENT_ALLOC)
     {
       caf_static_t *tmp = malloc (sizeof (caf_static_t));
       tmp->prev  = caf_static_list;
@@ -1071,6 +1073,45 @@ _gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,
     *stat = 0;
 }
 
+void
+_gfortran_caf_event_post (caf_token_t token, size_t index, 
+			  int image_index __attribute__ ((unused)), 
+			  int *stat, char *errmsg __attribute__ ((unused)), 
+			  int errmsg_len __attribute__ ((unused)))
+{
+  uint32_t value = 1;
+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));
+  __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);
+  
+  if(stat)
+    *stat = 0;
+}
+
+void
+_gfortran_caf_event_wait (caf_token_t token, size_t index, 
+			  int until_count, int *stat,
+			  char *errmsg __attribute__ ((unused)), 
+			  int errmsg_len __attribute__ ((unused)))
+{
+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));
+  uint32_t value = (uint32_t)-until_count;
+   __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);
+  
+   if(stat)
+    *stat = 0;    
+}
+
+void
+_gfortran_caf_event_query (caf_token_t token, size_t index, 
+			   int image_index __attribute__ ((unused)), 
+			   int *count, int *stat)
+{
+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));
+  __atomic_load (event, (uint32_t *) count, __ATOMIC_RELAXED);
+  
+  if(stat)
+    *stat = 0;
+}
 
 void
 _gfortran_caf_lock (caf_token_t token, size_t index,
diff --git a/libgfortran/io/format.c b/libgfortran/io/format.c
index 42be258..6ef029a 100644
--- a/libgfortran/io/format.c
+++ b/libgfortran/io/format.c
@@ -1171,26 +1171,6 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)
   *p++ = '^';
   *p = '\0';
 
-  /* Cleanup any left over memory allocations before calling generate
-     error.  */
-  if (is_internal_unit (dtp))
-    {
-      if (dtp->format != NULL)
-	{
-	  free (dtp->format);
-	  dtp->format = NULL;
-	}
-
-      /* Leave these alone if IOSTAT was given because execution will
-	 return from generate error in those cases.  */
-      if (!(dtp->common.flags & IOPARM_HAS_IOSTAT))
-	{
-	  free (dtp->u.p.fmt);
-	  free_format_hash_table (dtp->u.p.current_unit);
-	  free_internal_unit (dtp);
-	}
-    }
-
   generate_error (&dtp->common, LIBERROR_FORMAT, buffer);
 }
 
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index 45243ed..e02feca 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -58,7 +58,8 @@ typedef unsigned char uchar;
 /* This macro assumes that we're operating on a variable.  */
 
 #define is_separator(c) (c == '/' ||  c == ',' || c == '\n' || c == ' ' \
-                         || c == '\t' || c == '\r' || c == ';')
+                         || c == '\t' || c == '\r' || c == ';' || \
+			 (dtp->u.p.namelist_mode && c == '!'))
 
 /* Maximum repeat count.  Less than ten times the maximum signed int32.  */
 
@@ -75,7 +76,7 @@ typedef unsigned char uchar;
 
 /* Worker function to save a default KIND=1 character to a string
    buffer, enlarging it as necessary.  */
-   
+
 static void
 push_char_default (st_parameter_dt *dtp, int c)
 {
@@ -92,13 +93,8 @@ push_char_default (st_parameter_dt *dtp, int c)
   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)
     {
       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;
-      dtp->u.p.saved_string = 
+      dtp->u.p.saved_string =
 	xrealloc (dtp->u.p.saved_string, dtp->u.p.saved_length);
-      
-      // Also this should not be necessary.
-      memset (dtp->u.p.saved_string + dtp->u.p.saved_used, 0, 
-	      dtp->u.p.saved_length - dtp->u.p.saved_used);
-
     }
 
   dtp->u.p.saved_string[dtp->u.p.saved_used++] = (char) c;
@@ -107,11 +103,10 @@ push_char_default (st_parameter_dt *dtp, int c)
 
 /* Worker function to save a KIND=4 character to a string buffer,
    enlarging the buffer as necessary.  */
-   
 static void
 push_char4 (st_parameter_dt *dtp, int c)
 {
-  gfc_char4_t *new, *p = (gfc_char4_t *) dtp->u.p.saved_string;
+  gfc_char4_t *p = (gfc_char4_t *) dtp->u.p.saved_string;
 
   if (p == NULL)
     {
@@ -124,10 +119,10 @@ push_char4 (st_parameter_dt *dtp, int c)
   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)
     {
       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;
-      p = xrealloc (p, dtp->u.p.saved_length * sizeof (gfc_char4_t));
-      
-      memset4 (new + dtp->u.p.saved_used, 0, 
-	      dtp->u.p.saved_length - dtp->u.p.saved_used);
+      dtp->u.p.saved_string =
+	xrealloc (dtp->u.p.saved_string,
+		  dtp->u.p.saved_length * sizeof (gfc_char4_t));
+      p = (gfc_char4_t *) dtp->u.p.saved_string;
     }
 
   p[dtp->u.p.saved_used++] = c;
@@ -168,7 +163,7 @@ free_line (st_parameter_dt *dtp)
 /* Unget saves the last character so when reading the next character,
    we need to check to see if there is a character waiting.  Similar,
    if the line buffer is being used to read_logical, check it too.  */
-   
+
 static int
 check_buffers (st_parameter_dt *dtp)
 {
@@ -200,7 +195,7 @@ check_buffers (st_parameter_dt *dtp)
       dtp->u.p.line_buffer_pos = 0;
       dtp->u.p.line_buffer_enabled = 0;
     }
-    
+
 done:
   dtp->u.p.at_eol = (c == '\n' || c == EOF);
   return c;
@@ -254,7 +249,7 @@ next_char_internal (st_parameter_dt *dtp)
 	  record = next_array_record (dtp, dtp->u.p.current_unit->ls,
 				      &finished);
 
-	  /* Check for "end-of-file" condition.  */      
+	  /* Check for "end-of-file" condition.  */
 	  if (finished)
 	    {
 	      dtp->u.p.at_eof = 1;
@@ -289,17 +284,17 @@ next_char_internal (st_parameter_dt *dtp)
 
   if (is_array_io (dtp))
     {
-      /* Check whether we hit EOF.  */ 
+      /* Check whether we hit EOF.  */
       if (unlikely (length == 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 	  return '\0';
-	} 
+	}
       dtp->u.p.current_unit->bytes_left--;
     }
   else
     {
-      if (dtp->u.p.at_eof) 
+      if (dtp->u.p.at_eof)
 	return EOF;
       if (length == 0)
 	{
@@ -316,7 +311,7 @@ done:
 
 /* Worker function for UTF encoded files.  */
 static int
-next_char_utf8 (st_parameter_dt *dtp) 
+next_char_utf8 (st_parameter_dt *dtp)
 {
   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };
   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
@@ -336,7 +331,7 @@ next_char_utf8 (st_parameter_dt *dtp)
     if ((c & ~masks[nb-1]) == patns[nb-1])
       goto found;
   goto invalid;
-	
+
  found:
   c = (c & masks[nb-1]);
 
@@ -363,7 +358,7 @@ next_char_utf8 (st_parameter_dt *dtp)
 utf_done:
   dtp->u.p.at_eol = (c == '\n' || c == (gfc_char4_t) EOF);
   return (int) c;
-      
+
  invalid:
   generate_error (&dtp->common, LIBERROR_READ_VALUE, "Invalid UTF-8 encoding");
   return (gfc_char4_t) '?';
@@ -457,7 +452,7 @@ eat_line (st_parameter_dt *dtp)
    separator, we stop reading.  If there are more input items, we
    continue reading the separator with finish_separator() which takes
    care of the fact that we may or may not have seen a comma as part
-   of the separator. 
+   of the separator.
 
    Returns 0 for success, and non-zero error code otherwise.  */
 
@@ -521,12 +516,12 @@ eat_separator (st_parameter_dt *dtp)
       break;
 
     case '!':
+      /* Eat a namelist comment.  */
       if (dtp->u.p.namelist_mode)
-	{			/* Eat a namelist comment.  */
+	{
 	  err = eat_line (dtp);
 	  if (err)
 	    return err;
-
 	  break;
 	}
 
@@ -786,7 +781,7 @@ parse_repeat (st_parameter_dt *dtp)
 
 
 /* To read a logical we have to look ahead in the input stream to make sure
-    there is not an equal sign indicating a variable name.  To do this we use 
+    there is not an equal sign indicating a variable name.  To do this we use
     line_buffer to point to a temporary buffer, pushing characters there for
     possible later reading. */
 
@@ -852,6 +847,10 @@ read_logical (st_parameter_dt *dtp, int length)
 
       break;
 
+    case '!':
+      if (!dtp->u.p.namelist_mode)
+        goto bad_logical;
+
     CASE_SEPARATORS:
     case EOF:
       unget_char (dtp, c);
@@ -900,7 +899,7 @@ read_logical (st_parameter_dt *dtp, int length)
 	      goto logical_done;
 	    }
 	}
- 
+
       l_push_char (dtp, c);
       if (c == '=')
 	{
@@ -909,7 +908,7 @@ read_logical (st_parameter_dt *dtp, int length)
 	  dtp->u.p.line_buffer_pos = 0;
 	  return;
 	}
-      
+
     }
 
  bad_logical:
@@ -971,6 +970,10 @@ read_integer (st_parameter_dt *dtp, int length)
 	goto bad_integer;
       goto get_integer;
 
+    case '!':
+      if (!dtp->u.p.namelist_mode)
+        goto bad_integer;
+
     CASE_SEPARATORS:		/* Single null.  */
       unget_char (dtp, c);
       eat_separator (dtp);
@@ -999,6 +1002,10 @@ read_integer (st_parameter_dt *dtp, int length)
 	  push_char (dtp, '\0');
 	  goto repeat;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad_integer;
+
 	CASE_SEPARATORS:	/* Not a repeat count.  */
 	case EOF:
 	  goto done;
@@ -1021,6 +1028,10 @@ read_integer (st_parameter_dt *dtp, int length)
     CASE_DIGITS:
       break;
 
+    case '!':
+      if (!dtp->u.p.namelist_mode)
+        goto bad_integer;
+
     CASE_SEPARATORS:
       unget_char (dtp, c);
       eat_separator (dtp);
@@ -1049,6 +1060,10 @@ read_integer (st_parameter_dt *dtp, int length)
 	  push_char (dtp, c);
 	  break;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad_integer;
+
 	CASE_SEPARATORS:
 	case EOF:
 	  goto done;
@@ -1063,7 +1078,7 @@ read_integer (st_parameter_dt *dtp, int length)
   if (nml_bad_return (dtp, c))
     return;
 
-  free_saved (dtp);  
+  free_saved (dtp);
   if (c == EOF)
     {
       free_line (dtp);
@@ -1128,21 +1143,6 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))
     default:
       if (dtp->u.p.namelist_mode)
 	{
-	  if (dtp->u.p.current_unit->delim_status == DELIM_NONE)
-	    {
-	      /* No delimiters so finish reading the string now.  */
-	      int i;
-	      push_char (dtp, c);
-	      for (i = dtp->u.p.ionml->string_length; i > 1; i--)
-		{
-		  if ((c = next_char (dtp)) == EOF)
-		    goto done_eof;
-		  push_char (dtp, c);
-		}
-	      dtp->u.p.saved_type = BT_CHARACTER;
-	      free_line (dtp);
-	      return;
-	    }
 	  unget_char (dtp, c);
 	  return;
 	}
@@ -1216,10 +1216,10 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))
 	      push_char (dtp, c);
 	      break;
 	    }
-  
+
 	  /* See if we have a doubled quote character or the end of
 	     the string.  */
-  
+
 	  if ((c = next_char (dtp)) == EOF)
 	    goto done_eof;
 	  if (c == quote)
@@ -1227,21 +1227,21 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))
 	      push_char (dtp, quote);
 	      break;
 	    }
-  
+
 	  unget_char (dtp, c);
 	  goto done;
-  
+
 	CASE_SEPARATORS:
 	  if (quote == ' ')
 	    {
 	      unget_char (dtp, c);
 	      goto done;
 	    }
-  
+
 	  if (c != '\n' && c != '\r')
 	    push_char (dtp, c);
 	  break;
-  
+
 	default:
 	  push_char (dtp, c);
 	  break;
@@ -1253,13 +1253,13 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))
  done:
   c = next_char (dtp);
  done_eof:
-  if (is_separator (c) || c == '!' || c == EOF)
+  if (is_separator (c) || c == EOF)
     {
       unget_char (dtp, c);
       eat_separator (dtp);
       dtp->u.p.saved_type = BT_CHARACTER;
     }
-  else 
+  else
     {
       free_saved (dtp);
       snprintf (message, MSGLEN, "Invalid string input in item %d",
@@ -1287,7 +1287,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)
 
   if ((c = next_char (dtp)) == EOF)
     goto bad;
-    
+
   if (c == '-' || c == '+')
     {
       push_char (dtp, c);
@@ -1297,7 +1297,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)
 
   if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)
     c = '.';
-  
+
   if (!isdigit (c) && c != '.')
     {
       if (c == 'i' || c == 'I' || c == 'n' || c == 'N')
@@ -1347,6 +1347,10 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)
 	    goto bad;
 	  goto exp2;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad;
+
 	CASE_SEPARATORS:
 	case EOF:
 	  goto done;
@@ -1383,6 +1387,10 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)
 	  push_char (dtp, c);
 	  break;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad;
+
 	CASE_SEPARATORS:
 	case EOF:
 	  unget_char (dtp, c);
@@ -1443,7 +1451,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)
       push_char (dtp, 'n');
       push_char (dtp, 'a');
       push_char (dtp, 'n');
-      
+
       /* Match "NAN(alphanum)".  */
       if (c == '(')
 	{
@@ -1500,6 +1508,10 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)
     case '(':
       break;
 
+    case '!':
+      if (!dtp->u.p.namelist_mode)
+	goto bad_complex;
+
     CASE_SEPARATORS:
     case EOF:
       unget_char (dtp, c);
@@ -1543,7 +1555,7 @@ eol_3:
 
   if (parse_real (dtp, dest + size / 2, kind))
     return;
-    
+
 eol_4:
   eat_spaces (dtp);
   c = next_char (dtp);
@@ -1578,7 +1590,7 @@ eol_4:
       hit_eof (dtp);
       return;
     }
-  else if (c != '\n')   
+  else if (c != '\n')
     eat_line (dtp);
 
   snprintf (message, MSGLEN, "Bad complex value in item %d of list input",
@@ -1618,6 +1630,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
     case '-':
       goto got_sign;
 
+    case '!':
+      if (!dtp->u.p.namelist_mode)
+	goto bad_real;
+
     CASE_SEPARATORS:
       unget_char (dtp, c);		/* Single null.  */
       eat_separator (dtp);
@@ -1673,6 +1689,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
 	  push_char (dtp, '\0');
 	  goto got_repeat;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad_real;
+
 	CASE_SEPARATORS:
 	case EOF:
           if (c != '\n' && c != ',' && c != '\r' && c != ';')
@@ -1742,6 +1762,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
 	  push_char (dtp, c);
 	  break;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad_real;
+
 	CASE_SEPARATORS:
 	case EOF:
 	  goto done;
@@ -1802,6 +1826,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
 	  push_char (dtp, c);
 	  break;
 
+	case '!':
+	  if (!dtp->u.p.namelist_mode)
+	    goto bad_real;
+
 	CASE_SEPARATORS:
 	case EOF:
 	  goto done;
@@ -1899,7 +1927,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
     goto unwind;
 
   if (dtp->u.p.namelist_mode)
-    {	
+    {
       if (c == ' ' || c =='\n' || c == '\r')
 	{
 	  do
@@ -2058,7 +2086,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,
       dtp->u.p.input_complete = 0;
       dtp->u.p.repeat_count = 1;
       dtp->u.p.at_eol = 0;
-      
+
       if ((c = eat_spaces (dtp)) == EOF)
 	{
 	  err = LIBERROR_END;
@@ -2092,7 +2120,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,
 	    return err;
 	  goto set_value;
 	}
-	
+
       if (dtp->u.p.input_complete)
 	goto cleanup;
 
@@ -2231,7 +2259,7 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,
   for (elem = 0; elem < nelems; elem++)
     {
       dtp->u.p.item_count++;
-      err = list_formatted_read_scalar (dtp, type, tmp + stride*elem, 
+      err = list_formatted_read_scalar (dtp, type, tmp + stride*elem,
 					kind, size);
       if (err)
 	break;
@@ -2374,10 +2402,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
 		      || (c==')' && dim < rank -1))
 		    {
 		      if (is_char)
-		        snprintf (parse_err_msg, parse_err_msg_size, 
+		        snprintf (parse_err_msg, parse_err_msg_size,
 				  "Bad substring qualifier");
 		      else
-			snprintf (parse_err_msg, parse_err_msg_size, 
+			snprintf (parse_err_msg, parse_err_msg_size,
 				 "Bad number of index fields");
 		      goto err_ret;
 		    }
@@ -2396,7 +2424,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
 		    snprintf (parse_err_msg, parse_err_msg_size,
 			     "Bad character in substring qualifier");
 		  else
-		    snprintf (parse_err_msg, parse_err_msg_size, 
+		    snprintf (parse_err_msg, parse_err_msg_size,
 			      "Bad character in index");
 		  goto err_ret;
 		}
@@ -2405,10 +2433,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
 		  && dtp->u.p.saved_string == 0)
 		{
 		  if (is_char)
-		    snprintf (parse_err_msg, parse_err_msg_size, 
+		    snprintf (parse_err_msg, parse_err_msg_size,
 			      "Null substring qualifier");
 		  else
-		    snprintf (parse_err_msg, parse_err_msg_size, 
+		    snprintf (parse_err_msg, parse_err_msg_size,
 			      "Null index field");
 		  goto err_ret;
 		}
@@ -2417,7 +2445,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
 		  || (indx == 2 && dtp->u.p.saved_string == 0))
 		{
 		  if (is_char)
-		    snprintf (parse_err_msg, parse_err_msg_size, 
+		    snprintf (parse_err_msg, parse_err_msg_size,
 			      "Bad substring qualifier");
 		  else
 		    snprintf (parse_err_msg, parse_err_msg_size,
@@ -2506,10 +2534,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
 	   || (ls[dim].end < GFC_DIMENSION_LBOUND(ad[dim])))
 	{
 	  if (is_char)
-	    snprintf (parse_err_msg, parse_err_msg_size, 
+	    snprintf (parse_err_msg, parse_err_msg_size,
 		      "Substring out of range");
 	  else
-	    snprintf (parse_err_msg, parse_err_msg_size, 
+	    snprintf (parse_err_msg, parse_err_msg_size,
 		      "Index %d out of range", dim + 1);
 	  goto err_ret;
 	}
@@ -2517,7 +2545,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,
       if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)
 	  || (ls[dim].step == 0))
 	{
-	  snprintf (parse_err_msg, parse_err_msg_size, 
+	  snprintf (parse_err_msg, parse_err_msg_size,
 		   "Bad range in index %d", dim + 1);
 	  goto err_ret;
 	}
@@ -2560,7 +2588,7 @@ static bool
 strcmp_extended_type (char *p, char *q)
 {
   char *r, *s;
-  
+
   for (r = p, s = q; *r && *s; r++, s++)
     {
       if (*r != *s)
@@ -3068,7 +3096,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,
 	goto nml_err_ret;
       if (c != '?')
 	{
-	  snprintf (nml_err_msg, nml_err_msg_size, 
+	  snprintf (nml_err_msg, nml_err_msg_size,
 		    "namelist read: misplaced = sign");
 	  goto nml_err_ret;
 	}
@@ -3084,7 +3112,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,
       nml_match_name (dtp, "end", 3);
       if (dtp->u.p.nml_read_error)
 	{
-	  snprintf (nml_err_msg, nml_err_msg_size, 
+	  snprintf (nml_err_msg, nml_err_msg_size,
 		    "namelist not terminated with / or &end");
 	  goto nml_err_ret;
 	}
@@ -3379,7 +3407,7 @@ namelist_read (st_parameter_dt *dtp)
   dtp->u.p.namelist_mode = 1;
   dtp->u.p.input_complete = 0;
   dtp->u.p.expanded_read = 0;
-  
+
   /* Set the next_char and push_char worker functions.  */
   set_workers (dtp);
 
@@ -3425,7 +3453,7 @@ find_nml_name:
   if (dtp->u.p.nml_read_error)
     goto find_nml_name;
 
-  /* A trailing space is required, we give a little latitude here, 10.9.1.  */ 
+  /* A trailing space is required, we give a little latitude here, 10.9.1.  */
   c = next_char (dtp);
   if (!is_separator(c) && c != '!')
     {
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index 1bbe016..b983c78 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -938,7 +938,7 @@ snprintf (buffer, size, "%+-#.*Le", (prec), (val))
 
 #if defined(GFC_REAL_16_IS_FLOAT128)
 #define DTOA2Q(prec,val)							\
-__qmath_(quadmath_snprintf) (buffer, size, "%+-#.*Qe", (prec), (val))
+quadmath_snprintf (buffer, size, "%+-#.*Qe", (prec), (val))
 #endif
 
 #define FDTOA(suff,prec,val) TOKENPASTE(FDTOA2,suff)(prec,val)
@@ -953,7 +953,7 @@ snprintf (buffer, size, "%+-#.*Lf", (prec), (val))
 
 #if defined(GFC_REAL_16_IS_FLOAT128)
 #define FDTOA2Q(prec,val)			       \
-__qmath_(quadmath_snprintf) (buffer, size, "%+-#.*Qf", \
+quadmath_snprintf (buffer, size, "%+-#.*Qf", \
 			     (prec), (val))
 #endif
 
diff --git a/libgo/mksysinfo.sh b/libgo/mksysinfo.sh
index c68dc35..9062c2c 100755
--- a/libgo/mksysinfo.sh
+++ b/libgo/mksysinfo.sh
@@ -183,6 +183,12 @@ enum {
 #ifdef TIOCSCTTY
   TIOCSCTTY_val = TIOCSCTTY,
 #endif
+#ifdef TIOCGPGRP
+  TIOCGPGRP_val = TIOCGPGRP,
+#endif
+#ifdef TIOCSPGRP
+  TIOCSPGRP_val = TIOCSPGRP,
+#endif
 #ifdef TIOCGPTN
   TIOCGPTN_val = TIOCGPTN,
 #endif
@@ -261,6 +267,9 @@ enum {
 #ifdef TUNGETFILTER
   TUNGETFILTER_val = TUNGETFILTER,
 #endif
+#ifdef NLA_HDRLEN
+  NLA_HDRLEN_val = NLA_HDRLEN,
+#endif
 
 };
 EOF
@@ -531,7 +540,7 @@ upcase_fields () {
 # GNU/Linux specific; it should do no harm if there is no
 # _user_regs_struct.
 regs=`grep '^type _user_regs_struct struct' gen-sysinfo.go || true`
-if test "$regs" == ""; then
+if test "$regs" = ""; then
   # s390
   regs=`grep '^type __user_regs_struct struct' gen-sysinfo.go || true`
   if test "$regs" != ""; then
@@ -875,11 +884,13 @@ grep '^type _addrinfo ' gen-sysinfo.go | \
       -e 's/ ai_/ Ai_/g' \
     >> ${OUT}
 
-# The addrinfo flags and errors.
+# The addrinfo and nameinfo flags and errors.
 grep '^const _AI_' gen-sysinfo.go | \
   sed -e 's/^\(const \)_\(AI_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
 grep '^const _EAI_' gen-sysinfo.go | \
   sed -e 's/^\(const \)_\(EAI_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+grep '^const _NI_' gen-sysinfo.go | \
+  sed -e 's/^\(const \)_\(NI_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
 
 # The passwd struct.
 grep '^type _passwd ' gen-sysinfo.go | \
@@ -915,6 +926,16 @@ if ! grep '^const TIOCSCTTY' ${OUT} >/dev/null 2>&1; then
     echo 'const TIOCSCTTY = _TIOCSCTTY_val' >> ${OUT}
   fi
 fi
+if ! grep '^const TIOCGPGRP' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TIOCGPGRP_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TIOCGPGRP = _TIOCGPGRP_val' >> ${OUT}
+  fi
+fi
+if ! grep '^const TIOCSPGRP' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TIOCSPGRP_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TIOCSPGRP = _TIOCSPGRP_val' >> ${OUT}
+  fi
+fi
 if ! grep '^const TIOCGPTN' ${OUT} >/dev/null 2>&1; then
   if grep '^const _TIOCGPTN_val' ${OUT} >/dev/null 2>&1; then
     echo 'const TIOCGPTN = _TIOCGPTN_val' >> ${OUT}
@@ -1057,8 +1078,6 @@ if ! grep '^const TUNGETFILTER' ${OUT} >/dev/null 2>&1; then
   fi
 fi
 
-
-
 # The ioctl flags for terminal control
 grep '^const _TC[GS]ET' gen-sysinfo.go | grep -v _val | \
     sed -e 's/^\(const \)_\(TC[GS]ET[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
@@ -1404,9 +1423,15 @@ grep '^type _rtnexthop ' gen-sysinfo.go | \
 # The GNU/Linux netlink flags.
 grep '^const _NETLINK_' gen-sysinfo.go | \
   sed -e 's/^\(const \)_\(NETLINK_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
-grep '^const _NLA_' gen-sysinfo.go | \
+grep '^const _NLA_' gen-sysinfo.go | grep -v '_val =' | \
   sed -e 's/^\(const \)_\(NLA_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
 
+if ! grep '^const NLA_HDRLEN' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _NLA_HDRLEN_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const NLA_HDRLEN = _NLA_HDRLEN_val' >> ${OUT}
+  fi
+fi
+
 # The GNU/Linux packet socket flags.
 grep '^const _PACKET_' gen-sysinfo.go | \
   sed -e 's/^\(const \)_\(PACKET_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
@@ -1426,6 +1451,11 @@ grep '^type _inotify_event ' gen-sysinfo.go | \
 # The GNU/Linux CLONE flags.
 grep '^const _CLONE_' gen-sysinfo.go | \
   sed -e 's/^\(const \)_\(CLONE_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+# We need some CLONE constants that are not defined in older versions
+# of glibc.
+if ! grep '^const CLONE_NEWUSER ' ${OUT} > /dev/null 2>&1; then
+  echo "const CLONE_NEWUSER = 0x10000000" >> ${OUT}
+fi
 
 # Struct sizes.
 set cmsghdr Cmsghdr ip_mreq IPMreq ip_mreqn IPMreqn ipv6_mreq IPv6Mreq \
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index d04cd8e..3da9fa1 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,29 @@
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR lto/67709
+	2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	* testsuite/libgomp.fortran/declare-simd-4.f90: New test.
+
+2016-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/68960
+	* testsuite/libgomp.c/pr68960.c: New test.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* testsuite/libgomp.c/pr69110.c: New test.
+
+2016-01-14  Dominique d'Humieres <dominiq@lps.ens.fr>
+
+	PR fortran/66680
+	* testsuite/libgomp.fortran/pr66680.f90: New test.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libgomp/testsuite/libgomp.c/pr68960.c b/libgomp/testsuite/libgomp.c/pr68960.c
new file mode 100644
index 0000000..2accc6a
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr68960.c
@@ -0,0 +1,25 @@
+/* PR middle-end/68960 */
+/* { dg-do run } */
+
+int
+main ()
+{
+  int temp[257] __attribute__ ((aligned (256))) = { 0 };
+  #pragma omp parallel private (temp) num_threads (2)
+  {
+    int *p = &temp[0];
+    asm volatile ("" : "+g" (p));
+    if (((__UINTPTR_TYPE__) p) & 255)
+      __builtin_abort ();
+  }
+  #pragma omp parallel num_threads (2)
+  #pragma omp single
+  #pragma omp task firstprivate (temp)
+  {
+    int *p = &temp[0];
+    asm volatile ("" : "+g" (p));
+    if (((__UINTPTR_TYPE__) p) & 255)
+      __builtin_abort ();
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/pr69110.c b/libgomp/testsuite/libgomp.c/pr69110.c
new file mode 100644
index 0000000..0d9e5ca
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr69110.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-ftree-parallelize-loops=2 -O1 -fno-tree-loop-im" } */
+
+#define N 1000
+
+unsigned int i = 0;
+
+static void __attribute__((noinline, noclone))
+foo (void)
+{
+  unsigned int z;
+  for (z = 0; z < N; ++z)
+    ++i;
+}
+
+extern void abort (void);
+
+int
+main (void)
+{
+  foo ();
+  if (i != N)
+    abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.fortran/declare-simd-4.f90 b/libgomp/testsuite/libgomp.fortran/declare-simd-4.f90
new file mode 100644
index 0000000..bfdf9cf
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/declare-simd-4.f90
@@ -0,0 +1,7 @@
+! { dg-do run { target { vect_simd_clones && lto } } }
+! { dg-options "-fno-inline -flto -fno-use-linker-plugin" }
+! { dg-additional-sources declare-simd-3.f90 }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+include 'declare-simd-2.f90'
diff --git a/libgomp/testsuite/libgomp.fortran/pr66680.f90 b/libgomp/testsuite/libgomp.fortran/pr66680.f90
new file mode 100644
index 0000000..b068cb3
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/pr66680.f90
@@ -0,0 +1,46 @@
+! { dg-do run }
+! PR 66680: ICE with openmp, a loop and a type bound procedure
+! Contributed by Miha Polajnar <polajnar.miha@gmail.com>
+!
+module m1 
+  implicit none
+  integer :: n = 5
+  type :: t1
+  contains
+    procedure :: s => s1
+  end type t1
+contains
+  pure subroutine s1(self,p,esta)
+    class(t1), intent(in) :: self
+    integer, optional, intent(in) :: p
+    integer, intent(out) :: esta
+  end subroutine s1 
+end module m1
+module m2
+  use m1, only: t1, n
+  implicit none
+  type(t1), allocatable :: test(:)
+contains
+  pure subroutine s2(test1,esta)
+    type(t1), intent(in) :: test1
+    integer, intent(out) :: esta
+    integer :: p, i
+    do p = 1, n
+      i = p ! using i instead of p works
+      call test1%s(p=p,esta=esta)
+      if ( esta /= 0 ) return
+    end do
+  end subroutine s2
+  subroutine s3()
+    integer :: i, esta
+    !$omp parallel do  &
+    !$omp private(i)
+    do i = 1, n
+        call s2(test(i),esta)
+    end do
+    !$omp end parallel do
+  end subroutine s3
+end module m2
+program main
+  implicit none
+end program main
diff --git a/libjava/ChangeLog b/libjava/ChangeLog
index d413bfb..3104186 100644
--- a/libjava/ChangeLog
+++ b/libjava/ChangeLog
@@ -1,3 +1,8 @@
+2016-01-03  Matthias Klose  <doko@ubuntu.com>
+
+	* include/jvm.h (GCJ_CXX_ABI_VERSION): Freeze the ABI for releases
+	made from the gcc-5-branch.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libjava/include/jvm.h b/libjava/include/jvm.h
index ec74f29..bd39a94 100644
--- a/libjava/include/jvm.h
+++ b/libjava/include/jvm.h
@@ -686,7 +686,10 @@ extern void _Jv_RegisterBootstrapPackages ();
 					  loader.  */
 
 // These are used to find ABI versions we recognize.
-#define GCJ_CXX_ABI_VERSION (__GNUC__ * 100000 + __GNUC_MINOR__ * 1000)
+// GCC 5 changed the versioning schema; the __GNUC_MINOR__ is not anymore
+// a part of a GCC release series.  Freeze the ABI on the gcc-5-branch with
+// the value of the GCC 5.3 release.
+#define GCJ_CXX_ABI_VERSION (__GNUC__ * 100000 + 3 * 1000)
 
 // This is the old-style BC version ID used by GCJ 4.0.0.
 #define OLD_GCJ_40_BC_ABI_VERSION (4 * 10000 + 0 * 10 + 5)
diff --git a/libmpx/ChangeLog b/libmpx/ChangeLog
index 4f8f401..89d88cc 100644
--- a/libmpx/ChangeLog
+++ b/libmpx/ChangeLog
@@ -1,3 +1,11 @@
+2016-01-20  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	Backport from mainline r232619.
+	2016-01-20  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* mpxrt/mpxrt.c (handler): Fix verbosity for
+	error message.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libmpx/mpxrt/mpxrt.c b/libmpx/mpxrt/mpxrt.c
index 0eff87e..64ee260 100644
--- a/libmpx/mpxrt/mpxrt.c
+++ b/libmpx/mpxrt/mpxrt.c
@@ -296,7 +296,7 @@ handler (int sig __attribute__ ((unused)),
       __mpxrt_write_uint (VERB_ERROR, trapno, 10);
       __mpxrt_write (VERB_ERROR, ", ip = 0x");
       __mpxrt_write_uint (VERB_ERROR, ip, 16);
-      __mpxrt_write (VERB_BR, "\n");
+      __mpxrt_write (VERB_ERROR, "\n");
       exit (255);
     }
   else
@@ -305,7 +305,7 @@ handler (int sig __attribute__ ((unused)),
       __mpxrt_write_uint (VERB_ERROR, trapno, 10);
       __mpxrt_write (VERB_ERROR, "! at 0x");
       __mpxrt_write_uint (VERB_ERROR, ip, 16);
-      __mpxrt_write (VERB_BR, "\n");
+      __mpxrt_write (VERB_ERROR, "\n");
       exit (255);
     }
 }
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index 8be7f44..abd1d21 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,10 @@
+2016-01-13  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>
+
+	PR sanitizer/69147
+	* asan/asan_mac.cc: Cherry pick upstream r241487.
+	* sanitizer_common/sanitizer_mac.cc: Cherry pick upstream r224315.
+	* sanitizer_common/sanitizer_mac.h: Likewise.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libsanitizer/asan/asan_mac.cc b/libsanitizer/asan/asan_mac.cc
index 70823bd..22f3f70 100644
--- a/libsanitizer/asan/asan_mac.cc
+++ b/libsanitizer/asan/asan_mac.cc
@@ -99,6 +99,23 @@ void LeakyResetEnv(const char *name, const char *name_value) {
   }
 }
 
+bool DyldNeedsEnvVariable() {
+// If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if
+// DYLD_INSERT_LIBRARIES is not set.
+
+#if SANITIZER_IOSSIM
+  // GetMacosVersion will not work for the simulator, whose kernel version
+  // is tied to the host. Use a weak linking hack for the simulator.
+  // This API was introduced in the same version of the OS as the dyld
+  // optimization.
+
+  // Check for presence of a symbol that is available on OS X 10.11+, iOS 9.0+.
+  return (dlsym(RTLD_NEXT, "mach_memory_info") == nullptr);
+#else
+  return (GetMacosVersion() <= MACOS_VERSION_YOSEMITE);
+#endif
+}
+
 void MaybeReexec() {
   if (!flags()->allow_reexec) return;
   // Make sure the dynamic ASan runtime library is preloaded so that the
@@ -111,8 +128,9 @@ void MaybeReexec() {
   uptr old_env_len = dyld_insert_libraries ?
       internal_strlen(dyld_insert_libraries) : 0;
   uptr fname_len = internal_strlen(info.dli_fname);
-  if (!dyld_insert_libraries ||
-      !REAL(strstr)(dyld_insert_libraries, info.dli_fname)) {
+  bool lib_is_in_env =
+      dyld_insert_libraries && REAL(strstr)(dyld_insert_libraries, info.dli_fname);
+  if (DyldNeedsEnvVariable() && !lib_is_in_env) {
     // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime
     // library.
     char program_name[1024];
@@ -141,6 +159,10 @@ void MaybeReexec() {
     VReport(1, "Set ASAN_OPTIONS=allow_reexec=0 to disable this.\n");
     execv(program_name, *_NSGetArgv());
   } else {
+
+    if (!lib_is_in_env)
+      return;
+
     // DYLD_INSERT_LIBRARIES is set and contains the runtime library.
     if (old_env_len == fname_len) {
       // It's just the runtime library name - fine to unset the variable.
diff --git a/libsanitizer/sanitizer_common/sanitizer_mac.cc b/libsanitizer/sanitizer_common/sanitizer_mac.cc
index 17b931c..b53ffba 100644
--- a/libsanitizer/sanitizer_common/sanitizer_mac.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_mac.cc
@@ -296,7 +296,11 @@ MacosVersion GetMacosVersionInternal() {
         case '2': return MACOS_VERSION_MOUNTAIN_LION;
         case '3': return MACOS_VERSION_MAVERICKS;
         case '4': return MACOS_VERSION_YOSEMITE;
-        default: return MACOS_VERSION_UNKNOWN;
+        default:
+          if (IsDigit(version[1]))
+            return MACOS_VERSION_UNKNOWN_NEWER;
+          else
+            return MACOS_VERSION_UNKNOWN;
       }
     }
     default: return MACOS_VERSION_UNKNOWN;
diff --git a/libsanitizer/sanitizer_common/sanitizer_mac.h b/libsanitizer/sanitizer_common/sanitizer_mac.h
index 47739f7..46a7b44 100644
--- a/libsanitizer/sanitizer_common/sanitizer_mac.h
+++ b/libsanitizer/sanitizer_common/sanitizer_mac.h
@@ -25,6 +25,7 @@ enum MacosVersion {
   MACOS_VERSION_MOUNTAIN_LION,
   MACOS_VERSION_MAVERICKS,
   MACOS_VERSION_YOSEMITE,
+  MACOS_VERSION_UNKNOWN_NEWER
 };
 
 MacosVersion GetMacosVersion();
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 67bd0e7..dbbd160 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,148 @@
+2016-02-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69939
+	* include/experimental/tuple (__apply_impl): Qualify get and forward.
+
+2016-02-16  Tim Shen  <timshen@google.com>
+
+	Backport from mainline
+	2016-02-16  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/69794
+	* include/bits/regex_scanner.h: Add different special character
+	sets for grep and egrep regex.
+	* include/bits/regex_scanner.tcc: Use _M_spec_char more uniformly.
+	* testsuite/28_regex/regression.cc: Add new testcase.
+
+2016-02-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60976
+	* include/bits/alloc_traits.h (allocator_traits<allocator<_Tp>>):
+	Define partial specialization.
+	* testsuite/20_util/shared_ptr/cons/58659.cc: Add construct and
+	destroy members to std::allocator explicit specialization.
+
+2016-02-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69116
+	* include/bits/valarray_before.h (__fun, __fun_with_valarray): Only
+	define result_type for types which can be safely used with valarrays.
+	* testsuite/26_numerics/valarray/69116.cc: New.
+
+2016-01-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60637
+	* include/c_global/cmath (signbit) [__cplusplus < 201103L]: Use
+	__builtin_signbitf or __builtin_signbitl as appropriate.
+	* testsuite/26_numerics/headers/cmath/60637.cc: New.
+
+2016-01-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	* config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt: Add
+	__int128 symbols.
+
+2016-01-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69092
+	* include/bits/basic_string.h (basic_string::_S_copy_chars<_Iterator>):
+	Remove _GLIBCXX_NOEXCEPT.
+	testsuite/21_strings/basic_string/cons/char/69092.cc: New.
+
+	PR libstdc++/68995
+	* include/std/functional (_Function_handler::_M_invoke): Qualify
+	__callable_functor.
+	* testsuite/20_util/function/68995.cc: New.
+
+	PR libstdc++/69005
+	PR libstdc++/69222
+	* include/std/functional (function::_Invoke): Remove, use result_of.
+	(function::_Callable): Replace alias template with class template
+	and use partial specialization instead of _NotSelf alias template.
+	(function(_Functor)): Add "not self" constraint so that _Callable is
+	not used while type is incomplete.
+	* testsuite/20_util/function/69222.cc: New.
+
+2015-12-27  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	* include/bits/c++0x_warning.h Remove experimental language.
+
+2015-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/68912
+	* include/std/functional (_Bind::operator()): Use lvalue functor to
+	deduce return type.
+	* testsuite/20_util/bind/68912.cc: New.
+
+	PR libstdc++/68921
+	* src/c++11/futex.cc
+	(__atomic_futex_unsigned_base::_M_futex_wait_until): Use null pointer
+	as timeout argument.
+
+2015-12-15  Tim Shen  <timshen@google.com>
+
+	Backport from mainline
+	2015-12-15  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/68863
+	* include/bits/regex_executor.tcc (_Executor::_M_lookahead):
+	Copy the captured content for lookahead, so that the backreferences
+	inside can refer to them.
+	* testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc:
+	New testcase.
+
+2015-12-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/doxygen/user.cfg.in: Use EXTENSION_MAPPING tag. Add new headers
+	to INPUT. Remove obsolete XML_SCHEMA and XML_DTD tags. Update
+	PREDEFINED macros. Set BRIEF_MEMBER_DESC for man-pages.
+	* include/backward/strstream: Correct @file comment.
+	* include/bits/forward_list.h: Improve Doxygen comments.
+	* include/bits/locale_facets_nonio.h: Likewise.
+	* include/debug/vector (_Safe_vector): Add @brief section to comment.
+	* include/experimental/fs_fwd.h: Correct @file comment.
+	* include/experimental/fs_ops.h: Likewise.
+	* include/experimental/string_view.tcc: Likewise.
+	* include/experimental/optional: Document experimental status.
+	* include/experimental/string_view: Correct @file comment.
+	* include/ext/pb_ds/detail/bin_search_tree_/traits.hpp: Reduce
+	whitespace to avoid Doxygen bug.
+	* include/std/bitset: Remove redundant @class Doxygen command. Add
+	parentheses to avoid Doxygen bug.
+	* include/std/mutex: Improve Doxygen comments.
+	* include/tr2/dynamic_bitset: Add missing @param documentation.
+	* scripts/run_doxygen: Rename man pages for std::experimental types.
+
+2015-12-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/abi.xml: Backport documentation improvements from
+	mainline.
+	* doc/xml/manual/configure.xml: Likewise.
+	* doc/xml/manual/diagnostics.xml: Likewise.
+	* doc/xml/manual/extensions.xml: Likewise.
+	* doc/xml/manual/status_cxx2011.xml: Likewise.
+	* doc/xml/manual/status_cxx2014.xml: Likewise.
+	* doc/xml/manual/using.xml: Likewise.
+	* doc/html/*: Regenerate.
+
+2015-12-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/56383
+	* testsuite/20_util/enable_shared_from_this/56383.cc: New.
+	* include/bits/shared_ptr_base.h (__enable_shared_from_this): Make
+	friend declaration match previous declaration of
+	__enable_shared_from_this_helper.
+	* include/bits/shared_ptr.h (enable_shared_from_this): Likewise.
+
+2015-12-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_path.h (path::_Cmpt): Move definition
+	after __is_encoded_char explicit specializations.
+
+2015-12-04  Jason Merrill  <jason@redhat.com>
+
+	* include/bits/c++config: Fix abi_tag in special modes.
+
 2015-12-04  Release Manager
 
 	* GCC 5.3.0 released.
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
index 67b1f3e..6bc4a4b 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
@@ -4618,6 +4618,8 @@ OBJECT:2:_ZTSi@@CXXABI_1.3
 OBJECT:2:_ZTSj@@CXXABI_1.3
 OBJECT:2:_ZTSl@@CXXABI_1.3
 OBJECT:2:_ZTSm@@CXXABI_1.3
+OBJECT:2:_ZTSn@@CXXABI_1.3.9
+OBJECT:2:_ZTSo@@CXXABI_1.3.9
 OBJECT:2:_ZTSs@@CXXABI_1.3
 OBJECT:2:_ZTSt@@CXXABI_1.3
 OBJECT:2:_ZTSv@@CXXABI_1.3
@@ -4711,6 +4713,8 @@ OBJECT:3:_ZTSPi@@CXXABI_1.3
 OBJECT:3:_ZTSPj@@CXXABI_1.3
 OBJECT:3:_ZTSPl@@CXXABI_1.3
 OBJECT:3:_ZTSPm@@CXXABI_1.3
+OBJECT:3:_ZTSPn@@CXXABI_1.3.9
+OBJECT:3:_ZTSPo@@CXXABI_1.3.9
 OBJECT:3:_ZTSPs@@CXXABI_1.3
 OBJECT:3:_ZTSPt@@CXXABI_1.3
 OBJECT:3:_ZTSPv@@CXXABI_1.3
@@ -5116,6 +5120,8 @@ OBJECT:4:_ZTSPKi@@CXXABI_1.3
 OBJECT:4:_ZTSPKj@@CXXABI_1.3
 OBJECT:4:_ZTSPKl@@CXXABI_1.3
 OBJECT:4:_ZTSPKm@@CXXABI_1.3
+OBJECT:4:_ZTSPKn@@CXXABI_1.3.9
+OBJECT:4:_ZTSPKo@@CXXABI_1.3.9
 OBJECT:4:_ZTSPKs@@CXXABI_1.3
 OBJECT:4:_ZTSPKt@@CXXABI_1.3
 OBJECT:4:_ZTSPKv@@CXXABI_1.3
diff --git a/libstdc++-v3/doc/doxygen/user.cfg.in b/libstdc++-v3/doc/doxygen/user.cfg.in
index ff2db48..ccd5fbb 100644
--- a/libstdc++-v3/doc/doxygen/user.cfg.in
+++ b/libstdc++-v3/doc/doxygen/user.cfg.in
@@ -272,7 +272,7 @@ OPTIMIZE_OUTPUT_VHDL   = NO
 # Note that for custom extensions you also need to set FILE_PATTERNS otherwise
 # the files are not read by doxygen.
 
-EXTENSION_MAPPING      =
+EXTENSION_MAPPING      = no_extension=C++ .h=C++ .tcc=C++ .hpp=C++
 
 # If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
 # according to the Markdown format, which allows for more readable
@@ -757,6 +757,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          include/bitset \
                          include/chrono \
                          include/complex \
+                         include/codecvt \
                          include/condition_variable \
                          include/deque \
                          include/forward_list \
@@ -812,6 +813,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          include/cmath \
                          include/csetjmp \
                          include/csignal \
+                         include/cstdalign \
                          include/cstdarg \
                          include/cstdbool \
                          include/cstddef \
@@ -831,6 +833,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          include/backward/hash_set \
                          include/backward/strstream \
                          include/debug \
+                         include/debug/array \
                          include/debug/bitset \
                          include/debug/deque \
                          include/debug/forward_list \
@@ -853,6 +856,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          include/profile/unordered_set \
                          include/profile/vector \
                          include/ext/algorithm \
+                         include/ext/cmath \
                          include/ext/functional \
                          include/ext/iterator \
                          include/ext/memory \
@@ -886,9 +890,18 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          include/tr2/ratio \
                          include/tr2/type_traits \
                          include/decimal/decimal \
+                         include/experimental \
+                         include/experimental/algorithm \
                          include/experimental/any \
+                         include/experimental/chrono \
+                         include/experimental/filesystem \
+                         include/experimental/functional \
                          include/experimental/optional \
+                         include/experimental/ratio \
                          include/experimental/string_view \
+                         include/experimental/system_error \
+                         include/experimental/tuple \
+                         include/experimental/type_traits \
                          include/ext \
                          include/ext/pb_ds \
                          include/ext/pb_ds/detail \
@@ -1965,18 +1978,6 @@ GENERATE_XML           = @do_xml@
 
 XML_OUTPUT             = xml
 
-# The XML_SCHEMA tag can be used to specify a XML schema, which can be used by a
-# validating XML parser to check the syntax of the XML files.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_SCHEMA             =
-
-# The XML_DTD tag can be used to specify a XML DTD, which can be used by a
-# validating XML parser to check the syntax of the XML files.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_DTD                =
-
 # If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
 # listings (including syntax highlighting and cross-referencing information) to
 # the XML output. Note that enabling this will significantly increase the size
@@ -2111,9 +2112,10 @@ INCLUDE_FILE_PATTERNS  =
 # recursively expanded use the := operator instead of the = operator.
 # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
 
-PREDEFINED             = __cplusplus=201103L \
+PREDEFINED             = __cplusplus=201402L \
                          __GTHREADS \
                          _GLIBCXX_HAS_GTHREADS \
+                         _GLIBCXX_HAVE_TLS \
                          _GLIBCXX_INCLUDE_AS_CXX11 \
                          "_GLIBCXX_PURE= " \
                          "_GLIBCXX_CONST= " \
@@ -2144,7 +2146,7 @@ PREDEFINED             = __cplusplus=201103L \
                          _GLIBCXX_USE_NANOSLEEP \
                          __cpp_exceptions \
                          __cpp_rtti \
-                         ATOMIC_INT_LOCK_FREE \
+                         ATOMIC_INT_LOCK_FREE=2 \
                          PB_DS_DATA_TRUE_INDICATOR \
                          PB_DS_STATIC_ASSERT=// \
                          "_GLIBCXX_BEGIN_NAMESPACE_ALGO= " \
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
index bd2c58e..d2150e5 100644
--- a/libstdc++-v3/doc/html/index.html
+++ b/libstdc++-v3/doc/html/index.html
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
diff --git a/libstdc++-v3/doc/html/manual/abi.html b/libstdc++-v3/doc/html/manual/abi.html
index ec786b9..e7de3a5 100644
--- a/libstdc++-v3/doc/html/manual/abi.html
+++ b/libstdc++-v3/doc/html/manual/abi.html
@@ -38,7 +38,7 @@
   documented
 <a class="link" href="configure.html" title="Configure">here</a>.
 </p><p> Putting all of these ideas together results in the C++ Standard
-library ABI, which is the compilation of a given library API by a
+Library ABI, which is the compilation of a given library API by a
 given compiler ABI. In a nutshell:
 </p><p>
   <span class="quote">“<span class="quote">
diff --git a/libstdc++-v3/doc/html/manual/concept_checking.html b/libstdc++-v3/doc/html/manual/concept_checking.html
index 883eb5a..df7f22f 100644
--- a/libstdc++-v3/doc/html/manual/concept_checking.html
+++ b/libstdc++-v3/doc/html/manual/concept_checking.html
@@ -35,8 +35,9 @@
      <code class="literal">-D_GLIBCXX_CONCEPT_CHECKS</code>.
  </p><p>
    Please note that the checks are based on the requirements in the original
-   C++ standard, some of which have changed in the new C++11 revision.
-   Additionally, some correct code might be rejected by the concept checks,
+   C++ standard, many of which were relaxed in the C++11 standard and so valid
+   C++11 code may be incorrectly rejected by the concept checks.  Additionally,
+   some correct C++03 code might be rejected by the concept checks,
    for example template argument types may need to be complete when used in
    a template definition, rather than at the point of instantiation.
    There are no plans to address these shortcomings.
diff --git a/libstdc++-v3/doc/html/manual/configure.html b/libstdc++-v3/doc/html/manual/configure.html
index 96f40a6..626534c 100644
--- a/libstdc++-v3/doc/html/manual/configure.html
+++ b/libstdc++-v3/doc/html/manual/configure.html
@@ -174,10 +174,12 @@
 	Mostly useful together with shared memory allocators, see PR
 	libstdc++/16612 for details.
      </p></dd><dt><span class="term"><code class="code">--enable-concept-checks</code></span></dt><dd><p>This turns on additional compile-time checks for instantiated
-	library templates, in the form of specialized templates,
-	<a class="link" href="concept_checking.html" title="Concept Checking">described here</a>.  They
+	library templates, in the form of specialized templates described in
+        the <a class="link" href="concept_checking.html" title="Concept Checking">Concept
+        Checking</a> section.  They
 	can help users discover when they break the rules of the STL, before
-	their programs run.
+	their programs run. These checks are based on C++03 rules and some of
+	them are not compatible with correct C++11 code.
      </p></dd><dt><span class="term"><code class="code">--enable-symvers[=style]</code></span></dt><dd><p>In 3.1 and later, tries to turn on symbol versioning in the
 	shared library (if a shared library has been
 	requested). Values for 'style' that are currently supported
@@ -236,9 +238,10 @@
    </p></dd><dt><span class="term"><code class="code">--with-default-libstdcxx-abi=</code><em class="replaceable"><code>OPTION</code></em></span></dt><dd><p>
      Set the default value for the <span class="symbol">_GLIBCXX_USE_CXX11_ABI</span>
      macro (see <a class="xref" href="using_macros.html" title="Macros">Macros</a>).
-     The default is <code class="option">OPTION=c++11</code> which sets the macro to
+     The default is <code class="option">OPTION=new</code> which sets the macro to
      <code class="literal">1</code>,
-     use <code class="option">OPTION=c++98</code> to set it to <code class="literal">0</code>.
+     use <code class="option">OPTION=gcc4-compatible</code> to set it to
+     <code class="literal">0</code>.
      This option does not change the library ABI.
    </p></dd><dt><span class="term"><code class="code">--enable-vtable-verify</code>[default]</span></dt><dd><p>Use <code class="code">-fvtable-verify=std</code> to compile the C++
     runtime with instrumentation for vtable verification. All virtual
@@ -247,4 +250,8 @@
     <code class="classname">iostream</code>, and others.  Disabling means that
     the C++ runtime is compiled without support for vtable
     verification. By default, this option is off.
-     </p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="setup.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="setup.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="make.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Setup </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Make</td></tr></table></div></body></html>
\ No newline at end of file
+     </p></dd><dt><span class="term"><code class="code">--enable-libstdcxx-filesystem-ts</code>[default]</span></dt><dd><p>Build <code class="filename">libstdc++fs.a</code> as well
+      as the usual libstdc++ and libsupc++ libraries. This is enabled by
+      default on select POSIX targets where it is known to work and disabled
+      otherwise.
+    </p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="setup.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="setup.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="make.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Setup </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Make</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/ext_compile_checks.html b/libstdc++-v3/doc/html/manual/ext_compile_checks.html
index da47233..227bd25 100644
--- a/libstdc++-v3/doc/html/manual/ext_compile_checks.html
+++ b/libstdc++-v3/doc/html/manual/ext_compile_checks.html
@@ -29,7 +29,8 @@
       They can be enabled at configure time with
       <a class="link" href="configure.html" title="Configure"><code class="literal">--enable-concept-checks</code></a>.
       You can enable them on a per-translation-unit basis with
-      <code class="code">#define _GLIBCXX_CONCEPT_CHECKS</code> for GCC 3.4 and higher
+      <a class="link" href="using_macros.html" title="Macros"><code class="code">#define
+      _GLIBCXX_CONCEPT_CHECKS</code></a> for GCC 3.4 and higher
       (or with <code class="code">#define _GLIBCPP_CONCEPT_CHECKS</code> for versions
       3.1, 3.2 and 3.3).
    </p><p>Please note that the concept checks only validate the requirements
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index b6f34fa..3b13da4 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -4,7 +4,7 @@
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
diff --git a/libstdc++-v3/doc/html/manual/intro.html b/libstdc++-v3/doc/html/manual/intro.html
index ae8ce8f..0c2739b 100644
--- a/libstdc++-v3/doc/html/manual/intro.html
+++ b/libstdc++-v3/doc/html/manual/intro.html
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>Part I. 
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index 40e3323..f9e240e 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -148,8 +148,8 @@ This table is based on the table of contents of ISO/IEC
 JTC1 SC22 WG21 Doc No: N3290 Date: 2011-04-11
 Final Draft International Standard, Standard for Programming Language C++
 </p><p>
-In this implementation <code class="literal">-std=gnu++11</code> or
-<code class="literal">-std=c++11</code> flags must be used to enable language
+In this implementation the <code class="literal">-std=gnu++11</code> or
+<code class="literal">-std=c++11</code> flag must be used to enable language
 and library
 features. See <a class="link" href="using.html#manual.intro.using.flags" title="Command Options">dialect</a>
 options. The pre-defined symbol
@@ -171,10 +171,8 @@ particular release.
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>General utilities</em></span>
       </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.2</td><td align="left">Swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.3</td><td align="left"><code class="code">forward</code> and <code class="code">move</code> helpers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.4</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.2</td><td align="left">Class template <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.3</td><td align="left">Specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.4</td><td align="left">Tuple-like access to <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.5</td><td align="left">Piecewise construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2</td><td align="left">Class template <code class="code">tuple</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2.1</td><td align="left">Construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.2</td><td align="left">Assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.3</td><td align="left">Swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.4</td><td align="left">Tuple creation functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.5</td><td align="left">Tuple helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.6</td><td align="left">Element access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.7</td><td align="left">Relational operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.8</td><td align="left">Tuple traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.9</td><td align="left">Tuple specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.1</td><td align="left"><code class="code">bitset</code> constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.2</td><td align="left"><code class="code">bitset</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.3</td><td align="left"><code class="code">bitset</code> hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.4</td><td align="left"><code class="code">bitset</code> operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6</td><td align="left">Memory</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.2</td><td align="left">Header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.3</td><td align="left">Pointer traits</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.6.4</td><td align="left">Pointer safety</td><td align="left">Partial</td><td align="left"> </td></tr><tr><td align="left">20.6.5</td><td align="left">Align</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.6</td><td align="left">Allocator argument tag</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.7</td><td align="left"><code class="code">uses_allocator</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.8</td><td align="left">Allocator traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.9</td><td align="left">The default allocator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.10</td><td align="left">Raw storage iterator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.11</td><td align="left">Temporary buffers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12</td><td align="left">Specialized algorithms</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.12.1</td><td align="left"><code class="code">addressof</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.2</td><td align="left"><code class="code">uninitialized_copy</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.3</td><td align="left"><code class="code">uninitialized_fill</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.4</td><td align="left"><code class="code">uninitialized_fill_n</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.13</td><td align="left">C library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.7.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2</td><td align="left">Shared-ownership pointers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
-	<p>
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
-	</p>
       </td></tr><tr><td align="left">20.7.2.3</td><td align="left">Class template <code class="code">weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.4</td><td align="left">Class template <code class="code">emable_shared_from_this</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.5</td><td align="left"><code class="code">shared_ptr</code> atomic access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.6</td><td align="left">Smart pointer hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8</td><td align="left">Function objects</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.1</td><td align="left">Definitions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.2</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.3</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.4</td><td align="left">Arithmetic operation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.5</td><td align="left">Comparisons</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.6</td><td align="left">Logical operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.7</td><td align="left">Bitwise operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.8</td><td align="left">Negators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.9</td><td align="left">Function template <code class="code">bind</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.10</td><td align="left">Function template <code class="code">mem_fn</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.11</td><td align="left">Polymorphic function wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.11.1</td><td align="left">Class <code class="code">bad_function_call</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.8.11.2</td><td align="left">Class template <code class="code">function</code></td><td align="left">Partial</td><td align="left">Missing allocator support</td></tr><tr><td align="left">20.8.12</td><td align="left">Class template <code class="code">hash</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9</td><td align="left">Metaprogramming and type traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.1</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.2</td><td align="left">Header <code class="code">&lt;type_traits&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.3</td><td align="left">Helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4</td><td align="left">Unary Type Traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.1</td><td align="left">Primary type categories</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.2</td><td align="left">Composite type traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.3</td><td align="left">Type properties</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.5</td><td align="left">Type property queries</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.6</td><td align="left">Relationships between types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7</td><td align="left">Transformations between types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.7.1</td><td align="left">Const-volatile modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.2</td><td align="left">Reference modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.3</td><td align="left">Sign modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.4</td><td align="left">Array modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.5</td><td align="left">Pointer modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.6</td><td align="left">Other transformations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10</td><td align="left">Compile-time rational arithmetic</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.2</td><td align="left">Header <code class="code">&lt;ratio&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.3</td><td align="left">Class template <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.4</td><td align="left">Arithmetic on <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.5</td><td align="left">Comparison of <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.6</td><td align="left">SI types for <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11</td><td align="left">Time utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.3</td><td align="left">Clock requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4</td><td align="left">Time-related traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.4.1</td><td align="left"><code class="code">treat_as_floating_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.2</td><td align="left"><code class="code">duration_values</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.3</td><td align="left">Specializations of <code class="code">common_type</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.5</td><td align="left">Class template <code class="code">duration</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.6</td><td align="left">Class template <code class="code">time_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7</td><td align="left">Clocks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.7.1</td><td align="left">Class <code class="code">system_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.2</td><td align="left">Class <code class="code">steady_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.3</td><td align="left">Class <code class="code">high_resolution_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.8</td><td align="left">Date and time functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12</td><td align="left">Scoped allocator adaptor</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.1</td><td align="left">Header <code class="code">&lt;scoped_allocator&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.12.2</td><td align="left">Scoped allocator adaptor member types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.3</td><td align="left">Scoped allocator adaptor constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.12.4</td><td align="left">Scoped allocator adaptor members</td><td align="left">Partial</td><td align="left">OUTERMOST is not recursive.</td></tr><tr><td align="left">20.12.5</td><td align="left">Scoped allocator operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.13</td><td align="left">Class <code class="code">type_index</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>21</em></span>
       </td><td colspan="3" align="left">
@@ -299,7 +297,10 @@ particular release.
       <span class="emphasis"><em>30.2.3 [thread.req.native]/1</em></span>
       <code class="classname">native_handle_type</code> and
       <code class="methodname">native_handle</code> are provided. The handle types
-      are defined in terms of the Gthreads abstraction layer.
+      are defined in terms of the Gthreads abstraction layer, although this
+      is subject to change at any time. Any use of
+      <code class="classname">native_handle</code> is inherently non-portable and
+      not guaranteed to work between major releases of GCC.
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="classname">thread</code>: The native handle type is
             a typedef for <code class="code">__gthread_t</code> i.e. <code class="code">pthread_t</code>
             when GCC is configured with the <code class="literal">posix</code> thread
@@ -326,8 +327,8 @@ particular release.
       overloaded operators to support bitmask operations. There are no
       additional bitmask elements defined.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.2014"></a>C++ 2014</h3></div></div></div><p>
-In this implementation <code class="literal">-std=gnu++1y</code> or
-<code class="literal">-std=c++1y</code> flags must be used to enable language
+In this implementation the <code class="literal">-std=gnu++14</code> or
+<code class="literal">-std=c++14</code> flag must be used to enable language
 and library
 features. See <a class="link" href="using.html#manual.intro.using.flags" title="Command Options">dialect</a>
 options. The pre-defined symbol
@@ -392,7 +393,7 @@ not in any particular release.
 	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3659.html" target="_top">
 	  N3659
 	</a>
-      </td><td align="left">Shared Locking in C++</td><td align="left">Y</td><td align="left">Need tests</td></tr><tr><td align="left">
+      </td><td align="left">Shared Locking in C++</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3421.htm" target="_top">
 	  N3421
 	</a>
@@ -452,11 +453,15 @@ not in any particular release.
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3932.htm" target="_top">
 	  N3932
 	</a>
-      </td><td align="left">Variable Templates For Type Traits</td><td align="left">Y</td><td align="left">Library Fundamentals TS</td></tr><tr bgcolor="#C8C8B0"><td align="left">
-	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3932.htm" target="_top">
-	  N3940
+      </td><td align="left">Variable Templates For Type Traits</td><td align="left">Y</td><td align="left">Library Fundamentals TS</td></tr><tr><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf" target="_top">
+	  N4100
 	</a>
-      </td><td align="left">File System</td><td align="left">WIP</td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
+      </td><td align="left">File System</td><td align="left">Y</td><td align="left">
+	Link with
+	<a class="link" href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental" title="Experimental Library Extensions">
+	<code class="option">-lstdc++fs</code></a>
+      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
 This table is based on the table of contents of ISO/IEC DTR 19768
 Doc No: N1836=05-0096 Date: 2005-06-24
 Draft Technical Report on C++ Library Extensions
diff --git a/libstdc++-v3/doc/html/manual/using.html b/libstdc++-v3/doc/html/manual/using.html
index ccc870f..3b7aed7 100644
--- a/libstdc++-v3/doc/html/manual/using.html
+++ b/libstdc++-v3/doc/html/manual/using.html
@@ -2,14 +2,19 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 3. Using</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="Part I.  Introduction" /><link rel="prev" href="make.html" title="Make" /><link rel="next" href="using_headers.html" title="Headers" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Using</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="make.html">Prev</a> </td><th width="60%" align="center">Part I. 
   Introduction
   
-</th><td width="20%" align="right"> <a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter 3. Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
+</th><td width="20%" align="right"> <a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter 3. Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
       The set of features available in the GNU C++ library is shaped by
       several <a class="link" href="http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Invoking-GCC.html" target="_top">GCC
       Command Options</a>. Options that impact libstdc++ are
       enumerated and detailed in the table below.
     </p><p>
-      By default, <span class="command"><strong>g++</strong></span> is equivalent to  <span class="command"><strong>g++ -std=gnu++98</strong></span>. The standard library also defaults to this dialect.
-    </p><div class="table"><a id="table.cmd_options"></a><p class="title"><strong>Table 3.1. C++ Command Options</strong></p><div class="table-contents"><table summary="C++ Command Options" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Option Flags</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="literal">-std=c++98</code></td><td align="left">Use the 1998 ISO C++ standard plus amendments.</td></tr><tr><td align="left"><code class="literal">-std=gnu++98</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++11</code></td><td align="left">Use the 2011 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++11</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-fexceptions</code></td><td align="left">See <a class="link" href="using_exceptions.html#intro.using.exception.no" title="Doing without">exception-free dialect</a></td></tr><tr><td align="left"><code class="literal">-frtti</code></td><td align="left">As above, but RTTI-free dialect.</td></tr><tr><td align="left"><code class="literal">-pthread</code> or <code class="literal">-pthreads</code></td><td align="left">For ISO C++11
+      The standard library conforms to the dialect of C++ specified by the
+      <code class="option">-std</code> option passed to the compiler.
+      By default, <span class="command"><strong>g++</strong></span> is equivalent to
+      <span class="command"><strong>g++ -std=gnu++98</strong></span> for GCC 5 and older releases.
+    </p><div class="table"><a id="table.cmd_options"></a><p class="title"><strong>Table 3.1. C++ Command Options</strong></p><div class="table-contents"><table summary="C++ Command Options" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Option Flags</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="literal">-std=c++98</code> or <code class="literal">-std=c++03</code>
+      </td><td align="left">Use the 1998 ISO C++ standard plus amendments.</td></tr><tr><td align="left"><code class="literal">-std=gnu++98</code> or <code class="literal">-std=gnu++03</code>
+      </td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++11</code></td><td align="left">Use the 2011 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++11</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++14</code></td><td align="left">Use the 2014 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++14</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-fexceptions</code></td><td align="left">See <a class="link" href="using_exceptions.html#intro.using.exception.no" title="Doing without">exception-free dialect</a></td></tr><tr><td align="left"><code class="literal">-frtti</code></td><td align="left">As above, but RTTI-free dialect.</td></tr><tr><td align="left"><code class="literal">-pthread</code> or <code class="literal">-pthreads</code></td><td align="left">For ISO C++11
         <code class="filename">&lt;thread&gt;</code>,
         <code class="filename">&lt;future&gt;</code>,
         <code class="filename">&lt;mutex&gt;</code>,
@@ -17,4 +22,7 @@
       </td></tr><tr><td align="left"><code class="literal">-latomic</code></td><td align="left">Linking to <code class="filename">libatomic</code>
         is required for some uses of ISO C++11
         <code class="filename">&lt;atomic&gt;</code>.
+      </td></tr><tr><td align="left"><code class="literal">-lstdc++fs</code></td><td align="left">Linking to <code class="filename">libstdc++fs</code>
+        is required for use of the Filesystem library extensions in
+        <code class="filename">&lt;experimental/filesystem&gt;</code>.
       </td></tr><tr><td align="left"><code class="literal">-fopenmp</code></td><td align="left">For <a class="link" href="parallel_mode.html" title="Chapter 18. Parallel Mode">parallel</a> mode.</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="make.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="intro.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="using_headers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Make </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Headers</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/using_dynamic_or_shared.html b/libstdc++-v3/doc/html/manual/using_dynamic_or_shared.html
index ac46c7e..8defacd 100644
--- a/libstdc++-v3/doc/html/manual/using_dynamic_or_shared.html
+++ b/libstdc++-v3/doc/html/manual/using_dynamic_or_shared.html
@@ -102,4 +102,21 @@ A quick read of the relevant part of the GCC
       also installed, for use with Libtool.  If you use Libtool to
       create your executables, these details are taken care of for
       you.
+    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.linkage.experimental"></a>Experimental Library Extensions</h3></div></div></div><p>
+      GCC 5.3 includes an implementation of the Filesystem library defined
+      by the technical specification ISO/IEC TS 18822:2015. Because this is
+      an experimental library extension, not part of the C++ standard, it
+      is implemented in a separate library,
+      <code class="filename">libstdc++fs.a</code>, and there is
+      no shared library for it. To use the library you should include
+      <code class="filename">&lt;experimental/filesystem&gt;</code>
+      and link with <code class="option">-lstdc++fs</code>. The library implementation
+      is incomplete on non-POSIX platforms, specifically Windows support is
+      rudimentary.
+    </p><p>
+      Due to the experimental nature of the Filesystem library the usual
+      guarantees about ABI stability and backwards compatibility do not apply
+      to it. There is no guarantee that the components in any
+      <code class="filename">&lt;experimental/xxx&gt;</code>
+      header will remain compatible between different GCC releases.
     </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using_namespaces.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="using.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="using_concurrency.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Namespaces </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Concurrency</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/using_headers.html b/libstdc++-v3/doc/html/manual/using_headers.html
index 7e4d5be..de90e12 100644
--- a/libstdc++-v3/doc/html/manual/using_headers.html
+++ b/libstdc++-v3/doc/html/manual/using_headers.html
@@ -74,12 +74,15 @@ of <code class="code">std::sinf</code>, <code class="code">std::sin</code>,
 and <code class="code">std::sinl</code>.
 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.headers.pre"></a>Precompiled Headers</h3></div></div></div><p>There are three base header files that are provided. They can be
 used to precompile the standard headers and extensions into binary
-files that may the be used to speed compiles that use these headers.
+files that may then be used to speed up compilations that use these headers.
 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>stdc++.h</p><p>Includes all standard headers. Actual content varies depending on
-language dialect.
+<a class="link" href="using.html#manual.intro.using.flags" title="Command Options">language dialect</a>.
 </p></li><li class="listitem"><p>stdtr1c++.h</p><p>Includes all of &lt;stdc++.h&gt;, and adds all the TR1 headers.
-</p></li><li class="listitem"><p>extc++.h</p><p>Includes all of &lt;stdtr1c++.h&gt;, and adds all the Extension headers.
-</p></li></ul></div><p>How to construct a .gch file from one of these base header files.</p><p>First, find the include directory for the compiler. One way to do
+</p></li><li class="listitem"><p>extc++.h</p><p>Includes all of the Extension headers
+(and in C++98 mode also adds all the TR1 headers by including all of
+&lt;stdtr1c++.h&gt;).
+</p></li></ul></div><p>To construct a .gch file from one of these base header files,
+first find the include directory for the compiler. One way to do
 this is:</p><pre class="programlisting">
 g++ -v hello.cc
 
diff --git a/libstdc++-v3/doc/html/manual/using_namespaces.html b/libstdc++-v3/doc/html/manual/using_namespaces.html
index a7dd0b5..0fe9ce3 100644
--- a/libstdc++-v3/doc/html/manual/using_namespaces.html
+++ b/libstdc++-v3/doc/html/manual/using_namespaces.html
@@ -2,8 +2,8 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Namespaces</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="using.html" title="Chapter 3. Using" /><link rel="prev" href="using_dual_abi.html" title="Dual ABI" /><link rel="next" href="using_dynamic_or_shared.html" title="Linking" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Namespaces</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="using_dual_abi.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Using</th><td width="20%" align="right"> <a accesskey="n" href="using_dynamic_or_shared.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.namespaces"></a>Namespaces</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.namespaces.all"></a>Available Namespaces</h3></div></div></div><p> There are three main namespaces.
 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>std</p><p>The ISO C++ standards specify that "all library entities are defined
 within namespace std." This includes namespaces nested
-within <code class="code">namespace std</code>, such as <code class="code">namespace
-std::tr1</code>.
+within namespace <code class="code">std</code>, such as namespace
+<code class="code">std::chrono</code>.
 </p></li><li class="listitem"><p>abi</p><p>Specified by the C++ ABI. This ABI specifies a number of type and
 function APIs supplemental to those required by the ISO C++ Standard,
 but necessary for interoperability.
diff --git a/libstdc++-v3/doc/xml/manual/abi.xml b/libstdc++-v3/doc/xml/manual/abi.xml
index b399f71..a2ed57b 100644
--- a/libstdc++-v3/doc/xml/manual/abi.xml
+++ b/libstdc++-v3/doc/xml/manual/abi.xml
@@ -66,7 +66,7 @@
 </para>
 
 <para> Putting all of these ideas together results in the C++ Standard
-library ABI, which is the compilation of a given library API by a
+Library ABI, which is the compilation of a given library API by a
 given compiler ABI. In a nutshell:
 </para>
 
diff --git a/libstdc++-v3/doc/xml/manual/configure.xml b/libstdc++-v3/doc/xml/manual/configure.xml
index f6a5551..7b09d01 100644
--- a/libstdc++-v3/doc/xml/manual/configure.xml
+++ b/libstdc++-v3/doc/xml/manual/configure.xml
@@ -297,10 +297,12 @@
 
  <varlistentry><term><code>--enable-concept-checks</code></term>
  <listitem><para>This turns on additional compile-time checks for instantiated
-	library templates, in the form of specialized templates,
-	<link linkend="std.diagnostics.concept_checking">described here</link>.  They
+	library templates, in the form of specialized templates described in
+        the <link linkend="std.diagnostics.concept_checking">Concept
+        Checking</link> section.  They
 	can help users discover when they break the rules of the STL, before
-	their programs run.
+	their programs run. These checks are based on C++03 rules and some of
+	them are not compatible with correct C++11 code.
      </para>
  </listitem></varlistentry>
 
@@ -418,6 +420,15 @@
      </para>
  </listitem></varlistentry>
 
+ <varlistentry><term><code>--enable-libstdcxx-filesystem-ts</code>[default]</term>
+ <listitem>
+    <para>Build <filename class="libraryfile">libstdc++fs.a</filename> as well
+      as the usual libstdc++ and libsupc++ libraries. This is enabled by
+      default on select POSIX targets where it is known to work and disabled
+      otherwise.
+    </para>
+ </listitem></varlistentry>
+
 </variablelist>
 
 </section>
diff --git a/libstdc++-v3/doc/xml/manual/diagnostics.xml b/libstdc++-v3/doc/xml/manual/diagnostics.xml
index 99206e9..88ed2e2 100644
--- a/libstdc++-v3/doc/xml/manual/diagnostics.xml
+++ b/libstdc++-v3/doc/xml/manual/diagnostics.xml
@@ -114,8 +114,9 @@
 
  <para>
    Please note that the checks are based on the requirements in the original
-   C++ standard, some of which have changed in the new C++11 revision.
-   Additionally, some correct code might be rejected by the concept checks,
+   C++ standard, many of which were relaxed in the C++11 standard and so valid
+   C++11 code may be incorrectly rejected by the concept checks.  Additionally,
+   some correct C++03 code might be rejected by the concept checks,
    for example template argument types may need to be complete when used in
    a template definition, rather than at the point of instantiation.
    There are no plans to address these shortcomings.
diff --git a/libstdc++-v3/doc/xml/manual/extensions.xml b/libstdc++-v3/doc/xml/manual/extensions.xml
index c4120c9..41b1a80 100644
--- a/libstdc++-v3/doc/xml/manual/extensions.xml
+++ b/libstdc++-v3/doc/xml/manual/extensions.xml
@@ -82,7 +82,8 @@ extensions, be aware of two things:
       They can be enabled at configure time with
       <link linkend="manual.intro.setup.configure"><literal>--enable-concept-checks</literal></link>.
       You can enable them on a per-translation-unit basis with
-      <code>#define _GLIBCXX_CONCEPT_CHECKS</code> for GCC 3.4 and higher
+      <link linkend="manual.intro.using.macros"><code>#define
+      _GLIBCXX_CONCEPT_CHECKS</code></link> for GCC 3.4 and higher
       (or with <code>#define _GLIBCPP_CONCEPT_CHECKS</code> for versions
       3.1, 3.2 and 3.3).
    </para>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
index 965df13..16ea8c4 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
@@ -17,8 +17,8 @@ Final Draft International Standard, Standard for Programming Language C++
 </para>
 
 <para>
-In this implementation <literal>-std=gnu++11</literal> or
-<literal>-std=c++11</literal> flags must be used to enable language
+In this implementation the <literal>-std=gnu++11</literal> or
+<literal>-std=c++11</literal> flag must be used to enable language
 and library
 features. See <link linkend="manual.intro.using.flags">dialect</link>
 options. The pre-defined symbol
@@ -642,10 +642,8 @@ particular release.
       <entry>Class template <code>shared_ptr</code></entry>
       <entry>Y</entry>
       <entry>
-	<para>
 	  Uses code from
 	  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</link>.
-	</para>
       </entry>
     </row>
     <row>
@@ -2673,7 +2671,10 @@ particular release.
       <emphasis>30.2.3 [thread.req.native]/1</emphasis>
       <classname>native_handle_type</classname> and
       <methodname>native_handle</methodname> are provided. The handle types
-      are defined in terms of the Gthreads abstraction layer.
+      are defined in terms of the Gthreads abstraction layer, although this
+      is subject to change at any time. Any use of
+      <classname>native_handle</classname> is inherently non-portable and
+      not guaranteed to work between major releases of GCC.
       <itemizedlist>
          <listitem><para><classname>thread</classname>: The native handle type is
             a typedef for <code>__gthread_t</code> i.e. <code>pthread_t</code>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
index fc32995..6f1fbe5 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
@@ -10,8 +10,8 @@
 </info>
 
 <para>
-In this implementation <literal>-std=gnu++1y</literal> or
-<literal>-std=c++1y</literal> flags must be used to enable language
+In this implementation the <literal>-std=gnu++14</literal> or
+<literal>-std=c++14</literal> flag must be used to enable language
 and library
 features. See <link linkend="manual.intro.using.flags">dialect</link>
 options. The pre-defined symbol
@@ -196,7 +196,7 @@ not in any particular release.
       </entry>
       <entry>Shared Locking in C++</entry>
       <entry>Y</entry>
-      <entry>Need tests</entry>
+      <entry/>
     </row>
 
 
@@ -395,15 +395,18 @@ not in any particular release.
     </row>
 
     <row>
-      <?dbhtml bgcolor="#C8C8B0" ?>
       <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3932.htm">
-	  N3940
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf">
+	  N4100
 	</link>
       </entry>
       <entry>File System</entry>
-      <entry>WIP</entry>
-      <entry></entry>
+      <entry>Y</entry>
+      <entry>
+	Link with
+	<link linkend="manual.intro.using.linkage.experimental">
+	<option>-lstdc++fs</option></link>
+      </entry>
     </row>
 
 
diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
index ba90666..6228a86 100644
--- a/libstdc++-v3/doc/xml/manual/using.xml
+++ b/libstdc++-v3/doc/xml/manual/using.xml
@@ -13,7 +13,10 @@
     </para>
 
     <para>
-      By default, <command>g++</command> is equivalent to  <command>g++ -std=gnu++98</command>. The standard library also defaults to this dialect.
+      The standard library conforms to the dialect of C++ specified by the
+      <option>-std</option> option passed to the compiler.
+      By default, <command>g++</command> is equivalent to
+      <command>g++ -std=gnu++98</command> for GCC 5 and older releases.
     </para>
 
  <table frame="all" xml:id="table.cmd_options">
@@ -32,12 +35,14 @@
 
   <tbody>
     <row>
-      <entry><literal>-std=c++98</literal></entry>
+      <entry><literal>-std=c++98</literal> or <literal>-std=c++03</literal>
+      </entry>
       <entry>Use the 1998 ISO C++ standard plus amendments.</entry>
     </row>
 
     <row>
-      <entry><literal>-std=gnu++98</literal></entry>
+      <entry><literal>-std=gnu++98</literal> or <literal>-std=gnu++03</literal>
+      </entry>
       <entry>As directly above, with GNU extensions.</entry>
     </row>
 
@@ -52,6 +57,16 @@
     </row>
 
     <row>
+      <entry><literal>-std=c++14</literal></entry>
+      <entry>Use the 2014 ISO C++ standard.</entry>
+    </row>
+
+    <row>
+      <entry><literal>-std=gnu++14</literal></entry>
+      <entry>As directly above, with GNU extensions.</entry>
+    </row>
+
+    <row>
       <entry><literal>-fexceptions</literal></entry>
       <entry>See <link linkend="intro.using.exception.no">exception-free dialect</link></entry>
     </row>
@@ -80,6 +95,14 @@
     </row>
 
     <row>
+      <entry><literal>-lstdc++fs</literal></entry>
+      <entry>Linking to <filename class="libraryfile">libstdc++fs</filename>
+        is required for use of the Filesystem library extensions in
+        <filename class="headerfile">&lt;experimental/filesystem&gt;</filename>.
+      </entry>
+    </row>
+
+    <row>
       <entry><literal>-fopenmp</literal></entry>
       <entry>For <link linkend="manual.ext.parallel_mode">parallel</link> mode.</entry>
     </row>
@@ -703,7 +726,7 @@ and <code>std::sinl</code>.
 
 <para>There are three base header files that are provided. They can be
 used to precompile the standard headers and extensions into binary
-files that may the be used to speed compiles that use these headers.
+files that may then be used to speed up compilations that use these headers.
 </para>
 
 
@@ -711,7 +734,7 @@ files that may the be used to speed compiles that use these headers.
 <listitem>
   <para>stdc++.h</para>
 <para>Includes all standard headers. Actual content varies depending on
-language dialect.
+<link linkend="manual.intro.using.flags">language dialect</link>.
 </para>
 </listitem>
 
@@ -722,13 +745,14 @@ language dialect.
 </listitem>
 
 <listitem><para>extc++.h</para>
-<para>Includes all of &lt;stdtr1c++.h&gt;, and adds all the Extension headers.
+<para>Includes all of the Extension headers
+(and in C++98 mode also adds all the TR1 headers by including all of
+&lt;stdtr1c++.h&gt;).
 </para></listitem>
 </itemizedlist>
 
-<para>How to construct a .gch file from one of these base header files.</para>
-
-<para>First, find the include directory for the compiler. One way to do
+<para>To construct a .gch file from one of these base header files,
+first find the include directory for the compiler. One way to do
 this is:</para>
 
 <programlisting>
@@ -1027,8 +1051,8 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
   <listitem><para>std</para>
 <para>The ISO C++ standards specify that "all library entities are defined
 within namespace std." This includes namespaces nested
-within <code>namespace std</code>, such as <code>namespace
-std::tr1</code>.
+within namespace <code>std</code>, such as namespace
+<code>std::chrono</code>.
 </para>
 </listitem>
 <listitem><para>abi</para>
@@ -1333,8 +1357,31 @@ A quick read of the relevant part of the GCC
       you.
     </para>
     </section>
-  </section>
 
+    <section xml:id="manual.intro.using.linkage.experimental" xreflabel="Library Extensions"><info><title>Experimental Library Extensions</title></info>
+
+    <para>
+      GCC 5.3 includes an implementation of the Filesystem library defined
+      by the technical specification ISO/IEC TS 18822:2015. Because this is
+      an experimental library extension, not part of the C++ standard, it
+      is implemented in a separate library,
+      <filename class="libraryfile">libstdc++fs.a</filename>, and there is
+      no shared library for it. To use the library you should include
+      <filename class="headerfile">&lt;experimental/filesystem&gt;</filename>
+      and link with <option>-lstdc++fs</option>. The library implementation
+      is incomplete on non-POSIX platforms, specifically Windows support is
+      rudimentary.
+    </para>
+
+    <para>
+      Due to the experimental nature of the Filesystem library the usual
+      guarantees about ABI stability and backwards compatibility do not apply
+      to it. There is no guarantee that the components in any
+      <filename class="headerfile">&lt;experimental/xxx&gt;</filename>
+      header will remain compatible between different GCC releases.
+    </para>
+    </section>
+  </section>
 
   <section xml:id="manual.intro.using.concurrency" xreflabel="Concurrency"><info><title>Concurrency</title></info>
     <?dbhtml filename="using_concurrency.html"?>
diff --git a/libstdc++-v3/include/backward/strstream b/libstdc++-v3/include/backward/strstream
index 9288e56..10e2dfe 100644
--- a/libstdc++-v3/include/backward/strstream
+++ b/libstdc++-v3/include/backward/strstream
@@ -40,9 +40,8 @@
 // MAY BE REMOVED in a future standard revision.  One should use the
 // header <sstream> instead.
 
-/** @file backward/strstream
- *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{sstream}
+/** @file strstream
+ *  This is a Standard C++ Library header.
  */
 
 #ifndef _BACKWARD_STRSTREAM
diff --git a/libstdc++-v3/include/bits/alloc_traits.h b/libstdc++-v3/include/bits/alloc_traits.h
index 12c6c12..615e071 100644
--- a/libstdc++-v3/include/bits/alloc_traits.h
+++ b/libstdc++-v3/include/bits/alloc_traits.h
@@ -409,7 +409,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,
        *  Calls @c __a.destroy(__p) if that expression is well-formed,
        *  otherwise calls @c __p->~_Tp()
       */
-      template <class _Tp>
+      template<typename _Tp>
 	static void destroy(_Alloc& __a, _Tp* __p)
 	{ _S_destroy(__a, __p); }
 
@@ -437,6 +437,130 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,
       { return _S_select(__rhs, 0); }
     };
 
+  /// Partial specialization for std::allocator.
+  template<typename _Tp>
+    struct allocator_traits<allocator<_Tp>>
+    {
+      /// The allocator type
+      using allocator_type = allocator<_Tp>;
+      /// The allocated type
+      using value_type = _Tp;
+
+      /// The allocator's pointer type.
+      using pointer = _Tp*;
+
+      /// The allocator's const pointer type.
+      using const_pointer = const _Tp*;
+
+      /// The allocator's void pointer type.
+      using void_pointer = void*;
+
+      /// The allocator's const void pointer type.
+      using const_void_pointer = const void*;
+
+      /// The allocator's difference type
+      using difference_type = std::ptrdiff_t;
+
+      /// The allocator's size type
+      using size_type = std::size_t;
+
+      /// How the allocator is propagated on copy assignment
+      using propagate_on_container_copy_assignment = false_type;
+
+      /// How the allocator is propagated on move assignment
+      using propagate_on_container_move_assignment = true_type;
+
+      /// How the allocator is propagated on swap
+      using propagate_on_container_swap = false_type;
+
+      template<typename _Up>
+	using rebind_alloc = allocator<_Up>;
+
+      template<typename _Up>
+	using rebind_traits = allocator_traits<allocator<_Up>>;
+
+      /**
+       *  @brief  Allocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __n  The number of objects to allocate space for.
+       *
+       *  Calls @c a.allocate(n)
+      */
+      static pointer
+      allocate(allocator_type& __a, size_type __n)
+      { return __a.allocate(__n); }
+
+      /**
+       *  @brief  Allocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __n  The number of objects to allocate space for.
+       *  @param  __hint Aid to locality.
+       *  @return Memory of suitable size and alignment for @a n objects
+       *          of type @c value_type
+       *
+       *  Returns <tt> a.allocate(n, hint) </tt>
+      */
+      static pointer
+      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
+      { return __a.allocate(__n, __hint); }
+
+      /**
+       *  @brief  Deallocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to the memory to deallocate.
+       *  @param  __n  The number of objects space was allocated for.
+       *
+       *  Calls <tt> a.deallocate(p, n) </tt>
+      */
+      static void
+      deallocate(allocator_type& __a, pointer __p, size_type __n)
+      { __a.deallocate(__p, __n); }
+
+      /**
+       *  @brief  Construct an object of type @a _Up
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
+       *  @param  __args Constructor arguments.
+       *
+       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
+      */
+      template<typename _Up, typename... _Args>
+	static void
+	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
+	{ __a.construct(__p, std::forward<_Args>(__args)...); }
+
+      /**
+       *  @brief  Destroy an object of type @a _Up
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to the object to destroy
+       *
+       *  Calls @c __a.destroy(__p).
+      */
+      template<typename _Up>
+	static void
+	destroy(allocator_type& __a, _Up* __p)
+	{ __a.destroy(__p); }
+
+      /**
+       *  @brief  The maximum supported allocation size
+       *  @param  __a  An allocator.
+       *  @return @c __a.max_size()
+      */
+      static size_type
+      max_size(const allocator_type& __a) noexcept
+      { return __a.max_size(); }
+
+      /**
+       *  @brief  Obtain an allocator to use when copying a container.
+       *  @param  __rhs  An allocator.
+       *  @return @c __rhs
+      */
+      static allocator_type
+      select_on_container_copy_construction(const allocator_type& __rhs)
+      { return __rhs; }
+    };
+
+
   template<typename _Alloc>
     inline void
     __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 19222d1..9ef5be9 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -322,7 +322,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       template<class _Iterator>
         static void
         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
-	_GLIBCXX_NOEXCEPT
         {
 	  for (; __k1 != __k2; ++__k1, ++__p)
 	    traits_type::assign(*__p, *__k1); // These types are off.
@@ -2782,7 +2781,6 @@ _GLIBCXX_END_NAMESPACE_CXX11
       template<class _Iterator>
         static void
         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
-	_GLIBCXX_NOEXCEPT
         {
 	  for (; __k1 != __k2; ++__k1, ++__p)
 	    traits_type::assign(*__p, *__k1); // These types are off.
diff --git a/libstdc++-v3/include/bits/c++0x_warning.h b/libstdc++-v3/include/bits/c++0x_warning.h
index 5c7e972..dabc2c4 100644
--- a/libstdc++-v3/include/bits/c++0x_warning.h
+++ b/libstdc++-v3/include/bits/c++0x_warning.h
@@ -29,9 +29,9 @@
 #define _CXX0X_WARNING_H 1
 
 #if __cplusplus < 201103L
-#error This file requires compiler and library support for the \
-ISO C++ 2011 standard. This support is currently experimental, and must be \
-enabled with the -std=c++11 or -std=gnu++11 compiler options.
+#error This file requires compiler and library support \
+for the ISO C++ 2011 standard. This support must be enabled \
+with the -std=c++11 or -std=gnu++11 compiler options.
 #endif
 
 #endif
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index ae3065f..79d1b36 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -294,7 +294,7 @@ namespace std
 # endif
 
 # if _GLIBCXX_USE_CXX11_ABI
-  inline namespace __cxx11 __attribute__((__abi_tag__)) { }
+  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
 # endif
   }
 
diff --git a/libstdc++-v3/include/bits/forward_list.h b/libstdc++-v3/include/bits/forward_list.h
index 88eee1f..0cdd75b 100644
--- a/libstdc++-v3/include/bits/forward_list.h
+++ b/libstdc++-v3/include/bits/forward_list.h
@@ -463,7 +463,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       /**
        *  @brief  Creates a %forward_list with default constructed elements.
-       *  @param  __n  The number of elements to initially create.
+       *  @param  __n   The number of elements to initially create.
+       *  @param  __al  An allocator object.
        *
        *  This constructor creates the %forward_list with @a __n default
        *  constructed elements.
@@ -1083,6 +1084,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        *  after @a __pos in constant time.
        *
        *  Undefined if @a __pos is in (__before,__last).
+       *  @{
        */
       void
       splice_after(const_iterator __pos, forward_list&&,
@@ -1093,6 +1095,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       splice_after(const_iterator __pos, forward_list&,
                    const_iterator __before, const_iterator __last)
       { _M_splice_after(__pos, __before, __last); }
+      // @}
 
       /**
        *  @brief  Remove all elements equal to value.
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.h b/libstdc++-v3/include/bits/locale_facets_nonio.h
index 7eae6c8..527296b 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.h
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.h
@@ -709,7 +709,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *
        *  @param __s        Start of string to parse.
        *  @param __end      End of string to parse.
-       *  @param __io       Source of the locale.
+       *  @param __f        Source of the locale.
        *  @param __err      Error flags to set.
        *  @param __tm       Pointer to struct tm to fill in.
        *  @param __format   Format specifier.
diff --git a/libstdc++-v3/include/bits/regex_executor.tcc b/libstdc++-v3/include/bits/regex_executor.tcc
index f065499..de217da 100644
--- a/libstdc++-v3/include/bits/regex_executor.tcc
+++ b/libstdc++-v3/include/bits/regex_executor.tcc
@@ -147,7 +147,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
     _M_lookahead(_State<_TraitsT> __state)
     {
-      _ResultsVec __what(_M_cur_results.size());
+      // Backreferences may refer to captured content.
+      // We may want to make this faster by not copying,
+      // but let's not be clever prematurely.
+      _ResultsVec __what(_M_cur_results);
       _Executor __sub(_M_current, _M_end, __what, _M_re, _M_flags);
       __sub._M_states._M_start = __state._M_alt;
       if (__sub._M_search_from_first())
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index b47103e..6fefed7 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -95,11 +95,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		  : _M_awk_escape_tbl),
     _M_spec_char(_M_is_ecma()
 		 ? _M_ecma_spec_char
-		 : _M_is_basic()
+		 : _M_flags & regex_constants::basic
 		 ? _M_basic_spec_char
-		 : _M_extended_spec_char),
+		 : _M_flags & regex_constants::extended
+		 ? _M_extended_spec_char
+		 : _M_flags & regex_constants::grep
+		 ?  ".[\\*^$\n"
+		 : _M_flags & regex_constants::egrep
+		 ? ".[\\()*+?{|^$\n"
+		 : _M_flags & regex_constants::awk
+		 ? _M_extended_spec_char
+		 : nullptr),
     _M_at_bracket_start(false)
-    { }
+    { __glibcxx_assert(_M_spec_char); }
 
   protected:
     const char*
@@ -137,6 +145,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return _M_flags & regex_constants::awk; }
 
   protected:
+    // TODO: Make them static in the next abi change.
     const std::pair<char, _TokenT> _M_token_tbl[9] =
       {
 	{'^', _S_token_line_begin},
diff --git a/libstdc++-v3/include/bits/regex_scanner.tcc b/libstdc++-v3/include/bits/regex_scanner.tcc
index 1555669..4658f99 100644
--- a/libstdc++-v3/include/bits/regex_scanner.tcc
+++ b/libstdc++-v3/include/bits/regex_scanner.tcc
@@ -97,9 +97,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     _M_scan_normal()
     {
       auto __c = *_M_current++;
-      const char* __pos;
 
-      if (std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\0')) == nullptr)
+      if (std::strchr(_M_spec_char, _M_ctype.narrow(__c, ' ')) == nullptr)
 	{
 	  _M_token = _S_token_ord_char;
 	  _M_value.assign(1, __c);
@@ -171,12 +170,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  _M_state = _S_state_in_brace;
 	  _M_token = _S_token_interval_begin;
 	}
-      else if (((__pos = std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\0')))
-		  != nullptr
-		&& *__pos != '\0'
-		&& __c != ']'
-		&& __c != '}')
-	       || (_M_is_grep() && __c == '\n'))
+      else if (__c != ']' && __c != '}')
 	{
 	  auto __it = _M_token_tbl;
 	  auto __narrowc = _M_ctype.narrow(__c, '\0');
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index f96c078..26a0ad3 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -582,19 +582,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 	{ _M_weak_this._M_assign(__p, __n); }
 
-      template<typename _Tp1>
+      template<typename _Tp1, typename _Tp2>
 	friend void
-	__enable_shared_from_this_helper(const __shared_count<>& __pn,
-					 const enable_shared_from_this* __pe,
-					 const _Tp1* __px) noexcept
-	{
-	  if (__pe != 0)
-	    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
-	}
+	__enable_shared_from_this_helper(const __shared_count<>&,
+					 const enable_shared_from_this<_Tp1>*,
+					 const _Tp2*) noexcept;
 
       mutable weak_ptr<_Tp>  _M_weak_this;
     };
 
+  template<typename _Tp1, typename _Tp2>
+    inline void
+    __enable_shared_from_this_helper(const __shared_count<>& __pn,
+				     const enable_shared_from_this<_Tp1>*
+				     __pe, const _Tp2* __px) noexcept
+    {
+      if (__pe != nullptr)
+	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
+    }
+
   /**
    *  @brief  Create an object that is owned by a shared_ptr.
    *  @param  __a     An allocator.
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index 8c3af12..d71df31 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1540,19 +1540,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 	{ _M_weak_this._M_assign(__p, __n); }
 
-      template<typename _Tp1>
+      template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
 	friend void
-	__enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
-					 const __enable_shared_from_this* __pe,
-					 const _Tp1* __px) noexcept
-	{
-	  if (__pe != 0)
-	    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
-	}
+	__enable_shared_from_this_helper(const __shared_count<_Lp1>&,
+					 const __enable_shared_from_this<_Tp1,
+					 _Lp1>*, const _Tp2*) noexcept;
 
       mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;
     };
 
+  template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
+    inline void
+    __enable_shared_from_this_helper(const __shared_count<_Lp1>& __pn,
+				     const __enable_shared_from_this<_Tp1,
+				     _Lp1>* __pe,
+				     const _Tp2* __px) noexcept
+    {
+      if (__pe != nullptr)
+	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
+    }
 
   template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
     inline __shared_ptr<_Tp, _Lp>
diff --git a/libstdc++-v3/include/bits/valarray_before.h b/libstdc++-v3/include/bits/valarray_before.h
index 6cc9574..498c573 100644
--- a/libstdc++-v3/include/bits/valarray_before.h
+++ b/libstdc++-v3/include/bits/valarray_before.h
@@ -331,14 +331,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return pow(__x, __y); }
   };
 
+  template<typename _Tp, bool _IsValidValarrayValue = !__is_abstract(_Tp)>
+    struct __fun_with_valarray
+    {
+      typedef _Tp result_type;
+    };
+
+  template<typename _Tp>
+    struct __fun_with_valarray<_Tp, false>
+    {
+      // No result type defined for invalid value types.
+    };
 
   // We need these bits in order to recover the return type of
   // some functions/operators now that we're no longer using
   // function templates.
   template<typename, typename _Tp>
-    struct __fun
+    struct __fun : __fun_with_valarray<_Tp>
     {
-      typedef _Tp result_type;
     };
 
   // several specializations for relational operators.
diff --git a/libstdc++-v3/include/c_global/cmath b/libstdc++-v3/include/c_global/cmath
index 4cafe5f..d3fc8b7 100644
--- a/libstdc++-v3/include/c_global/cmath
+++ b/libstdc++-v3/include/c_global/cmath
@@ -880,7 +880,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     signbit(_Tp __f)
     {
       typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
-      return __builtin_signbit(__type(__f));
+      return sizeof(__type) == sizeof(float)
+	? __builtin_signbitf(__type(__f))
+	: sizeof(__type) == sizeof(double)
+	? __builtin_signbit(__type(__f))
+	: __builtin_signbitl(__type(__f));
     }
 
   template<typename _Tp>
diff --git a/libstdc++-v3/include/debug/vector b/libstdc++-v3/include/debug/vector
index bf0a88e..085e5f7 100644
--- a/libstdc++-v3/include/debug/vector
+++ b/libstdc++-v3/include/debug/vector
@@ -37,9 +37,12 @@
 
 namespace __gnu_debug
 {
-  /// Special vector safe base class to add a guaranteed capacity information
-  /// useful to detect code relying on the libstdc++ reallocation management
-  /// implementation detail.
+  /** @brief Base class for Debug Mode vector.
+   *
+   * Adds information about the guaranteed capacity, which is useful for
+   * detecting code which relies on non-portable implementation details of
+   * the libstdc++ reallocation policy.
+   */
   template<typename _SafeSequence,
 	   typename _BaseSequence>
     class _Safe_vector
diff --git a/libstdc++-v3/include/experimental/fs_fwd.h b/libstdc++-v3/include/experimental/fs_fwd.h
index a5ed2c5..dd6f5e6 100644
--- a/libstdc++-v3/include/experimental/fs_fwd.h
+++ b/libstdc++-v3/include/experimental/fs_fwd.h
@@ -22,8 +22,9 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-/** @file experimental/filesystem
- *  This is a TS C++ Library header.
+/** @file experimental/fs_fwd.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{experimental/filesystem}
  */
 
 #ifndef _GLIBCXX_EXPERIMENTAL_FS_FWD_H
@@ -52,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 
   /**
-   * @defgroup filesystem
+   * @defgroup filesystem Filesystem
    * @ingroup experimental
    *
    * Utilities for performing operations on file systems and their components,
diff --git a/libstdc++-v3/include/experimental/fs_ops.h b/libstdc++-v3/include/experimental/fs_ops.h
index 6b7d470..91b8902 100644
--- a/libstdc++-v3/include/experimental/fs_ops.h
+++ b/libstdc++-v3/include/experimental/fs_ops.h
@@ -22,8 +22,9 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-/** @file experimental/filesystem
- *  This is a TS C++ Library header.
+/** @file experimental/fs_fwd.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{experimental/filesystem}
  */
 
 #ifndef _GLIBCXX_EXPERIMENTAL_FS_OPS_H
diff --git a/libstdc++-v3/include/experimental/fs_path.h b/libstdc++-v3/include/experimental/fs_path.h
index 1632a7e..176918a 100644
--- a/libstdc++-v3/include/experimental/fs_path.h
+++ b/libstdc++-v3/include/experimental/fs_path.h
@@ -549,16 +549,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     std::string _M_what = _M_gen_what();
   };
 
-  struct path::_Cmpt : path
-  {
-    _Cmpt(string_type __s, _Type __t, size_t __pos)
-      : path(std::move(__s), __t), _M_pos(__pos) { }
-
-    _Cmpt() : _M_pos(-1) { }
-
-    size_t _M_pos;
-  };
-
   template<>
     struct path::__is_encoded_char<char> : std::true_type
     { using value_type = char; };
@@ -575,6 +565,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     struct path::__is_encoded_char<char32_t> : std::true_type
     { using value_type = char32_t; };
 
+  struct path::_Cmpt : path
+  {
+    _Cmpt(string_type __s, _Type __t, size_t __pos)
+      : path(std::move(__s), __t), _M_pos(__pos) { }
+
+    _Cmpt() : _M_pos(-1) { }
+
+    size_t _M_pos;
+  };
+
   // specialize _Cvt for degenerate 'noconv' case
   template<>
     struct path::_Cvt<path::value_type>
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index 811235b..f6e3fa0 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -33,6 +33,12 @@
  * @defgroup experimental Experimental
  *
  * Components specified by various Technical Specifications.
+ *
+ * As indicated by the std::experimental namespace and the  header paths,
+ * the contents of these Technical Specifications are experimental and not
+ * part of the C++ standard. As such the interfaces and implementations may
+ * change in the future, and there is <STRONG> no guarantee of compatibility
+ * between different GCC releases </STRONG> for these features.
  */
 
 #if __cplusplus <= 201103L
diff --git a/libstdc++-v3/include/experimental/string_view b/libstdc++-v3/include/experimental/string_view
index 9c2b773..f11a187 100644
--- a/libstdc++-v3/include/experimental/string_view
+++ b/libstdc++-v3/include/experimental/string_view
@@ -23,7 +23,7 @@
 // <http://www.gnu.org/licenses/>.
 
 /** @file experimental/string_view
- *  This is a Standard C++ Library header.
+ *  This is a TS C++ Library header.
  */
 
 //
diff --git a/libstdc++-v3/include/experimental/string_view.tcc b/libstdc++-v3/include/experimental/string_view.tcc
index 75a34f9..9421842 100644
--- a/libstdc++-v3/include/experimental/string_view.tcc
+++ b/libstdc++-v3/include/experimental/string_view.tcc
@@ -24,7 +24,7 @@
 
 /** @file experimental/string_view.tcc
  *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{string_view}
+ *  Do not attempt to use it directly. @headername{experimental/string_view}
  */
 
 //
diff --git a/libstdc++-v3/include/experimental/tuple b/libstdc++-v3/include/experimental/tuple
index 4baede4..99935f1 100644
--- a/libstdc++-v3/include/experimental/tuple
+++ b/libstdc++-v3/include/experimental/tuple
@@ -54,7 +54,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template <typename _Fn, typename _Tuple, std::size_t... _Idx>
     constexpr decltype(auto)
     __apply_impl(_Fn&& f, _Tuple&& t, std::index_sequence<_Idx...>)
-    { return std::forward<_Fn>(f)(get<_Idx>(forward<_Tuple>(t))...); }
+    {
+      return std::forward<_Fn>(f)(std::get<_Idx>(std::forward<_Tuple>(t))...);
+    }
 
   template <typename _Fn, typename _Tuple>
     constexpr decltype(auto)
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp b/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
index da01e1a..674fa92 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
@@ -166,13 +166,8 @@ namespace __gnu_pbds
 	     class Node_Update,
 	     class Node,
 	     typename _Alloc>
-    struct bin_search_tree_traits<
-      Key,
-      null_type,
-      Cmp_Fn,
-      Node_Update,
-      Node,
-      _Alloc>
+    struct
+    bin_search_tree_traits<Key, null_type, Cmp_Fn, Node_Update, Node, _Alloc>
     {
     private:
       typedef types_traits<Key, null_type, _Alloc, false> type_traits;
diff --git a/libstdc++-v3/include/std/bitset b/libstdc++-v3/include/std/bitset
index d6be839..44df60c 100644
--- a/libstdc++-v3/include/std/bitset
+++ b/libstdc++-v3/include/std/bitset
@@ -663,7 +663,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
     };
 
 #if __cplusplus >= 201103L
-  template<size_t _Nb, bool = _Nb < _GLIBCXX_BITSET_BITS_PER_ULL>
+  template<size_t _Nb, bool = (_Nb < _GLIBCXX_BITSET_BITS_PER_ULL)>
     struct _Sanitize_val
     {
       static constexpr unsigned long long
@@ -681,8 +681,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #endif
 
   /**
-   *  @class bitset <bitset>
-   *
    *  @brief The %bitset class represents a @e fixed-size sequence of bits.
    *  @ingroup utilities
    *
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index e9d48e4..cc40e4d 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -1122,7 +1122,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
 
       // Call unqualified
       template<typename... _Args, typename _Result
-	= decltype( std::declval<_Functor>()(
+	= decltype( std::declval<_Functor&>()(
 	      _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1136,7 +1136,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
       // Call as const
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-		       typename add_const<_Functor>::type>::type>()(
+		       typename add_const<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1150,7 +1150,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
       // Call as volatile
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-                       typename add_volatile<_Functor>::type>::type>()(
+                       typename add_volatile<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1164,7 +1164,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
       // Call as const volatile
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-                       typename add_cv<_Functor>::type>::type>()(
+                       typename add_cv<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1883,7 +1883,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
       static _Res
       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
       {
-	return __callable_functor(**_Base::_M_get_pointer(__functor))(
+	return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
 	      std::forward<_ArgTypes>(__args)...);
       }
     };
@@ -1898,7 +1898,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
       static void
       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
       {
-	__callable_functor(**_Base::_M_get_pointer(__functor))(
+	std::__callable_functor(**_Base::_M_get_pointer(__functor))(
 	    std::forward<_ArgTypes>(__args)...);
       }
     };
@@ -1977,19 +1977,14 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
     {
       typedef _Res _Signature_type(_ArgTypes...);
 
-      template<typename _Functor>
-	using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())
-				 (std::declval<_ArgTypes>()...) );
+      template<typename _Func,
+	       typename _Res2 = typename result_of<_Func(_ArgTypes...)>::type>
+	struct _Callable : __check_func_return_type<_Res2, _Res> { };
 
       // Used so the return type convertibility checks aren't done when
       // performing overload resolution for copy construction/assignment.
       template<typename _Tp>
-	using _NotSelf = __not_<is_same<_Tp, function>>;
-
-      template<typename _Functor>
-	using _Callable
-	  = __and_<_NotSelf<_Functor>,
-		   __check_func_return_type<_Invoke<_Functor>, _Res>>;
+	struct _Callable<function, _Tp> : false_type { };
 
       template<typename _Cond, typename _Tp>
 	using _Requires = typename enable_if<_Cond::value, _Tp>::type;
@@ -2054,6 +2049,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
        *  reference_wrapper<F>, this function will not throw.
        */
       template<typename _Functor,
+	       typename = _Requires<__not_<is_same<_Functor, function>>, void>,
 	       typename = _Requires<_Callable<_Functor>, void>>
 	function(_Functor);
 
@@ -2246,7 +2242,7 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
     }
 
   template<typename _Res, typename... _ArgTypes>
-    template<typename _Functor, typename>
+    template<typename _Functor, typename, typename>
       function<_Res(_ArgTypes...)>::
       function(_Functor __f)
       : _Function_base()
diff --git a/libstdc++-v3/include/std/mutex b/libstdc++-v3/include/std/mutex
index deb85df..b80a8a0 100644
--- a/libstdc++-v3/include/std/mutex
+++ b/libstdc++-v3/include/std/mutex
@@ -114,7 +114,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    * @{
    */
 
-  /// mutex
+  /// The standard mutex type.
   class mutex : private __mutex_base
   {
   public:
@@ -158,7 +158,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return &_M_mutex; }
   };
 
-  /// recursive_mutex
+  /// The standard recursive mutex type.
   class recursive_mutex : private __recursive_mutex_base
   {
   public:
@@ -243,7 +243,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	}
     };
 
-  /// timed_mutex
+  /// The standard timed mutex type.
   class timed_mutex
   : private __mutex_base, public __timed_mutex_impl<timed_mutex>
   {
@@ -295,7 +295,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return &_M_mutex; }
   };
 
-  /// recursive_timed_mutex
+  /// The standard recursive timed mutex type.
   class recursive_timed_mutex
   : private __recursive_mutex_base,
     public __timed_mutex_impl<recursive_timed_mutex>
@@ -360,13 +360,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// and manage it.
   struct adopt_lock_t { };
 
+  /// Tag used to prevent a scoped lock from acquiring ownership of a mutex.
   constexpr defer_lock_t	defer_lock { };
+
+  /// Tag used to prevent a scoped lock from blocking if a mutex is locked.
   constexpr try_to_lock_t	try_to_lock { };
+
+  /// Tag used to make a scoped lock take ownership of a locked mutex.
   constexpr adopt_lock_t	adopt_lock { };
 
-  /// @brief  Scoped lock idiom.
-  // Acquire the mutex here with a constructor call, then release with
-  // the destructor call in accordance with RAII style.
+  /** @brief A movable scoped lock type.
+   *
+   * A unique_lock controls mutex ownership within a scope. Ownership of the
+   * mutex can be delayed until after construction and can be transferred
+   * to another unique_lock by move construction or move assignment. If a
+   * mutex lock is owned when the destructor runs ownership will be released.
+   */
   template<typename _Mutex>
     class lock_guard
     {
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
index 183179f..77bddc3 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset
+++ b/libstdc++-v3/include/tr2/dynamic_bitset
@@ -593,6 +593,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  @param  __str  A string of '0' and '1' characters.
        *  @param  __pos  Index of the first character in @p __str to use.
        *  @param  __n    The number of characters to copy.
+       *  @param  __zero The character to use for unset bits.
+       *  @param  __one  The character to use for set bits.
+       *  @param  __alloc An allocator.
        *  @throw  std::out_of_range  If @p __pos is bigger the size of @p __str.
        *  @throw  std::invalid_argument  If a character appears in the string
        *                                 which is neither '0' nor '1'.
diff --git a/libstdc++-v3/scripts/run_doxygen b/libstdc++-v3/scripts/run_doxygen
index 461adaa..021ebd0 100644
--- a/libstdc++-v3/scripts/run_doxygen
+++ b/libstdc++-v3/scripts/run_doxygen
@@ -334,6 +334,23 @@ for f in *__profile_*; do
     mv $f $newname
 done
 
+# Remove inline namespaces used for versioning.
+for f in *_V2_*; do
+    newname=`echo $f | sed 's/_V2_/::/'`
+    sed 's/::_V2::/::/g' $f > $newname
+    rm $f
+done
+for f in *_experimental_filesystem_v?_*; do
+    newname=`echo $f | sed 's/_filesystem_v._/::filesystem::/'`
+    sed 's/::filesystem::v.::/::filesystem::/g' $f > $newname
+    rm $f
+done
+for f in *experimental_fundamentals_v?_*; do
+    newname=`echo $f | sed 's/experimental_.*_v[[:digit:]]_/experimental::/'`
+    sed 's/::experimental::fundamentals_v[[:digit:]]::/::experimental::/g' $f > $newname
+    rm $f
+done
+
 # Then, clean up other top-level namespaces.
 for f in std_tr1_*; do
     newname=`echo $f | sed 's/^std_tr1_/std::tr1::/'`
diff --git a/libstdc++-v3/src/c++11/futex.cc b/libstdc++-v3/src/c++11/futex.cc
index e04dba8..e723364 100644
--- a/libstdc++-v3/src/c++11/futex.cc
+++ b/libstdc++-v3/src/c++11/futex.cc
@@ -52,7 +52,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	// we will fall back to spin-waiting.  The only thing we could do
 	// here on errors is abort.
 	int ret __attribute__((unused));
-	ret = syscall (SYS_futex, __addr, futex_wait_op, __val);
+	ret = syscall (SYS_futex, __addr, futex_wait_op, __val, nullptr);
 	_GLIBCXX_DEBUG_ASSERT(ret == 0 || errno == EINTR || errno == EAGAIN);
 	return true;
       }
diff --git a/libstdc++-v3/testsuite/20_util/bind/68912.cc b/libstdc++-v3/testsuite/20_util/bind/68912.cc
new file mode 100644
index 0000000..7a00b75
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/bind/68912.cc
@@ -0,0 +1,53 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include<functional>
+
+struct Wrong {};
+struct A {};
+struct B {};
+struct C{};
+struct D{};
+
+struct X {
+  A operator()(int, double) & { return {}; }
+  Wrong operator()(int, double) && {return {}; }
+
+  B operator()(int, double) const & { return {}; }
+  Wrong operator()(int, double) const && {return {}; }
+
+  C operator()(int, double) volatile & { return {}; }
+  Wrong operator()(int, double) volatile && {return {}; }
+
+  D operator()(int, double) const volatile & { return {}; }
+  Wrong operator()(int, double) const volatile && {return {}; }
+};
+
+void test01()
+{
+  auto bound = std::bind(X{}, 5, std::placeholders::_1);
+  A res = bound(1.0);
+  const auto bound_c = bound;
+  B res_c = bound_c(1.0);
+  volatile auto bound_v = bound;
+  C res_v = bound_v(1.0);
+  volatile const auto bound_cv = bound;
+  D res_cv = bound_cv(1.0);
+}
diff --git a/libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc b/libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc
new file mode 100644
index 0000000..ea0f28d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc
@@ -0,0 +1,56 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <memory>
+#include <testsuite_hooks.h>
+
+struct A : std::enable_shared_from_this<A>
+{
+    void* a() { return shared_from_this().get(); }
+};
+
+struct B : std::enable_shared_from_this<B>
+{
+};
+
+struct D : A, B
+{
+};
+
+void test01()
+{
+  bool test = false;
+
+  auto d = std::make_shared<D>();
+  try
+  {
+      d->a();
+  }
+  catch (const std::bad_weak_ptr&)
+  {
+    test = true;
+  }
+  VERIFY(test);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/function/68995.cc b/libstdc++-v3/testsuite/20_util/function/68995.cc
new file mode 100644
index 0000000..75dafb4
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function/68995.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <tr1/memory>
+#include <functional>
+#include <tr1/functional>
+
+std::tr1::shared_ptr<int> test() { return {}; }
+
+std::function<std::tr1::shared_ptr<int>()> func = test;
+std::function<std::tr1::shared_ptr<int>()> funcr = std::ref(test);
+
+void test2(std::tr1::shared_ptr<int>) { }
+
+std::function<void(std::tr1::shared_ptr<int>)> func2 = std::ref(test2);
diff --git a/libstdc++-v3/testsuite/20_util/function/69222.cc b/libstdc++-v3/testsuite/20_util/function/69222.cc
new file mode 100644
index 0000000..7c9dfec
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function/69222.cc
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <functional>
+
+// Reduced from c++/69005
+struct Foo {
+  std::function<void(Foo)> f;
+};
+
+extern Foo exfoo;
+Foo f(exfoo);
+Foo& r = f = exfoo;
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc
index 42714a9..9486974 100644
--- a/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc
@@ -51,6 +51,14 @@ namespace std
         allocated = false;
       }
 
+      template<typename _Up, typename... _Args>
+        void construct(_Up* __p, _Args&&... __args)
+        { ::new(__p) _Up(std::forward<_Args>(__args)...); }
+
+      template<typename _Up>
+        void destroy(_Up* __p)
+        { __p->~_Up(); }
+
       static char storage[sizeof(spcd)];
       static bool allocated;
     };
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc
new file mode 100644
index 0000000..483708b
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc
@@ -0,0 +1,58 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// PR libstdc++/69092
+
+#include <string>
+#include <iterator>
+
+struct hate_T_iterator : std::iterator<std::forward_iterator_tag, char> {
+    explicit hate_T_iterator(char* p) : p(p) {}
+    char* p;
+
+    hate_T_iterator& operator++() { ++p; return *this; }
+
+    hate_T_iterator operator++(int)
+    {
+      hate_T_iterator r = *this;
+      ++*this; return r;
+    }
+
+    char& operator*() const
+    {
+      if (*p == 'T')
+        throw 1;
+      return *p;
+    }
+
+    char* operator->() const { return p; }
+
+    bool operator== (hate_T_iterator other) const { return p == other.p;}
+    bool operator!= (hate_T_iterator other) const { return p != other.p;}
+};
+
+int main()
+{
+  char test_str[4] = "ATA";
+  try {
+    std::string s(hate_T_iterator(test_str), hate_T_iterator(test_str+3));
+  }
+  catch(int) {
+  }
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc b/libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc
new file mode 100644
index 0000000..16a7896
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++98 -ffast-math" }
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  long double ld = -5.3165867831218916301793863361917824e-2467L;
+  VERIFY( std::signbit(ld) == 1 );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/69116.cc b/libstdc++-v3/testsuite/26_numerics/valarray/69116.cc
new file mode 100644
index 0000000..ef98267
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/69116.cc
@@ -0,0 +1,53 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+// libstdc++/69116
+
+#include <exception>
+#include <valarray>
+
+template<typename T>
+  void foo(const T&) { }
+
+struct X : std::exception // makes namespace std an associated namespace
+{
+  virtual void pure() = 0;
+
+  typedef void(*func_type)(const X&);
+
+  void operator+(func_type) const;
+  void operator-(func_type) const;
+  void operator*(func_type) const;
+  void operator/(func_type) const;
+  void operator%(func_type) const;
+  void operator<<(func_type) const;
+  void operator>>(func_type) const;
+};
+
+void foo(X& x)
+{
+  x + foo;
+  x - foo;
+  x * foo;
+  x / foo;
+  x % foo;
+  x << foo;
+  x >> foo;
+}
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc
new file mode 100644
index 0000000..9e7a9a7
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 28.11.2 regex_match
+
+#include <regex>
+#include <testsuite_hooks.h>
+#include <testsuite_regex.h>
+
+using namespace __gnu_test;
+using namespace std;
+
+// libstdc++/68863
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  VERIFY(!std::regex_match("aa", std::regex("(.)(?!\\1).")));
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/28_regex/regression.cc b/libstdc++-v3/testsuite/28_regex/regression.cc
index 71d82d5..660d170 100644
--- a/libstdc++-v3/testsuite/28_regex/regression.cc
+++ b/libstdc++-v3/testsuite/28_regex/regression.cc
@@ -33,10 +33,26 @@ test01()
   regex re("((.)", regex_constants::basic);
 }
 
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::string re_str
+    {
+      "/abcd" "\n"
+      "/aecf" "\n"
+      "/ghci"
+    };
+  auto rx = std::regex(re_str, std::regex_constants::grep | std::regex_constants::icase);
+  VERIFY(std::regex_search("/abcd", rx));
+}
+
 int
 main()
 {
   test01();
+  test02();
   return 0;
 }
 
