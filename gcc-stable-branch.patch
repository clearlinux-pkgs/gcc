Alexander Monakov (1):
      sel-sched: allow negative insn priority (PR 88879)

Andrea Corallo (1):
      Backport fix for PR jit/91928

Andreas Krebbel (7):
      re PR rtl-optimization/88751 (Performance regression reload vs lra)
      S/390: Add support for z15 as CPU name.
      IBM Z: Use tree_fits_uhwi_p in vector_alignment hook
      IBM Z: Fix testsuite useable_hw check
      IBM Z: gen-vect-11/32: Set min-vect-loop-bound param back to default
      IBM Z: gen-vect-26/28: Vectorizing without peeling is ok for Z
      Fix PR92950: Wrong code emitted for movv1qi

Bernd Edlinger (4):
      backport: re PR tree-optimization/91109 ([arm] gcc.c-torture/execute/20040709-1.c fails since r273135)
      backport: re PR tree-optimization/91109 ([arm] gcc.c-torture/execute/20040709-1.c fails since r273135)
      backport: re PR fortran/91716 (ICE in output_constant, at varasm.c:5026)
      Avoid collect2 calling signal unsafe functions and/or unlink with uninitialized memory

Bill Schmidt (2):
      backport: re PR target/91275 (__builtin_crypto_vpmsumd gives different results -O[123] vs -O0)
      backport: re PR testsuite/92093 (New test case gcc.target/powerpc/pr91275.c from r276410 fails on BE)

Carl Love (1):
      PPC64, fix documentation for __builtin_crypto_vpmsum* builtin functions.

Christophe Lyon (2):
      ARM: Add support for -mpure-code in thumb-1 (v6m)
      ARM: Fix -mpure-code for v6m

Claudiu Zissulescu (2):
      [ARC] Backport from mainline r278056,r278057
      [ARC] Enable using DCMPF for hard float comparisons (backports)

Dragan Mladjenovic (4):
      Backprot fix for uninitialised use in mips_split_move
      Backport fix for PR target/91769
      Backport fix for PR89245
      Sanitize the constant argument for rotr<mode>3

Edward Smith-Rowland (1):
      Update docs for p858 - Constexpr iterator changes available since 9.1.

Eric Botcazou (18):
      re PR rtl-optimization/91347 (hppa: wrong code generated with tail call optimisation)
      re PR target/91472 (gmp testsuite segfaults with gcc-8 and gcc-9, works fine with gcc-7)
      re PR rtl-optimization/89795 (wrong code with -O2 -fno-dce -fno-forward-propagate -fno-sched-pressure)
      re PR target/91269 (unaligned floating-point register with -mcpu=niagara4 -fcall-used-g6)
      trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep on the underlying type of the node.
      decl.c (annotate_value): Really test the sign of the value when deciding to build a NEGATE_EXPR.
      re PR ada/91995 (gnat miscompilation and bootstrap failure on m68k-linux)
      re PR tree-optimization/92131 (incorrect assumption that (ao >= 0) is always false)
      re PR target/92095 (internal error with -O1 -mcpu=niagara2 -fPIE)
      overflow-1.c: Add -fno-pie to the options.
      c-ada-spec.c (get_underlying_decl): Do not look through typedefs.
      * doc/invoke.texi (-gno-internal-reset-location-views): Fix typo.
      re PR ada/92575 (couple of suspicious assignments in expect.c)
      re PR ada/92362 (double elaboration of expression in Address aspect)
      re PR ada/92489 (internal error on Invalid_Value Attribute attribute)
      tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute TYPE_CANONICAL from the element type...
      Fix problematic TLS sequences for the Solaris linker
      Fix link failure with debug info in LTO mode

Eric S. Raymond (1):
      Clean up references to Subversion in documentation sources.

GCC Administrator (205):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Georg-Johann Lay (4):
      avr-mmcu.texi: Re-generate because config/avr/avr-devices.c was changed in r269487.
      backport: re PR target/86040 ([avr]: RAMPZ is not always cleared after loading __flashN data)
      backport: re PR target/92545 (avr: support ATmega devices from the 0-series)
      backport: Add -nodevicespecs option for avr.

H.J. Lu (6):
      [PR87833] x86: Put -fPIC and -shared the last to create offload image
      x86-64: Pass aggregates with only float/double in GPRs for MS_ABI
      i386: Properly pop restore token in signal frame
      i386: Skip ENDBR32 at the target function entry
      x32: Update baseline_symbols.txt
      lto: Also copy .note.gnu.property section

Harald Anlauf (3):
      backport: re PR fortran/91496 (!GCC$ directives error if mistyped or unknown)
      backport: re PR fortran/92629 (internal compiler error: in convert_mpz_to_unsigned, at fortran/simplify.c:173)
      backport: re PR fortran/92898 (ICE in gfc_check_is_contiguous, at fortran/check.c:7157)

Iain Sandoe (25):
      Darwin, libsanitizer - remove reference to __cxa_rethrow_primary_exception.
      [Darwin, PPC] Fix fail of cpp/assert4.c
      [Darwin, fixincludes] Backport fix for PR83531
      [c-family] Backport fix for PCH / PR61250.
      [Darwin, opts processing] Fix missing RejectNegative etc.
      [Darwin, specs] Backport fixes for driver handling of PIE options.
      [Darwin] Pick up SDKROOT as the sysroot fallback.
      [Darwin] Update machopic_legitimize_pic_address.
      [Darwin] Amend section for constants with relocations.
      [Darwin, PPC] Check for out of range asm values.
      [Darwin, machopic] Preparatory patches.
      [Darwin, machopic] Fix for 67183
      [Darwin, PPC] Fix PR 65342.
      [Darwin] Use of symbol stubs should depend on the linker in use.
      [Darwin] The need for FDE symbols is dependent on linker used, not OS rev.
      [Darwin, PPC] Move the out of line register save/restore to an endfile.
      [Darwin, PPC] Move the out of line register save/restore to an endfile.
      [Darwin] Some TLC for older Darwin versions.
      [Darwin] Fix Objective-C NeXT ABI version check diagnostics.
      [Darwin, machopic] Back out part of PR71767 fix.
      [testsuite] Make the Wnonnull test independent of system headers.
      [objective-c/c++, testsuite] Fix stubify tests for -fnext-runtime.
      [Darwin, PPC] Use Darwin9 bundle header for Rosetta builds.
      [testsuite, Darwin] Fix failing darwin-version-1.c.
      Darwin, libsanitizer: Update minimum supported system version.

Ian Lance Taylor (4):
      go/internal/gccgoimporter: support embedded field in pointer loop
      re PR go/91621 (libgo/mksysinfo.sh: please avoid test ==)
      compiler: don't inline integer expressions with named types
      compiler: fix loopdepth tracking in array slicing expression in escape analysis

Ilya Leoshkevich (3):
      Move jump threading before reload
      S/390: Fix failing RTL check in s390_canonicalize_comparison
      Free dominance info at the beginning of pass_jump_after_combine

Jakub Jelinek (108):
      * BASE-VER: Set to 9.2.1.
      baseline_symbols.txt: Update.
      re PR tree-optimization/91597 (GCC miscompiles a branch depending on a pointer tag)
      re PR target/91704 ([X86] Codegen for _mm256_cmpgt_epi8 is affected by -funsigned-char)
      re PR target/87853 (_mm_cmpgt_epi8 broken with -funsigned-char)
      backport: quadmath.h (M_Eq, [...]): Use two more decimal places.
      backport: re PR c/91401 (schedule + dist_schedule clauses rejected on distribute parallel for)
      backport: re PR go/91617 (Many go test case failures after r275026)
      backport: re PR lto/91572 (lto1: error: type variant has different ‘TREE_TYPE’ since r269862)
      backport: re PR middle-end/91623 (-msse4.1 -O3 segfault in /usr/lib/gcc/x86_64-pc-linux-gnu/8.3.0/include/smmintrin.h:270:10)
      backport: re PR tree-optimization/91632 (Probably wrong code since r275026)
      backport: re PR middle-end/91001 (internal compiler error: in extract_insn, at recog.c:2310)
      backport: re PR tree-optimization/91665 (ICE in build_vector_from_val, at tree.c:1904)
      backport: re PR tree-optimization/91723 (builtin fma is not optimized or vectorized as *+)
      backport: re PR rtl-optimization/89435 (wrong code with -O1 -march=armv4 -fno-forward-propagate with __builtin_sub_overflow())
      backport: re PR middle-end/91920 (ggc 9.2.0 failing openmp compile on ppc64le)
      backport: re PR c++/88203 (assert does not compile with OpenMP's pragma omp parallel for default(none))
      backport: re PR bootstrap/90543 (Build failure on MINGW for gcc-9.1.0)
      backport: re PR c++/91925 (-fpack-struct causes a decltype with template to ICE)
      backport: re PR c++/91974 (function not sequenced before function argument)
      backport: re PR tree-optimization/91734 (gcc skip an if statement  with "-O1 -ffast-math")
      backport: re PR fortran/87752 (ICE in omp_add_variable, at gimplify.c:6776)
      backport: re PR tree-optimization/92056 (ice in expr_object_size, at tree-object-si ze.c:675 with -O3)
      re PR c++/92201 (ICE: ‘verify_gimple’ failed with -std=c++2a)
      backport: re PR c++/92015 (internal compiler error: in cxx_eval_array_reference, at cp/constexpr.c:2568)
      backport: re PR sanitizer/92154 (new glibc breaks arm bootstrap due to libsanitizer)
      backport: re PR tree-optimization/85887 (Missing DW_TAG_lexical_block PC range)
      backport: locales.c (iso_3166): Add missing comma after "United-States".
      backport: install.texi (--enable-offload-targets): Fix up a typo in the example, use actual names of supported offload targets.
      backport: re PR c++/90947 (Simple lookup table of array of strings is miscompiled)
      backport: re PR middle-end/92231 (ICE in gimple_fold_stmt_to_constant_1)
      backport: re PR preprocessor/92296 (internal compiler error: Segmentation fault  #pragma push_macro("__LINE__"))
      backport: re PR c++/92343 ([[likely]]/[[unlikely]] prevent method from being a constant expression)
      re PR middle-end/92384 (Empty class instances have different equal testing result among GCC versions)
      re PR middle-end/91450 (__builtin_mul_overflow(A,B,R) wrong code if product < 0, *R is unsigned, and !(A&B))
      backport: re PR c++/92504 (ICE on gcc-9 -fopenmp: internal compiler error: tree check: expected tree that contains 'decl common' structure, have 'baselink' in get_inner_reference, at expr.c:7238)
      re PR c/90898 (ICE in insert_clobber_before_stack_restore, at tree-ssa-ccp.c:2112)
      re PR target/90867 (Multiplication or typecast of integer and double always zero when...)
      re PR middle-end/90840 (ICE in simplify_subreg, at simplify-rtx.c:6441)
      re PR c++/90767 (jumbled error message with this and const)
      re PR tree-optimization/91355 (optimized code does not call destructor while unwinding after exception)
      backport: re PR c++/90842 (ICE in poplevel, at cp/decl.c:585)
      backport: re PR c/90677 (gcc-9.1.0 fails to build __gcc_diag__ souce: error: 'cgraph_node' is not defined as a type)
      backport: re PR inline-asm/92615 (ICE in extract_insn)
      backport: re PR tree-optimization/92644 (ICE in wide_int_to_tree_1, at tree.c:1530)
      backport: re PR sanitizer/92154 (new glibc breaks arm bootstrap due to libsanitizer)
      backport: re PR c++/61414 (enum class bitfield size-checking needs a separate warning flag controlling it)
      backport: re PR c++/92648 (Handling of unknown attributes)
      backport: re PR debug/92664 (Wrong .debug_line section information when compiling stdin input with -g3)
      backport: re PR c++/92524 (ICE in short program with constexpr and std::array)
      backport: re PR fortran/91944 (ICE in gfc_conv_array_initializer, at fortran/trans-array.c:6156)
      backport: re PR c++/92695 (P1064R0 - virtual constexpr fails if object taken from array)
      backport: re PR c++/60228 (ICE using lambda in #pragma omp declare reduction)
      backport: re PR c++/92695 (P1064R0 - virtual constexpr fails if object taken from array)
      backport: re PR c++/92695 (P1064R0 - virtual constexpr fails if object taken from array)
      backport: re PR c++/92732 (Bit-field of scoped enumeration type cannot be initialized)
      re PR fortran/92756 (ICE in lower_omp, at omp-low.c:12988)
      backport: re PR fortran/92781 (ICE in convert_nonlocal_reference_op, at tree-nested.c:1065)
      backport: re PR fortran/92775 (Incorrect expression in DW_AT_byte_stride on an array)
      backport: PR c++/92831 - CWG 1299, not extending temporary lifetime for ?:
      backport: re PR target/92723 (ICE in expand_shift_1, at expmed.c:2635)
      backport: re PR fortran/92899 ([OpenMP] ICE in gfc_trans_omp_atomic, at fortran/trans-openmp.c:3769)
      backport: re PR target/92904 (varargs for __int128 is placed at an unaligned location and uses movdqa for the load)
      backport: re PR tree-optimization/92930 (GCC incorrectly optimizes away __builtin_apply() calls)
      backport: re PR ipa/92357 (ICE in IPA pass fnsummary in openmp offload)
      backport: re PR fortran/92977 (ICE in gfc_trans_omp_atomic, at fortran/trans-openmp.c:3526)
      re PR c/90677 (gcc-9.1.0 fails to build __gcc_diag__ souce: error: 'cgraph_node' is not defined as a type)
      re PR c++/92992 (Side-effects dropped when decltype(nullptr) typed expression is passed to ellipsis)
      re PR c++/92438 (Function declaration parsed incorrectly with `-std=c++1z`)
      re PR libgomp/93065 (libgomp: destructor missing to delete goacc_cleanup_key)
      re PR ipa/93087 (Bogus `-Wsuggest-attribute=cold` on function already marked as `__attribute__((cold))`)
      re PR rtl-optimization/93088 (Compile time hog on gcc/testsuite/gcc.target/i386/pr56348.c w/ -O3 -funroll-loops -fno-tree-dominator-opts -fno-tree-vrp)
      re PR inline-asm/93202 ([RISCV] ICE when using inline asm 'h' operand modifier)
      re PR libgomp/93219 (unused return value in affinity-fmt.c)
      i386: Fix wrong-code x86 issue with avx512{f,vl} fma PR93009
      c++: Fix deprecated attribute handling on templates (PR c++/93228)
      powerpc: Fix ICE with fp conditional move (PR target/93073)
      riscv: Fix up riscv_rtx_costs for RTL checking (PR target/93333)
      openmp: Teach omp_code_to_statement about rest of OpenMP statements
      openmp: Fix up !$omp target parallel handling
      i386: Fix up -fdollars-in-identifiers with identifiers starting with $ in -masm=att [PR91298]
      aarch64: Fix aarch64_expand_subvti constant handling [PR93335]
      Cherry-pick 15 bugfixes from mainline
      postreload: Fix up postreload combine [PR93402]
      i386: Fix ix86_fold_builtin shift folding [PR93418]
      openmp: Handle rest of EXEC_OACC_* in oacc_code_to_statement [PR93463]
      openmp: c++: Consider typeinfo decls to be predetermined shared [PR91118]
      combine: Punt on out of range rotate counts [PR93505]
      openmp: Avoid ICEs with declare simd; declare simd inbranch [PR93555]
      c++: Mark __builtin_convertvector operand as read [PR93557]
      openmp: Notice reduction decl in outer contexts after adding it to shared [PR93515]
      openmp: Fix handling of non-addressable shared scalars in parallel nested inside of target [PR93515]
      i386: Make xmm16-xmm31 call used even in ms ABI [PR65782]
      i386: Fix -mavx -mno-mavx2 ICE with VEC_COND_EXPR [PR93637]
      i386: Fix up vec_extract_lo* patterns [PR93670]
      i386: Fix k*shift* intrinsics [PR93673]
      i386: Fix up _mm*_mask_popcnt_epi* [PR93696]
      c: Fix ICE with cast to VLA [93576]
      c++: Fix thinko in enum_min_precision [PR61414]
      match.pd: Disallow side-effects in GENERIC for non-COND_EXPR to COND_EXPR simplifications [PR93744]
      combine: Fix find_split_point handling of constant store into ZERO_EXTRACT [PR93908]
      c++: Fix rejects-valid bug in cxx_eval_outermost_constant_expr [PR93905]
      store-merging: Fix coalesce_immediate_stores [PR93820]
      sccvn: Punt on ref->size not multiple of 8 for memset (, 123, ) in 9.x [PR93945]
      gimplify: Don't optimize register const vars to static [PR93949]
      explow: Fix ICE caused by plus_constant [PR94002]
      maintainer-scripts: Speed up git clone in gcc_release
      i386: Fix some -O0 avx2intrin.h and xopintrin.h intrinsic macros [PR94046]

Jan Hubicka (3):
      Backport ggc_trim 	Backport from mainline
      free summary vectors.
      Avoid gimple body modifications while streaming.

Janne Blomqvist (2):
      PR fortran/91414 Improve initialization of PRNG
      PR fortran/91414 Correctly fill master_state from os_seed.

Jason Merrill (32):
      PR c++/90538 - multiple expansions of capture packs
      PR c++/91378 - ICE with noexcept and auto return type.
      PR c++/90393 - ICE with throw in ?:
      PR c++/92150 - partial specialization with class NTTP.
      PR c++/92446 - deduction of class NTTP.
      PR c++/92859 - ADL and bit-field.
      PR c++/57082 - new X{} and private destructor.
      PR c++/93286 - ICE with __is_constructible and variadic template.
      PR c++/92531 - ICE with noexcept(lambda).
      PR c++/91476 - anon-namespace reference temp clash between TUs.
      c++: Unshare expressions from constexpr cache.
      c++: Fix ICE with lambda in member operator (PR93279)
      c++: Fix array of char typedef in template (PR90966).
      c++: Function declared with typedef with eh-specification.
      c++: Allow template rvalue-ref conv to bind to lvalue ref.
      c++: Drop alignas restriction for stack variables.
      c++: Preserve location in maybe_constant_value.
      c++: Fix decltype of empty pack expansion of parm.
      c++: Fix constexpr vs. omitted aggregate init.
      cgraph: A COMDAT decl always has non-zero address.
      c++: Fix attributes with lambda and trailing return type.
      PR c++/90732 - ICE with VLA capture and generic lambda.
      c++: Fix return deduction of lambda in discarded stmt.
      checking: avoid verify_type_variant crash on incomplete type.
      c++: Fix cast to pointer to VLA.
      c++: Allow parm of empty class type in constexpr.
      c++: Fix ({ ... }) array mem-initializer.
      c++: avoid ICE with __builtin_memset (PR90997).
      c++: Fix [[no_unique_address]] and default mem-init [PR90432]
      c++: Fix constexpr ICE from const mismatch [PR91607]
      c++: Fix SFINAE for invalid non-type tparm types.
      c++: Avoid ICE on infinite recursion with concepts.

Jerry DeLisle (2):
      backport: re PR libfortran/92100 (Formatted stream IO irreproducible read with binary data in file)
      Bug 93234 - INQUIRE on pre-assigned files of ROUND and SIGN properties fails

Jiufu Guo (2):
      backport: re PR target/70010 (powerpc: -flto forgets 'no-vsx' function attributes)
      rs6000: mark clobber for registers changed by untpyed_call

John David Anglin (20):
      pa.c (pa_trampoline_init): Remove spurious extended character.
      lib2funcs.S (__gcc_plt_call): Load branch target to %r21.
      pa.c (pa_output_call): Load descriptor address to register %r22.
      fptr.c (_dl_read_access_allowed): Change argument to unsigned int.
      pa.c (pa_output_indirect_call): Fix typos in last change.
      baseline_symbols.txt: Update.
      backport: pa.h (MAX_PCREL17F_OFFSET): Adjust.
      backport: pa.c (pa_output_call): Remove 64-bit sibcall sequence.
      backport: pa.md (memory_barrier): Revise to use ldcw barriers.
      linux-atomic.c (__kernel_cmpxchg): Change argument 1 to volatile void *.
      backport: re PR libgomp/93066 (libgomp/target.c:525:46: error: expected expression before ')' token)
      re PR target/93111 (FAIL: gfortran.fortran-torture/compile/pr32663.f,  -O3 -g   (internal compiler error))
      re PR target/67834 (Local references inside comdat groups)
      pa.md: Revert change to use ordered_comparison_operator instead of...
      Fix ICE in pa_elf_select_rtx_section.
      Fix handling of floating-point homogeneous aggregates.
      Disable gnat.dg/socket1.adb on hppa*-*-hpux*.
      Skip charset.cc tests on *-*-hpux*.
      Fix libbacktrace build on hppa-hpux.
      Fix/skip various tests for hppa*-*-hpux*.

Jonathan Wakely (48):
      PR libstdc++/90361 add missing macro definition
      PR c++/91436 fix C++ dialect for std::make_unique fix-it hint
      Implement new serial algorithms from Parallelism TS (P0024R2)
      Fix markdown in Doxygen comments for std::reduce
      Update ABI baselines for x86 and powerpc GNU targets
      PR libstdc++/91067 add more missing exports for directory iterators
      Update libstdc++ docs for library version bumps
      Fix Xmethod for shared_ptr::use_count()
      PR libstdc++/91748 fix std::for_each_n for random access iterators
      PR libstdc++/92059 fix several bugs in tr2::dynamic_bitset
      P1651R0 bind_front should not unwrap reference_wrapper
      Fix array index error in address_v6 comparisons
      Include netinet/in.h in include/experimental/internet
      PR libstdc++/91456 make INVOKE<R> work with uncopyable prvalues
      Update URL for Hoard in libstdc++ docs
      Update URL for CUJ article in libstdc++ docs
      Add makefile target to update HTML files in source tree
      Fix testsuite bugs
      Fix more tests that fail in C++2a mode
      PR libstdc++/92143 adjust for OS X aligned_alloc behaviour
      Do not declare std::uses_allocator before C++11
      PR libstdc++/89164 enforce constraints for uninitialized algos
      Fix indentation in testsuite utility header
      Fix tests that fail with -std=gnu++98 or -std=gnu++11
      Fix more failing tests for C++98 mode
      PR libstdc++/61761 fix std::proj for targets without C99 cproj
      PR libstdc++/90682 allow set_terminate(0) and set_unexpected(0)
      PR libstdc++/92267 fix ABI change in deque iterators
      libstdc++: fix buffer overflow in path::operator+= (PR92853)
      PR libstdc++/91786 fix compilation error with Clang
      libstdc++: Fix whitepace in changelog
      libstdc++: Fix error handling in filesystem::remove_all (PR93201)
      libstdc++: Define memory resource key functions non-inline (PR93208)
      libstdc++: Fix documentation claiming to refer to mainline
      Build filesystem library with large file support
      libstdc++: Fix recent documentation changes
      libstdc++: Simplify makefile rule for largefile-config.h (PR91947)
      PR libstdc++/78552 only construct std::locale for C locale once
      libstdc++: Fix freestanding build (PR 92376)
      libstdc++: Fix regressions in unique_ptr::swap (PR 93562)
      libstdc++: Replace glibc-specific check for clock_gettime (PR 93325)
      libstdc++: Fix description of std::ios::trunc (PR 92886)
      libstdc++: Fix undefined behaviour in random dist serialization (PR93205)
      libstdc++: Avoid using sizeof with function types (PR 93470)
      libstdc++: make negative count safe with std::for_each_n
      Add 'noexcept' to std::lerp
      PR libstdc++/91910 fix data race in Debug Mode destructors
      libstdc++: Fix some warnings in filesystem tests

Joseph Myers (15):
      * zh_CN.po: Update.
      Fix libstdc++ lstat missing return type for Windows target.
      * es.po: Update.
      * es.po: Update.
      * es.po: Update.
      * fi.po: Update.
      Document -Wc11-c2x-compat.
      * fi.po: Update.
      Update gcc_release to mainline version.
      Fix libdecnumber handling of non-canonical BID significands (PR middle-end/91226).
      Fix handling of overflow in C casts in integer constant expressions (PR c/93241).
      Fix setting of DECL_CONTEXT in pushdecl (PR c/93072).
      Update GCC zh_TW.po.
      Fix ICE with cast of division by zero (PR c/93348).
      Revert "setup branch"

Kewen Lin (1):
      Fix PR91790 by considering different first_stmt_info for realign

Kito Cheng (3):
      RISC-V: Fix bad insn splits with paradoxical subregs.
      RISC-V: Fix more splitters accidentally calling gen_reg_rtx.
      RISC-V: Disallow regrenme if the TO register never used before for interrupt functions

Kyrylo Tkachov (3):
      [arm] Fix use of CRC32 intrinsics with Armv8-a and hard-float
      driver: Also prune joined switches with negation
      [AArch64] Don't split 64-bit constant stores to volatile location

Li Jia He (1):
      [rs6000]Fix PR92098 by backporting vec_cmp and vcond_mask supports to gcc-9-branch

Marek Polacek (18):
      PR c++/81429 - wrong parsing of constructor with C++11 attribute.
      PR c++/87519 - bogus warning with -Wsign-conversion.
      PR c++/90473 - wrong code with nullptr in default argument.
      PR c++/90884 - stray note with -Wctor-dtor-privacy.
      PR c++/91521 - wrong error with operator->.
      PR c++/91129 - wrong error with binary op in template argument.
      PR c++/91705 - constexpr evaluation rejects ++/-- on floats.
      PR c++/91923 - failure-to-SFINAE with class type NTTP in C++17.
      PR c++/91740 - ICE with constexpr call and ?: in ARRAY_REF.
      PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr.
      PR c++/92062 - ODR-use ignored for static member of class template.
      * decl.c (reshape_init_r): Add missing space.
      PR c++/90998 - ICE with copy elision in init by ctor and -Wconversion.
      PR c++/92745 - bogus error when initializing array of vectors.
      c++: Fix mismatch in template argument deduction [PR90505]
      c++: Fix value-init crash in template [PR93676]
      sanopt: Avoid crash on anonymous parameter [PR93436]
      c++: Fix ICE in tsubst_copy with parenthesized expression [PR93299]

Mark Eggleston (6):
      Fortran: PR93263 -fno-automatic and RECURSIVE
      PR Fortran/93263 Correct test case
      [fortran] ICE in gfc_validate_kind(): Got bad kind [PR93580]
      [Fortran] ICE assign character pointer to non target PR93714
      [fortran] xfail no longer necessary in typebound_call_22.f03
      fortran: ICE using SHAPE with FINDLOC PR93835

Martin Jambor (2):
      IPA-CP: Remove bogus static keyword (PR 92971)
      IPA: Avoid segfault in devirtualization_time_bonus (PR 93223)

Martin Liska (11):
      Backport r274502
      Backport r274503
      Backport r274504
      Backport r275291
      Backport r275292
      Backport r276141
      Backport r276178
      Backport r278210
      Backport r279306
      Backport f48c6014133c8989702458f9082e34ba6dd326d4
      Backport 08bf7bde9f2987b1c623d272cc71fc14a1622442

Martin Sebor (3):
      backport: re PR c++/90947 (Simple lookup table of array of strings is miscompiled)
      PR c++/90938 - Initializing array with {1} works, but not {0}
      Backport fix for PR c++/93753 from trunk.

Matheus Castanho (1):
      rs6000: fixinc: Skip machine_name fix for powerpc*-*-linux*

Max Filippov (1):
      xtensa: backport fix for PR target/90922

Michael Matz (1):
      re PR middle-end/90796 (GCC: O2 vs O3 output differs on simple test)

Michael Meissner (3):
      Fix bad code of vector extract of PC-relative address with variable element #.
      Adjust how variable vector extraction is done.
      setup branch

Mihail Ionescu (1):
      [arm] Backport -- Fix multilibs for Armv7-R

Mihailo Stojanovic (1):
      mips.md (mips_get_fcsr, [...]): Use SI machine mode for unspec_volatile operand.

Nathan Sidwell (1):
      c++: Bogus error using namespace alias [PR91826]

Oleg Endo (4):
      backport: re PR target/80672 (gcc/config/sh/sh.c:716: prefer compare to find.)
      backport: re PR target/86805 (sh port needs updating for CVE-2017-5753)
      backport: re PR c++/88562 (Incorrect pointer incrementing on SH4)
      backport: re PR target/88630 (Incorrect float negating together with convertion to int on ST-40)

Paul Thomas (6):
      re PR fortran/91589 (ICE in gfc_conv_component_ref, at fortran/trans-expr.c:2447)
      backport: re PR fortran/91588 (ICE in check_inquiry, at fortran/expr.c:2673)
      backport: re PR fortran/86248 (LEN_TRIM in specification expression causes link failure)
      re PR fortran/91926 (assumed rank optional)
      re PR fortran/92753 (ICE in gfc_trans_call, at fortran/trans-stmt.c:392)
      Fix ICE in trans_associate_var

Peter Bergner (10):
      backport: config.gcc: Move -L usage from LINK_OS_EXTRA_SPEC32 and LINK_OS_EXTRA_SPEC64 to...
      [rs6000] PR70010, avoid no-vsx function to be inlined to vsx function
      Backport fix for PR92090.
      rs6000: Fix infinite loop building ghostscript and icu [PR93658]
      rs6000: Fix more testsuite fallout from rs6000_legitimate_address_p() fix. [PR93913]
      Revert "rs6000: Fix more testsuite fallout from rs6000_legitimate_address_p() fix. [PR93913]"
      Revert "rs6000: Fix infinite loop building ghostscript and icu [PR93658]"
      Revert "Adjust how variable vector extraction is done."
      Revert "Fix bad code of vector extract of PC-relative address with variable element #."
      Readd ChangeLog entries for

Prathamesh Kulkarni (1):
      re PR target/90724 (ICE with __sync_bool_compare_and_swap with -march=armv8.2-a+sve)

Przemyslaw Wirkus (2):
      backport: arm: fix v[78]-r multilibs when configured with --with-multlib-list=aprofile
      backport: arm: Fix rmprofile multilibs when architecture includes +mp or +sec (PR target/93188)

Rainer Orth (2):
      Update Solaris baselines for GCC 9.3
      testsuite: xfail gcc.target/i386/pr91298-?.c on Solaris/x86 with as

Richard Biener (18):
      backport: [multiple changes]
      backport: [multiple changes]
      backport: re PR tree-optimization/90637 (ICE in vect_loop_versioning, at tree-vect-loop-manip.c:3055)
      re PR tree-optimization/91568 (internal compiler error: in vect_schedule_slp_instance, at tree-vect-slp.c:3922)
      backport: re PR tree-optimization/90278 (ICE: verify_gimple failed (error: statement marked for throw, but doesn't))
      Backport PRs 91606, 91772, 91790, 91812, 91968
      backport: re PR debug/91887 (-fdebug-types-section ICE building chromium)
      backport: re PR tree-optimization/90930 (Excessive memory consumption)
      revert: re PR tree-optimization/91790 (ICE: verify_ssa failed (error: definition in block 2 follows the use))
      backport: re PR tree-optimization/92222 (ice in useless_type_conversion_p, at gimple-expr.c:86)
      PR middle-end/93246 - missing alias subsets
      middle-end/92674 delay purging EH edges when folding during inlining
      tree-optimization/92704 fix ifcvt ICE with loops without stores
      debug/92763 keep DIEs that might be used in DW_TAG_inlined_subroutine
      middle-end/93054 deal with undefs in call gimplification
      tree-optimization/93439 move clique bookkeeping to OMP expansion
      tree-optimization/93381 fix integer offsetting in points-to analysis
      middle-end/90648 fend off builtin calls with not enough arguments from match

Richard Earnshaw (4):
      [aarch64] PR target/91386 Use copy_rtx to avoid modifying original insns in peep2 pattern
      [arm]  PR target/89400 fix thumb1 unaligned access expansion
      [arm][PR88167] Fix __builtin_return_address returns invalid address
      arm: Fix incorrect modes with 'borrow' operations [PR90311]

Richard Sandiford (6):
      Fix SLP downward group access classification [PR92420]
      Don't pass booleans as mask types to simd clones [PR92710]
      predcom: Fix invalid store-store commoning [PR93434]
      Reject tail calls that read from an escaped RESULT_DECL [PR90313]
      Check for bitwise identity when encoding VECTOR_CSTs [PR92768]
      vect: Fix offset calculation for -ve strides [PR93767]

Roman Zhuykov (3):
      modulo-sched: backport PR92591 fix from mainline
      Backport: rename tests to reference the correct PR
      doc: backport proper description of --enable-checking behavior

Sandra Loosemore (1):
      Fix bugs relating to flexibly-sized objects in nios2 backend.

Segher Boessenkool (6):
      backport: altivec.md (unspec): Delete UNSPEC_DARN...
      backport: re PR target/91481 (POWER9 "DARN" RNG intrinsic produces repeated output (CVE-2019-15847))
      backport: re PR target/91481 (POWER9 "DARN" RNG intrinsic produces repeated output (CVE-2019-15847))
      backport for PR91289
      backport "rs6000: Implement [u]avg<mode>3_ceil"
      backport: rs6000.md (rs6000_set_fpscr_drn): Use ULL on big hexadecimal literal.

Steve Ellcey (1):
      backport: omp-simd-clone.c (simd_clone_adjust_return_type): Remove call to build_distinct_type_copy.

Steven G. Kargl (35):
      re PR fortran/42546 (ALLOCATED statement typo in the docs and for scalar variables)
      re PR fortran/91359 (logical function X returns .TRUE. - Warning:  spaghetti code)
      re PR fortran/87993 (ICE in gfc_constructor_first, at fortran/constructor.c:234)
      re PR fortran/89647 (Host associated procedure unable to be used as binding target)
      re PR fortran/88072 (gfortran crashes with an internal compiler error)
      re PR fortran/87991 (ICE in gfc_constructor_append_expr, at fortran/constructor.c:135)
      re PR fortran/82992 (ICE in create_int_parameter_array, at fortran/module.c:6586)
      re PR fortran/78719 ([F03] ICE in gfc_get_symbol_decl, at fortran/trans-decl.c:1438)
      re PR fortran/78739 (ICE in gfc_get_symbol_decl, at fortran/trans-decl.c:1477)
      re PR fortran/91471 (f951: internal compiler error: gfc_variable_attr(): Bad array reference)
      re PR fortran/91485 (Erroneous conflict between variable x and operator(.x.))
      re PR fortran/91551 (ICE in sort_actual, at fortran/intrinsic.c:4193)
      re PR fortran/91564 (ICE in gimplify_expr, at gimplify.c:14147)
      re PR fortran/91565 (ICE in gfc_simplify_reshape, at fortran/simplify.c:6707 etc.)
      re PR fortran/91587 (ICE in gfc_resolve_filepos, at fortran/io.c:2913)
      re PR fortran/91552 (ICE with valid array constructor)
      re PR fortran/91660 (Missing error on invalid type declaration)
      re PR fortran/91642 (ICE: Bad IO basetype (transfer_expr, at fortran/trans-io.c:2507))
      re PR fortran/91566 (ICE in gfc_constructor_copy, at fortran/constructor.c:103)
      re PR fortran/91553 (ICE in gfc_real2complex, at fortran/arith.c:2208)
      re PR fortran/91727 (ICE in conformable_arrays, at fortran/resolve.c:7490)
      re PR fortran/91641 (ICE in gfc_conv_is_contiguous_expr, at fortran/trans-intrinsic.c:2857)
      re PR fortran/91714 (Accepts type statement without delimiter in free form)
      backport: re PR fortran/91802 (ICE in mio_name_expr_t, at fortran/module.c:2141)
      [multiple changes]
      re PR fortran/91785 (ICE in check_assumed_size_reference, at fortran/resolve.c:1601)
      re PR fortran/91942 (ICE in match_vtag, at fortran/io.c:1485)
      re PR fortran/47054 (Compilation error when cray pointers are declared in both host and internal subroutines)
      re PR fortran/91801 (ICE in gfc_simplify_reshape, at fortran/simplify.c:6733)
      re PR fortran/91649 (ICE in gfc_resolve_findloc, at fortran/iresolve.c:1827)
      re PR fortran/91715 (ICE in resolve_fntype, at fortran/resolve.c:16884)
      re PR fortran/83113 (Bogus "duplicate allocatable attribute" error for submodule character function)
      re PR fortran/69455 ([F08] Assembler error(s) when using intrinsic modules in two BLOCK)
      re PR fortran/92174 (runtime error: index 15 out of bounds for type 'gfc_expr *[15])
      re PR fortran/92897 ([Coarray] ICE in gfc_set_array_spec, at fortran/array.c:864)

Szabolcs Nagy (1):
      [AArch64] PR92424: Fix -fpatchable-function-entry=N,M with BTI

Tamar Christina (2):
      AArch64: Correct HWCAP for fp16fml
      middle-end: Fix logical shift truncation (PR rtl-optimization/91838) (gcc-9 backport)

Thomas Koenig (12):
      backport: re PR fortran/91424 (Extend warnings about DO loops)
      backport: re PR fortran/90561 (ICE in gimplify_var_or_parm_decl, at gimplify.c:2747)
      backport: re PR fortran/90563 (Out of bounds error when compiling with -Wextra)
      backport: re PR fortran/91557 (Bogus warning about unused dummy argument _formal_*)
      backport: re PR fortran/91550 (ICE in do_subscript, at fortran/frontend-passes.c:2652)
      backport: re PR fortran/84487 (Large rodate section increase in 465.tonto with r254427)
      Commit symbol for external BLAS routine when translating MATMUL to *GEMM.
      Put vtab into RO section, same for __def_init if it contains an initializer.
      Fix EOF handling for arrays.
      backport: re PR fortran/91783 (ICE in gfc_dep_resolver, at fortran/dependency.c:2111)
      Catch division by zero errors in array sizes.
      backport: re PR fortran/92961 (ICE in gfc_zero_size_array, at fortran/arith.c:1680)

Thomas König (1):
      Use au->lock exclusively for locking in async I/O.

Thomas Rodgers (1):
      Restore enable_if lost during original import of pstl

Thomas Schwinge (5):
      Avoid '-Wmaybe-uninitialized' diagnostic in 'gcc/dwarf2out.c'
      [LIBPHOBOS] Fix multi-lib RUNTESTFLAGS handling
      [build] Properly track GCC language configure fragments
      Assert 'offset2' instead of 'offset' in 'gcc/gimplify.c:gimplify_scan_omp_clauses'
      [OpenACC, libgomp] Initialize 'dynamic_refcount' whenever we initialize 'refcount'

Tobias Burnus (15):
      Fortran] PR91586 Fix ICE on invalid code with CLASS
      Fortran] PR91863 - fix call to bind(C) with array descriptor
      Backport Fortran BIND(C) fixes
      Fortran] PR 92208 don't use function-result dummy variable as actual argument
      PR 92208 + PR 92277 – GCC 9 follow-up fix
      Fortran] PR91253 fix continuation-line handling with -pre_include
      PR fortran/92470 Fixes for CFI_address
      Fix gfortran.dg/ISO_Fortran_binding_17.c using rel. #include
      Fortran] PR 92050 - fix ICE with -fcheck=all
      Fix testcase - was missing -fopenacc
      libgomp – spelling fixes, incl. omp_lib.h.in
      Fortran] PR84135 fix merging dimension into codimension array spec
      Fortran] PR93309 – permit repeated 'implicit none(external)'
      [Fortran] Disable front-end optimization for OpenACC atomic (PR93462)
      [OpenMP] Add missing parameters to omp_lib documentation (PR fortran/93541)

Tom Honermann (1):
      PR c++/88095, CTAD for literal operator templates per P0732

Uros Bizjak (9):
      test_summary: Do not escape "=".
      baseline_symbols.txt: Update.
      re PR target/91533 (abs pattern generates MMX instructions but fails to call EMMS)
      re PR target/92022 (ICE in alpha_handle_trap_shadows, at config/alpha/alpha.c:8847)
      re PR target/92225 (ice in gen_smaxv2di3, at config/i386/sse.md:12225)
      PR target/93254 - -msse generates sse2 instructions
      i386: Fix atan2l argument order [PR93743]
      i386: Fix *vec_extractv2sf_1 and *vec_extractv2sf_1 shufps alternative [PR93828]
      testsuite: Compile asan_test.C with -Wno-alloc-size-larger-than

Ville Voutilainen (1):
      re PR c++/85254 (boost::is_final does not work for template types)

Wilco Dijkstra (2):
      [AArch64] Fix PR81800
      [AArch64] Fix shrinkwrapping interactions with atomics (PR92692)

Will Schmidt (2):
      backport: rs6000-builtin.def: (LVSL...
      Remove unnecessary XFAILs from existing testcase 20050603-3.c.

Xiong Hu Luo (1):
      backport: Enable math functions linking with static library for LTO

liuhongt (3):
      Intrinsic macro of vpshr* and vpshl* lack a closing parenthesis which would cause failure in O0.
      Add Changelog entries to relavent Changelog files for my last commit.
      Add -mavx512vbmi2 to i386-2.C and i386-3.C

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 8565be188d9..c9b9e26ee57 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/contrib/test_summary b/contrib/test_summary
index 3560a64c4f1..5760b053ec2 100755
--- a/contrib/test_summary
+++ b/contrib/test_summary
@@ -127,7 +127,7 @@ NR == 1 {
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 829d91dac87..1ac63fe5f6a 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,33 @@
+2020-02-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2020-02-13  Matheus Castanho  <msc@linux.ibm.com>
+
+	* fixinc.in: Skip machine_name fix on powerpc*-*-linux*.
+
+2020-01-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-12-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgomp/93066
+	* inclhack.def (hpux_c99_inttypes3): Fix defines for INTPTR_MAX
+	and UINTPTR_MAX, and missing define for SIZE_MAX.
+	* fixincl.x: Regenerate.
+	* tests/base/inttypes.h: Update for above fix.
+
+2019-08-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-18  C.G. Dogan <gcc+cgdogan.00@gmail.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/83531
+	* inclhack.def (darwin_api_availability): New; strip leading
+	underscores from API_XXXX defines.
+	* fixincl.x: Regenerate.
+	* tests/base/os/availability.h: New file.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/fixincludes/fixinc.in b/fixincludes/fixinc.in
index cd0b458b8f8..de5a37f6acc 100755
--- a/fixincludes/fixinc.in
+++ b/fixincludes/fixinc.in
@@ -136,7 +136,7 @@ fi
 #  disable the fix.
 
 case "${target_canonical}" in
-    *-*-vxworks*)
+    *-*-vxworks* | powerpc*-*-linux*)
 	test -f ${MACRO_LIST} &&  echo > ${MACRO_LIST}
         ;;
 esac
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
index 802162bb507..47a3578f017 100644
--- a/fixincludes/fixincl.x
+++ b/fixincludes/fixincl.x
@@ -2,11 +2,11 @@
  *
  * DO NOT EDIT THIS FILE   (fixincl.x)
  *
- * It has been AutoGen-ed  July  7, 2019 at 11:43:37 AM by AutoGen 5.17.4
+ * It has been AutoGen-ed  January  1, 2020 at 11:59:56 AM by AutoGen 5.18.16
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Jul  7 11:43:37 BST 2019
+/* DO NOT SVN-MERGE THIS FILE, EITHER Wed Jan  1 11:59:56 EST 2020
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 255 fixup descriptions.
+ * This file contains 257 fixup descriptions.
  *
  * See README for more information.
  *
@@ -267,6 +267,56 @@ static const char* apzAab_Darwin7_9_Long_Double_FuncsPatch[] = {
 #endif /* __MATH__ */",
     (char*)NULL };
 
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Darwin_Api_Availability fix
+ */
+tSCC zDarwin_Api_AvailabilityName[] =
+     "darwin_api_availability";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Api_AvailabilityList[] =
+  "os/availability.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Api_AvailabilityMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilitySelect0[] =
+       " *#define __API_AVAILABLE.*\n\
+ *#define __API_DEPRECATED.*\n\
+ *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n\
+ *#define __API_UNAVAILABLE.*\n";
+
+/*
+ *  content bypass pattern - skip fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilityBypass0[] =
+       "__IPHONE_OS_VERSION_MIN_REQUIRED";
+
+#define    DARWIN_API_AVAILABILITY_TEST_CT  2
+static tTestDesc aDarwin_Api_AvailabilityTests[] = {
+  { TT_NEGREP,   zDarwin_Api_AvailabilityBypass0, (regex_t*)NULL },
+  { TT_EGREP,    zDarwin_Api_AvailabilitySelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Api_Availability
+ */
+static const char* apzDarwin_Api_AvailabilityPatch[] = {
+    "format",
+    "    #define API_AVAILABLE(...)\n\
+    #define API_DEPRECATED(...)\n\
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n\
+    #define API_UNAVAILABLE(...)\n",
+    (char*)NULL };
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
  *  Description of Aab_Fd_Zero_Asm_Posix_Types_H fix
@@ -5097,6 +5147,55 @@ static const char* apzHpux_C99_Inttypes2Patch[] = { sed_cmd_z,
     "-e", "s@^[ \t]*#[ \t]*define[ \t]*UINT16_C(__c)[ \t]*((unsigned short)(__c))[ \t]*$@#define UINT16_C(__c) (__c)@",
     (char*)NULL };
 
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Hpux_C99_Inttypes3 fix
+ */
+tSCC zHpux_C99_Inttypes3Name[] =
+     "hpux_c99_inttypes3";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zHpux_C99_Inttypes3List[] =
+  "inttypes.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzHpux_C99_Inttypes3Machs[] = {
+        "hppa*-hp-hpux11*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zHpux_C99_Inttypes3Select0[] =
+       "#define[ \t]INTPTR_MAX[ \t]*\n\
+#define[ \t]UINTPTR_MAX[ \t]*\n";
+
+#define    HPUX_C99_INTTYPES3_TEST_CT  1
+static tTestDesc aHpux_C99_Inttypes3Tests[] = {
+  { TT_EGREP,    zHpux_C99_Inttypes3Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Hpux_C99_Inttypes3
+ */
+static const char* apzHpux_C99_Inttypes3Patch[] = {
+    "format",
+    "#undef SIZE_MAX\n\
+#define SIZE_MAX __SIZE_MAX__\n\
+#ifdef __INTPTR_MAX__\n\
+# undef INTPTR_MAX\n\
+# define INTPTR_MAX __INTPTR_MAX__\n\
+# undef INTPTR_MIN\n\
+# define INTPTR_MIN (-INTPTR_MAX - 1)\n\
+#endif\n\
+#ifdef __UINTPTR_MAX__\n\
+# undef UINTPTR_MAX\n\
+# define UINTPTR_MAX __UINTPTR_MAX__\n\
+#endif\n",
+    (char*)NULL };
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
  *  Description of Hpux_Ctype_Macros fix
@@ -10346,9 +10445,9 @@ static const char* apzX11_SprintfPatch[] = {
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          293
+#define REGEX_COUNT          296
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            255
+#define FIX_COUNT            257
 
 /*
  *  Enumerate the fixes
@@ -10357,6 +10456,7 @@ typedef enum {
     AAB_AIX_STDIO_FIXIDX,
     AAB_AIX_FCNTL_FIXIDX,
     AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_FIXIDX,
+    DARWIN_API_AVAILABILITY_FIXIDX,
     AAB_FD_ZERO_ASM_POSIX_TYPES_H_FIXIDX,
     AAB_FD_ZERO_GNU_TYPES_H_FIXIDX,
     AAB_FD_ZERO_SELECTBITS_H_FIXIDX,
@@ -10476,6 +10576,7 @@ typedef enum {
     HPUX_C99_INTPTR_FIXIDX,
     HPUX_C99_INTTYPES_FIXIDX,
     HPUX_C99_INTTYPES2_FIXIDX,
+    HPUX_C99_INTTYPES3_FIXIDX,
     HPUX_CTYPE_MACROS_FIXIDX,
     HPUX_EXTERN_ERRNO_FIXIDX,
     HPUX_HTONL_FIXIDX,
@@ -10627,6 +10728,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
      aAab_Darwin7_9_Long_Double_FuncsTests,   apzAab_Darwin7_9_Long_Double_FuncsPatch, 0 },
 
+  {  zDarwin_Api_AvailabilityName,    zDarwin_Api_AvailabilityList,
+     apzDarwin_Api_AvailabilityMachs,
+     DARWIN_API_AVAILABILITY_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Api_AvailabilityTests,   apzDarwin_Api_AvailabilityPatch, 0 },
+
   {  zAab_Fd_Zero_Asm_Posix_Types_HName,    zAab_Fd_Zero_Asm_Posix_Types_HList,
      apzAab_Fd_Zero_Asm_Posix_Types_HMachs,
      AAB_FD_ZERO_ASM_POSIX_TYPES_H_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
@@ -11222,6 +11328,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      HPUX_C99_INTTYPES2_TEST_CT, FD_MACH_ONLY,
      aHpux_C99_Inttypes2Tests,   apzHpux_C99_Inttypes2Patch, 0 },
 
+  {  zHpux_C99_Inttypes3Name,    zHpux_C99_Inttypes3List,
+     apzHpux_C99_Inttypes3Machs,
+     HPUX_C99_INTTYPES3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aHpux_C99_Inttypes3Tests,   apzHpux_C99_Inttypes3Patch, 0 },
+
   {  zHpux_Ctype_MacrosName,    zHpux_Ctype_MacrosList,
      apzHpux_Ctype_MacrosMachs,
      HPUX_CTYPE_MACROS_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index 861532c2a1d..bf136fdaa20 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -194,6 +194,33 @@ fix = {
 	_EndOfHeader_;
 };
 
+/*
+ *  SDKs for 10.13 and 10.14 omit the definitions for API_AVAILABLE where
+ *  __attribute__((availability)) is not supported.
+ */
+fix = {
+    hackname  = darwin_api_availability;
+    mach      = "*-*-darwin*";
+    files     = os/availability.h;
+    bypass    = "__IPHONE_OS_VERSION_MIN_REQUIRED";
+    select    =
+    " *#define __API_AVAILABLE.*\n"
+    " *#define __API_DEPRECATED.*\n"
+    " *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n"
+    " *#define __API_UNAVAILABLE.*\n";
+    c_fix     = format;
+    c_fix_arg =
+    "    #define API_AVAILABLE(...)\n"
+    "    #define API_DEPRECATED(...)\n"
+    "    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "    #define API_UNAVAILABLE(...)\n";
+    test_text =
+    "#define __API_AVAILABLE(...)\n"
+    "#define __API_DEPRECATED(...)\n"
+    "#define __API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "#define __API_UNAVAILABLE(...)\n";
+};
+
 /*
  *  This fixes __FD_ZERO bug for linux 2.x.y (x <= 2 && y <= some n)
  */
@@ -2560,6 +2587,32 @@ fix = {
 		"#  define	UINT16_C(__c)	((unsigned short)(__c))\n";
 };
 
+/*
+ * Fix broken and missing defines in inttypes.h
+ */
+fix = {
+    hackname  = hpux_c99_inttypes3;
+    mach      = "hppa*-hp-hpux11*";
+    files     = inttypes.h;
+    select    = "#define[ \t]INTPTR_MAX[ \t]*\n"
+		"#define[ \t]UINTPTR_MAX[ \t]*\n";
+    c_fix     = format;
+    c_fix_arg = "#undef SIZE_MAX\n"
+		"#define SIZE_MAX __SIZE_MAX__\n"
+		"#ifdef __INTPTR_MAX__\n"
+		"# undef INTPTR_MAX\n"
+		"# define INTPTR_MAX __INTPTR_MAX__\n"
+		"# undef INTPTR_MIN\n"
+		"# define INTPTR_MIN (-INTPTR_MAX - 1)\n"
+		"#endif\n"
+		"#ifdef __UINTPTR_MAX__\n"
+		"# undef UINTPTR_MAX\n"
+		"# define UINTPTR_MAX __UINTPTR_MAX__\n"
+		"#endif\n";
+    test_text = "#define INTPTR_MAX\n"
+		"#define UINTPTR_MAX\n";
+};
+
 /*
  *  Fix hpux broken ctype macros
  */
diff --git a/fixincludes/tests/base/inttypes.h b/fixincludes/tests/base/inttypes.h
index 3f556856a41..e2216832666 100644
--- a/fixincludes/tests/base/inttypes.h
+++ b/fixincludes/tests/base/inttypes.h
@@ -16,3 +16,20 @@
 #define UINT32_C(__c) __CONCAT__(__c,u)
 
 #endif  /* HPUX_C99_INTTYPES_CHECK */
+
+
+#if defined( HPUX_C99_INTTYPES3_CHECK )
+#undef SIZE_MAX
+#define SIZE_MAX __SIZE_MAX__
+#ifdef __INTPTR_MAX__
+# undef INTPTR_MAX
+# define INTPTR_MAX __INTPTR_MAX__
+# undef INTPTR_MIN
+# define INTPTR_MIN (-INTPTR_MAX - 1)
+#endif
+#ifdef __UINTPTR_MAX__
+# undef UINTPTR_MAX
+# define UINTPTR_MAX __UINTPTR_MAX__
+#endif
+
+#endif  /* HPUX_C99_INTTYPES3_CHECK */
diff --git a/fixincludes/tests/base/os/availability.h b/fixincludes/tests/base/os/availability.h
new file mode 100644
index 00000000000..e8696b14acd
--- /dev/null
+++ b/fixincludes/tests/base/os/availability.h
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/availability.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_API_AVAILABILITY_CHECK )
+    #define API_AVAILABLE(...)
+    #define API_DEPRECATED(...)
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)
+    #define API_UNAVAILABLE(...)
+
+#endif  /* DARWIN_API_AVAILABILITY_CHECK */
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index deeb3d66ef0..45acc9e6670 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.2.0
+9.2.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 7f6557d8018..f6069066c2f 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,2351 @@
+2020-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94046
+	* config/i386/avx2intrin.h (_mm_mask_i32gather_ps): Fix first cast of
+	SRC and MASK arguments to __m128 from __m128d.
+	(_mm256_mask_i32gather_ps): Fix first cast of MASK argument to __m256
+	from __m256d.
+	(_mm_mask_i64gather_ps): Fix first cast of MASK argument to __m128
+	from __m128d.
+	* config/i386/xopintrin.h (_mm_permute2_pd): Fix first cast of C
+	argument to __m128i from __m128d.
+	(_mm256_permute2_pd): Fix first cast of C argument to __m256i from
+	__m256d.
+	(_mm_permute2_ps): Fix first cast of C argument to __m128i from __m128.
+	(_mm256_permute2_ps): Fix first cast of C argument to __m256i from
+	__m256.
+
+2020-03-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/90311
+	Backport from master
+	2019-07-18  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/predicates.md (arm_borrow_operation): New predicate.
+	* config/arm/arm.c (subdi3_compare1): Use CCmode for the split.
+	(arm_subdi3, subdi_di_zesidi, subdi_di_sesidi): Likewise.
+	(subdi_zesidi_zesidi): Likewise.
+	(negdi2_compare, negdi2_insn): Likewise.
+	(negdi_extensidi): Likewise.
+	(negdi_zero_extendsidi): Likewise.
+	(arm_cmpdi_insn): Likewise.
+	(subsi3_carryin): Use arm_borrow_operation.
+	(subsi3_carryin_const): Likewise.
+	(subsi3_carryin_const0): Likewise.
+	(subsi3_carryin_compare): Likewise.
+	(subsi3_carryin_compare_const): Likewise.
+	(subsi3_carryin_compare_const0): Likewise.
+	(subsi3_carryin_shift): Likewise.
+	(rsbsi3_carryin_shift): Likewise.
+	(negsi2_carryin_compare): Likewise.
+
+2020-03-04  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2020-01-26  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/93436
+	* sanopt.c (sanitize_rewrite_addressable_params): Avoid crash on
+	null DECL_NAME.
+
+2020-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94002
+	* explow.c (plus_constant): Punt if cst has VOIDmode and
+	get_pool_mode is different from mode.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92601
+	* tree.c (verify_type_variant): Only verify TYPE_NEEDS_CONSTRUCTING
+	of complete types.
+
+2020-02-29  Peter Bergner <bergner@linux.ibm.com>
+
+	Revert
+	2020-02-20  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93658
+	* config/rs6000/rs6000.c (rs6000_legitimate_address_p): Handle VSX
+	vector modes.
+
+	2020-02-05  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/93568
+	* config/rs6000/rs6000.c (get_vector_offset): Fix Q constraint assert
+	to use "mem".
+
+	Backport from master
+	2020-02-03  Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (get_vector_offset): New helper function
+	to calculate the offset in memory from the start of a vector of a
+	particular element.  Add code to keep the element number in
+	bounds if the element number is variable.
+	(rs6000_adjust_vec_address): Move calculation of offset of the
+	vector element to get_vector_offset.
+	(rs6000_split_vec_extract_var): Do not do the initial AND of
+	element here, move the code to get_vector_offset.
+
+	2020-01-06  Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/vsx.md (vsx_extract_<mode>_var, VSX_D iterator):
+	Use 'Q' for doing vector extract from memory.
+	(vsx_extract_v4sf_var): Use 'Q' for doing vector extract from
+	memory.
+	(vsx_extract_<mode>_var, VSX_EXTRACT_I iterator): Use 'Q' for
+	doing vector extract from memory.
+	(vsx_extract_<mode>_<VS_scalar>mode_var): Use 'Q' for doing vector
+	extract from memory.
+
+2020-02-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-02-28  Martin Liska  <mliska@suse.cz>
+
+	PR other/93965
+	* configure.ac: Improve detection of ld_date by requiring
+	either two dashes or none.
+	* configure: Regenerate.
+
+2020-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/93949
+	* gimplify.c (gimplify_init_constructor): Don't promote readonly
+	DECL_REGISTER variables to TREE_STATIC.
+
+2020-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93945
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): For memset with non-zero
+	second operand, require ref->size to be a multiple of BITS_PER_UNIT.
+
+2020-02-26  Carl Love  <cel@us.ibm.com>
+
+	PR target/91276
+	* doc/extend.texi (PowerPC AltiVec Built-in Functions  Available on ISA
+	3.0): The builtin-function name __builtin_crypto_vpmsumb is only for
+	the vector unsigned short arguments.  It is also listed as the name of
+	the built-in for arguments vector unsigned short,
+	vector unsigned int and vector unsigned long long built-ins.  The
+	name of the builtins for these arguments should be:
+	__builtin_crypto_vpmsumh, __builtin_crypto_vpmsumw and
+	__builtin_crypto_vpmsumd respectively.
+
+2020-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92003
+	* symtab.c (symtab_node::nonzero_address): A DECL_COMDAT decl has
+	non-zero address even if weak and not yet defined.
+
+2020-02-26  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/93047
+	* config/rs6000/rs6000.md (untyped_call): Add emit_clobber.
+
+2020-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93820
+	* gimple-ssa-store-merging.c (check_no_overlap): Change RHS_CODE
+	argument to ALL_INTEGER_CST_P boolean.
+	(imm_store_chain_info::try_coalesce_bswap): Adjust caller.
+	(imm_store_chain_info::coalesce_immediate_stores): Likewise.  Handle
+	adjacent INTEGER_CST store into merged_store->only_constants like
+	overlapping one.
+
+2020-02-25  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2020-02-25  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* config/arm/arm.md (required_for_purecode): New attribute.
+	(enabled): Handle required_for_purecode.
+	* config/arm/thumb1.md (thumb1_movsi_insn): Add alternative to
+	work with -mpure-code.
+
+2020-02-25  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2019-12-17  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* config/arm/arm-protos.h (thumb1_gen_const_int): Add new prototype.
+	* config/arm/arm.c (arm_option_check_internal): Remove restriction
+	on MOVT for -mpure-code.
+	(thumb1_gen_const_int): New function.
+	(thumb1_legitimate_address_p): Support -mpure-code.
+	(thumb1_rtx_costs): Likewise.
+	(thumb1_size_rtx_costs): Likewise.
+	(arm_thumb1_mi_thunk): Likewise.
+	* config/arm/arm.h (CASE_VECTOR_PC_RELATIVE): Likewise.
+	* config/arm/thumb1.md (thumb1_movsi_symbol_ref): New.
+	(*thumb1_movhf): Support -mpure-code.
+	* doc/invoke.texi (-mpure-code): Remove restriction on MOVT.
+
+2020-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93908
+	* combine.c (find_split_point): For store into ZERO_EXTRACT, and src
+	with mask.
+
+2019-02-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* dwarf2out.c (dwarf2out_size_function): Run in early-DWARF mode.
+
+2020-02-25  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from master
+	2020-02-24  Roman Zhuykov  <zhroma@ispras.ru>
+
+	* doc/install.texi (--enable-checking): Properly document current
+	behavior.
+	(--enable-stage1-checking): Minor clarification about bootstrap.
+
+2020-02-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2020-02-19  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/93767
+	* tree-vect-data-refs.c (vect_compile_time_alias): Remove the
+	access-size bias from the offset calculations for negative strides.
+
+2020-02-24  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* collect2.c (tool_cleanup): Avoid calling not signal-safe
+	functions.
+	(maybe_run_lto_and_relink): Avoid possible signal handler
+	access to unintialzed memory (lto_o_files).
+
+2020-02-23  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from master
+	2020-02-20  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93658
+	* config/rs6000/rs6000.c (rs6000_legitimate_address_p): Handle VSX
+	vector modes.
+
+2020-02-23  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from master
+	2020-02-05  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/93568
+	* config/rs6000/rs6000.c (get_vector_offset): Fix Q constraint assert
+	to use "mem".
+
+	Backport from master
+	2020-02-03  Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (get_vector_offset): New helper function
+	to calculate the offset in memory from the start of a vector of a
+	particular element.  Add code to keep the element number in
+	bounds if the element number is variable.
+	(rs6000_adjust_vec_address): Move calculation of offset of the
+	vector element to get_vector_offset.
+	(rs6000_split_vec_extract_var): Do not do the initial AND of
+	element here, move the code to get_vector_offset.
+
+2020-02-23  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from master
+	2020-01-06  Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/vsx.md (vsx_extract_<mode>_var, VSX_D iterator):
+	Use 'Q' for doing vector extract from memory.
+	(vsx_extract_v4sf_var): Use 'Q' for doing vector extract from
+	memory.
+	(vsx_extract_<mode>_var, VSX_EXTRACT_I iterator): Use 'Q' for
+	doing vector extract from memory.
+	(vsx_extract_<mode>_<VS_scalar>mode_var): Use 'Q' for doing vector
+	extract from memory.
+
+2020-02-21  John David Anglin  <danglin@gcc.gnu.org>
+
+	* gcc/config/pa/pa.c (pa_function_value): Fix check for word and
+	double-word size when handling aggregate return values.
+	* gcc/config/pa/som.h (ASM_DECLARE_FUNCTION_NAME): Fix to indicate
+	that homogeneous SFmode and DFmode aggregates are passed and returned
+	in general registers.
+
+2020-02-20  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/93828
+	* config/i386/mmx.md (*vec_extractv2sf_1): Match source operand
+	to destination operand for shufps alternative.
+	(*vec_extractv2si_1): Ditto.
+
+2020-02-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-02-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93656
+	* config/i386/i386.c (ix86_trampoline_init): Skip ENDBR32 at
+	the target function entry.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-12-05  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/92768
+	* tree-core.h (OEP_BITWISE): New flag.
+	* fold-const.c (operand_compare::operand_equal_p): Handle it.
+	* tree-vector-builder.h (tree_vector_builder::equal_p): Pass it.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-08-09  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/90313
+	* tree-tailcall.c (find_tail_calls): Reject calls that might
+	read from an escaped RESULT_DECL.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2020-01-28  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/93434
+	* tree-predcom.c (split_data_refs_to_components): Record which
+	components have had aliasing loads removed.  Prevent store-store
+	commoning for all such components.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/92710
+	* tree-vect-stmts.c (vectorizable_simd_clone_call): Reject
+	vector mask arguments.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-11-11  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/92420
+	* tree-vect-stmts.c (get_negative_load_store_type): Move further
+	up file.
+	(get_group_load_store_type): Use it for reversed SLP accesses.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-08-21  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>
+
+	PR target/90724
+	* config/aarch64/aarch64.c (aarch64_gen_compare_reg_maybe_ze): Force y
+	in reg if it fails aarch64_plus_operand predicate.
+
+2020-02-14 Hongtao Liu  <hongtao.liu@intel.com>
+
+	PR target/93724
+	* config/i386/avx512vbmi2intrin.h
+	(_mm512_shrdi_epi16, _mm512_mask_shrdi_epi16,
+	_mm512_maskz_shrdi_epi16, _mm512_shrdi_epi32,
+	_mm512_mask_shrdi_epi32, _mm512_maskz_shrdi_epi32,
+	_m512_shrdi_epi64, _m512_mask_shrdi_epi64,
+	_m512_maskz_shrdi_epi64, _mm512_shldi_epi16,
+	_mm512_mask_shldi_epi16, _mm512_maskz_shldi_epi16,
+	_mm512_shldi_epi32, _mm512_mask_shldi_epi32,
+	_mm512_maskz_shldi_epi32, _mm512_shldi_epi64,
+	_mm512_mask_shldi_epi64, _mm512_maskz_shldi_epi64): Fix typo
+	of lacking a closing parenthesis.
+	* config/i386/avx512vbmi2vlintrin.h
+	(_mm256_shrdi_epi16, _mm256_mask_shrdi_epi16,
+	_mm256_maskz_shrdi_epi16, _mm256_shrdi_epi32,
+	_mm256_mask_shrdi_epi32, _mm256_maskz_shrdi_epi32,
+	_m256_shrdi_epi64, _m256_mask_shrdi_epi64,
+	_m256_maskz_shrdi_epi64, _mm256_shldi_epi16,
+	_mm256_mask_shldi_epi16, _mm256_maskz_shldi_epi16,
+	_mm256_shldi_epi32, _mm256_mask_shldi_epi32,
+	_mm256_maskz_shldi_epi32, _mm256_shldi_epi64,
+	_mm256_mask_shldi_epi64, _mm256_maskz_shldi_epi64,
+	_mm_shrdi_epi16, _mm_mask_shrdi_epi16,
+	_mm_maskz_shrdi_epi16, _mm_shrdi_epi32,
+	_mm_mask_shrdi_epi32, _mm_maskz_shrdi_epi32,
+	_mm_shrdi_epi64, _mm_mask_shrdi_epi64,
+	_m_maskz_shrdi_epi64, _mm_shldi_epi16,
+	_mm_mask_shldi_epi16, _mm_maskz_shldi_epi16,
+	_mm_shldi_epi32, _mm_mask_shldi_epi32,
+	_mm_maskz_shldi_epi32, _mm_shldi_epi64,
+	_mm_mask_shldi_epi64, _mm_maskz_shldi_epi64): Ditto.
+
+2020-02-16  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/93743
+	* config/i386/i386.md (atan2xf3): Swap operands 1 and 2.
+	(atan2<mode>3): Update operand order in the call to gen_atan2xf3.
+
+2020-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93744
+	* match.pd (((m1 >/</>=/<= m2) * d -> (m1 >/</>=/<= m2) ? d : 0): For
+	GENERIC, make sure @2 in the first and @1 in the other patterns has no
+	side-effects.
+
+2020-02-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/93704
+	* config/sparc/sparc.c (eligible_for_call_delay): Test HAVE_GNU_LD in
+	conjunction with TARGET_GNU_TLS in early return.
+
+2020-02-14  Alexander Monakov  <amonakov@ispras.ru>
+
+	Backport from mainline
+	PR rtl-optimization/88879
+	* sel-sched.c (sel_target_adjust_priority): Remove assert.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-02-05  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90648
+	* genmatch.c (dt_node::gen_kids_1): Emit number of argument
+	checks before matching calls.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93381
+	* tree-ssa-structalias.c (find_func_aliases): Assume offsetting
+	throughout, handle all conversions the same.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93439
+	* tree-parloops.c (create_loop_fn): Move clique bookkeeping...
+	* tree-cfg.c (move_sese_region_to_fn): ... here.
+	(verify_types_in_gimple_reference): Verify used cliques are
+	tracked.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/93054
+	* gimplify.c (gimplify_expr): Deal with NOP definitions.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-20  Richard Biener  <rguenther@suse.de>
+
+	PR debug/92763
+	* dwarf2out.c (prune_unused_types): Unconditionally mark
+	called function DIEs.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-11-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/92704
+	* tree-if-conv.c (combine_blocks): Deal with virtual PHIs
+	in loops performing only loads.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-11-27  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/92674
+	* tree-inline.c (expand_call_inline): Delay purging EH/abnormal
+	edges and instead record blocks in bitmap.
+	(gimple_expand_calls_inline): Adjust.
+	(fold_marked_statements): Delay EH cleanup until all folding is
+	done.
+	(optimize_inline_calls): Do EH/abnormal cleanup for calls after
+	inlining finished.
+
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93696
+	* config/i386/avx512bitalgintrin.h (_mm512_mask_popcnt_epi8,
+	_mm512_mask_popcnt_epi16, _mm256_mask_popcnt_epi8,
+	_mm256_mask_popcnt_epi16, _mm_mask_popcnt_epi8,
+	_mm_mask_popcnt_epi16): Rename __B argument to __A and __A to __W,
+	pass __A to the builtin followed by __W instead of __A followed by
+	__B.
+	* config/i386/avx512vpopcntdqintrin.h (_mm512_mask_popcnt_epi32,
+	_mm512_mask_popcnt_epi64): Likewise.
+	* config/i386/avx512vpopcntdqvlintrin.h (_mm_mask_popcnt_epi32,
+	_mm256_mask_popcnt_epi32, _mm_mask_popcnt_epi64,
+	_mm256_mask_popcnt_epi64): Likewise.
+
+	PR target/93673
+	* config/i386/sse.md (k<code><mode>): Drop mode from last operand and
+	use const_0_to_255_operand predicate instead of immediate_operand.
+	(avx512dq_fpclass<mode><mask_scalar_merge_name>,
+	avx512dq_vmfpclass<mode><mask_scalar_merge_name>,
+	vgf2p8affineinvqb_<mode><mask_name>,
+	vgf2p8affineqb_<mode><mask_name>): Drop mode from
+	const_0_to_255_operand predicated operands.
+
+	Backported from mainline
+	2020-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93670
+	* config/i386/sse.md (VI48F_256_DQ): New mode iterator.
+	(avx512vl_vextractf128<mode>): Use it instead of VI48F_256.  Remove
+	TARGET_AVX512DQ from condition.
+	(vec_extract_lo_<mode><mask_name>): Use <mask_avx512dq_condition>
+	instead of <mask_mode512bit_condition> in condition.  If
+	TARGET_AVX512DQ is false, emit vextract*64x4 instead of
+	vextract*32x8.
+	(vec_extract_lo_<mode><mask_name>): Drop <mask_avx512dq_condition>
+	from condition.
+
+	2020-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93637
+	* config/i386/sse.md (VI_256_AVX2): New mode iterator.
+	(vcond_mask_<mode><sseintvecmodelower>): Use it instead of VI_256.
+	Change condition from TARGET_AVX2 to TARGET_AVX.
+
+	2020-02-08  Uroš Bizjak  <ubizjak@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/65782
+	* config/i386/i386.h (CALL_USED_REGISTERS): Make
+	xmm16-xmm31 call-used even in 64-bit ms-abi.
+
+	2020-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/93515
+	* omp-low.c (use_pointer_for_field): For nested constructs, also
+	look for map clauses on target construct.
+	(scan_omp_1_stmt) <case GIMPLE_OMP_TARGET>: Bump temporarily
+	taskreg_nesting_level.
+
+	PR libgomp/93515
+	* gimplify.c (gimplify_scan_omp_clauses) <do_notice>: If adding
+	shared clause, call omp_notice_variable on outer context if any.
+
+	2020-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93555
+	* omp-simd-clone.c (expand_simd_clones): If simd_clone_mangle or
+	simd_clone_create failed when i == 0, adjust clone->nargs by
+	clone->inbranch.
+
+	2020-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93505
+	* combine.c (simplify_comparison) <case ROTATE>: Punt on out of range
+	rotate counts.
+
+	2020-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93418
+	* config/i386/i386.c (ix86_fold_builtin) <do_shift>: If mask is not
+	-1 or is_vshift is true, use new_vector with number of elts npatterns
+	rather than new_unary_operation.
+
+	2020-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93402
+	* postreload.c (reload_combine_recognize_pattern): Don't try to adjust
+	USE insns.
+
+2020-02-11  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from mainline
+	2020-01-31  Tamar Christina  <tamar.christina@arm.com>
+
+	PR rtl-optimization/91838
+	* simplify-rtx.c (simplify_binary_operation_1): Update LSHIFTRT case
+	to truncate if allowed or reject combination.
+
+2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/85667
+	* config/i386/i386.c (function_arg_ms_64): Add a type argument.
+	Don't return aggregates with only SFmode and DFmode in SSE
+	register.
+	(ix86_function_arg): Pass type to function_arg_ms_64.
+
+2020-01-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_elf_select_rtx_section): Place function pointers
+	without a DECL in .data.rel.ro.local.
+
+2020-01-30  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2020-01-21  Kito Cheng  <kito.cheng@sifive.com>
+
+	PR target/93304
+	* config/riscv/riscv-protos.h (riscv_hard_regno_rename_ok): New.
+	* config/riscv/riscv.c (riscv_hard_regno_rename_ok): New.
+	* config/riscv/riscv.h (HARD_REGNO_RENAME_OK): Defined.
+
+2020-01-29  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline
+	2020-01-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/92424
+	* config/aarch64/aarch64.c (aarch64_declare_function_name): Set
+	cfun->machine->label_is_assembled.
+	(aarch64_print_patchable_function_entry): New.
+	(TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY): Define.
+	* config/aarch64/aarch64.h (struct machine_function): New field,
+	label_is_assembled.
+
+2020-01-27  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/92692
+	* config/aarch64/aarch64.c (aarch64_split_compare_and_swap)
+	Add assert to ensure prolog has been emitted.
+	(aarch64_split_atomic_op): Likewise.
+	* config/aarch64/atomics.md (aarch64_compare_and_swap<mode>)
+	Use epilogue_completed rather than reload_completed.
+	(aarch64_atomic_exchange<mode>): Likewise.
+	(aarch64_atomic_<atomic_optab><mode>): Likewise.
+	(atomic_nand<mode>): Likewise.
+	(aarch64_atomic_fetch_<atomic_optab><mode>): Likewise.
+	(atomic_fetch_nand<mode>): Likewise.
+	(aarch64_atomic_<atomic_optab>_fetch<mode>): Likewise.
+	(atomic_nand_fetch<mode>): Likewise.
+
+2020-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93335
+	* config/aarch64/aarch64.c (aarch64_expand_subvti): Only use
+	gen_subdi3_compare1_imm if low_in2 satisfies aarch64_plus_immediate
+	predicate, not whenever it is CONST_INT.  Otherwise, force_reg it.
+	Call force_reg on high_in2 unconditionally.
+
+	PR target/91298
+	* output.h (assemble_name_resolve): Declare.
+	* varasm.c (assemble_name_resolve): New function.
+	(assemble_name): Use it.
+	* config/i386/i386.h (ASM_OUTPUT_SYMBOL_REF): Define.
+
+	Backported from mainline
+	2020-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93333
+	* config/riscv/riscv.c (riscv_rtx_costs) <case ZERO_EXTRACT>: Verify
+	the last two operands are CONST_INT_P before using them as such.
+
+	PR target/93073
+	* config/rs6000/rs6000.c (rs6000_emit_cmove): If using fsel, punt for
+	compare_mode other than SFmode or DFmode.
+
+	2020-01-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93009
+	* config/i386/sse.md
+	(*<sd_mask_codefor>fma_fmadd_<mode><sd_maskz_name>_bcst_1,
+	*<sd_mask_codefor>fma_fmsub_<mode><sd_maskz_name>_bcst_1,
+	*<sd_mask_codefor>fma_fnmadd_<mode><sd_maskz_name>_bcst_1,
+	*<sd_mask_codefor>fma_fnmsub_<mode><sd_maskz_name>_bcst_1): Use
+	just a single alternative instead of two, make operands 1 and 2
+	commutative.
+
+	2020-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/93202
+	* config/riscv/riscv.c (riscv_print_operand_reloc): Use
+	output_operand_lossage instead of gcc_unreachable.
+	* doc/md.texi (riscv f constraint): Fix typo.
+
+	2020-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93088
+	* loop-iv.c (find_single_def_src): Punt after looking through
+	128 reg copies for regs with single definitions.  Move definitions
+	to first uses.
+
+	2020-01-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/93087
+	* predict.c (compute_function_frequency): Don't call
+	warn_function_cold on functions that already have cold attribute.
+
+2020-01-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	PR middle-end/93246
+	* alias.c (record_component_aliases): Take superset to record
+	into, recurse for alias-set zero fields.
+	(record_component_aliases): New oveerload wrapping around the above.
+
+2020-01-19  Eric S. Raymond <esr@thyrsus.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backport from mainline:
+
+	2020-01-19  Eric S. Raymond <esr@thyrsus.com>
+
+	* doc/contribute.texi: Update for SVN -> Git transition.
+	* doc/install.texi: Likewise.
+
+2020-01-15  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/93254
+	* config/i386/i386.md (*movsf_internal): Require SSE2 ISA for
+	alternatives 9 and 10.  Do not require SSE2 ISA for alternatives
+	14 and 15.
+
+2020-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2020-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/93223
+	* ipa-cp.c (devirtualization_time_bonus): Check whether isummary is
+	NULL.
+
+2020-01-10  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-12-17  Martin Jambor  <mjambor@suse.cz>
+
+        PR ipa/92971
+        * Ipa-cp.c (cgraph_edge_brings_all_agg_vals_for_node): Fix
+          definition of values, release memory on exit.
+
+2020-01-10  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com>
+
+	Backport from trunk
+	PR target/93188
+	* config/arm/t-multilib (MULTILIB_MATCHES): Add rules to match
+	armv7-a{+mp,+sec,+mp+sec} to appropriate armv7 multilib variants
+	when only building rm-profile multilibs.
+
+2020-01-10  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com>
+
+	Backport from trunk
+	* config/arm/t-multilib: Use arm->thumb multilib reuse rules
+	on a-profile.
+
+2020-01-09  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-12-12  Jan Hubicka  <hubicka@ucw.cz>
+
+	* ipa-prop.c (read_ipcp_transformation_info): Fix undefined ordering
+	of execution of function call parameters.
+
+2020-01-08  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2020-01-08 trunk r279995.
+
+	Add -nodevicespecs option for avr.
+
+	PR target/93182
+	* config/avr/avr.opt (-nodevicespecs): New driver option.
+	* config/avr/driver-avr.c (avr_devicespecs_file): Only issue
+	"-specs=device-specs/..." if that option is not set.
+	* doc/invoke.texi (AVR Options) <-nodevicespecs>: Document.
+
+2020-01-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Revert change to use ordered_comparison_operator
+	instead of cmpib_comparison_operator in cmpib patterns.
+	* config/pa/predicates.md (cmpib_comparison_operator): Revert removal
+	of cmpib_comparison_operator.  Revise comment.
+
+2020-01-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/67834
+	* config/pa/pa.c (pa_elf_select_rtx_section): New.  Put references to
+	COMDAT group function labels in .data.rel.ro.local section.
+	* config/pa/pa32-linux.h (TARGET_ASM_SELECT_RTX_SECTION): Define.
+
+	PR target/93111
+	* config/pa/pa.md (scc): Use ordered_comparison_operator instead of
+	comparison_operator in B and S integer comparisons.  Likewise, use
+	ordered_comparison_operator instead of cmpib_comparison_operator in
+	cmpib patterns.
+	* config/pa/predicates.md (cmpib_comparison_operator): Remove.
+
+2019-12-25 Iain Sandoe <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-12-14 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.h (DARWIN_EXTRA_SPECS): Add new
+	bundle spec. (DARWIN_BUNDLE1_SPEC): New.
+	(STARTFILE_SPEC): Use darwin bundle spec.
+	* config/rs6000/darwin.h (DARWIN_BUNDLE1_SPEC): New.
+	(DARWIN_DYLIB1_SPEC): Delete duplicate.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92756
+	* omp-low.c (check_omp_nesting_restrictions): If lang_GNU_Fortran,
+	diagnose teams not closely nested inside of target.
+
+	Backported from mainline
+	2019-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/92357
+	* ipa-fnsummary.c (ipa_fn_summary_write): Use
+	lto_symtab_encoder_iterator with lsei_start_function_in_partition and
+	lsei_next_function_in_partition instead of walking all cgraph nodes
+	in encoder.
+
+	PR tree-optimization/92930
+	* ipa-pure-const.c (special_builtin_state): Don't handle
+	BUILT_IN_APPLY.
+
+	2019-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92904
+	* config/i386/i386.c (ix86_gimplify_va_arg): If need_intregs and
+	not need_temp, decrease alignment of the read because the GPR save
+	area only guarantees 8-byte alignment.
+
+	2019-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92723
+	* tree-vect-patterns.c (vect_recog_rotate_pattern): If dt is not
+	vect_internal_def, use oprnd1 as is, without trying to cast it.
+	Formatting fix.
+
+	2019-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/92664
+	* dwarf2out.c (lookup_filename): Use "<stdin>" instead of "".
+
+	2019-11-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92644
+	* tree-ssa-phiopt.c (minmax_replacement): Add INTEGRAL_TYPE_P check
+	next to INTEGER_CST checks.
+
+	2019-11-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92615
+	* config/i386/i386.c (ix86_md_asm_adjust): If dest_mode is
+	GET_MODE (dest), is not QImode, using ZERO_EXTEND and dest is not
+	register_operand, force x into register before storing it into dest.
+	Formatting fix.
+
+2019-12-20  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-12-13  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/92591
+	* modulo-sched.c (ps_add_node_check_conflicts): Improve checking
+	for history > 0 case.
+	* params.def (sms-dfa-history): Limit to 16.
+
+2019-12-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport support for some AVR devices from avrxmega3 family
+	from SVN trunk r279309, r278387, r278389, r278478.
+
+	PR target/92545
+	* config/avr/avr-arch.h (avr_mcu_t) <flash_pm_offset>: New field.
+	* config/avr/avr-devices.c (avr_mcu_types): Adjust initializers.
+	* config/avr/avr-mcus.def (AVR_MCU): Add respective field.
+	* config/avr/gen-avr-mmcu-specs.c (print_mcu)
+	<*cpp, *cpp_mcu, *cpp_avrlibc, *link_pm_base_address>: Emit code
+	for spec definitions.
+	* config/avr/gen-avr-mmcu-texi.c: Rewrite.
+	* doc/avr-mmcu.texi: Regenerate.
+
+2019-12-17  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-12-16  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/92950
+	* config/s390/vector.md ("mov<mode>" for V_8): Replace lh, lhy,
+	and lhrl with llc.
+
+2019-12-12  Vineet Gupta  <vgupta@synopsys.com>
+
+	Backport from mainline
+	* config/arc/arc-modes.def (CC_FPUE): New Mode CC_FPUE which
+	helps codegen generate exceptions even for quiet NaN.
+	* config/arc/arc.c (arc_init_reg_tables): Handle New CC_FPUE mode.
+	(get_arc_condition_code): Likewise.
+	(arc_select_cc_mode): LT, LE, GT, GE to use the New CC_FPUE mode.
+	* config/arc/arc.h (REVERSE_CONDITION): Handle New CC_FPUE mode.
+	* config/arc/predicates.md (proper_comparison_operator): Likewise.
+	* config/arc/fpu.md (cmpsf_fpu_trap): New Pattern for CC_FPUE.
+	(cmpdf_fpu_trap): Likewise.
+
+2019-12-12  Claudiu Zissulescu  <claziss@synopsys.com>
+
+	Backport from mainline
+	* config/arc/arc.md (iterator SDF): Check TARGET_FP_DP_BASE.
+	(cstoredi4): Use TARGET_HARD_FLOAT.
+
+2019-12-10  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2019-11-27  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR tree-optimization/91790
+	* gcc/tree-vect-stmts.c (vectorizable_load): Use the adjusted DR for
+	vect_setup_realignment when first_stmt_info is different from
+	first_stmt_info_for_drptr.
+
+2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute
+	TYPE_CANONICAL from the element type only if it is true.  Remove a few
+	obsolete lines and adjust recursive call.
+	(fld_process_array_type): Adjust call to build_array_type_1.
+	(build_array_type): Likewise.
+	(build_nonshared_array_type): Likewise.
+
+2019-12-02  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Fix bugs relating to flexibly-sized objects in nios2 backend.
+	
+	PR target/92499
+	* config/nios2/nios2.c (nios2_in_small_data_p): Do not consider
+	objects of flexible types to be small if they have internal linkage
+	or are declared extern.
+	* config/nios2/nios2.h (ASM_OUTPUT_ALIGNED_LOCAL): Replace with...
+	(ASM_OUTPUT_ALIGNED_DECL_LOCAL): ...this.  Use targetm.in_small_data_p
+	instead of the size of the object initializer.
+	* tree.c (flexible_array_type_p): Move from C front end, and
+	generalize to handle fields in non-C structures.
+	* tree.h (flexible_array_type_p): Declare.
+
+2019-12-02  Li Jia He  <helijia@linux.ibm.com>
+
+	Partial backport from mainline
+	PR target/92098
+	2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR target/92132
+	* config/rs6000/predicates.md
+	(signed_or_equality_comparison_operator): New predicate.
+	(unsigned_or_equality_comparison_operator): Likewise.
+	* config/rs6000/rs6000.md (one_cmpl<mode>2): Remove expand.
+	(one_cmpl<mode>3_internal): Rename to one_cmpl<mode>2.
+	* config/rs6000/vector.md
+	(vcond_mask_<mode><mode> for VEC_I and VEC_I): New expand.
+	(vec_cmp<mode><mode> for VEC_I and VEC_I): Likewise.
+	(vec_cmpu<mode><mode> for VEC_I and VEC_I): Likewise.
+
+2019-11-27  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/92222
+	* tree-vect-slp.c (_slp_oprnd_info::first_pattern): Remove.
+	(_slp_oprnd_info::second_pattern): Likewise.
+	(_slp_oprnd_info::any_pattern): New.
+	(vect_create_oprnd_info): Adjust.
+	(vect_get_and_check_slp_defs): Compute whether any stmt is
+	in a pattern.
+	(vect_build_slp_tree_2): Avoid building up a node from scalars
+	if any of the operand defs, not just the first, is in a pattern.
+
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91355
+	* tree-ssa-sink.c (select_best_block): Use >= rather than >
+	for early_bb scaled count with best_bb count comparison.
+
+2019-11-21  Richard Biener  <rguenther@suse.de>
+
+	Revert
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91790
+	* tree-vect-stmts.c (vectorizable_load): For BB vectorization
+	use the correct DR for setting up realignment.
+
+2019-11-20  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* config/rs6000/predicates.md (input_operand): Allow MODE_PARTIAL_INT
+	modes for integer constants.
+
+2019-11-20  Michael Matz  <matz@suse.de>
+
+	Backport from mainline
+	PR middle-end/90796
+	* gimple-loop-jam.c (any_access_function_variant_p): New function.
+	(adjust_unroll_factor): Use it to constrain safety, new parameter.
+	(tree_loop_unroll_and_jam): Adjust call and profitable unroll factor.
+
+2019-11-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* doc/invoke.texi (-Wc11-c2x-compat): Document.
+
+2019-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90840
+	* expmed.c (store_bit_field_1): Handle the case where op0 is not a MEM
+	and has a mode that doesn't have corresponding integral type.
+
+	PR target/90867
+	* config/i386/i386.c (ix86_valid_target_attribute_tree): Don't
+	clear opts->x_ix86_isa_flags{,2} here...
+	(ix86_valid_target_attribute_inner_p): ... but here when seeing
+	arch=.  Also clear opts->x_ix86_isa_flags{,2}_explicit.
+
+	PR c/90898
+	* tree-ssa-ccp.c (insert_clobber_before_stack_restore): Remove
+	assertion.
+	(insert_clobbers_for_var): Fix a typo in function comment.
+
+2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91450
+	* internal-fn.c (expand_mul_overflow): For s1 * s2 -> ur, if one
+	operand is negative and one non-negative, compare the non-negative
+	one against 0 rather than comparing s1 & s2 against 0.  Otherwise,
+	don't compare (s1 & s2) == 0, but compare separately both s1 == 0
+	and s2 == 0, unless one of them is known to be negative.  Remove
+	tem2 variable, use tem where tem2 has been used before.
+
+2019-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (-gno-internal-reset-location-views): Fix typo.
+
+2019-11-18  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-11-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/rs6000.md (rs6000_set_fpscr_drn): Use ULL on big
+	hexadecimal literal.
+
+2019-11-15  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from mainline
+	2019-09-24  Stamatis Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* config/aarch64/aarch64-option-extensions.def (fp16fml):
+	Update hwcap string for fp16fml.
+
+2019-11-15  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	PR rtl-optimization/92430
+	* cfgcleanup.c (pass_jump_after_combine::gate): New function.
+	(pass_jump_after_combine::execute): Free
+	dominance info at the beginning.
+
+2019-11-13  Claudiu Zissulescu <claziss@gmail.com>
+
+	Backport from mainline
+	* config/arc/arc.md (movsi_ne): Reorder instruction variants and
+	use new register constraint letters.
+	* config/arc/arc.c (arc_legitimize_pic_address): Consider UNSPECs
+	as well, if interesting recover the symbol and re-legitimize the
+	pic address.
+
+2019-11-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-11-14  Martin Liska  <mliska@suse.cz>
+
+	PR target/92389
+	* config/i386/i386.h: Add PTA_AVX512VPOPCNTDQ to
+	PTA_ICELAKE_CLIENT which is later interited by
+	PTA_ICELAKE_SERVER and PTA_TIGERLAKE.
+
+2019-11-13  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	* config/mips/mips.md (rotr<mode>3): Sanitize the constant argument
+	instead of asserting its value.
+
+2019-11-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90930
+	* tree-ssa-reassoc.c (reassociate_bb): Only rewrite expression
+	into parallel form in the last pass instance.
+
+2019-11-11  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backport from trunk:
+	PR target/87833
+	* config/i386/intelmic-mkoffload.c (prepare_target_image): Put
+	-fPIC and -shared the last to create offload image.
+
+2019-11-11  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+	* gimplify.c (gimplify_scan_omp_clauses): Assert 'offset2' instead
+	of 'offset'.
+
+	Backport from trunk:
+	* Makefile.in (LANG_CONFIGUREFRAGS): Define.
+	(config.status): Use/depend on it.
+	* configure.ac (all_lang_configurefrags): Track, 'AC_SUBST'.
+	* configure: Regenerate.
+
+2019-11-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-11-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (memory_barrier): Revise to use ldcw barriers.
+	Enhance comment.
+	(memory_barrier_coherent, memory_barrier_64, memory_barrier_32): New
+	insn patterns using ldcw instruction.
+	(memory_barrier): Remove insn pattern using sync instruction.
+	* config/pa/pa.opt (coherent-ldcw): New option.
+	(ordered): New option.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92384
+	* function.c (assign_parm_setup_block, assign_parm_setup_stack): Don't
+	copy TYPE_EMPTY_P arguments from data->entry_parm to data->stack_parm
+	slot.
+	(assign_parms): For TREE_ADDRESSABLE parms with TYPE_EMPTY_P type
+	force creation of a unique data.stack_parm slot.
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/92231
+	* tree.h (fndecl_built_in_p): Use fndecl_built_in_p instead of
+	DECL_BUILT_IN in comment.  Remove redundant ()s around return
+	argument.
+	* tree.c (free_lang_data_in_decl): Check if var is FUNCTION_DECL
+	before calling fndecl_built_in_p.
+	* gimple-fold.c (gimple_fold_stmt_to_constant_1): Check if
+	TREE_OPERAND (fn, 0) is a FUNCTION_DECL before calling
+	fndecl_built_in_p on it.
+
+	PR c++/90947
+	* tree.h (type_initializer_zero_p): Remove.
+	* tree.c (type_initializer_zero_p): Remove.
+
+	2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* doc/install.texi (--enable-offload-targets): Fix up a typo in the
+	example, use actual names of supported offload targets.
+
+2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/92095
+	* config/sparc/sparc-protos.h (output_load_pcrel_sym): Declare.
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Revert latest
+ 	change.
+	(got_helper_needed): New static variable.
+	(output_load_pcrel_sym): New function.
+	(get_pc_thunk_name): Remove after inlining...
+	(load_got_register): ...here.  Rework the initialization of the GOT
+	register and of the GOT helper.
+	(save_local_or_in_reg_p): Test the REGNO of the GOT register.
+	(sparc_file_end): Test got_helper_needed to decide whether the GOT
+	helper must be emitted.  Use output_asm_insn instead of fprintf.
+	(sparc_init_pic_reg): In PIC mode, always initialize the PIC register
+	if optimization is enabled.
+	* config/sparc/sparc.md (load_pcrel_sym<P:mode>): Emit the assembly
+	by calling output_load_pcrel_sym.
+
+2019-11-06  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	* config/s390/s390.c (s390_canonicalize_comparison): Use XEXP
+	(*op0, 1) instead of XEXP (*op1, 0).
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-24  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (altivec_vavgu<VI_char>): Rename to...
+	(uavg<mode>3_ceil): ... This.
+	(altivec_vavgs<VI_char>): Rename to...
+	(avg<mode>3_ceil): ... This.
+	* config/rs6000/rs6000-builtin.def (VAVGUB, VAVGSB, VAVGUH, VAVGSH,
+	VAVGUW, VAVGSW): Adjust.
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91289
+	* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Don't add an
+	immediate to r0; use r11 instead.  Save and restore r11 to r0 around
+	this.
+
+2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_vector_alignment): Check if the value
+	fits into uhwi before using it.
+
+2019-11-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_call): Remove 64-bit sibcall sequence.
+	(pa_attr_length_call): Adjust length for 64-bit plabel sequence.
+
+2019-11-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (MAX_PCREL17F_OFFSET): Adjust.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirection_name): Rework the
+	function to emit linker-visible symbols only for indirections
+	in the data section.  Clean up the code and update comments.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make the check for
+	Objective-C ABI version more specific for 64bit code.
+
+	Backport from mainline
+	2019-10-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Adjust objective-c
+	ABI version error messages to avoid punctuation and contracted
+	negations.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (REAL_LIBGCC_SPEC): Adjust for earlier Darwin.
+	(STARTFILE_SPEC): Split crt3 into a separate spec.
+	(DARWIN_EXTRA_SPECS): Add crt2 and crt3 spec.
+	(DARWIN_CRT2_SPEC): New.
+	(DARWIN_CRT3_SPEC): New.
+	(MIN_LD64_OMIT_STUBS): Revise to 62.1.
+	* config/rs6000/darwin.h (DARWIN_CRT2_SPEC): Revise conditions.
+	(DARWIN_CRT3_SPEC): New.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): Correct whitespace in the
+	spec.
+
+	Backport from mainline
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): New.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_emit_unwind_label): New.
+	(darwin_override_options): Set darwin_emit_unwind_label as needed.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-13 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Rename symbol stub
+	flag.
+	(darwin_override_options): Likewise.
+	* config/darwin.h: Likewise.
+	* config/darwin.opt: Likewise.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Likewise.
+	* config/i386/darwin.h (TARGET_MACHO_PICSYM_STUBS): Rename to ...
+	... this TARGET_MACHO_SYMBOL_STUBS.
+	(FUNCTION_PROFILER):Likewise.
+	* config/i386/i386.h: Likewise.
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Use renamed
+	darwin_picsymbol_stubs to decide on output.
+	(darwin_override_options): Handle darwin_picsymbol_stubs.
+	* config/darwin.h (MIN_LD64_OMIT_STUBS): New.
+	(LD64_VERSION): Revise default.
+	* config/darwin.opt: (mpic-symbol-stubs): New option.
+	(darwin_picsymbol_stubs): New variable.
+	* config/i386/darwin.h (TARGET_MACHO_BRANCH_ISLANDS):
+	rename to TARGET_MACHO_PICSYM_STUBS.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/i386/i386.h Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Use renamed
+	darwin_picsymbol_stubs.
+
+2019-10-30  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-09  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* cfgcleanup.c (old_insns_match_p): Check if used hard regs set is equal
+	for both call instructions.
+
+2019-10-30  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	* dwarf2out.c (mem_loc_descriptor): Initialize int_mode.
+
+2019-10-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92225
+	* config/i386/sse.md (REDUC_SSE_SMINMAX_MODE): Use TARGET_SSE4_2
+	condition for V2DImode.
+
+2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	PR rtl-optimization/92007
+	* cfgcleanup.c (thread_jump): Add an assertion that we don't
+	call it after reload if hot/cold partitioning has been done.
+	(class pass_postreload_jump): Rename to
+	pass_jump_after_combine.
+	(make_pass_postreload_jump): Rename to
+	make_pass_jump_after_combine.
+	* passes.def(pass_postreload_jump): Move before reload, rename
+	to pass_jump_after_combine.
+	* tree-pass.h (make_pass_postreload_jump): Rename to
+	make_pass_jump_after_combine.
+
+2019-10-28  Peter Bergner <bergner@linux.ibm.com>
+	    Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/70010
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Prohibit inlining if
+	the callee explicitly disables some isa_flags the caller is using.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/65342
+	* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.
+	(movdi_low_st): Delete.
+	* config/rs6000/rs6000.c
+	(darwin_rs6000_legitimate_lo_sum_const_p): New.
+	(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.
+	* config/rs6000/rs6000.md (movsi_low): Delete.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/67183
+	* config/darwin.c (machopic_indirection): New field to flag
+	non-lazy-symbol-pointers in the data section.
+	(machopic_indirection_name): Compute if an indirection should
+	appear in the data section.
+	(machopic_output_data_section_indirection): New callback split
+	from machopic_output_indirection.
+	(machopic_output_stub_indirection): Likewise.
+	(machopic_output_indirection): Retain the code for non-lazy
+	symbol pointers in their regular section.
+	(machopic_finish): Use the new callbacks to order the indirection
+	output.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-protos.h (machopic_finish): Delete.
+	* config/darwin.c (machopic_finish): Make static.
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Set flag to
+	indicate that the new symbol is an indirection.
+	(machopic_indirect_call_target): Likewise.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_INDIRECTION): New.
+	(MACHO_SYMBOL_INDIRECTION_P): New.
+	(MACHO_SYMBOL_FLAG_STATIC): Adjust bit number.
+
+	Backport from mainline
+	2019-10-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Check for
+	required indirections before making direct access to defined
+	values.
+	(machopic_output_indirection): Place the indirected pointes for
+	required indirections into the non-lazy symbol pointers section.
+	(darwin_encode_section_info):
+	* config/darwin.h (MACHO_SYMBOL_FLAG_MUST_INDIRECT): New.
+	(MACHO_SYMBOL_MUST_INDIRECT_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_output_indirection): Don't put
+	hidden symbol indirections into the .data section, use the
+	non-lazy symbol pointers section as normal.
+	(darwin_encode_section_info): Record if a symbol is hidden.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_HIDDEN_VIS): New.
+	(MACHO_SYMBOL_HIDDEN_VIS_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_symbol_defined_p): Use symbol flag
+	predicates instead of accessing bits directly.
+	(machopic_indirect_call_target): Likewise.
+	(machopic_output_indirection): Likewise.
+	(darwin_encode_section_info): Improve description.  Use renamed
+	symbol flags.  Use predicate macros for variables and functions.
+	* config/darwin.h:
+	Rename MACHO_SYMBOL_VARIABLE to MACHO_SYMBOL_FLAG_VARIABLE.
+	Rename MACHO_SYMBOL_DEFINED to MACHO_SYMBOL_FLAG_DEFINED.
+	Rename MACHO_SYMBOL_STATIC to MACHO_SYMBOL_FLAG_STATIC.
+	(MACHO_SYMBOL_VARIABLE_P): New.
+	(MACHO_SYMBOL_DEFINED_P):New.
+	(MACHO_SYMBOL_STATIC_P): New.
+	* config/i386/darwin.h (MACHO_SYMBOL_FLAG_VARIABLE): Delete.
+	(SYMBOL_FLAG_SUBT_DEP): New.
+	* config/rs6000/darwin.h (SYMBOL_FLAG_SUBT_DEP): New.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* gimple-streamer-out.c (output_gimple_stmt): Add explicit function
+	parameter.
+	* lto-streamer-out.c: Include tree-dfa.h.
+	(output_cfg): Do not use cfun.
+	(lto_prepare_function_for_streaming): New.
+	(output_function): Do not push cfun; do not initialize loop optimizer.
+	* lto-streamer.h (lto_prepare_function_for_streaming): Declare.
+	* passes.c (ipa_write_summaries): Use it.
+	(ipa_write_optimization_summaries): Do not modify bodies.
+	* tree-dfa.c (renumber_gimple_stmt_uids): Add function parameter.
+	* tree.dfa.h (renumber_gimple_stmt_uids): Update prototype.
+	* tree-ssa-dse.c (pass_dse::execute): Update use of
+	renumber_gimple_stmt_uids.
+	* tree-ssa-math-opts.c (pass_optimize_widening_mul::execute): Likewise.
+
+	2019-10-12  Jan Hubicka  <hubicka@ucw.cz>
+	* lto-streamer-out.c (collect_block_tree_leafs): Renumber statements
+	so non-virutal are before virutals.
+	(output_function): Avoid body modifications.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	    Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New
+	function.
+	(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.
+	(thumb1_compute_save_core_reg_mask): Don't force a spare work
+	register if both the epilogue and prologue can use call-clobbered
+	regs.
+	(thumb1_unexpanded_epilogue): Use
+	thumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for
+	picking temporaries for restoring high regs to match that of the
+	prologue where possible.
+	(thumb1_expand_prologue): Add any usable call-clobbered low registers to
+	the list of work registers.  Detect if the return address is still live
+	at the end of the prologue and avoid using it for a work register if so.
+	If the return address is not live, add LR to the list of pushable regs
+	after the first pass.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	2019-10-24  Jan Hubicka  <hubicka@ucw.cz>
+	* symbols-summary.h (fast_function_summary<T *, V>::release,
+	fast_call_summary<T *, V>::release): Free m_vector.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+
+	2019-10-18  Jakub Jelinek  <jakub@redhat.com>
+	PR middle-end/92153
+	* ggc-page.c (release_pages): Read g->alloc_size before free rather
+	than after it.
+
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* ggc-page.c (release_pages): Output statistics when !quiet_flag.
+	(ggc_collect): Dump later to not interfere with release_page dump.
+	(ggc_trim): New function.
+	* ggc-none.c (ggc_trim): New.
+	* ggc.h (ggc_trim): Declare.
+
+2019-10-24  Mihail Ionescu  <mihail.ionescu@arm.com>
+
+	Backport from mainline
+	2019-10-18  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/t-multilib: Add new multilib variants and new
+	mappings.
+
+2019-10-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-23  Iain Sandoe  <iain@sandoe.co.uk>
+	* config/rs6000/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Guard
+	against out of range max skip or log values.
+
+2019-10-23  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-08  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	* config.gcc: Move -L usage from LINK_OS_EXTRA_SPEC32 and
+	LINK_OS_EXTRA_SPEC64 to MD_STARTFILE_PREFIX and
+	MD_STARTFILE_PREFIX_1 when using --with-advance-toolchain.
+
+2019-10-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-26  Martin Liska  <mliska@suse.cz>
+
+	PR tree-optimization/91885
+	* tree-vectorizer.c (try_vectorize_loop_1):
+	Add TODO_update_ssa_only_virtuals similarly to what slp
+	pass does.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/92131
+	* tree-vrp.c (extract_range_from_plus_minus_expr): If the resulting
+	range would be symbolic, drop to varying for any explicit overflow
+	in the constant part or if neither range is a singleton.
+
+2019-10-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* dwarf2out.c (gen_formal_parameter_die): Also try to match
+	context_die against a DW_TAG_GNU_formal_parameter_pack parent.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92056
+	* tree-object-size.c (cond_expr_object_size): Return early if then_
+	processing resulted in unknown size.
+
+	2019-10-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91734
+	* generic-match-head.c: Include fold-const-call.h.
+	* match.pd (sqrt(x) cmp c): Check the boundary value and
+	in case inexact computation of c*c affects comparison of the boundary,
+	turn LT_EXPR into LE_EXPR, GE_EXPR into GT_EXPR, LE_EXPR into LT_EXPR
+	or GT_EXPR into GE_EXPR.  Punt for sqrt comparisons against NaN and
+	for -frounding-math.  For c2, try the next smaller or larger floating
+	point constant depending on comparison code and if it has the same
+	sqrt as c2, use it instead of c2.
+
+	2019-09-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/90543
+	* optc-save-gen.awk: Fix up printing string option differences.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91920
+	* gimplify.c (omp_default_clause): Predetermine DECL_IN_CONSTANT_POOL
+	variables as shared.
+
+	2019-09-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91723
+	* tree-vect-stmts.c (vectorizable_call): Use types_compatible_p check
+	instead of pointer equality when checking if argument vectypes are
+	the same.
+
+	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91665
+	* tree-vect-loop.c (vectorizable_reduction): Punt if base has type
+	incompatible with the type of PHI result.
+
+	2019-09-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* function.c (assign_parm_find_data_types): Use RECORD_OR_UNION_TYPE_P
+	before testing TYPE_TRANSPARENT_AGGR.
+	* calls.c (initialize_argument_information, load_register_parameters):
+	Likewise.
+
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91001
+	PR middle-end/91105
+	PR middle-end/91106
+	* calls.c (load_register_parameters): For TYPE_TRANSPARENT_AGGR
+	types, use type of their first field instead of type of
+	args[i].tree_value.
+
+	2019-09-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR go/91617
+	* fold-const.c (range_check_type): For enumeral and boolean
+	type, pass 1 to type_for_size langhook instead of
+	TYPE_UNSIGNED (etype).  Return unsigned_type_for result whenever
+	etype isn't TYPE_UNSIGNED INTEGER_TYPE.
+	(build_range_check): Don't call unsigned_type_for for pointer types.
+	* match.pd (X / C1 op C2): Don't call unsigned_type_for on
+	range_check_type result.
+
+	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91623
+	* optabs.c (expand_vec_cond_expr): If op0 is a VECTOR_CST and only
+	EQ_EXPR/NE_EXPR is supported, verify that op0 only contains
+	zeros or negative elements and use NE_EXPR instead of LT_EXPR against
+	zero vector.
+
+	PR lto/91572
+	* tree.c (find_decls_types_in_node): Also walk TREE_PURPOSE of
+	GIMPLE_ASM TREE_LIST operands.
+
+	2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91351
+	* tree-cfg.c (generate_range_test): Use range_check_type instead of
+	unsigned_type_for.
+	* tree-cfgcleanup.c (convert_single_case_switch): Punt if
+	range_check_type returns NULL.
+	* tree-switch-conversion.c (switch_conversion::build_one_array):
+	Use range_check_type instead of unsigned_type_for, don't perform
+	linear opt if it returns NULL.
+	(bit_test_cluster::find_bit_tests): Formatting fix.
+	(bit_test_cluster::emit): Use range_check_type instead of
+	unsigned_type_for.
+	(switch_decision_tree::try_switch_expansion): Punt if range_check_type
+	returns NULL.
+
+2019-10-18  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2019-10-18 trunk r277143.
+
+	PR target/86040
+	* config/avr/avr.c (avr_out_lpm): Do not shortcut-return.
+
+2019-10-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/59888
+	* config/darwin.c (darwin_rodata_section): Add relocation flag,
+	choose const_data section for constants with relocations.
+	(machopic_select_section): Pass relocation flag to
+	darwin_rodata_section ().
+
+2019-10-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-09-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_legitimize_pic_address): Check
+	for lra, rather than reload.
+
+2019-10-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_indirect_call): Fix typos in last change.
+
+2019-10-17  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/89400
+	* config/arm/arm.md (unaligned_loadsi): Add variant for thumb1.
+	Restrict 'all' variant to 32-bit configurations.
+	(unaligned_loadhiu): Likewise.
+	(unaligned_storehi): Likewise.
+	(unaligned_storesi): Likewise.
+	(unaligned_loadhis): Disable when compiling for thumb1.
+
+2019-10-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/87243
+	* config/darwin-driver.c (maybe_get_sysroot_from_sdkroot): New.
+	(darwin_driver_init): Use the sysroot provided by SDKROOT when that
+	is available and the user has not set one on the command line.
+
+2019-10-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Remove the linker cases.
+	(RDYNAMIC): Rename to, DARWIN_RDYNAMIC.
+	(DARWIN_PIE_SPEC, DARWIN_NOPIE_SPEC): Adjust to remove the Xlinker
+	clauses.
+	(LINK_COMMAND_SPEC_A): Add DARWIN_RDYNAMIC, DARWIN_PIE_SPEC and
+	DARWIN_NOPIE_SPEC.
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Add RDYNAMIC, DARWIN_PIE_SPEC
+	and DARWIN_NOPIE_SPEC.
+	(RDYNAMIC): New, modified from DARWIN_EXPORT_DYNAMIC.
+	(DARWIN_PIE_SPEC): Collate from darwin.h and darwin9.h.
+	(DARWIN_NOPIE_SPEC): Collate from darwin10.h.
+	(DARWIN_NOCOMPACT_UNWIND): New from darwin10.h
+	(DARWIN_EXPORT_DYNAMIC): Delete.
+	* config/darwin10.h (LINK_GCC_C_SEQUENCE_SPEC): Move no_compact_unwind
+	and pie options processing to  darwin.h.
+	* config/darwin9.h (DARWIN_PIE_SPEC): Move pie processing to darwin.h
+
+2019-10-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-04  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91968
+	* tree.c (find_decls_types_r): Do not remove LABEL_DECLs from
+	BLOCK_VARS.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* tree-ssa-phiprop.c (propagate_with_phi): Do not replace
+	volatile loads.
+
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91772
+	* dwarf2out.c (dwarf2out_late_global_decl): If early dwarf
+	was missing generate locations only once.
+
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91790
+	* tree-vect-stmts.c (vectorizable_load): For BB vectorization
+	use the correct DR for setting up realignment.
+
+2019-10-14  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk
+	2019-09-26  Will Schmidt <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def: (LVSL, LVSR, LVEBX, LVEHX,
+	LVEWX, LVXL, LVXL_V2DF, LVXL_V2DI, LVXL_V4SF, LVXL_V4SI, LVXL_V8HI,
+	LVXL_V16QI, LVX, LVX_V1TI, LVX_V2DF, LVX_V2DI, LVX_V4SF, LVX_V4SI,
+	LVX_V8HI, LVX_V16QI, LVLX, LVLXL, LVRX, LVRXL, LXSDX, LXVD2X_V1TI,
+	LXVD2X_V2DF, LXVD2X_V2DI, LXVDSX, LXVW4X_V4SF, LXVW4X_V4SI,
+	LXVW4X_V8HI, LXVW4X_V16QI, LD_ELEMREV_V1TI, LD_ELEMREV_V2DF,
+	LD_ELEMREV_V2DI, LD_ELEMREV_V4SF, LD_ELEMREV_V4SI, LD_ELEMREV_V8HI,
+	LD_ELEMREV_V16QI): Use the PURE attribute.
+
+2019-10-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92022
+	* config/alpha/alpha.c (alpha_handle_trap_shadows): Skip DEBUG_INSN.
+
+2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88630
+	* config/sh/sh.h (TARGET_FPU_SH4_300): New macro.
+	* config/sh/sh.c (sh_option_override): Enable fsca and fsrra insns
+	also for TARGET_FPU_SH4_300.
+	(sh_emit_mode_set): Check for TARGET_FPU_SH4_300 instead of
+	TARGET_SH4_300.
+	* config/sh/sh.md (toggle_pr): Add TARGET_FPU_SH4_300 condition.
+	(negsf2): Expand to either negsf2_fpscr or negsf2_no_fpscr.
+	(*negsf2_i): Split into ...
+	(negsf2_fpscr, negsf2_no_fpscr): ... these new patterns.
+	(abssf2): Expand to either abssf2_fpsc or abssf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(abssf2_fpscr, abssf2_no_fpscr): ... these new patterns.
+	(negdf2): Expand to either negdf2_fpscr or negdf2_no_fpscr.
+	(*negdf2_i): Split into ...
+	(negdf2_fpscr, negdf2_no_fpscr): ... these new patterns.
+	(absdf2): Expand to either absdf2_fpscr or absdf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(absdf2_fpscr, absdf2_no_fpscr): ... these new patterns.
+
+2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* common/config/s390/s390-common.c (PF_ARCH13): Rename to...
+	(PF_Z15): ... this.
+	* config.gcc: Add z15 as option for --with-arch and --with-tune
+	configure switches.
+	* config/s390/s390-c.c (s390_resolve_overloaded_builtin): Add
+	error reporting for unsupported builtins.
+	* config/s390/s390-opts.h (enum processor_type): Rename
+	PROCESSOR_8561_ARCH13 to PROCESSOR_8561_Z15.
+	* config/s390/8561.md: Rename arch13 to z15 throughout the file.
+	* config/s390/driver-native.c (s390_host_detect_local_cpu):
+	Likewise.
+	* config/s390/s390-builtins.def: Likewise.
+	* config/s390/s390.c (processor_table): Add z15 as option and keep arch13 as alternative.
+	(s390_expand_builtin): Add missing check for unsupported builtins.
+	(s390_canonicalize_comparison): Rename TARGET_ARCH13 to TARGET_Z15.
+	(s390_rtx_costs): Likewise.
+	(s390_get_sched_attrmask): Rename arch13 to z15.
+	(s390_get_unit_mask): Likewise.
+	(s390_is_fpd): Likewise.
+	(s390_is_fxd): Likewise.
+	* config/s390/s390.h (enum processor_flags): Likewise.
+	* config/s390/s390.md: Likewise.
+	* config/s390/vector.md: Likewise.
+	* config/s390/vx-builtins.md: Likewise.
+	* config/s390/s390.opt: Add z15 to processor_type value.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/91275
+	* config/rs6000/rs6000-p8swap.c (rtx_is_swappable_p): Don't swap
+	vpmsumd.
+
+2019-10-05  Andrea Corallo  <andrea.corallo@arm.com>
+
+	Backport from mainline
+	2019-10-03  Andrea Corallo  <andrea.corallo@arm.com>
+	* gcc/ipa-cp.c (ipa_cp_c_finalize): Release ipcp_transformation_sum
+	when finished.
+	* ipa-prop.c (ipcp_free_transformation_sum): New function.
+	* ipa-prop.h (ipcp_free_transformation_sum): Add declaration.
+
+2019-10-04  Dragan Mladjenovic <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-10-03  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	PR target/91769
+	* config/mips/mips.c (mips_split_move): Use reg_overlap_mentioned_p
+	instead of REGNO equality check on addr.reg.
+
+2019-10-04  Dragan Mladjenovic <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/mips/mips.c (mips_split_move): Zero-initialize addr
+	and check whether addr.reg is nonnull before using it.
+
+2019-10-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+
+	2019-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR fortran/91716
+	* trans-array.c (gfc_conv_array_initializer): Always assign the
+	array type of the field to the string constant.
+
+2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+
+	2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88562
+	* config/sh/sh.c (sh_extending_set_of_reg::use_as_extended_reg): Use
+	sh_check_add_incdec_notes to preserve REG_INC notes when replacing
+	a memory access insn.
+
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md (mov<mode>): Don't call
+	aarch64_split_dimode_const_store on volatile MEM.
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-26  Matt Turner  <mattst88@gmail.com>
+
+	PR driver/69471
+	* config/aarch64/aarch64.opt (march=): Add Negative(march=).
+	(mtune=): Add Negative(mtune=).
+	(mcpu=): Add Negative(mcpu=).
+	* config/arm/arm.opt: Likewise.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/86805
+	* config/sh/sh.c (TARGET_HAVE_SPECULATION_SAFE_VALUE): Define.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/80672
+	* config/sh/sh.c (parse_validate_atomic_model_option): Use
+	std::string::compare instead of std::string::find.
+
+2019-09-25  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-08-22  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	* config/arm/arm_acle.h: Use arch=armv8-a+crc+simd pragma for CRC32
+	intrinsics if __ARM_FP.
+	Use __ARM_FEATURE_CRC32 ifdef guard.
+
+2019-09-23  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2019-06-18  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (xtensa_expand_prologue): Add stack
+	pointer adjustment for the case of no callee-saved registers and
+	stack frame bigger than 128 bytes.
+
+2019-09-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt (prebind, noprebind, seglinkedit,
+	noseglinkedit): Add RejectNegative.
+
+	Backport from mainline
+	2019-06-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt: Add RejectNegative where needed, reorder
+	and add minimal functional descriptions.
+
+2019-09-20  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_trampoline_init): Remove spurious extended
+	character.
+
+2019-09-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-06-06  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR rtl-optimization/88751
+	* ira.c (ira): Use the number of the actually referenced registers
+	when calculating the threshold.
+
+2019-09-20  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-09-18  Jim Wilson  <jimw@sifive.com>
+
+	PR target/91683
+	* config/riscv/riscv-protos.h (riscv_split_symbol): New bool parameter.
+	(riscv_move_integer): Likewise.
+	* config/riscv/riscv.c (riscv_split_integer): Pass FALSE for new
+	riscv_move_integer arg.
+	(riscv_legitimize_move): Likewise.
+	(riscv_force_temporary): New parameter in_splitter.  Don't call
+	force_reg if true.
+	(riscv_unspec_offset_high): Pass FALSE for new riscv_force_temporary
+	arg.
+	(riscv_add_offset): Likewise.
+	(riscv_split_symbol): New parameter in_splitter.  Pass to
+	riscv_force_temporary.
+	(riscv_legitimize_address): Pass FALSE for new riscv_split_symbol
+	arg.
+	(riscv_move_integer): New parameter in_splitter.  New local
+	can_create_psuedo.  Don't call riscv_split_integer or force_reg when
+	in_splitter TRUE.
+	(riscv_legitimize_const_move): Pass FALSE for new riscv_move_integer,
+	riscv_split_symbol, and riscv_force_temporary args.
+	* config/riscv/riscv.md (low<mode>+1): Pass TRUE for new
+	riscv_move_integer arg.
+	(low<mode>+2): Pass TRUE for new riscv_split_symbol arg.
+
+2019-09-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91269
+	* config/sparc/sparc.h (HARD_REGNO_CALLER_SAVE_MODE): Define.
+
+2019-09-19  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+		    Jim Wilson  <jimw@sifive.com>
+
+	PR target/91635
+	* config/riscv/riscv.md (zero_extendsidi2, zero_extendhi<GPR:mode>2,
+	extend<SHORT:mode><SUPERQI:mode>2): Don't split if
+	paradoxical_subreg_p (operands[0]).
+	(*lshrsi3_zero_extend_3+1, *lshrsi3_zero_extend_3+2): Add clobber and
+	use as intermediate value.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89795
+	* rtlanal.c (nonzero_bits1) <SUBREG>: Do not propagate results from
+	inner REGs to paradoxical SUBREGs if WORD_REGISTER_OPERATIONS is set.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* config/i386/emmintrin.h (_mm_cmpeq_epi8): Use casts to __v16qi
+	instead of __v16qs.
+
+	PR target/91704
+	* config/i386/avxintrin.h (__v32qs): New typedef.
+	* config/i386/avx2intrin.h (_mm256_cmpgt_epi8): Use casts to __v32qs
+	instead of __v32qi.
+
+2019-09-04  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-08-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/81800
+	* gcc/config/aarch64/aarch64.md (lrint): Disable lrint pattern if GPF
+	operand is larger than a long int.
+
+2019-09-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91597
+	* tree-vrp.c (extract_range_from_binary_expr): Remove unsafe
+	BIT_AND_EXPR optimization for pointers, even if both operand
+	ranges don't include NULL, the result can be NULL.
+
+2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/91601
+	* gcov.c (path_contains_zero_cycle_arc): Rename to ...
+	(path_contains_zero_or_negative_cycle_arc): ... this and handle
+	also negative edges.
+	(circuit): Handle also negative edges as they can happen
+	in some situations.
+
+2019-09-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91472
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Return true
+	during LRA/reload in PIC mode if the PIC register hasn't been used yet.
+	(sparc_pic_register_p): Test reload_in_progress for consistency's sake.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* ggc-page.c (ggc_pch_read): Read the ggc_pch_ondisk structure
+	and issue any diagnostics needed before collecting the pre-PCH
+	state.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* config/rs6000/rs6000.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	and UNSPEC_DARN_RAW.
+	(unspecv): New enumerator values UNSPECV_DARN, UNSPECV_DARN_32, and
+	UNSPECV_DARN_RAW.
+	(darn_32): Use an unspec_volatile, and UNSPECV_DARN_32.
+	(darn_raw): Use an unspec_volatile, and UNSPECV_DARN_RAW.
+	(darn): Use an unspec_volatile, and UNSPECV_DARN.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	UNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...
+	* config/rs6000/rs6000.md (unspec): ... here.
+	* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): Delete, move to...
+	* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): ... here.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* tree-ssa-forwprop.c (pass_forwprop::execute): Transfer/clean
+	EH on comparison simplification.
+
+2019-08-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91568
+	* tree-vectorizer.h (_slp_tree::max_nunits): Add.
+	(vect_update_max_nunits): Add overload for poly_uint64.
+	* tree-vect-slp.c (vect_create_new_slp_node): Initialize it.
+	(vect_build_slp_tree): Record max_nunits into the subtree
+	and merge it upwards.
+	(vect_print_slp_tree): Print max_nunits.
+
+2019-08-28  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90637
+	* tree-ssa-sink.c (statement_sink_location): Honor the
+	computed sink location for single-uses.
+
+2019-08-26  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport r274411 from trunk to gcc-9-branch.
+	2019-08-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	PR lto/91287
+	* builtins.c (builtin_with_linkage_p): New function.
+	* builtins.h (builtin_with_linkage_p): New function.
+	* symtab.c (write_symbol): Remove redundant assert.
+	* lto-streamer-out.c (symtab_node::output_to_lto_symbol_table_p):
+	Remove FIXME and use builtin_with_linkage_p.
+
+2019-08-25  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/91533
+	Backport from mainline
+	2019-06-30  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (ssse3_abs<mode>2): Rename from abs<mode>2.
+	* config/i386/i386-builtin.def (__builtin_ia32_pabsb):
+	Use CODE_FOR_ssse3_absv8qi2.
+	(__builtin_ia32_pabsw): Use CODE_FOR_ssse3_absv4hi2.
+	(__builtin_ia32_pabsd): Use CODE_FOR_ssse3_absv2si2.
+
+2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	Backport from mainline
+	2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	* config/mips/mips.md (mips_get_fcsr, *mips_get_fcsr): Use SI
+	machine mode for unspec_volatile operand.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91508
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91438
+	* cgraph.c (cgraph_node::remove): When setting
+	n->origin = NULL for all nested functions, reset
+	also next_nested.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	* cgraph.c (cgraph_node::verify_node): Verify origin, nested
+	and next_nested.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91404
+	* passes.c (order): Remove.
+	(uid_hash_t): Likewise).
+	(remove_cgraph_node_from_order): Remove from set
+	of pointers (cgraph_node *).
+	(insert_cgraph_node_to_order): New.
+	(duplicate_cgraph_node_to_order): New.
+	(do_per_function_toporder): Register all 3 cgraph hooks.
+	Skip removed_nodes now as we know about all of them.
+
+2019-08-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (TARGET_OS_CPP_BUILTINS): Add asserts
+	for cpu and machine.  Factor 64/32b builtins.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-09-09  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/91386
+	* config/aarch64/aarch64.c (aarch64_gen_adjusted_ldpstp): Use copy_rtx
+	to preserve the contents of the original insns.
+
+2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-int.h (lra_need_for_scratch_reg_p): Declare.
+	* lra.c (lra): Use lra_need_for_scratch_reg_p.
+	* lra-spills.c (lra_need_for_scratch_reg_p): New function.
+
+	2019-08-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-remat.c (update_scratch_ops): Remove assignment of the
+	hard register.
+
+2019-08-15  Steve Ellcey  <sellcey@marvell.com>
+
+	Backport from mainline
+	2019-08-02  Steve Ellcey  <sellcey@marvell.com>
+
+	* omp-simd-clone.c (simd_clone_adjust_return_type): Remove call to
+	build_distinct_type_copy.
+	(simd_clone_adjust_argument_types): Ditto.
+	(simd_clone_adjust): Call build_distinct_type_copy here.
+	(expand_simd_clones): Ditto.
+
+2019-08-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91445
+	Backport from mainline
+	2019-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91091
+	* tree-ssa-alias.h (get_continuation_for_phi): Add tbaa_p parameter.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-alias.c (maybe_skip_until): Pass down tbaa_p.
+	(get_continuation_for_phi): New tbaa_p parameter and pass
+	it down.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-pre.c (translate_vuse_through_block): Likewise.
+	* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):
+	Likewise.
+	* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add tbaa_p flag.
+	(vn_reference_lookup_3): Handle and pass down tbaa_p flag.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Remove alias-set altering, instead pass
+	down false as tbaa_p.
+
+	2019-07-04  Richard Biener  <rguenther@suse.de>
+
+	* tree-ssa-sccvn.h (vn_reference_lookup): Add last_vuse_ptr
+	argument.
+	* tree-ssa-sccvn.c (last_vuse_ptr, vn_walk_kind): Move
+	globals into...
+	(struct vn_walk_cb_data): New callback data struct.
+	(vn_reference_lookup_2): Adjust.
+	(vn_reference_lookup_3): Likewise.
+	(vn_reference_lookup_pieces): Likewise.
+	(vn_reference_lookup): Likewise, get last_vuse_ptr argument.
+	(visit_reference_op_load): Adjust.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* tree.c (type_initializer_zero_p): Define.
+	* tree.h (type_initializer_zero_p): New function.
+
+	2019-08-05  Martin Sebor  <msebor@redhat.com>
+
+	* doc/extend.texi (Common Variable Attributes): Document alias
+	attribute.
+
+2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91375
+	* tree.c (free_lang_data_in_type): Do not free TYPE_BINFO dependent on
+	flag_devirtualize.
+
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR driver/91130
+	* lto-wrapper.c (get_options_from_collect_gcc_options): Remove
+	lang_mask option, always use CL_DRIVER.
+	(find_and_merge_options): Adjust.
+	(run_gcc): Likewise.
+
+	2019-08-07  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR driver/91130
+	* lto-wrapper.c (find_and_merge_options): Use CL_DRIVER when
+	processing COLLECT_GCC_OPTIONS.
+	(run_gcc): Likewise.
+
+2019-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.2.1.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -513,7 +2861,7 @@
 
 2019-07-11  Uroš Bizjak  <ubizjak@gmail.com>
 
-	Backported from mainline
+	Backport from mainline
 	2019-07-06  Richard Sandiford  <richard.sandiford@arm.com>
 
 	* config/i386/sse.md (*andnot<mode>3_bcst): Fix VI/VI48_AVX512VL typo.
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 5f43d9de00e..abae872cd63 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1120,6 +1120,7 @@ endif
 # Support for additional languages (other than C).
 # C can be supported this way too (leave for later).
 
+LANG_CONFIGUREFRAGS  = @all_lang_configurefrags@
 LANG_MAKEFRAGS = @all_lang_makefrags@
 
 # Used by gcc/jit/Make-lang.in
@@ -1894,7 +1895,7 @@ cstamp-h: config.in config.status
 # Really, really stupid make features, such as SUN's KEEP_STATE, may force
 # a target to build even if it is up-to-date.  So we must verify that
 # config.status does not exist before failing.
-config.status: $(srcdir)/configure $(srcdir)/config.gcc
+config.status: $(srcdir)/configure $(srcdir)/config.gcc $(LANG_CONFIGUREFRAGS)
 	@if [ ! -f config.status ] ; then \
 	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
 	  false; \
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 22cd00956dc..5464c6b3d68 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,57 @@
+2019-11-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/92489
+	Backport from mainline
+	2019-07-01  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_attr.adb (Expand_Attribute_Reference, case Invalid_Value):
+	Resolve result of call to Get_Simple_Init_Val, which may be a
+	conversion of a literal.
+
+2019-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/92362
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Attribute_Definition_Clause>:
+	Use a temporary instead of clobbering the result with a freeze node.
+
+2019-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/92575
+	* expect.c (__gnat_expect_poll [VMS, HPUX]): Fix typo.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* locales.c (iso_3166): Add missing comma after "United-States".
+
+2019-10-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/91995
+	* sem_ch8.adb (Chain_Use_Clause): Remove second argument in calls
+	to Defining_Entity.
+	* sem_elab.adb (Find_Unit_Entity): Likewise.  Deal with N_Subunit
+	here in lieu of in Defining_Entity.
+	* sem_spark.adb (Check_Callable_Body): Likewise.
+	(Check_Package_Body): Likewise.
+	* sem_util.ads (Defining_Entity): Remove 2nd and 3th parameters.
+	* sem_util.adb (Defining_Entity): Remove 2nd and 3th parameters,
+	and adjust accordingly.  Deal with N_Compilation_Unit.
+
+2019-10-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Really test the
+	sign of the value when deciding to build a NEGATE_EXPR.
+	<PLUS_EXPR>: Remove redundant line.
+	<BIT_AND_EXPR>: Do the negation here.
+
+2019-09-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep
+	on the underlying type of the node.
+	(Call_to_gnu): Likewise with the type of the prefix.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/ada/exp_attr.adb b/gcc/ada/exp_attr.adb
index 22368a19d0b..cbf7db372ff 100644
--- a/gcc/ada/exp_attr.adb
+++ b/gcc/ada/exp_attr.adb
@@ -4242,6 +4242,11 @@ package body Exp_Attr is
       when Attribute_Invalid_Value =>
          Rewrite (N, Get_Simple_Init_Val (Ptyp, N));
 
+         --  The value produced may be a conversion of a literal, which
+         --  must be resolved to establish its proper type.
+
+         Analyze_And_Resolve (N);
+
       ----------
       -- Last --
       ----------
diff --git a/gcc/ada/expect.c b/gcc/ada/expect.c
index 76fce788fc9..d4ffae21913 100644
--- a/gcc/ada/expect.c
+++ b/gcc/ada/expect.c
@@ -265,7 +265,7 @@ __gnat_expect_poll (int *fd,
 	  if ((status & 1) != 1)
 	    {
               ready = -1;
-              dead_process = i + 1;
+              *dead_process = i + 1;
               return ready;
 	    }
 	}
@@ -450,7 +450,7 @@ __gnat_expect_poll (int *fd,
 	            if (ei.request == TIOCCLOSE)
 		      {
 		        ioctl (fd[i], TIOCREQSET, &ei);
-                        dead_process = i + 1;
+                        *dead_process = i + 1;
 		        return -1;
 		      }
 
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index 4e73df0d7f0..a724ba693fd 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -8255,9 +8255,8 @@ annotate_value (tree gnu_size)
     {
     case INTEGER_CST:
       /* For negative values, build NEGATE_EXPR of the opposite.  Such values
-	 can appear for discriminants in expressions for variants.  Note that,
-	 sizetype being unsigned, we don't directly use tree_int_cst_sgn.  */
-      if (tree_int_cst_sign_bit (gnu_size))
+	 can appear for discriminants in expressions for variants.  */
+      if (tree_int_cst_sgn (gnu_size) < 0)
 	{
 	  tree t = wide_int_to_tree (sizetype, -wi::to_wide (gnu_size));
 	  tcode = Negate_Expr;
@@ -8335,9 +8334,8 @@ annotate_value (tree gnu_size)
 	  && tree_int_cst_sign_bit (TREE_OPERAND (gnu_size, 1)))
 	{
 	  tcode = Minus_Expr;
-	  ops[0] = annotate_value (TREE_OPERAND (gnu_size, 0));
-	  wide_int op1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
-	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  wide_int wop1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, wop1));
 	  break;
 	}
 
@@ -8378,9 +8376,9 @@ annotate_value (tree gnu_size)
 	 Such values can appear in expressions with aligning patterns.  */
       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)
 	{
-	  wide_int op1 = wi::sext (wi::to_wide (TREE_OPERAND (gnu_size, 1)),
-				   TYPE_PRECISION (sizetype));
-	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  wide_int wop1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
+	  tree op1 = wide_int_to_tree (sizetype, wop1);
+	  ops[1] = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
 	}
       break;
 
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index 49fd34656ad..2581b71d6fa 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -2248,32 +2248,29 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)
       /* For other address attributes applied to a nested function,
 	 find an inner ADDR_EXPR and annotate it so that we can issue
 	 a useful warning with -Wtrampolines.  */
-      else if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_prefix)))
+      else if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_prefix))
+	       && (gnu_expr = remove_conversions (gnu_result, false))
+	       && TREE_CODE (gnu_expr) == ADDR_EXPR
+	       && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
 	{
-	  gnu_expr = remove_conversions (gnu_result, false);
+	  set_expr_location_from_node (gnu_expr, gnat_node);
 
-	  if (TREE_CODE (gnu_expr) == ADDR_EXPR
-	      && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
-	    {
-	      set_expr_location_from_node (gnu_expr, gnat_node);
-
-	      /* Also check the inlining status.  */
-	      check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
-
-	      /* Moreover, for 'Access or 'Unrestricted_Access with non-
-		 foreign-compatible representation, mark the ADDR_EXPR so
-		 that we can build a descriptor instead of a trampoline.  */
-	      if ((attribute == Attr_Access
-		   || attribute == Attr_Unrestricted_Access)
-		  && targetm.calls.custom_function_descriptors > 0
-		  && Can_Use_Internal_Rep (Etype (gnat_node)))
-		FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
-
-	      /* Otherwise, we need to check that we are not violating the
-		 No_Implicit_Dynamic_Code restriction.  */
-	      else if (targetm.calls.custom_function_descriptors != 0)
-	        Check_Implicit_Dynamic_Code_Allowed (gnat_node);
-	    }
+	  /* Also check the inlining status.  */
+	  check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
+
+	  /* Moreover, for 'Access or 'Unrestricted_Access with non-
+	     foreign-compatible representation, mark the ADDR_EXPR so
+	     that we can build a descriptor instead of a trampoline.  */
+	  if ((attribute == Attr_Access
+	       || attribute == Attr_Unrestricted_Access)
+	      && targetm.calls.custom_function_descriptors > 0
+	      && Can_Use_Internal_Rep (Underlying_Type (Etype (gnat_node))))
+	    FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
+
+	  /* Otherwise, we need to check that we are not violating the
+	     No_Implicit_Dynamic_Code restriction.  */
+	  else if (targetm.calls.custom_function_descriptors != 0)
+	    Check_Implicit_Dynamic_Code_Allowed (gnat_node);
 	}
       break;
 
@@ -5103,7 +5100,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,
       /* If the access type doesn't require foreign-compatible representation,
 	 be prepared for descriptors.  */
       if (targetm.calls.custom_function_descriptors > 0
-	  && Can_Use_Internal_Rep (Etype (Prefix (Name (gnat_node)))))
+	  && Can_Use_Internal_Rep
+	     (Underlying_Type (Etype (Prefix (Name (gnat_node))))))
 	by_descriptor = true;
     }
   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)
@@ -8310,7 +8308,7 @@ gnat_to_gnu (Node_Id gnat_node)
       gnat_temp = Entity (Name (gnat_node));
       if (Freeze_Node (gnat_temp))
 	{
-	  tree gnu_address = gnat_to_gnu (Expression (gnat_node));
+	  tree gnu_address = gnat_to_gnu (Expression (gnat_node)), gnu_temp;
 
 	  /* Get the value to use as the address and save it as the equivalent
 	     for the object; when it is frozen, gnat_to_gnu_entity will do the
@@ -8320,7 +8318,7 @@ gnat_to_gnu (Node_Id gnat_node)
 	     of the object is limited and it is initialized with the result of
 	     a function call.  */
 	  if (Is_Subprogram (gnat_temp))
-	    gnu_result = gnu_address;
+	    gnu_temp = gnu_address;
 	  else
 	    {
 	      tree gnu_type = gnat_to_gnu_type (Etype (gnat_temp));
@@ -8329,11 +8327,11 @@ gnat_to_gnu (Node_Id gnat_node)
 	      gnu_type
 		= build_reference_type_for_mode (gnu_type, ptr_mode, true);
 	      gnu_address = convert (gnu_type, gnu_address);
-	      gnu_result
+	      gnu_temp
 		= build_unary_op (INDIRECT_REF, NULL_TREE, gnu_address);
 	    }
 
-	  save_gnu_tree (gnat_temp, gnu_result, true);
+	  save_gnu_tree (gnat_temp, gnu_temp, true);
 	}
       break;
 
diff --git a/gcc/ada/locales.c b/gcc/ada/locales.c
index 2bf900319ca..9372bdb2d58 100644
--- a/gcc/ada/locales.c
+++ b/gcc/ada/locales.c
@@ -529,7 +529,7 @@ static char* iso_3166[] =
   "UM", "United States Minor Outlying Islands",
   "US", "United States",
   "US", "United States of America",
-  "US", "United-States"
+  "US", "United-States",
   "UY", "Uruguay",
   "UZ", "Uzbekistan",
 
diff --git a/gcc/ada/sem_ch8.adb b/gcc/ada/sem_ch8.adb
index a5e821da1b4..340aa49bd11 100644
--- a/gcc/ada/sem_ch8.adb
+++ b/gcc/ada/sem_ch8.adb
@@ -4256,16 +4256,14 @@ package body Sem_Ch8 is
 
       --  Common case for compilation unit
 
-      elsif Defining_Entity (N               => Parent (N),
-                             Empty_On_Errors => True) = Current_Scope
-      then
+      elsif Defining_Entity (Parent (N)) = Current_Scope then
          null;
 
       else
          --  If declaration appears in some other scope, it must be in some
          --  parent unit when compiling a child.
 
-         Pack := Defining_Entity (Parent (N), Empty_On_Errors => True);
+         Pack := Defining_Entity (Parent (N));
 
          if not In_Open_Scopes (Pack) then
             null;
diff --git a/gcc/ada/sem_elab.adb b/gcc/ada/sem_elab.adb
index b74f88d0461..ee0c49ba40c 100644
--- a/gcc/ada/sem_elab.adb
+++ b/gcc/ada/sem_elab.adb
@@ -5544,13 +5544,23 @@ package body Sem_Elab is
                                    N_Procedure_Instantiation)
         and then Nkind (Context) = N_Compilation_Unit
       then
-         return
-           Related_Instance (Defining_Entity (N, Concurrent_Subunit => True));
+         return Related_Instance (Defining_Entity (N));
+
+      --  The unit denotes a concurrent body acting as a subunit. Such bodies
+      --  are generally rewritten into null statements. The proper entity is
+      --  that of the "original node".
+
+      elsif Nkind (N) = N_Subunit
+        and then Nkind (Proper_Body (N)) = N_Null_Statement
+        and then Nkind_In (Original_Node (Proper_Body (N)), N_Protected_Body,
+                                                            N_Task_Body)
+      then
+         return Defining_Entity (Original_Node (Proper_Body (N)));
 
       --  Otherwise the proper entity is the defining entity
 
       else
-         return Defining_Entity (N, Concurrent_Subunit => True);
+         return Defining_Entity (N);
       end if;
    end Find_Unit_Entity;
 
diff --git a/gcc/ada/sem_spark.adb b/gcc/ada/sem_spark.adb
index cfa6df81854..439d29fe9dc 100644
--- a/gcc/ada/sem_spark.adb
+++ b/gcc/ada/sem_spark.adb
@@ -804,7 +804,7 @@ package body Sem_SPARK is
 
       if Present (SPARK_Pragma (Defining_Entity (Body_N))) then
          if Get_SPARK_Mode_From_Annotation
-           (SPARK_Pragma (Defining_Entity (Body_N, False))) /= Opt.On
+           (SPARK_Pragma (Defining_Entity (Body_N))) /= Opt.On
          then
             return;
          end if;
@@ -1914,7 +1914,7 @@ package body Sem_SPARK is
       CorSp : Node_Id;
 
    begin
-      if Present (SPARK_Pragma (Defining_Entity (Pack, False))) then
+      if Present (SPARK_Pragma (Defining_Entity (Pack))) then
          if Get_SPARK_Mode_From_Annotation
            (SPARK_Pragma (Defining_Entity (Pack))) /= Opt.On
          then
diff --git a/gcc/ada/sem_util.adb b/gcc/ada/sem_util.adb
index 16c671111e4..eedfaf1376e 100644
--- a/gcc/ada/sem_util.adb
+++ b/gcc/ada/sem_util.adb
@@ -5827,11 +5827,7 @@ package body Sem_Util is
    -- Defining_Entity --
    ---------------------
 
-   function Defining_Entity
-     (N                  : Node_Id;
-      Empty_On_Errors    : Boolean := False;
-      Concurrent_Subunit : Boolean := False) return Entity_Id
-   is
+   function Defining_Entity (N : Node_Id) return Entity_Id is
    begin
       case Nkind (N) is
          when N_Abstract_Subprogram_Declaration
@@ -5882,24 +5878,11 @@ package body Sem_Util is
          =>
             return Defining_Identifier (N);
 
-         when N_Subunit =>
-            declare
-               Bod      : constant Node_Id := Proper_Body (N);
-               Orig_Bod : constant Node_Id := Original_Node (Bod);
-
-            begin
-               --  Retrieve the entity of the original protected or task body
-               --  if requested by the caller.
+         when N_Compilation_Unit =>
+            return Defining_Entity (Unit (N));
 
-               if Concurrent_Subunit
-                 and then Nkind (Bod) = N_Null_Statement
-                 and then Nkind_In (Orig_Bod, N_Protected_Body, N_Task_Body)
-               then
-                  return Defining_Entity (Orig_Bod);
-               else
-                  return Defining_Entity (Bod);
-               end if;
-            end;
+         when N_Subunit =>
+            return Defining_Entity (Proper_Body (N));
 
          when N_Function_Instantiation
             | N_Function_Specification
@@ -5925,14 +5908,10 @@ package body Sem_Util is
                --  can continue semantic analysis.
 
                elsif Nam = Error then
-                  if Empty_On_Errors then
-                     return Empty;
-                  else
-                     Err := Make_Temporary (Sloc (N), 'T');
-                     Set_Defining_Unit_Name (N, Err);
+                  Err := Make_Temporary (Sloc (N), 'T');
+                  Set_Defining_Unit_Name (N, Err);
 
-                     return Err;
-                  end if;
+                  return Err;
 
                --  If not an entity, get defining identifier
 
@@ -5947,11 +5926,7 @@ package body Sem_Util is
             return Entity (Identifier (N));
 
          when others =>
-            if Empty_On_Errors then
-               return Empty;
-            else
-               raise Program_Error;
-            end if;
+            raise Program_Error;
       end case;
    end Defining_Entity;
 
diff --git a/gcc/ada/sem_util.ads b/gcc/ada/sem_util.ads
index 4e4d4ba8826..f098ea44d97 100644
--- a/gcc/ada/sem_util.ads
+++ b/gcc/ada/sem_util.ads
@@ -543,10 +543,7 @@ package Sem_Util is
    --  in the case of a descendant of a generic formal type (returns Int'Last
    --  instead of 0).
 
-   function Defining_Entity
-     (N                  : Node_Id;
-      Empty_On_Errors    : Boolean := False;
-      Concurrent_Subunit : Boolean := False) return Entity_Id;
+   function Defining_Entity (N : Node_Id) return Entity_Id;
    --  Given a declaration N, returns the associated defining entity. If the
    --  declaration has a specification, the entity is obtained from the
    --  specification. If the declaration has a defining unit name, then the
@@ -557,22 +554,6 @@ package Sem_Util is
    --  local entities declared during loop expansion. These entities need
    --  debugging information, generated through Qualify_Entity_Names, and
    --  the loop declaration must be placed in the table Name_Qualify_Units.
-   --
-   --  Set flag Empty_On_Error to change the behavior of this routine as
-   --  follows:
-   --
-   --    * True  - A declaration that lacks a defining entity returns Empty.
-   --      A node that does not allow for a defining entity returns Empty.
-   --
-   --    * False - A declaration that lacks a defining entity is given a new
-   --      internally generated entity which is subsequently returned. A node
-   --      that does not allow for a defining entity raises Program_Error.
-   --
-   --  The former semantics is appropriate for the back end; the latter
-   --  semantics is appropriate for the front end.
-   --
-   --  Set flag Concurrent_Subunit to handle rewritings of concurrent bodies
-   --  which act as subunits. Such bodies are generally rewritten as null.
 
    function Denotes_Discriminant
      (N                : Node_Id;
diff --git a/gcc/alias.c b/gcc/alias.c
index b64e3ea264d..053c3494e79 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -1186,15 +1186,14 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)
     }
 }
 
-/* Record that component types of TYPE, if any, are part of that type for
+/* Record that component types of TYPE, if any, are part of SUPERSET for
    aliasing purposes.  For record types, we only record component types
    for fields that are not marked non-addressable.  For array types, we
    only record the component type if it is not marked non-aliased.  */
 
 void
-record_component_aliases (tree type)
+record_component_aliases (tree type, alias_set_type superset)
 {
-  alias_set_type superset = get_alias_set (type);
   tree field;
 
   if (superset == 0)
@@ -1244,7 +1243,21 @@ record_component_aliases (tree type)
 				       == get_alias_set (TREE_TYPE (field)));
 	      }
 
-	    record_alias_subset (superset, get_alias_set (t));
+	    alias_set_type set = get_alias_set (t);
+	    record_alias_subset (superset, set);
+	    /* If the field has alias-set zero make sure to still record
+	       any componets of it.  This makes sure that for
+		 struct A {
+		   struct B {
+		     int i;
+		     char c[4];
+		   } b;
+		 };
+	       in C++ even though 'B' has alias-set zero because
+	       TYPE_TYPELESS_STORAGE is set, 'A' has the alias-set of
+	       'int' as subset.  */
+	    if (set == 0)
+	      record_component_aliases (t, superset);
 	  }
       break;
 
@@ -1260,6 +1273,19 @@ record_component_aliases (tree type)
     }
 }
 
+/* Record that component types of TYPE, if any, are part of that type for
+   aliasing purposes.  For record types, we only record component types
+   for fields that are not marked non-addressable.  For array types, we
+   only record the component type if it is not marked non-aliased.  */
+
+void
+record_component_aliases (tree type)
+{
+  alias_set_type superset = get_alias_set (type);
+  record_component_aliases (type, superset);
+}
+
+
 /* Allocate an alias set for use in storing and reading from the varargs
    spill area.  */
 
diff --git a/gcc/builtins.c b/gcc/builtins.c
index 9bcb310c015..ed11f79ff0b 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -11236,3 +11236,90 @@ target_char_cst_p (tree t, char *p)
   *p = (char)tree_to_uhwi (t);
   return true;
 }
+
+/* Return true if the builtin DECL is implemented in a standard library.
+   Otherwise returns false which doesn't guarantee it is not (thus the list of
+   handled builtins below may be incomplete).  */
+
+bool
+builtin_with_linkage_p (tree decl)
+{
+  if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)
+    switch (DECL_FUNCTION_CODE (decl))
+    {
+      CASE_FLT_FN (BUILT_IN_ACOS):
+      CASE_FLT_FN (BUILT_IN_ACOSH):
+      CASE_FLT_FN (BUILT_IN_ASIN):
+      CASE_FLT_FN (BUILT_IN_ASINH):
+      CASE_FLT_FN (BUILT_IN_ATAN):
+      CASE_FLT_FN (BUILT_IN_ATANH):
+      CASE_FLT_FN (BUILT_IN_ATAN2):
+      CASE_FLT_FN (BUILT_IN_CBRT):
+      CASE_FLT_FN (BUILT_IN_CEIL):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_CEIL):
+      CASE_FLT_FN (BUILT_IN_COPYSIGN):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_COPYSIGN):
+      CASE_FLT_FN (BUILT_IN_COS):
+      CASE_FLT_FN (BUILT_IN_COSH):
+      CASE_FLT_FN (BUILT_IN_ERF):
+      CASE_FLT_FN (BUILT_IN_ERFC):
+      CASE_FLT_FN (BUILT_IN_EXP):
+      CASE_FLT_FN (BUILT_IN_EXP2):
+      CASE_FLT_FN (BUILT_IN_EXPM1):
+      CASE_FLT_FN (BUILT_IN_FABS):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):
+      CASE_FLT_FN (BUILT_IN_FDIM):
+      CASE_FLT_FN (BUILT_IN_FLOOR):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FLOOR):
+      CASE_FLT_FN (BUILT_IN_FMA):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMA):
+      CASE_FLT_FN (BUILT_IN_FMAX):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMAX):
+      CASE_FLT_FN (BUILT_IN_FMIN):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMIN):
+      CASE_FLT_FN (BUILT_IN_FMOD):
+      CASE_FLT_FN (BUILT_IN_FREXP):
+      CASE_FLT_FN (BUILT_IN_HYPOT):
+      CASE_FLT_FN (BUILT_IN_ILOGB):
+      CASE_FLT_FN (BUILT_IN_LDEXP):
+      CASE_FLT_FN (BUILT_IN_LGAMMA):
+      CASE_FLT_FN (BUILT_IN_LLRINT):
+      CASE_FLT_FN (BUILT_IN_LLROUND):
+      CASE_FLT_FN (BUILT_IN_LOG):
+      CASE_FLT_FN (BUILT_IN_LOG10):
+      CASE_FLT_FN (BUILT_IN_LOG1P):
+      CASE_FLT_FN (BUILT_IN_LOG2):
+      CASE_FLT_FN (BUILT_IN_LOGB):
+      CASE_FLT_FN (BUILT_IN_LRINT):
+      CASE_FLT_FN (BUILT_IN_LROUND):
+      CASE_FLT_FN (BUILT_IN_MODF):
+      CASE_FLT_FN (BUILT_IN_NAN):
+      CASE_FLT_FN (BUILT_IN_NEARBYINT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_NEARBYINT):
+      CASE_FLT_FN (BUILT_IN_NEXTAFTER):
+      CASE_FLT_FN (BUILT_IN_NEXTTOWARD):
+      CASE_FLT_FN (BUILT_IN_POW):
+      CASE_FLT_FN (BUILT_IN_REMAINDER):
+      CASE_FLT_FN (BUILT_IN_REMQUO):
+      CASE_FLT_FN (BUILT_IN_RINT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_RINT):
+      CASE_FLT_FN (BUILT_IN_ROUND):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ROUND):
+      CASE_FLT_FN (BUILT_IN_SCALBLN):
+      CASE_FLT_FN (BUILT_IN_SCALBN):
+      CASE_FLT_FN (BUILT_IN_SIN):
+      CASE_FLT_FN (BUILT_IN_SINH):
+      CASE_FLT_FN (BUILT_IN_SINCOS):
+      CASE_FLT_FN (BUILT_IN_SQRT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SQRT):
+      CASE_FLT_FN (BUILT_IN_TAN):
+      CASE_FLT_FN (BUILT_IN_TANH):
+      CASE_FLT_FN (BUILT_IN_TGAMMA):
+      CASE_FLT_FN (BUILT_IN_TRUNC):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_TRUNC):
+	return true;
+      default:
+	break;
+    }
+  return false;
+}
diff --git a/gcc/builtins.h b/gcc/builtins.h
index 1ffb491d785..66c9295ff4a 100644
--- a/gcc/builtins.h
+++ b/gcc/builtins.h
@@ -150,5 +150,6 @@ extern internal_fn replacement_internal_fn (gcall *);
 
 extern void warn_string_no_nul (location_t, const char *, tree, tree);
 extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);
+extern bool builtin_with_linkage_p (tree);
 
 #endif /* GCC_BUILTINS_H */
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index acdfe79894e..f5e10a9e430 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,69 @@
+2020-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/89357
+	* c-attribs.c (check_cxx_fundamental_alignment_constraints): Remove.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-11-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/61414
+	* c-attribs.c (handle_mode_attribute): Add mode attribute to
+	ENUMERAL_TYPEs.
+
+	2019-11-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* c-common.h (identifier_global_tag): Declare.
+	* c-format.c (get_pointer_to_named_type): Renamed to ...
+	(get_named_type): ... this.  Use identifier_global_tag instead of
+	identifier_global_value, handle the return value being a TYPE_P.
+	(init_dynamic_diag_info): Adjust get_pointer_to_named_type callers
+	to call get_named_type instead.  Formatting fixes.
+
+2019-11-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (get_underlying_decl): Do not look through typedefs.
+	(dump_forward_type): Do not generate a declaration for function types.
+	(dump_nested_type) <ARRAY_TYPE>: Do not generate a nested declaration
+	of the component type if it is declared in another file.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91925
+	* c-warn.c (check_alignment_of_packed_member): Ignore FIELD_DECLs
+	with NULL DECL_FIELD_OFFSET.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* c-common.h (c_omp_predefined_variable): Declare.
+	* c-omp.c (c_omp_predefined_variable): New function.
+	(c_omp_predetermined_sharing): Return OMP_CLAUSE_DEFAULT_SHARED
+	for predefined variables.
+
+2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	PR c++/91155
+	* c-common.c (fname_as_string): Use cxx_printable_name for
+	__PRETTY_FUNCTION__ same as was used before r265711.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-lex.c (c_lex_with_flags):  Don't call
+	c_common_no_more_pch () from here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/c-family/c-ada-spec.c b/gcc/c-family/c-ada-spec.c
index 76e736964de..0fee9a0d037 100644
--- a/gcc/c-family/c-ada-spec.c
+++ b/gcc/c-family/c-ada-spec.c
@@ -1025,7 +1025,9 @@ get_underlying_decl (tree type)
 
   if (TYPE_P (type))
     {
-      type = TYPE_MAIN_VARIANT (type);
+      /* Strip qualifiers but do not look through typedefs.  */
+      if (TYPE_QUALS_NO_ADDR_SPACE (type))
+	type = TYPE_MAIN_VARIANT (type);
 
       /* type is a typedef.  */
       if (TYPE_NAME (type) && DECL_P (TYPE_NAME (type)))
@@ -2451,6 +2453,9 @@ dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)
   if (DECL_SOURCE_FILE (decl) != DECL_SOURCE_FILE (t))
     return;
 
+  if (TREE_CODE (type) == FUNCTION_TYPE)
+    return;
+
   /* Generate an incomplete type declaration.  */
   pp_string (buffer, "type ");
   dump_ada_node (buffer, decl, NULL_TREE, spc, false, true);
@@ -2519,7 +2524,10 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,
       while (TREE_CODE (tmp) == ARRAY_TYPE)
 	tmp = TREE_TYPE (tmp);
       decl = get_underlying_decl (tmp);
-      if (decl && !DECL_NAME (decl) && !TREE_VISITED (decl))
+      if (decl
+	  && !DECL_NAME (decl)
+	  && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)
+	  && !TREE_VISITED (decl))
 	{
 	  /* Generate full declaration.  */
 	  dump_nested_type (buffer, decl, t, parent, spc);
diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
index 93b210eed9c..a19e4ca7e89 100644
--- a/gcc/c-family/c-attribs.c
+++ b/gcc/c-family/c-attribs.c
@@ -1843,6 +1843,7 @@ handle_mode_attribute (tree *node, tree name, tree args,
 		typefm = make_signed_type (TYPE_PRECISION (typefm));
 	      TREE_TYPE (typefm) = type;
 	    }
+	  *no_add_attrs = false;
 	}
       else if (VECTOR_MODE_P (mode)
 	       ? TREE_CODE (type) != TREE_CODE (TREE_TYPE (typefm))
@@ -1921,65 +1922,6 @@ fail:
   return NULL_TREE;
 }
 
-/* If in c++-11, check if the c++-11 alignment constraint with respect
-   to fundamental alignment (in [dcl.align]) are satisfied.  If not in
-   c++-11 mode, does nothing.
-
-   [dcl.align]2/ says:
-
-   [* if the constant expression evaluates to a fundamental alignment,
-   the alignment requirement of the declared entity shall be the
-   specified fundamental alignment.
-
-   * if the constant expression evaluates to an extended alignment
-   and the implementation supports that alignment in the context
-   of the declaration, the alignment of the declared entity shall
-   be that alignment
-
-   * if the constant expression evaluates to an extended alignment
-   and the implementation does not support that alignment in the
-   context of the declaration, the program is ill-formed].  */
-
-static bool
-check_cxx_fundamental_alignment_constraints (tree node,
-					     unsigned align_log,
-					     int flags)
-{
-  bool alignment_too_large_p = false;
-  unsigned requested_alignment = (1U << align_log) * BITS_PER_UNIT;
-  unsigned max_align = 0;
-
-  if ((!(flags & ATTR_FLAG_CXX11) && !warn_cxx_compat)
-      || (node == NULL_TREE || node == error_mark_node))
-    return true;
-
-  if (cxx_fundamental_alignment_p (requested_alignment))
-    return true;
-
-  if (VAR_P (node))
-    {
-      if (TREE_STATIC (node) || DECL_EXTERNAL (node))
-	/* For file scope variables and static members, the target supports
-	   alignments that are at most MAX_OFILE_ALIGNMENT.  */
-	max_align = MAX_OFILE_ALIGNMENT;
-      else
-	/* For stack variables, the target supports at most
-	   MAX_STACK_ALIGNMENT.  */
-	max_align = MAX_STACK_ALIGNMENT;
-      if (requested_alignment > max_align)
-	alignment_too_large_p = true;
-    }
-  /* Let's be liberal for types and fields; don't limit their alignment any
-     more than check_user_alignment already did.  */
-
-  if (alignment_too_large_p)
-    pedwarn (input_location, OPT_Wattributes,
-	     "requested alignment %d is larger than %d",
-	     requested_alignment / BITS_PER_UNIT, max_align / BITS_PER_UNIT);
-
-  return !alignment_too_large_p;
-}
-
 /* Common codes shared by handle_warn_if_not_aligned_attribute and
    handle_aligned_attribute.  */
 
@@ -2023,8 +1965,7 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,
   /* Log2 of specified alignment.  */
   int pow2align = check_user_alignment (align_expr, objfile,
 					/* warn_zero = */ true);
-  if (pow2align == -1
-      || !check_cxx_fundamental_alignment_constraints (*node, pow2align, flags))
+  if (pow2align == -1)
     {
       *no_add_attrs = true;
       return NULL_TREE;
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index 1cf2cae6395..68376426721 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -800,6 +800,7 @@ extern void c_register_addr_space (const char *str, addr_space_t as);
 extern bool in_late_binary_op;
 extern const char *c_addr_space_name (addr_space_t as);
 extern tree identifier_global_value (tree);
+extern tree identifier_global_tag (tree);
 extern tree c_linkage_bindings (tree);
 extern void record_builtin_type (enum rid, const char *, tree);
 extern tree build_void_list_node (void);
@@ -1184,6 +1185,7 @@ extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,
 				 tree, tree *);
 extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);
 extern void c_omp_declare_simd_clauses_to_decls (tree, tree);
+extern bool c_omp_predefined_variable (tree);
 extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);
 
 /* Return next tree in the chain for chain_next walking of tree nodes.  */
diff --git a/gcc/c-family/c-format.c b/gcc/c-family/c-format.c
index a7f76c1c01d..f706793a479 100644
--- a/gcc/c-family/c-format.c
+++ b/gcc/c-family/c-format.c
@@ -3909,31 +3909,32 @@ init_dynamic_gfc_info (void)
     }
 }
 
-/* Lookup the type named NAME and return a pointer-to-NAME type if found.
-   Otherwise, return void_type_node if NAME has not been used yet, or NULL_TREE if
-   NAME is not a type (issuing an error).  */
+/* Lookup the type named NAME and return a NAME type if found.
+   Otherwise, return void_type_node if NAME has not been used yet,
+   or NULL_TREE if NAME is not a type (issuing an error).  */
 
 static tree
-get_pointer_to_named_type (const char *name)
+get_named_type (const char *name)
 {
-  tree result;
-  if ((result = maybe_get_identifier (name)))
+  if (tree result = maybe_get_identifier (name))
     {
-      result = identifier_global_value (result);
+      result = identifier_global_tag (result);
       if (result)
 	{
-	  if (TREE_CODE (result) != TYPE_DECL)
+	  if (TYPE_P (result))
+	    ;
+	  else if (TREE_CODE (result) == TYPE_DECL)
+	    result = TREE_TYPE (result);
+	  else
 	    {
 	      error ("%qs is not defined as a type", name);
 	      result = NULL_TREE;
 	    }
-	  else
-	    result = TREE_TYPE (result);
 	}
+      return result;
     }
   else
-    result = void_type_node;
-  return result;
+    return void_type_node;
 }
 
 /* Determine the types of "tree" and "location_t" in the code being
@@ -3963,23 +3964,24 @@ init_dynamic_diag_info (void)
 	 an extra type level.  */
       if ((local_tree_type_node = maybe_get_identifier ("tree")))
 	{
-	  local_tree_type_node = identifier_global_value (local_tree_type_node);
+	  local_tree_type_node
+	    = identifier_global_value (local_tree_type_node);
 	  if (local_tree_type_node)
 	    {
 	      if (TREE_CODE (local_tree_type_node) != TYPE_DECL)
 		{
 		  error ("%<tree%> is not defined as a type");
-		  local_tree_type_node = 0;
+		  local_tree_type_node = NULL_TREE;
 		}
 	      else if (TREE_CODE (TREE_TYPE (local_tree_type_node))
 		       != POINTER_TYPE)
 		{
 		  error ("%<tree%> is not defined as a pointer type");
-		  local_tree_type_node = 0;
+		  local_tree_type_node = NULL_TREE;
 		}
 	      else
-		local_tree_type_node =
-		  TREE_TYPE (TREE_TYPE (local_tree_type_node));
+		local_tree_type_node
+		  = TREE_TYPE (TREE_TYPE (local_tree_type_node));
 	    }
 	}
       else
@@ -3989,12 +3991,12 @@ init_dynamic_diag_info (void)
   /* Similar to the above but for gimple*.  */
   if (!local_gimple_ptr_node
       || local_gimple_ptr_node == void_type_node)
-    local_gimple_ptr_node = get_pointer_to_named_type ("gimple");
+    local_gimple_ptr_node = get_named_type ("gimple");
 
   /* Similar to the above but for cgraph_node*.  */
   if (!local_cgraph_node_ptr_node
       || local_cgraph_node_ptr_node == void_type_node)
-    local_cgraph_node_ptr_node = get_pointer_to_named_type ("cgraph_node");
+    local_cgraph_node_ptr_node = get_named_type ("cgraph_node");
 
   static tree hwi;
 
diff --git a/gcc/c-family/c-lex.c b/gcc/c-family/c-lex.c
index 0a368a33a58..3c92103a5d4 100644
--- a/gcc/c-family/c-lex.c
+++ b/gcc/c-family/c-lex.c
@@ -394,7 +394,6 @@ enum cpp_ttype
 c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
 		  int lex_flags)
 {
-  static bool no_more_pch;
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
@@ -628,12 +627,6 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
   if (cpp_flags)
     *cpp_flags = tok->flags | add_flags;
 
-  if (!no_more_pch)
-    {
-      no_more_pch = true;
-      c_common_no_more_pch ();
-    }
-
   timevar_pop (TV_CPP);
 
   return type;
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index 1f288a6fbb2..ebe0b4e8155 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -2023,6 +2023,25 @@ c_omp_declare_simd_clauses_to_decls (tree fndecl, tree clauses)
       }
 }
 
+/* Return true for __func__ and similar function-local predefined
+   variables (which are in OpenMP predetermined shared, allowed in
+   shared/firstprivate clauses).  */
+
+bool
+c_omp_predefined_variable (tree decl)
+{
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && TREE_READONLY (decl)
+      && TREE_STATIC (decl)
+      && DECL_NAME (decl)
+      && (DECL_NAME (decl) == ridpointers[RID_C99_FUNCTION_NAME]
+	  || DECL_NAME (decl) == ridpointers[RID_FUNCTION_NAME]
+	  || DECL_NAME (decl) == ridpointers[RID_PRETTY_FUNCTION_NAME]))
+    return true;
+  return false;
+}
+
 /* True if OpenMP sharing attribute of DECL is predetermined.  */
 
 enum omp_clause_default_kind
@@ -2036,5 +2055,8 @@ c_omp_predetermined_sharing (tree decl)
       && INTEGRAL_TYPE_P (TREE_TYPE (decl)))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  if (c_omp_predefined_variable (decl))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
diff --git a/gcc/c-family/c-warn.c b/gcc/c-family/c-warn.c
index 322cf98eb02..67dce9e125a 100644
--- a/gcc/c-family/c-warn.c
+++ b/gcc/c-family/c-warn.c
@@ -2784,6 +2784,8 @@ check_alignment_of_packed_member (tree type, tree field, bool rvalue)
   /* Check alignment of the data member.  */
   if (TREE_CODE (field) == FIELD_DECL
       && (DECL_PACKED (field) || TYPE_PACKED (TREE_TYPE (field)))
+      /* Ignore FIELDs not laid out yet.  */
+      && DECL_FIELD_OFFSET (field)
       && (!rvalue || TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE))
     {
       /* Check the expected alignment against the field alignment.  */
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 89e5b25d020..5ba4516e114 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,83 @@
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/93576
+	* c-decl.c (grokdeclarator): If this_size_varies, only push size into
+	*expr if it has side effects.
+
+2020-01-22  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-22  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93348
+	* c-typeck.c (build_c_cast): Call remove_c_maybe_const_expr on
+	argument with integer operands.
+
+2020-01-15  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-15  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93072
+	* c-decl.c (pushdecl): Use TREE_PUBLIC, not DECL_EXTERNAL, to
+	determine whether to set DECL_CONTEXT.
+
+2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93241
+	* c-typeck.c (build_c_cast): Check for expressions with integer
+	operands that can occur in an unevaluated part of an integer
+	constant expression and call note_integer_operands as needed.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-11-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* c-decl.c (identifier_global_tag): Define.
+
+2019-12-02  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Fix bugs relating to flexibly-sized objects in nios2 backend.
+	
+	PR target/92499
+
+	* c-decl.c (flexible_array_type_p): Move to common code.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* c-parser.c (c_parser_predefined_identifier): New function.
+	(c_parser_postfix_expression): Use it.
+	(c_parser_omp_variable_list): Parse predefined identifiers.
+	* c-typeck.c (c_finish_omp_clauses): Allow predefined variables
+	in shared and firstprivate clauses, even when they are predetermined
+	shared.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* c-parser.c (c_parser_omp_clause_dist_schedule): Fix up typos in the
+	check_no_duplicate_clause call.  Comment it out, instead emit a
+	warning for duplicate dist_schedule clauses.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-parser.c (c_parse_file): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index 04e0f4dc198..859a6241258 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -3044,7 +3044,7 @@ pushdecl (tree x)
      unless they have initializers (which generate code).  */
   if (current_function_decl
       && (!VAR_OR_FUNCTION_DECL_P (x)
-	  || DECL_INITIAL (x) || !DECL_EXTERNAL (x)))
+	  || DECL_INITIAL (x) || !TREE_PUBLIC (x)))
     DECL_CONTEXT (x) = current_function_decl;
 
   /* Anonymous decls are just inserted in the scope.  */
@@ -5586,39 +5586,6 @@ check_compound_literal_type (location_t loc, struct c_type_name *type_name)
 		"defining a type in a compound literal is invalid in C++");
 }
 
-/* Determine whether TYPE is a structure with a flexible array member,
-   or a union containing such a structure (possibly recursively).  */
-
-static bool
-flexible_array_type_p (tree type)
-{
-  tree x;
-  switch (TREE_CODE (type))
-    {
-    case RECORD_TYPE:
-      x = TYPE_FIELDS (type);
-      if (x == NULL_TREE)
-	return false;
-      while (DECL_CHAIN (x) != NULL_TREE)
-	x = DECL_CHAIN (x);
-      if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE
-	  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE
-	  && TYPE_DOMAIN (TREE_TYPE (x)) != NULL_TREE
-	  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)
-	return true;
-      return false;
-    case UNION_TYPE:
-      for (x = TYPE_FIELDS (type); x != NULL_TREE; x = DECL_CHAIN (x))
-	{
-	  if (flexible_array_type_p (TREE_TYPE (x)))
-	    return true;
-	}
-      return false;
-    default:
-    return false;
-  }
-}
-
 /* Performs sanity checks on the TYPE and WIDTH of the bit-field NAME,
    replacing with appropriate values if they are invalid.  */
 
@@ -6401,11 +6368,14 @@ grokdeclarator (const struct c_declarator *declarator,
 		  }
 		if (this_size_varies)
 		  {
-		    if (*expr)
-		      *expr = build2 (COMPOUND_EXPR, TREE_TYPE (size),
-				      *expr, size);
-		    else
-		      *expr = size;
+		    if (TREE_SIDE_EFFECTS (size))
+		      {
+			if (*expr)
+			  *expr = build2 (COMPOUND_EXPR, TREE_TYPE (size),
+					  *expr, size);
+			else
+			  *expr = size;
+		      }
 		    *expr_const_operands &= size_maybe_const;
 		  }
 	      }
@@ -9974,6 +9944,20 @@ identifier_global_value	(tree t)
   return NULL_TREE;
 }
 
+/* Return the global value of tag T as a symbol.  */
+
+tree
+identifier_global_tag (tree t)
+{
+  struct c_binding *b;
+
+  for (b = I_TAG_BINDING (t); b; b = b->shadowed)
+    if (B_IN_FILE_SCOPE (b) || B_IN_EXTERNAL_SCOPE (b))
+      return b->decl;
+
+  return NULL_TREE;
+}
+
 /* In C, the only C-linkage public declaration is at file scope.  */
 
 tree
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index f8d1fb3fa78..aafe8d1740b 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -8012,6 +8012,41 @@ enum tgmath_parm_kind
     tgmath_fixed, tgmath_real, tgmath_complex
   };
 
+/* Helper function for c_parser_postfix_expression.  Parse predefined
+   identifiers.  */
+
+static struct c_expr
+c_parser_predefined_identifier (c_parser *parser)
+{
+  location_t loc = c_parser_peek_token (parser)->location;
+  switch (c_parser_peek_token (parser)->keyword)
+    {
+    case RID_FUNCTION_NAME:
+      pedwarn (loc, OPT_Wpedantic, "ISO C does not support %qs predefined "
+	       "identifier", "__FUNCTION__");
+      break;
+    case RID_PRETTY_FUNCTION_NAME:
+      pedwarn (loc, OPT_Wpedantic, "ISO C does not support %qs predefined "
+	       "identifier", "__PRETTY_FUNCTION__");
+      break;
+    case RID_C99_FUNCTION_NAME:
+      pedwarn_c90 (loc, OPT_Wpedantic, "ISO C90 does not support "
+		   "%<__func__%> predefined identifier");
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  struct c_expr expr;
+  expr.original_code = ERROR_MARK;
+  expr.original_type = NULL;
+  expr.value = fname_decl (loc, c_parser_peek_token (parser)->keyword,
+			   c_parser_peek_token (parser)->value);
+  set_c_expr_source_range (&expr, loc, loc);
+  c_parser_consume_token (parser);
+  return expr;
+}
+
 /* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2,
    C11 6.5.1-6.5.2).  Compound literals aren't handled here; callers have to
    call c_parser_postfix_expression_after_paren_type on encountering them.
@@ -8232,31 +8267,9 @@ c_parser_postfix_expression (c_parser *parser)
       switch (c_parser_peek_token (parser)->keyword)
 	{
 	case RID_FUNCTION_NAME:
-	  pedwarn (loc, OPT_Wpedantic,  "ISO C does not support "
-		   "%<__FUNCTION__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
-	  break;
 	case RID_PRETTY_FUNCTION_NAME:
-	  pedwarn (loc, OPT_Wpedantic,  "ISO C does not support "
-		   "%<__PRETTY_FUNCTION__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
-	  break;
 	case RID_C99_FUNCTION_NAME:
-	  pedwarn_c90 (loc, OPT_Wpedantic,  "ISO C90 does not support "
-		   "%<__func__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
+	  expr = c_parser_predefined_identifier (parser);
 	  break;
 	case RID_VA_ARG:
 	  {
@@ -11950,15 +11963,9 @@ c_parser_omp_variable_list (c_parser *parser,
 {
   auto_vec<c_token> tokens;
   unsigned int tokens_avail = 0;
+  bool first = true;
 
-  if (kind != OMP_CLAUSE_DEPEND
-      && (c_parser_next_token_is_not (parser, CPP_NAME)
-	  || c_parser_peek_token (parser)->id_kind != C_ID_ID))
-    c_parser_error (parser, "expected identifier");
-
-  while (kind == OMP_CLAUSE_DEPEND
-	 || (c_parser_next_token_is (parser, CPP_NAME)
-	     && c_parser_peek_token (parser)->id_kind == C_ID_ID))
+  while (1)
     {
       bool array_section_p = false;
       if (kind == OMP_CLAUSE_DEPEND)
@@ -11979,6 +11986,7 @@ c_parser_omp_variable_list (c_parser *parser,
 		break;
 
 	      c_parser_consume_token (parser);
+	      first = false;
 	      continue;
 	    }
 
@@ -12029,16 +12037,35 @@ c_parser_omp_variable_list (c_parser *parser,
 	  parser->tokens_avail = tokens.length ();
 	}
 
-      tree t = lookup_name (c_parser_peek_token (parser)->value);
+      tree t = NULL_TREE;
 
-      if (t == NULL_TREE)
+      if (c_parser_next_token_is (parser, CPP_NAME)
+	  && c_parser_peek_token (parser)->id_kind == C_ID_ID)
 	{
-	  undeclared_variable (c_parser_peek_token (parser)->location,
-			       c_parser_peek_token (parser)->value);
-	  t = error_mark_node;
-	}
+	  t = lookup_name (c_parser_peek_token (parser)->value);
 
-      c_parser_consume_token (parser);
+	  if (t == NULL_TREE)
+	    {
+	      undeclared_variable (c_parser_peek_token (parser)->location,
+	      c_parser_peek_token (parser)->value);
+	      t = error_mark_node;
+	    }
+
+	  c_parser_consume_token (parser);
+	}
+      else if (c_parser_next_token_is (parser, CPP_KEYWORD)
+	       && (c_parser_peek_token (parser)->keyword == RID_FUNCTION_NAME
+		   || (c_parser_peek_token (parser)->keyword
+		       == RID_PRETTY_FUNCTION_NAME)
+		   || (c_parser_peek_token (parser)->keyword
+		       == RID_C99_FUNCTION_NAME)))
+	t = c_parser_predefined_identifier (parser).value;
+      else
+	{
+	  if (first)
+	    c_parser_error (parser, "expected identifier");
+	  break;
+	}
 
       if (t == error_mark_node)
 	;
@@ -12176,6 +12203,7 @@ c_parser_omp_variable_list (c_parser *parser,
 	break;
 
       c_parser_consume_token (parser);
+      first = false;
     }
 
   return list;
@@ -14707,7 +14735,10 @@ c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)
     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
 			       "expected %<,%> or %<)%>");
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, "schedule");
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule"); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (loc, 0, "too many %qs clauses", "dist_schedule");
   if (t == error_mark_node)
     return list;
 
@@ -19859,6 +19890,8 @@ c_parse_file (void)
 
   if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)
     c_parser_pragma_pch_preprocess (&tparser);
+  else
+    c_common_no_more_pch ();
 
   the_parser = ggc_alloc<c_parser> ();
   *the_parser = tparser;
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index 4a4eb08b73f..c0582a54c93 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -5702,10 +5702,14 @@ build_c_cast (location_t loc, tree type, tree expr)
 {
   tree value;
 
+  bool int_operands = EXPR_INT_CONST_OPERANDS (expr);
+
   if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)
     expr = TREE_OPERAND (expr, 0);
 
   value = expr;
+  if (int_operands)
+    value = remove_c_maybe_const_expr (value);
 
   if (type == error_mark_node || expr == error_mark_node)
     return error_mark_node;
@@ -5936,6 +5940,14 @@ build_c_cast (location_t loc, tree type, tree expr)
 	       || TREE_CODE (expr) == COMPLEX_CST)))
       value = build1 (NOP_EXPR, type, value);
 
+  /* If the expression has integer operands and so can occur in an
+     unevaluated part of an integer constant expression, ensure the
+     return value reflects this.  */
+  if (int_operands
+      && INTEGRAL_TYPE_P (type)
+      && !EXPR_INT_CONST_OPERANDS (value))
+    value = note_integer_operands (value);
+
   protected_set_expr_location (value, loc);
   return value;
 }
@@ -14713,6 +14725,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 		case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 		  break;
 		case OMP_CLAUSE_DEFAULT_SHARED:
+		  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
+		       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)
+		      && c_omp_predefined_variable (t))
+		    /* The __func__ variable and similar function-local
+		       predefined variables may be listed in a shared or
+		       firstprivate clause.  */
+		    break;
 		  share_name = "shared";
 		  break;
 		case OMP_CLAUSE_DEFAULT_PRIVATE:
diff --git a/gcc/calls.c b/gcc/calls.c
index c8a42680041..56795995650 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -1971,8 +1971,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,
       /* If TYPE is a transparent union or record, pass things the way
 	 we would pass the first field of the union or record.  We have
 	 already verified that the modes are the same.  */
-      if ((TREE_CODE (type) == UNION_TYPE || TREE_CODE (type) == RECORD_TYPE)
-	   && TYPE_TRANSPARENT_AGGR (type))
+      if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
 	type = TREE_TYPE (first_field (type));
 
       /* Decide where to pass this arg.
@@ -2750,6 +2749,9 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	  poly_int64 size = 0;
 	  HOST_WIDE_INT const_size = 0;
 	  rtx_insn *before_arg = get_last_insn ();
+	  tree type = TREE_TYPE (args[i].tree_value);
+	  if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
+	    type = TREE_TYPE (first_field (type));
 	  /* Set non-negative if we must move a word at a time, even if
 	     just one word (e.g, partial == 4 && mode == DFmode).  Set
 	     to -1 if we just use a normal move insn.  This value can be
@@ -2762,11 +2764,11 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	      gcc_assert (partial % UNITS_PER_WORD == 0);
 	      nregs = partial / UNITS_PER_WORD;
 	    }
-	  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)
+	  else if (TYPE_MODE (type) == BLKmode)
 	    {
 	      /* Variable-sized parameters should be described by a
 		 PARALLEL instead.  */
-	      const_size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
+	      const_size = int_size_in_bytes (type);
 	      gcc_assert (const_size >= 0);
 	      nregs = (const_size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
 	      size = const_size;
@@ -2893,8 +2895,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	  if (GET_CODE (reg) == PARALLEL)
 	    use_group_regs (call_fusage, reg);
 	  else if (nregs == -1)
-	    use_reg_mode (call_fusage, reg,
-			  TYPE_MODE (TREE_TYPE (args[i].tree_value)));
+	    use_reg_mode (call_fusage, reg, TYPE_MODE (type));
 	  else if (nregs > 0)
 	    use_regs (call_fusage, REGNO (reg), nregs);
 	}
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 992912ce195..01e13b9dc4f 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dce.h"
 #include "dbgcnt.h"
 #include "rtl-iter.h"
+#include "regs.h"
 
 #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)
 
@@ -257,6 +258,10 @@ thread_jump (edge e, basic_block b)
   bool failed = false;
   reg_set_iterator rsi;
 
+  /* Jump threading may cause fixup_partitions to introduce new crossing edges,
+     which is not allowed after reload.  */
+  gcc_checking_assert (!reload_completed || !crtl->has_bb_partition);
+
   if (b->flags & BB_NONTHREADABLE_BLOCK)
     return NULL;
 
@@ -1224,6 +1229,14 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)
 		}
 	    }
 	}
+
+      HARD_REG_SET i1_used, i2_used;
+
+      get_call_reg_set_usage (i1, &i1_used, call_used_reg_set);
+      get_call_reg_set_usage (i2, &i2_used, call_used_reg_set);
+
+      if (!hard_reg_set_equal_p (i1_used, i2_used))
+        return dir_none;
     }
 
   /* If both i1 and i2 are frame related, verify all the CFA notes
@@ -3269,10 +3282,10 @@ make_pass_jump (gcc::context *ctxt)
 
 namespace {
 
-const pass_data pass_data_postreload_jump =
+const pass_data pass_data_jump_after_combine =
 {
   RTL_PASS, /* type */
-  "postreload_jump", /* name */
+  "jump_after_combine", /* name */
   OPTGROUP_NONE, /* optinfo_flags */
   TV_JUMP, /* tv_id */
   0, /* properties_required */
@@ -3282,31 +3295,34 @@ const pass_data pass_data_postreload_jump =
   0, /* todo_flags_finish */
 };
 
-class pass_postreload_jump : public rtl_opt_pass
+class pass_jump_after_combine : public rtl_opt_pass
 {
 public:
-  pass_postreload_jump (gcc::context *ctxt)
-    : rtl_opt_pass (pass_data_postreload_jump, ctxt)
+  pass_jump_after_combine (gcc::context *ctxt)
+    : rtl_opt_pass (pass_data_jump_after_combine, ctxt)
   {}
 
   /* opt_pass methods: */
+  virtual bool gate (function *) { return flag_thread_jumps; }
   virtual unsigned int execute (function *);
 
-}; // class pass_postreload_jump
+}; // class pass_jump_after_combine
 
 unsigned int
-pass_postreload_jump::execute (function *)
+pass_jump_after_combine::execute (function *)
 {
-  cleanup_cfg (flag_thread_jumps ? CLEANUP_THREADING : 0);
+  /* Jump threading does not keep dominators up-to-date.  */
+  free_dominance_info (CDI_DOMINATORS);
+  cleanup_cfg (CLEANUP_THREADING);
   return 0;
 }
 
 } // anon namespace
 
 rtl_opt_pass *
-make_pass_postreload_jump (gcc::context *ctxt)
+make_pass_jump_after_combine (gcc::context *ctxt)
 {
-  return new pass_postreload_jump (ctxt);
+  return new pass_jump_after_combine (ctxt);
 }
 
 namespace {
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index db4c9c747b9..1febb6369a0 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -1779,8 +1779,6 @@ cgraph_node::release_body (bool keep_arguments)
 void
 cgraph_node::remove (void)
 {
-  cgraph_node *n;
-
   if (symtab->ipa_clones_dump_file && symtab->cloned_nodes.contains (this))
     fprintf (symtab->ipa_clones_dump_file,
 	     "Callgraph removal;%s;%d;%s;%d;%d\n", asm_name (), order,
@@ -1797,8 +1795,13 @@ cgraph_node::remove (void)
      */
   force_output = false;
   forced_by_abi = false;
-  for (n = nested; n; n = n->next_nested)
+  cgraph_node *next = nested;
+  for (cgraph_node *n = nested; n; n = next)
+  {
+    next = n->next_nested;
     n->origin = NULL;
+    n->next_nested = NULL;
+  }
   nested = NULL;
   if (origin)
     {
@@ -1852,7 +1855,7 @@ cgraph_node::remove (void)
      */
   if (symtab->state != LTO_STREAMING)
     {
-      n = cgraph_node::get (decl);
+      cgraph_node *n = cgraph_node::get (decl);
       if (!n
 	  || (!n->clones && !n->clone_of && !n->global.inlined_to
 	      && ((symtab->global_info_ready || in_lto_p)
@@ -3449,6 +3452,30 @@ cgraph_node::verify_node (void)
 	  e->aux = 0;
 	}
     }
+
+  if (nested != NULL)
+    {
+      for (cgraph_node *n = nested; n != NULL; n = n->next_nested)
+	{
+	  if (n->origin == NULL)
+	    {
+	      error ("missing origin for a node in a nested list");
+	      error_found = true;
+	    }
+	  else if (n->origin != this)
+	    {
+	      error ("origin points to a different parent");
+	      error_found = true;
+	      break;
+	    }
+	}
+    }
+  if (next_nested != NULL && origin == NULL)
+    {
+      error ("missing origin for a node in a nested list");
+      error_found = true;
+    }
+
   if (error_found)
     {
       dump (stderr);
diff --git a/gcc/collect2.c b/gcc/collect2.c
index eb84f84639b..8f092e7539e 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -384,6 +384,10 @@ static void scan_prog_file (const char *, scanpass, scanfilter);
 void
 tool_cleanup (bool from_signal)
 {
+  /* maybe_unlink may call notice, which is not signal safe.  */
+  if (from_signal)
+    verbose = false;
+
   if (c_file != 0 && c_file[0])
     maybe_unlink (c_file);
 
@@ -743,7 +747,10 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,
 	      ++num_files;
 	  }
 
-	lto_o_files = XNEWVEC (char *, num_files + 1);
+	/* signal handler may access uninitialized memory
+	   and delete whatever it points to, if lto_o_files
+	   is not allocated with calloc.  */
+	lto_o_files = XCNEWVEC (char *, num_files + 1);
 	lto_o_files[num_files] = NULL;
 	start = XOBFINISH (&temporary_obstack, char *);
 	for (i = 0; i < num_files; ++i)
diff --git a/gcc/combine.c b/gcc/combine.c
index 4de759a8e6b..48a60eb0206 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -5138,10 +5138,9 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)
 	{
 	  HOST_WIDE_INT pos = INTVAL (XEXP (SET_DEST (x), 2));
 	  unsigned HOST_WIDE_INT len = INTVAL (XEXP (SET_DEST (x), 1));
-	  unsigned HOST_WIDE_INT src = INTVAL (SET_SRC (x));
 	  rtx dest = XEXP (SET_DEST (x), 0);
-	  unsigned HOST_WIDE_INT mask
-	    = (HOST_WIDE_INT_1U << len) - 1;
+	  unsigned HOST_WIDE_INT mask = (HOST_WIDE_INT_1U << len) - 1;
+	  unsigned HOST_WIDE_INT src = INTVAL (SET_SRC (x)) & mask;
 	  rtx or_mask;
 
 	  if (BITS_BIG_ENDIAN)
@@ -12424,7 +12423,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)
 	     bit.  This will be converted into a ZERO_EXTRACT.  */
 	  if (const_op == 0 && sign_bit_comparison_p
 	      && CONST_INT_P (XEXP (op0, 1))
-	      && mode_width <= HOST_BITS_PER_WIDE_INT)
+	      && mode_width <= HOST_BITS_PER_WIDE_INT
+	      && UINTVAL (XEXP (op0, 1)) < mode_width)
 	    {
 	      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),
 					    (HOST_WIDE_INT_1U
diff --git a/gcc/common/config/s390/s390-common.c b/gcc/common/config/s390/s390-common.c
index f9c3a95f897..2e1914e3768 100644
--- a/gcc/common/config/s390/s390-common.c
+++ b/gcc/common/config/s390/s390-common.c
@@ -47,9 +47,9 @@ EXPORTED_CONST int processor_flags_table[] =
     /* z14 */    PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
 		 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12 | PF_TX
 		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14,
-    /* arch13 */ PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
+    /* z15 */    PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
 		 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12 | PF_TX
-		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14 | PF_VXE2 | PF_ARCH13
+		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14 | PF_VXE2 | PF_Z15
   };
 
 /* Change optimizations to be performed, depending on the
diff --git a/gcc/config.gcc b/gcc/config.gcc
index ddd3b8f4d9d..b2282ecdf0b 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -4700,14 +4700,12 @@ case "${target}" in
 			 echo "#undef  LINK_OS_EXTRA_SPEC32"
 			 echo "#define LINK_OS_EXTRA_SPEC32" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib -rpath $at/lib" \
-			      "-L $prefix/lib -L $at/lib\""
+			      "-rpath $prefix/lib -rpath $at/lib\""
 			 echo
 			 echo "#undef  LINK_OS_EXTRA_SPEC64"
 			 echo "#define LINK_OS_EXTRA_SPEC64" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib64 -rpath $at/lib64" \
-			      "-L $prefix/lib64 -L $at/lib64\""
+			      "-rpath $prefix/lib64 -rpath $at/lib64\""
 			 echo
 			 echo "#undef  LINK_OS_NEW_DTAGS_SPEC"
 			 echo "#define LINK_OS_NEW_DTAGS_SPEC" \
@@ -4720,7 +4718,10 @@ case "${target}" in
 			 echo "#define MD_EXEC_PREFIX \"$at/bin/\""
 			 echo
 			 echo "#undef  MD_STARTFILE_PREFIX"
-			 echo "#define MD_STARTFILE_PREFIX \"$at/lib/\"") \
+			 echo "#define MD_STARTFILE_PREFIX \"$prefix/lib/\""
+			 echo
+			 echo "#undef  MD_STARTFILE_PREFIX_1"
+			 echo "#define MD_STARTFILE_PREFIX_1 \"$at/lib/\"") \
 			    > advance-toolchain.h
 		    else
 			echo "Unknown advance-toolchain $with_advance_toolchain"
@@ -4743,7 +4744,7 @@ case "${target}" in
 		for which in arch tune; do
 			eval "val=\$with_$which"
 			case ${val} in
-			"" | native | z900 | z990 | z9-109 | z9-ec | z10 | z196 | zEC12 | z13 | z14 | arch5 | arch6 | arch7 | arch8 | arch9 | arch10 | arch11 | arch12 | arch13 )
+			"" | native | z900 | z990 | z9-109 | z9-ec | z10 | z196 | zEC12 | z13 | z14 | z15 | arch5 | arch6 | arch7 | arch8 | arch9 | arch10 | arch11 | arch12 | arch13 )
 				# OK
 				;;
 			*)
diff --git a/gcc/config/aarch64/aarch64-option-extensions.def b/gcc/config/aarch64/aarch64-option-extensions.def
index 53dcd03590d..010fd3ccf76 100644
--- a/gcc/config/aarch64/aarch64-option-extensions.def
+++ b/gcc/config/aarch64/aarch64-option-extensions.def
@@ -108,7 +108,7 @@ AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, false, "sm3 sm4
 
 /* Enabling "fp16fml" also enables "fp" and "fp16".
    Disabling "fp16fml" just disables "fp16fml".  */
-AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, false, "asimdfml")
+AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, false, "asimdfhm")
 
 /* Enabling "sve" also enables "fp16", "fp" and "simd".
    Disabling "sve" just disables "sve".  */
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 6b25d9cbfae..b452a53af99 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -1910,6 +1910,9 @@ aarch64_gen_compare_reg_maybe_ze (RTX_CODE code, rtx x, rtx y,
 	}
     }
 
+  if (!aarch64_plus_operand (y, y_mode))
+    y = force_reg (y_mode, y);
+
   return aarch64_gen_compare_reg (code, x, y);
 }
 
@@ -15343,6 +15346,34 @@ aarch64_declare_function_name (FILE *stream, const char* name,
   /* Don't forget the type directive for ELF.  */
   ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, "function");
   ASM_OUTPUT_LABEL (stream, name);
+
+  cfun->machine->label_is_assembled = true;
+}
+
+/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  Check if the patch area is after
+   the function label and emit a BTI if necessary.  */
+
+void
+aarch64_print_patchable_function_entry (FILE *file,
+					unsigned HOST_WIDE_INT patch_area_size,
+					bool record_p)
+{
+  if (cfun->machine->label_is_assembled
+      && aarch64_bti_enabled ()
+      && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
+    {
+      /* Remove the BTI that follows the patch area and insert a new BTI
+	 before the patch area right after the function label.  */
+      rtx_insn *insn = next_real_nondebug_insn (get_insns ());
+      if (insn
+	  && INSN_P (insn)
+	  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
+	  && XINT (PATTERN (insn), 1) == UNSPECV_BTI_C)
+	delete_insn (insn);
+      asm_fprintf (file, "\thint\t34 // bti c\n");
+    }
+
+  default_print_patchable_function_entry (file, patch_area_size, record_p);
 }
 
 /* Implement ASM_OUTPUT_DEF_FROM_DECLS.  Output .variant_pcs for aliases.  */
@@ -15504,6 +15535,9 @@ aarch64_emit_post_barrier (enum memmodel model)
 void
 aarch64_split_compare_and_swap (rtx operands[])
 {
+  /* Split after prolog/epilog to avoid interactions with shrinkwrapping.  */
+  gcc_assert (epilogue_completed);
+
   rtx rval, mem, oldval, newval, scratch;
   machine_mode mode;
   bool is_weak;
@@ -15620,6 +15654,9 @@ void
 aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
 			 rtx value, rtx model_rtx, rtx cond)
 {
+  /* Split after prolog/epilog to avoid interactions with shrinkwrapping.  */
+  gcc_assert (epilogue_completed);
+
   machine_mode mode = GET_MODE (mem);
   machine_mode wmode = (mode == DImode ? DImode : SImode);
   const enum memmodel model = memmodel_from_int (INTVAL (model_rtx));
@@ -17247,14 +17284,15 @@ aarch64_expand_subvti (rtx op0, rtx low_dest, rtx low_in1,
     }
   else
     {
-      if (CONST_INT_P (low_in2))
+      if (aarch64_plus_immediate (low_in2, DImode))
+	emit_insn (gen_subdi3_compare1_imm (low_dest, low_in1, low_in2,
+					    GEN_INT (-INTVAL (low_in2))));
+      else
 	{
-	  high_in2 = force_reg (DImode, high_in2);
-	  emit_insn (gen_subdi3_compare1_imm (low_dest, low_in1, low_in2,
-					      GEN_INT (-INTVAL (low_in2))));
+	  low_in2 = force_reg (DImode, low_in2);
+	  emit_insn (gen_subdi3_compare1 (low_dest, low_in1, low_in2));
 	}
-      else
-	emit_insn (gen_subdi3_compare1 (low_dest, low_in1, low_in2));
+      high_in2 = force_reg (DImode, high_in2);
 
       if (unsigned_p)
 	emit_insn (gen_usubdi3_carryinC (high_dest, high_in1, high_in2));
@@ -18162,19 +18200,21 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
   /* Sort the operands.  */
   qsort (temp_operands, 4, 2 * sizeof (rtx *), aarch64_ldrstr_offset_compare);
 
+  /* Copy the memory operands so that if we have to bail for some
+     reason the original addresses are unchanged.  */
   if (load)
     {
-      mem_1 = temp_operands[1];
-      mem_2 = temp_operands[3];
-      mem_3 = temp_operands[5];
-      mem_4 = temp_operands[7];
+      mem_1 = copy_rtx (temp_operands[1]);
+      mem_2 = copy_rtx (temp_operands[3]);
+      mem_3 = copy_rtx (temp_operands[5]);
+      mem_4 = copy_rtx (temp_operands[7]);
     }
   else
     {
-      mem_1 = temp_operands[0];
-      mem_2 = temp_operands[2];
-      mem_3 = temp_operands[4];
-      mem_4 = temp_operands[6];
+      mem_1 = copy_rtx (temp_operands[0]);
+      mem_2 = copy_rtx (temp_operands[2]);
+      mem_3 = copy_rtx (temp_operands[4]);
+      mem_4 = copy_rtx (temp_operands[6]);
       gcc_assert (code == UNKNOWN);
     }
 
@@ -18944,6 +18984,9 @@ aarch64_run_selftests (void)
 #undef TARGET_ASM_TRAMPOLINE_TEMPLATE
 #define TARGET_ASM_TRAMPOLINE_TEMPLATE aarch64_asm_trampoline_template
 
+#undef TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY
+#define TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY aarch64_print_patchable_function_entry
+
 #undef TARGET_BUILD_BUILTIN_VA_LIST
 #define TARGET_BUILD_BUILTIN_VA_LIST aarch64_build_builtin_va_list
 
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index fc6df970c2e..772a9729688 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -731,6 +731,7 @@ typedef struct GTY (()) machine_function
   struct aarch64_frame frame;
   /* One entry for each hard register.  */
   bool reg_is_wrapped_separately[LAST_SAVED_REGNUM];
+  bool label_is_assembled;
 } machine_function;
 #endif
 
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 5a1894063a1..cc5a887d404 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1059,8 +1059,8 @@
 	(match_operand:GPI 1 "general_operand" ""))]
   ""
   "
-    if (MEM_P (operands[0]) && CONST_INT_P (operands[1])
-	&& <MODE>mode == DImode
+    if (MEM_P (operands[0]) && !MEM_VOLATILE_P (operands[0])
+	&& CONST_INT_P (operands[1]) && <MODE>mode == DImode
 	&& aarch64_split_dimode_const_store (operands[0], operands[1]))
       DONE;
 
@@ -6304,7 +6304,7 @@
   [(match_operand:GPI 0 "register_operand")
    (match_operand:GPF 1 "register_operand")]
   "TARGET_FLOAT
-   && ((GET_MODE_SIZE (<GPF:MODE>mode) <= GET_MODE_SIZE (<GPI:MODE>mode))
+   && ((GET_MODE_BITSIZE (<GPF:MODE>mode) <= LONG_TYPE_SIZE)
    || !flag_trapping_math || flag_fp_int_builtin_inexact)"
 {
   rtx cvt = gen_reg_rtx (<GPF:MODE>mode);
diff --git a/gcc/config/aarch64/aarch64.opt b/gcc/config/aarch64/aarch64.opt
index 7719c3b6352..3c6d1cc90ad 100644
--- a/gcc/config/aarch64/aarch64.opt
+++ b/gcc/config/aarch64/aarch64.opt
@@ -119,15 +119,15 @@ EnumValue
 Enum(aarch64_tls_size) String(48) Value(48)
 
 march=
-Target RejectNegative ToLower Joined Var(aarch64_arch_string)
+Target RejectNegative Negative(march=) ToLower Joined Var(aarch64_arch_string)
 Use features of architecture ARCH.
 
 mcpu=
-Target RejectNegative ToLower Joined Var(aarch64_cpu_string)
+Target RejectNegative Negative(mcpu=) ToLower Joined Var(aarch64_cpu_string)
 Use features of and optimize for CPU.
 
 mtune=
-Target RejectNegative ToLower Joined Var(aarch64_tune_string)
+Target RejectNegative Negative(mtune=) ToLower Joined Var(aarch64_tune_string)
 Optimize for CPU.
 
 mabi=
diff --git a/gcc/config/aarch64/atomics.md b/gcc/config/aarch64/atomics.md
index b6b5f6be232..0f357662ac3 100644
--- a/gcc/config/aarch64/atomics.md
+++ b/gcc/config/aarch64/atomics.md
@@ -56,7 +56,7 @@
    (clobber (match_scratch:SI 7 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_compare_and_swap (operands);
@@ -80,7 +80,7 @@
    (clobber (match_scratch:SI 7 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_compare_and_swap (operands);
@@ -166,7 +166,7 @@
    (clobber (match_scratch:SI 4 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (SET, operands[0], NULL, operands[1],
@@ -254,7 +254,7 @@
   (clobber (match_scratch:SI 4 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],
@@ -310,7 +310,7 @@
    (clobber (match_scratch:SI 4 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
      aarch64_split_atomic_op (NOT, NULL, operands[3], operands[0],
@@ -380,7 +380,7 @@
    (clobber (match_scratch:SI 5 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (<CODE>, operands[0], operands[4], operands[1],
@@ -427,7 +427,7 @@
    (clobber (match_scratch:SI 5 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (NOT, operands[0], operands[4], operands[1],
@@ -480,7 +480,7 @@
    (clobber (match_scratch:SI 4 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (<CODE>, NULL, operands[0], operands[1],
@@ -504,7 +504,7 @@
    (clobber (match_scratch:SI 4 "=&r"))]
   ""
   "#"
-  "&& reload_completed"
+  "&& epilogue_completed"
   [(const_int 0)]
   {
     aarch64_split_atomic_op (NOT, NULL, operands[0], operands[1],
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 984540f0b53..524379d3763 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -8839,6 +8839,9 @@ alpha_handle_trap_shadows (void)
 		    case CODE_LABEL:
 		      goto close_shadow;
 
+		    case DEBUG_INSN:
+		      break;
+
 		    default:
 		      gcc_unreachable ();
 		    }
diff --git a/gcc/config/arc/arc-modes.def b/gcc/config/arc/arc-modes.def
index 36a2f4abfb2..d16b6a289a1 100644
--- a/gcc/config/arc/arc-modes.def
+++ b/gcc/config/arc/arc-modes.def
@@ -38,4 +38,5 @@ VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */
 
 /* FPU condition flags.  */
 CC_MODE (CC_FPU);
+CC_MODE (CC_FPUE);
 CC_MODE (CC_FPU_UNEQ);
diff --git a/gcc/config/arc/arc.c b/gcc/config/arc/arc.c
index ee1f70bbb51..f7ff95a0edf 100644
--- a/gcc/config/arc/arc.c
+++ b/gcc/config/arc/arc.c
@@ -1445,6 +1445,7 @@ get_arc_condition_code (rtx comparison)
 	default : gcc_unreachable ();
 	}
     case E_CC_FPUmode:
+    case E_CC_FPUEmode:
       switch (GET_CODE (comparison))
 	{
 	case EQ	       : return ARC_CC_EQ;
@@ -1567,11 +1568,13 @@ arc_select_cc_mode (enum rtx_code op, rtx x, rtx y)
       case UNLE:
       case UNGT:
       case UNGE:
+	return CC_FPUmode;
+
       case LT:
       case LE:
       case GT:
       case GE:
-	return CC_FPUmode;
+	return CC_FPUEmode;
 
       case LTGT:
       case UNEQ:
@@ -1725,7 +1728,7 @@ arc_init_reg_tables (void)
 	  if (i == (int) CCmode || i == (int) CC_ZNmode || i == (int) CC_Zmode
 	      || i == (int) CC_Cmode
 	      || i == CC_FP_GTmode || i == CC_FP_GEmode || i == CC_FP_ORDmode
-	      || i == CC_FPUmode || i == CC_FPU_UNEQmode)
+	      || i == CC_FPUmode || i == CC_FPUEmode || i == CC_FPU_UNEQmode)
 	    arc_mode_class[i] = 1 << (int) C_MODE;
 	  else
 	    arc_mode_class[i] = 0;
@@ -5992,6 +5995,22 @@ arc_legitimize_pic_address (rtx addr)
 
   switch (GET_CODE (addr))
     {
+    case UNSPEC:
+      /* Can be one or our GOT or GOTOFFPC unspecs.  This situation
+	 happens when an address is not a legitimate constant and we
+	 need the resolve it via force_reg in
+	 prepare_move_operands.  */
+      switch (XINT (addr, 1))
+	{
+	case ARC_UNSPEC_GOT:
+	case ARC_UNSPEC_GOTOFFPC:
+	  /* Recover the symbol ref.  */
+	  addr = XVECEXP (addr, 0, 0);
+	  break;
+	default:
+	  return addr;
+	}
+      /* Fall through.  */
     case SYMBOL_REF:
       /* TLS symbols are handled in different place.  */
       if (SYMBOL_REF_TLS_MODEL (addr))
@@ -8217,6 +8236,7 @@ arc_reorg (void)
 
 	  /* Avoid FPU instructions.  */
 	  if ((GET_MODE (XEXP (XEXP (pc_target, 0), 0)) == CC_FPUmode)
+	      || (GET_MODE (XEXP (XEXP (pc_target, 0), 0)) == CC_FPUEmode)
 	      || (GET_MODE (XEXP (XEXP (pc_target, 0), 0)) == CC_FPU_UNEQmode))
 	    continue;
 
diff --git a/gcc/config/arc/arc.h b/gcc/config/arc/arc.h
index 80dead957cb..00fc3e4711d 100644
--- a/gcc/config/arc/arc.h
+++ b/gcc/config/arc/arc.h
@@ -1530,7 +1530,7 @@ enum arc_function_type {
   (((MODE) == CC_FP_GTmode || (MODE) == CC_FP_GEmode		 \
     || (MODE) == CC_FP_UNEQmode || (MODE) == CC_FP_ORDmode	 \
     || (MODE) == CC_FPXmode || (MODE) == CC_FPU_UNEQmode	 \
-    || (MODE) == CC_FPUmode)					 \
+    || (MODE) == CC_FPUmode || (MODE) == CC_FPUEmode)		 \
    ? reverse_condition_maybe_unordered ((CODE))			 \
    : reverse_condition ((CODE)))
 
diff --git a/gcc/config/arc/arc.md b/gcc/config/arc/arc.md
index 78e304d4c71..34e8248bcdb 100644
--- a/gcc/config/arc/arc.md
+++ b/gcc/config/arc/arc.md
@@ -3674,7 +3674,7 @@ core_3, archs4x, archs4xd, archs4xd_slow"
 })
 
 (define_mode_iterator SDF [(SF "TARGET_FP_SP_BASE || TARGET_OPTFPE")
-			   (DF "TARGET_OPTFPE")])
+			   (DF "TARGET_FP_DP_BASE || TARGET_OPTFPE")])
 
 (define_expand "cstore<mode>4"
   [(set (reg:CC CC_REG)
@@ -3684,7 +3684,7 @@ core_3, archs4x, archs4xd, archs4xd_slow"
 	(match_operator:SI 1 "comparison_operator" [(reg CC_REG)
 						    (const_int 0)]))]
 
-  "TARGET_FP_SP_BASE || TARGET_OPTFPE"
+  "TARGET_HARD_FLOAT || TARGET_OPTFPE"
 {
   gcc_assert (XEXP (operands[1], 0) == operands[2]);
   gcc_assert (XEXP (operands[1], 1) == operands[3]);
@@ -3742,20 +3742,20 @@ core_3, archs4x, archs4xd, archs4xd_slow"
 ; cond_exec patterns
 (define_insn "*movsi_ne"
   [(cond_exec
-     (ne (match_operand:CC_Z 2 "cc_use_register"    "Rcc,  Rcc,  Rcc,Rcc,Rcc") (const_int 0))
-     (set (match_operand:SI 0 "dest_reg_operand" "=Rcq#q,Rcq#q,Rcq#q,  w,w")
-	  (match_operand:SI 1 "nonmemory_operand"   "C_0,    h, ?Cal, Lc,?Cal")))]
+    (ne (match_operand:CC_Z 2 "cc_use_register"  "Rcc,Rcc,Rcc,Rcc,Rcc") (const_int 0))
+    (set (match_operand:SI 0 "dest_reg_operand"   "=q,  q,  r,  q,  r")
+	 (match_operand:SI 1 "nonmemory_operand" "C_0,  h, Lr,Cal,Cal")))]
   ""
   "@
-	* current_insn_predicate = 0; return \"sub%?.ne %0,%0,%0%&\";
-	* current_insn_predicate = 0; return \"mov%?.ne %0,%1\";
-	* current_insn_predicate = 0; return \"mov%?.ne %0,%1\";
-	mov.ne %0,%1
-	mov.ne %0,%1"
+	* current_insn_predicate = 0; return \"sub%?.ne\\t%0,%0,%0\";
+	* current_insn_predicate = 0; return \"mov%?.ne\\t%0,%1\";
+	mov.ne\\t%0,%1
+	* current_insn_predicate = 0; return \"mov%?.ne\\t%0,%1\";
+	mov.ne\\t%0,%1"
   [(set_attr "type" "cmove")
-   (set_attr "iscompact" "true,true,true_limm,false,false")
-   (set_attr "length" "2,2,6,4,8")
-   (set_attr "cpu_facility" "*,av2,av2,*,*")])
+   (set_attr "iscompact" "true,true,false,true_limm,false")
+   (set_attr "length" "2,2,4,6,8")
+   (set_attr "cpu_facility" "*,av2,*,av2,*")])
 
 (define_insn "*movsi_cond_exec"
   [(cond_exec
diff --git a/gcc/config/arc/fpu.md b/gcc/config/arc/fpu.md
index 6289e9c3f59..6729795de54 100644
--- a/gcc/config/arc/fpu.md
+++ b/gcc/config/arc/fpu.md
@@ -242,6 +242,18 @@
    (set_attr "type" "fpu")
    (set_attr "predicable" "yes")])
 
+(define_insn "*cmpsf_fpu_trap"
+  [(set (reg:CC_FPUE CC_REG)
+	(compare:CC_FPUE (match_operand:SF 0 "register_operand"  "r,  r,r")
+			(match_operand:SF 1 "nonmemory_operand" "r,CfZ,F")))]
+  "TARGET_FP_SP_BASE"
+  "fscmpf%?\\t%0,%1"
+  [(set_attr "length" "4,4,8")
+   (set_attr "iscompact" "false")
+   (set_attr "cond" "set")
+   (set_attr "type" "fpu")
+   (set_attr "predicable" "yes")])
+
 (define_insn "*cmpsf_fpu_uneq"
   [(set (reg:CC_FPU_UNEQ CC_REG)
 	(compare:CC_FPU_UNEQ
@@ -338,6 +350,18 @@
    (set_attr "type" "fpu")
    (set_attr "predicable" "yes")])
 
+(define_insn "*cmpdf_fpu_trap"
+  [(set (reg:CC_FPUE CC_REG)
+	(compare:CC_FPUE (match_operand:DF 0 "even_register_operand"  "r")
+			(match_operand:DF 1 "even_register_operand"  "r")))]
+  "TARGET_FP_DP_BASE"
+  "fdcmpf%? %0, %1"
+  [(set_attr "length" "4")
+   (set_attr "iscompact" "false")
+   (set_attr "cond" "set")
+   (set_attr "type" "fpu")
+   (set_attr "predicable" "yes")])
+
 (define_insn "*cmpdf_fpu_uneq"
   [(set (reg:CC_FPU_UNEQ CC_REG)
 	(compare:CC_FPU_UNEQ
diff --git a/gcc/config/arc/predicates.md b/gcc/config/arc/predicates.md
index 72fbf2a8528..7d31ad9f99e 100644
--- a/gcc/config/arc/predicates.md
+++ b/gcc/config/arc/predicates.md
@@ -437,6 +437,7 @@
 	      || code == ORDERED || code == UNORDERED);
 
     case E_CC_FPUmode:
+    case E_CC_FPUEmode:
       return 1;
     case E_CC_FPU_UNEQmode:
       return 1;
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 485bc68a618..98beb6109b9 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -66,6 +66,7 @@ extern bool arm_small_register_classes_for_mode_p (machine_mode);
 extern int const_ok_for_arm (HOST_WIDE_INT);
 extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);
 extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);
+extern void thumb1_gen_const_int (rtx, HOST_WIDE_INT);
 extern int arm_split_constant (RTX_CODE, machine_mode, rtx,
 			       HOST_WIDE_INT, rtx, rtx, int);
 extern int legitimate_pic_operand_p (rtx);
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 45abcd89963..cdfc0f9e72f 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -2904,13 +2904,18 @@ arm_option_check_internal (struct gcc_options *opts)
     {
       const char *flag = (target_pure_code ? "-mpure-code" :
 					     "-mslow-flash-data");
+      bool common_unsupported_modes = arm_arch_notm || flag_pic || TARGET_NEON;
 
-      /* We only support -mpure-code and -mslow-flash-data on M-profile targets
-	 with MOVT.  */
-      if (!TARGET_HAVE_MOVT || arm_arch_notm || flag_pic || TARGET_NEON)
+      /* We only support -mslow-flash-data on M-profile targets with
+	 MOVT.  */
+      if (target_slow_flash_data && (!TARGET_HAVE_MOVT || common_unsupported_modes))
 	error ("%s only supports non-pic code on M-profile targets with the "
 	       "MOVT instruction", flag);
 
+      /* We only support -mpure-code on M-profile targets.  */
+      if (target_pure_code && common_unsupported_modes)
+	error ("%s only supports non-pic code on M-profile targets", flag);
+
       /* Cannot load addresses: -mslow-flash-data forbids literal pool and
 	 -mword-relocations forbids relocation of MOVT/MOVW.  */
       if (target_word_relocations)
@@ -4316,6 +4321,38 @@ const_ok_for_dimode_op (HOST_WIDE_INT i, enum rtx_code code)
     }
 }
 
+/* Emit a sequence of movs/adds/shift to produce a 32-bit constant.
+   Avoid generating useless code when one of the bytes is zero.  */
+void
+thumb1_gen_const_int (rtx op0, HOST_WIDE_INT op1)
+{
+  bool mov_done_p = false;
+  int i;
+
+  /* Emit upper 3 bytes if needed.  */
+  for (i = 0; i < 3; i++)
+    {
+      int byte = (op1 >> (8 * (3 - i))) & 0xff;
+
+      if (byte)
+	{
+	  emit_set_insn (op0, mov_done_p
+			 ? gen_rtx_PLUS (SImode,op0, GEN_INT (byte))
+			 : GEN_INT (byte));
+	  mov_done_p = true;
+	}
+
+      if (mov_done_p)
+	emit_set_insn (op0, gen_rtx_ASHIFT (SImode, op0, GEN_INT (8)));
+    }
+
+  /* Emit lower byte if needed.  */
+  if (!mov_done_p)
+    emit_set_insn (op0, GEN_INT (op1 & 0xff));
+  else if (op1 & 0xff)
+    emit_set_insn (op0, gen_rtx_PLUS (SImode, op0, GEN_INT (op1 & 0xff)));
+}
+
 /* Emit a sequence of insns to handle a large constant.
    CODE is the code of the operation required, it can be any of SET, PLUS,
    IOR, AND, XOR, MINUS;
@@ -8325,7 +8362,8 @@ thumb1_legitimate_address_p (machine_mode mode, rtx x, int strict_p)
   /* This is PC relative data before arm_reorg runs.  */
   else if (GET_MODE_SIZE (mode) >= 4 && CONSTANT_P (x)
 	   && GET_CODE (x) == SYMBOL_REF
-           && CONSTANT_POOL_ADDRESS_P (x) && !flag_pic)
+	   && CONSTANT_POOL_ADDRESS_P (x) && !flag_pic
+	   && !arm_disable_literal_pool)
     return 1;
 
   /* This is PC relative data after arm_reorg runs.  */
@@ -8393,6 +8431,7 @@ thumb1_legitimate_address_p (machine_mode mode, rtx x, int strict_p)
 	   && GET_MODE_SIZE (mode) == 4
 	   && GET_CODE (x) == SYMBOL_REF
 	   && CONSTANT_POOL_ADDRESS_P (x)
+	   && !arm_disable_literal_pool
 	   && ! (flag_pic
 		 && symbol_mentioned_p (get_pool_constant (x))
 		 && ! pcrel_constant_p (get_pool_constant (x))))
@@ -9028,7 +9067,9 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)
 	    return 0;
 	  if (thumb_shiftable_const (INTVAL (x)))
 	    return COSTS_N_INSNS (2);
-	  return COSTS_N_INSNS (3);
+	  return arm_disable_literal_pool
+	    ? COSTS_N_INSNS (8)
+	    : COSTS_N_INSNS (3);
 	}
       else if ((outer == PLUS || outer == COMPARE)
 	       && INTVAL (x) < 256 && INTVAL (x) > -256)
@@ -9185,7 +9226,9 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)
 	  /* See split "TARGET_THUMB1 && satisfies_constraint_K".  */
           if (thumb_shiftable_const (INTVAL (x)))
             return COSTS_N_INSNS (2);
-          return COSTS_N_INSNS (3);
+	  return arm_disable_literal_pool
+	    ? COSTS_N_INSNS (8)
+	    : COSTS_N_INSNS (3);
         }
       else if ((outer == PLUS || outer == COMPARE)
                && INTVAL (x) < 256 && INTVAL (x) > -256)
@@ -19670,6 +19713,35 @@ arm_compute_save_core_reg_mask (void)
   return save_reg_mask;
 }
 
+/* Return a mask for the call-clobbered low registers that are unused
+   at the end of the prologue.  */
+static unsigned long
+thumb1_prologue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
+/* Similarly for the start of the epilogue.  */
+static unsigned long
+thumb1_epilogue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
 /* Compute a bit mask of which core registers need to be
    saved on the stack for the current function.  */
 static unsigned long
@@ -19701,10 +19773,19 @@ thumb1_compute_save_core_reg_mask (void)
   if (mask & 0xff || thumb_force_lr_save ())
     mask |= (1 << LR_REGNUM);
 
-  /* Make sure we have a low work register if we need one.
-     We will need one if we are going to push a high register,
-     but we are not currently intending to push a low register.  */
+  bool call_clobbered_scratch
+    = (thumb1_prologue_unused_call_clobbered_lo_regs ()
+       && thumb1_epilogue_unused_call_clobbered_lo_regs ());
+
+  /* Make sure we have a low work register if we need one.  We will
+     need one if we are going to push a high register, but we are not
+     currently intending to push a low register.  However if both the
+     prologue and epilogue have a spare call-clobbered low register,
+     then we won't need to find an additional work register.  It does
+     not need to be the same register in the prologue and
+     epilogue.  */
   if ((mask & 0xff) == 0
+      && !call_clobbered_scratch
       && ((mask & 0x0f00) || TARGET_BACKTRACE))
     {
       /* Use thumb_find_work_register to choose which register
@@ -24930,12 +25011,7 @@ thumb1_unexpanded_epilogue (void)
       unsigned long mask = live_regs_mask & 0xff;
       int next_hi_reg;
 
-      /* The available low registers depend on the size of the value we are
-         returning.  */
-      if (size <= 12)
-	mask |=  1 << 3;
-      if (size <= 8)
-	mask |= 1 << 2;
+      mask |= thumb1_epilogue_unused_call_clobbered_lo_regs ();
 
       if (mask == 0)
 	/* Oh dear!  We have no low registers into which we can pop
@@ -24943,7 +25019,7 @@ thumb1_unexpanded_epilogue (void)
 	internal_error
 	  ("no low registers available for popping high registers");
 
-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)
+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)
 	if (live_regs_mask & (1 << next_hi_reg))
 	  break;
 
@@ -24951,7 +25027,7 @@ thumb1_unexpanded_epilogue (void)
 	{
 	  /* Find lo register(s) into which the high register(s) can
              be popped.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		high_regs_pushed--;
@@ -24959,20 +25035,22 @@ thumb1_unexpanded_epilogue (void)
 		break;
 	    }
 
-	  mask &= (2 << regno) - 1;	/* A noop if regno == 8 */
+	  if (high_regs_pushed == 0 && regno >= 0)
+	    mask &= ~((1 << regno) - 1);
 
 	  /* Pop the values into the low register(s).  */
 	  thumb_pop (asm_out_file, mask);
 
 	  /* Move the value(s) into the high registers.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		{
 		  asm_fprintf (asm_out_file, "\tmov\t%r, %r\n", next_hi_reg,
 			       regno);
 
-		  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)
+		  for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;
+		       next_hi_reg--)
 		    if (live_regs_mask & (1 << next_hi_reg))
 		      break;
 		}
@@ -25354,10 +25432,20 @@ thumb1_expand_prologue (void)
 	  break;
 
       /* Here we need to mask out registers used for passing arguments
-	 even if they can be pushed.  This is to avoid using them to stash the high
-	 registers.  Such kind of stash may clobber the use of arguments.  */
+	 even if they can be pushed.  This is to avoid using them to
+	 stash the high registers.  Such kind of stash may clobber the
+	 use of arguments.  */
       pushable_regs = l_mask & (~arg_regs_mask);
-      if (lr_needs_saving)
+      pushable_regs |= thumb1_prologue_unused_call_clobbered_lo_regs ();
+
+      /* Normally, LR can be used as a scratch register once it has been
+	 saved; but if the function examines its own return address then
+	 the value is still live and we need to avoid using it.  */
+      bool return_addr_live
+	= REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			   LR_REGNUM);
+
+      if (lr_needs_saving || return_addr_live)
 	pushable_regs &= ~(1 << LR_REGNUM);
 
       if (pushable_regs == 0)
@@ -25398,6 +25486,11 @@ thumb1_expand_prologue (void)
 	      push_mask |= 1 << LR_REGNUM;
 	      real_regs_mask |= 1 << LR_REGNUM;
 	      lr_needs_saving = false;
+	      /* If the return address is not live at this point, we
+		 can add LR to the list of registers that we can use
+		 for pushes.  */
+	      if (!return_addr_live)
+		pushable_regs |= 1 << LR_REGNUM;
 	    }
 
 	  insn = thumb1_emit_multi_reg_push (push_mask, real_regs_mask);
@@ -26782,14 +26875,41 @@ arm_thumb1_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,
 	  /* push r3 so we can use it as a temporary.  */
 	  /* TODO: Omit this save if r3 is not used.  */
 	  fputs ("\tpush {r3}\n", file);
-	  fputs ("\tldr\tr3, ", file);
+
+	  /* With -mpure-code, we cannot load the address from the
+	     constant pool: we build it explicitly.  */
+	  if (target_pure_code)
+	    {
+	      fputs ("\tmovs\tr3, #:upper8_15:#", file);
+	      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));
+	      fputc ('\n', file);
+	      fputs ("\tlsls r3, #8\n", file);
+	      fputs ("\tadds\tr3, #:upper0_7:#", file);
+	      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));
+	      fputc ('\n', file);
+	      fputs ("\tlsls r3, #8\n", file);
+	      fputs ("\tadds\tr3, #:lower8_15:#", file);
+	      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));
+	      fputc ('\n', file);
+	      fputs ("\tlsls r3, #8\n", file);
+	      fputs ("\tadds\tr3, #:lower0_7:#", file);
+	      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));
+	      fputc ('\n', file);
+	    }
+	  else
+	    fputs ("\tldr\tr3, ", file);
 	}
       else
 	{
 	  fputs ("\tldr\tr12, ", file);
 	}
-      assemble_name (file, label);
-      fputc ('\n', file);
+
+      if (!target_pure_code)
+	{
+	  assemble_name (file, label);
+	  fputc ('\n', file);
+	}
+
       if (flag_pic)
 	{
 	  /* If we are generating PIC, the ldr instruction below loads
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 4866e1e4b7d..9ee6a4eb524 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -1854,9 +1854,11 @@ enum arm_auto_incmodes
    for the index in the tablejump instruction.  */
 #define CASE_VECTOR_MODE Pmode
 
-#define CASE_VECTOR_PC_RELATIVE (TARGET_THUMB2				\
-				 || (TARGET_THUMB1			\
-				     && (optimize_size || flag_pic)))
+#define CASE_VECTOR_PC_RELATIVE ((TARGET_THUMB2				\
+				  || (TARGET_THUMB1			\
+				      && (optimize_size || flag_pic)))	\
+				 && (!target_pure_code))
+
 
 #define CASE_VECTOR_SHORTEN_MODE(min, max, body)			\
   (TARGET_THUMB1							\
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 0aecd03891c..53e54874c12 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -94,6 +94,11 @@
 ; an IT block in their expansion which is not a short IT.
 (define_attr "enabled_for_short_it" "no,yes" (const_string "yes"))
 
+; Mark an instruction sequence as the required way of loading a
+; constant when -mpure-code is enabled (which implies
+; arm_disable_literal_pool)
+(define_attr "required_for_purecode" "no,yes" (const_string "no"))
+
 ;; Operand number of an input operand that is shifted.  Zero if the
 ;; given instruction does not shift one of its input operands.
 (define_attr "shift" "" (const_int 0))
@@ -237,6 +242,10 @@
 	       (match_test "arm_restrict_it"))
 	  (const_string "no")
 
+	  (and (eq_attr "required_for_purecode" "yes")
+	       (not (match_test "arm_disable_literal_pool")))
+	  (const_string "no")
+
 	  (eq_attr "arch_enabled" "no")
 	  (const_string "no")]
 	 (const_string "yes")))
@@ -1110,7 +1119,7 @@
    (parallel [(set (reg:CC CC_REGNUM)
 		   (compare:CC (match_dup 4) (match_dup 5)))
 	     (set (match_dup 3) (minus:SI (minus:SI (match_dup 4) (match_dup 5))
-			       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))])]
+			       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))])]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1141,7 +1150,7 @@
   [(set (match_operand:SI 0 "s_register_operand" "=r,r,r")
 	(minus:SI (minus:SI (match_operand:SI 1 "reg_or_int_operand" "r,I,Pz")
 			    (match_operand:SI 2 "s_register_operand" "r,r,r"))
-		  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+		  (match_operand:SI 3 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "@
    sbc%?\\t%0, %1, %2
@@ -1155,9 +1164,10 @@
 
 (define_insn "*subsi3_carryin_const"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
-        (minus:SI (plus:SI (match_operand:SI 1 "s_register_operand" "r")
-                           (match_operand:SI 2 "arm_neg_immediate_operand" "L"))
-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+	(minus:SI (plus:SI
+		   (match_operand:SI 1 "s_register_operand" "r")
+		   (match_operand:SI 2 "arm_neg_immediate_operand" "L"))
+		  (match_operand:SI 3 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "sbc\\t%0, %1, #%n2"
   [(set_attr "conds" "use")
@@ -1166,8 +1176,8 @@
 
 (define_insn "*subsi3_carryin_const0"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
-        (minus:SI (match_operand:SI 1 "s_register_operand" "r")
-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+	(minus:SI (match_operand:SI 1 "s_register_operand" "r")
+		  (match_operand:SI 2 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "sbc\\t%0, %1, #0"
   [(set_attr "conds" "use")
@@ -1176,12 +1186,11 @@
 
 (define_insn "*subsi3_carryin_compare"
   [(set (reg:CC CC_REGNUM)
-        (compare:CC (match_operand:SI 1 "s_register_operand" "r")
-                    (match_operand:SI 2 "s_register_operand" "r")))
+	(compare:CC (match_operand:SI 1 "s_register_operand" "r")
+		    (match_operand:SI 2 "s_register_operand" "r")))
    (set (match_operand:SI 0 "s_register_operand" "=r")
-        (minus:SI (minus:SI (match_dup 1)
-                            (match_dup 2))
-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+	(minus:SI (minus:SI (match_dup 1) (match_dup 2))
+		  (match_operand:SI 3 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "sbcs\\t%0, %1, %2"
   [(set_attr "conds" "set")
@@ -1190,12 +1199,13 @@
 
 (define_insn "*subsi3_carryin_compare_const"
   [(set (reg:CC CC_REGNUM)
-        (compare:CC (match_operand:SI 1 "reg_or_int_operand" "r")
-                    (match_operand:SI 2 "const_int_I_operand" "I")))
+	(compare:CC (match_operand:SI 1 "reg_or_int_operand" "r")
+		    (match_operand:SI 2 "const_int_I_operand" "I")))
    (set (match_operand:SI 0 "s_register_operand" "=r")
-        (minus:SI (plus:SI (match_dup 1)
-                           (match_operand:SI 3 "arm_neg_immediate_operand" "L"))
-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+	(minus:SI (plus:SI
+		   (match_dup 1)
+		   (match_operand:SI 3 "arm_neg_immediate_operand" "L"))
+		  (match_operand:SI 4 "arm_borrow_operation" "")))]
   "TARGET_32BIT
    && (INTVAL (operands[2])
        == trunc_int_for_mode (-INTVAL (operands[3]), SImode))"
@@ -1206,11 +1216,11 @@
 
 (define_insn "*subsi3_carryin_compare_const0"
   [(set (reg:CC CC_REGNUM)
-        (compare:CC (match_operand:SI 1 "reg_or_int_operand" "r")
+	(compare:CC (match_operand:SI 1 "reg_or_int_operand" "r")
 		    (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=r")
-        (minus:SI (match_dup 1)
-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+	(minus:SI (match_dup 1)
+		  (match_operand:SI 2 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "sbcs\\t%0, %1, #0"
   [(set_attr "conds" "set")
@@ -1220,28 +1230,28 @@
 (define_insn "*subsi3_carryin_shift"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(minus:SI (minus:SI
-		  (match_operand:SI 1 "s_register_operand" "r")
-                  (match_operator:SI 2 "shift_operator"
-                   [(match_operand:SI 3 "s_register_operand" "r")
-                    (match_operand:SI 4 "reg_or_int_operand" "rM")]))
-                 (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+		   (match_operand:SI 1 "s_register_operand" "r")
+		   (match_operator:SI 2 "shift_operator"
+		    [(match_operand:SI 3 "s_register_operand" "r")
+		     (match_operand:SI 4 "reg_or_int_operand" "rM")]))
+		  (match_operand:SI 5 "arm_borrow_operation" "")))]
   "TARGET_32BIT"
   "sbc%?\\t%0, %1, %3%S2"
   [(set_attr "conds" "use")
    (set_attr "predicable" "yes")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
-		      (const_string "alu_shift_imm")
-                     (const_string "alu_shift_reg")))]
+				    (const_string "alu_shift_imm")
+				    (const_string "alu_shift_reg")))]
 )
 
 (define_insn "*rsbsi3_carryin_shift"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(minus:SI (minus:SI
-                  (match_operator:SI 2 "shift_operator"
-                   [(match_operand:SI 3 "s_register_operand" "r")
-                    (match_operand:SI 4 "reg_or_int_operand" "rM")])
+		   (match_operator:SI 2 "shift_operator"
+		    [(match_operand:SI 3 "s_register_operand" "r")
+		     (match_operand:SI 4 "reg_or_int_operand" "rM")])
 		   (match_operand:SI 1 "s_register_operand" "r"))
-                 (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+		  (match_operand:SI 5 "arm_borrow_operation" "")))]
   "TARGET_ARM"
   "rsc%?\\t%0, %1, %3%S2"
   [(set_attr "conds" "use")
@@ -1311,7 +1321,7 @@
 		   (compare:CC (match_dup 1) (match_dup 2)))
 	      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])
    (set (match_dup 3) (minus:SI (minus:SI (match_dup 4) (match_dup 5))
-			       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+			       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1338,7 +1348,7 @@
 		   (compare:CC (match_dup 1) (match_dup 2)))
 	      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])
    (set (match_dup 3) (minus:SI (match_dup 4)
-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+				(ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1365,7 +1375,7 @@
    (set (match_dup 3) (minus:SI (minus:SI (match_dup 4)
                                          (ashiftrt:SI (match_dup 2)
                                                       (const_int 31)))
-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+                                (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1392,7 +1402,7 @@
 		   (compare:CC (match_dup 2) (match_dup 1)))
 	      (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))])
    (set (match_dup 3) (minus:SI (minus:SI (const_int 0) (match_dup 4))
-			       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+			       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1422,7 +1432,7 @@
                                 (ashiftrt:SI (match_dup 2)
                                              (const_int 31))
                                 (match_dup 4))
-			       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+			       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -1448,7 +1458,7 @@
 		   (compare:CC (match_dup 1) (match_dup 2)))
 	      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])
    (set (match_dup 3) (minus:SI (minus:SI (match_dup 1) (match_dup 1))
-			       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+			       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
        operands[3] = gen_highpart (SImode, operands[0]);
        operands[0] = gen_lowpart (SImode, operands[0]);
@@ -4483,62 +4493,78 @@
 ; ARMv6+ unaligned load/store instructions (used for packed structure accesses).
 
 (define_insn "unaligned_loadsi"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
-	(unspec:SI [(match_operand:SI 1 "memory_operand" "Uw,m")]
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
+	(unspec:SI [(match_operand:SI 1 "memory_operand" "m,Uw,m")]
 		   UNSPEC_UNALIGNED_LOAD))]
   "unaligned_access"
-  "ldr%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldr\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_4")])
 
+;; The 16-bit Thumb1 variant of ldrsh requires two registers in the
+;; address (there's no immediate format).  That's tricky to support
+;; here and we don't really need this pattern for that case, so only
+;; enable for 32-bit ISAs.
 (define_insn "unaligned_loadhis"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
 	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
-  "unaligned_access"
+  "unaligned_access && TARGET_32BIT"
   "ldrsh%?\t%0, %1\t@ unaligned"
   [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
 	(zero_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "m,Uw,m")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
-  "ldrh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldrh\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_storesi"
-  [(set (match_operand:SI 0 "memory_operand" "=Uw,m")
-	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:SI 0 "memory_operand" "=m,Uw,m")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "str%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   str\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 (define_insn "unaligned_storehi"
-  [(set (match_operand:HI 0 "memory_operand" "=Uw,m")
-	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:HI 0 "memory_operand" "=m,Uw,m")
+	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "strh%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   strh\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 
@@ -4645,7 +4671,7 @@
 	     (set (match_dup 2)
 		  (minus:SI
 		   (minus:SI (const_int 0) (match_dup 3))
-		   (ltu:SI (reg:CC_C CC_REGNUM)
+		   (ltu:SI (reg:CC CC_REGNUM)
 			   (const_int 0))))])]
   {
     operands[2] = gen_highpart (SImode, operands[0]);
@@ -4687,7 +4713,7 @@
 		   (compare:CC (const_int 0) (match_dup 1)))
 	      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])
    (set (match_dup 2) (minus:SI (minus:SI (const_int 0) (match_dup 3))
-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+                                (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[2] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -4706,7 +4732,7 @@
    (set (match_operand:SI 0 "s_register_operand" "=r")
 	(minus:SI (minus:SI (const_int 0)
 			    (match_dup 1))
-		  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+		  (match_operand:SI 2 "arm_borrow_operation" "")))]
   "TARGET_ARM"
   "rscs\\t%0, %1, #0"
   [(set_attr "conds" "set")
@@ -4783,7 +4809,7 @@
 		asr	Rhi, Rin, #31
 		rsbs	Rlo, Rin, #0
 		rsc	Rhi, Rhi, #0 (thumb2: sbc Rhi, Rhi, Rhi, lsl #1).  */
-	rtx cc_reg = gen_rtx_REG (CC_Cmode, CC_REGNUM);
+	rtx cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);
 
 	emit_insn (gen_rtx_SET (high,
 				gen_rtx_ASHIFTRT (SImode, operands[1],
@@ -4845,10 +4871,10 @@
       ;; since we just need to propagate the carry.
   "&& reload_completed"
   [(parallel [(set (reg:CC CC_REGNUM)
-                   (compare:CC (const_int 0) (match_dup 1)))
-              (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])
+		   (compare:CC (const_int 0) (match_dup 1)))
+	      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])
    (set (match_dup 2) (minus:SI (minus:SI (match_dup 2) (match_dup 2))
-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]
+				(ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]
   {
     operands[2] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
@@ -7429,12 +7455,12 @@
   "#"   ; "cmp\\t%Q0, %Q1\;sbcs\\t%2, %R0, %R1"
   "&& reload_completed"
   [(set (reg:CC CC_REGNUM)
-        (compare:CC (match_dup 0) (match_dup 1)))
+	(compare:CC (match_dup 0) (match_dup 1)))
    (parallel [(set (reg:CC CC_REGNUM)
-                   (compare:CC (match_dup 3) (match_dup 4)))
-              (set (match_dup 2)
-                   (minus:SI (match_dup 5)
-			     (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))])]
+		   (compare:CC (match_dup 3) (match_dup 4)))
+	      (set (match_dup 2)
+		   (minus:SI (match_dup 5)
+			     (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))])]
   {
     operands[3] = gen_highpart (SImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
diff --git a/gcc/config/arm/arm.opt b/gcc/config/arm/arm.opt
index 9067d491b9c..78f3878e037 100644
--- a/gcc/config/arm/arm.opt
+++ b/gcc/config/arm/arm.opt
@@ -82,7 +82,7 @@ mapcs-stack-check
 Target Report Mask(APCS_STACK) Undocumented
 
 march=
-Target RejectNegative ToLower Joined Var(arm_arch_string)
+Target RejectNegative Negative(march=) ToLower Joined Var(arm_arch_string)
 Specify the name of the target architecture.
 
 ; Other arm_arch values are loaded from arm-tables.opt
@@ -107,7 +107,7 @@ Target Report Mask(CALLER_INTERWORKING)
 Thumb: Assume function pointers may go to non-Thumb aware code.
 
 mcpu=
-Target RejectNegative ToLower Joined Var(arm_cpu_string)
+Target RejectNegative Negative(mcpu=) ToLower Joined Var(arm_cpu_string)
 Specify the name of the target CPU.
 
 mfloat-abi=
@@ -232,7 +232,7 @@ Target Report Mask(TPCS_LEAF_FRAME)
 Thumb: Generate (leaf) stack frames even if not needed.
 
 mtune=
-Target RejectNegative ToLower Joined Var(arm_tune_string)
+Target RejectNegative Negative(mtune=) ToLower Joined Var(arm_tune_string)
 Tune code for the given processor.
 
 mprint-tune-info
diff --git a/gcc/config/arm/arm_acle.h b/gcc/config/arm/arm_acle.h
index 2c7acc698ea..6857ab1787d 100644
--- a/gcc/config/arm/arm_acle.h
+++ b/gcc/config/arm/arm_acle.h
@@ -174,8 +174,12 @@ __arm_mrrc2 (const unsigned int __coproc, const unsigned int __opc1,
 #endif /* (!__thumb__ || __thumb2__) &&  __ARM_ARCH >= 4.  */
 
 #pragma GCC push_options
-#if __ARM_ARCH >= 8
+#ifdef __ARM_FEATURE_CRC32
+#ifdef __ARM_FP
+#pragma GCC target ("arch=armv8-a+crc+simd")
+#else
 #pragma GCC target ("arch=armv8-a+crc")
+#endif
 
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
@@ -235,7 +239,7 @@ __crc32cd (uint32_t __a, uint64_t __b)
 }
 #endif
 
-#endif /* __ARM_ARCH >= 8.  */
+#endif /* __ARM_FEATURE_CRC32  */
 #pragma GCC pop_options
 
 #ifdef __cplusplus
diff --git a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
index f53378a250e..25f86471ded 100644
--- a/gcc/config/arm/predicates.md
+++ b/gcc/config/arm/predicates.md
@@ -358,6 +358,27 @@
 (define_special_predicate "lt_ge_comparison_operator"
   (match_code "lt,ge"))
 
+;; Match a "borrow" operation for use with SBC.  The precise code will
+;; depend on the form of the comparison.  This is generally the inverse of
+;; a carry operation, since the logic of SBC uses "not borrow" in it's
+;; calculation.
+(define_special_predicate "arm_borrow_operation"
+  (match_code "geu,ltu")
+  {
+    if (XEXP (op, 1) != const0_rtx)
+      return false;
+    rtx op0 = XEXP (op, 0);
+    if (!REG_P (op0) || REGNO (op0) != CC_REGNUM)
+      return false;
+    machine_mode ccmode = GET_MODE (op0);
+    if (ccmode == CC_Cmode)
+      return GET_CODE (op) == GEU;
+    else if (ccmode == CCmode)
+      return GET_CODE (op) == LTU;
+    return false;
+  }
+)
+
 ;; The vsel instruction only accepts the ARM condition codes listed below.
 (define_special_predicate "arm_vsel_comparison_operator"
   (and (match_operand 0 "expandable_comparison_operator")
diff --git a/gcc/config/arm/t-multilib b/gcc/config/arm/t-multilib
index 08526302283..87069f71ecc 100644
--- a/gcc/config/arm/t-multilib
+++ b/gcc/config/arm/t-multilib
@@ -24,6 +24,8 @@
 # values during the configure step.  We enforce this during the
 # top-level configury.
 
+s-mlib: $(srcdir)/config/arm/t-multilib $(srcdir)/config/arm/t-aprofile $(srcdir)/config/arm/t-rmprofile
+
 MULTILIB_OPTIONS     =
 MULTILIB_DIRNAMES    =
 MULTILIB_EXCEPTIONS  =
@@ -63,6 +65,8 @@ all_early_arch		:= armv5tej armv6 armv6j armv6k armv6z armv6kz \
 v7_a_arch_variants	:= $(call all_feat_combs, mp sec)
 v7_a_nosimd_variants	:= +fp +vfpv3 +vfpv3-d16-fp16 +vfpv3-fp16 +vfpv4-d16 +vfpv4
 v7_a_simd_variants	:= +simd +neon-fp16 +neon-vfpv4
+v7_r_sp_variants	:= +fp.sp +fp.sp+idiv +vfpv3xd-fp16 +vfpv3xd-fp16+idiv
+v7_r_dp_variants	:= +fp +fp+idiv +vfpv3-d16-fp16 +vfpv3-d16-fp16+idiv
 v7ve_nosimd_variants	:= +vfpv3-d16 +vfpv3 +vfpv3-d16-fp16 +vfpv3-fp16 +fp +vfpv4
 v7ve_vfpv3_simd_variants := +neon +neon-fp16
 v7ve_vfpv4_simd_variants := +simd
@@ -86,8 +90,8 @@ SEP := $(and $(HAS_APROFILE),$(HAS_RMPROFILE),/)
 MULTILIB_OPTIONS	+= marm/mthumb
 MULTILIB_DIRNAMES	+= arm thumb
 
-MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv7/march=armv7+fp/$(MULTI_ARCH_OPTS_A)$(SEP)$(MULTI_ARCH_OPTS_RM)
-MULTILIB_DIRNAMES	+= v5te v7 v7+fp $(MULTI_ARCH_DIRS_A) $(MULTI_ARCH_DIRS_RM)
+MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv7/march=armv7+fp/march=armv7-r+fp.sp/$(MULTI_ARCH_OPTS_A)$(SEP)$(MULTI_ARCH_OPTS_RM)
+MULTILIB_DIRNAMES	+= v5te v7 v7+fp v7-r+fp.sp $(MULTI_ARCH_DIRS_A) $(MULTI_ARCH_DIRS_RM)
 
 MULTILIB_OPTIONS	+= mfloat-abi=soft/mfloat-abi=softfp/mfloat-abi=hard
 MULTILIB_DIRNAMES	+= nofp softfp hard
@@ -100,29 +104,47 @@ MULTILIB_REQUIRED	+= mthumb/march=armv7/mfloat-abi=soft
 MULTILIB_REQUIRED	+= mthumb/march=armv7+fp/mfloat-abi=softfp
 MULTILIB_REQUIRED	+= mthumb/march=armv7+fp/mfloat-abi=hard
 
-# Map v7-r down onto common v7 code.
+MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp.sp/mfloat-abi=softfp
+MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp.sp/mfloat-abi=hard
+
+# Map v7-r with double precision down onto common v7 code.
 MULTILIB_MATCHES	+= march?armv7=march?armv7-r
 MULTILIB_MATCHES	+= march?armv7=march?armv7-r+idiv
-MULTILIB_MATCHES	+= march?armv7+fp=march?armv7-r+fp
-MULTILIB_MATCHES	+= march?armv7+fp=march?armv7-r+fp+idiv
+MULTILIB_MATCHES	+= $(foreach ARCH, $(v7_r_dp_variants), \
+			     march?armv7+fp=march?armv7-r$(ARCH))
+
+# Map v7-r single precision variants to v7-r with single precision.
+MULTILIB_MATCHES	+= $(foreach ARCH, \
+			     $(filter-out +fp.sp, $(v7_r_sp_variants)), \
+			     march?armv7-r+fp.sp=march?armv7-r$(ARCH))
 
 MULTILIB_MATCHES	+= $(foreach ARCH, $(all_early_arch), \
 			     march?armv5te+fp=march?$(ARCH)+fp)
-# Map v8-r down onto common v7 code.
+# Map v8-r down onto common v7 code or v7-r sp.
 MULTILIB_MATCHES	+= march?armv7=march?armv8-r
 MULTILIB_MATCHES	+= $(foreach ARCH, $(v8_r_nosimd_variants), \
 			     march?armv7=march?armv8-r$(ARCH))
 MULTILIB_MATCHES	+= $(foreach ARCH,+simd +crypto, \
 			     march?armv7+fp=march?armv8-r$(ARCH) \
 			     march?armv7+fp=march?armv8-r+crc$(ARCH))
-
+MULTILIB_MATCHES	+= march?armv7-r+fp.sp=march?armv8-r+fp.sp
+MULTILIB_MATCHES	+= march?armv7-r+fp.sp=march?armv8-r+crc+fp.sp
 
 ifeq (,$(HAS_APROFILE))
 # Map all v7-a
+
 MULTILIB_MATCHES	+= march?armv7=march?armv7-a
+
+MULTILIB_MATCHES	+= $(foreach ARCH, $(v7_a_arch_variants), \
+			     march?armv7=march?armv7-a$(ARCH))
+
 MULTILIB_MATCHES	+= $(foreach ARCH, $(v7_a_nosimd_variants) $(v7_a_simd_variants), \
 			     march?armv7+fp=march?armv7-a$(ARCH))
 
+MULTILIB_MATCHES	+= $(foreach ARCHVAR, $(v7_a_arch_variants), \
+			     $(foreach ARCH, $(v7_a_nosimd_variants) $(v7_a_simd_variants), \
+			       march?armv7+fp=march?armv7-a$(ARCHVAR)$(ARCH)))
+
 MULTILIB_MATCHES	+= march?armv7=march?armv7ve
 
 # ARMv7ve FP/SIMD variants: map down to v7+fp
@@ -172,12 +194,14 @@ MULTILIB_MATCHES	+= march?armv7=march?armv8.5-a
 MULTILIB_MATCHES	+= $(foreach ARCH, $(v8_5_a_simd_variants), \
 			     march?armv7+fp=march?armv8.5-a$(ARCH))
 
+endif		# Not APROFILE.
+
 # Use Thumb libraries for everything.
 
 MULTILIB_REUSE		+= mthumb/march.armv7/mfloat-abi.soft=marm/march.armv7/mfloat-abi.soft
 
 MULTILIB_REUSE		+= $(foreach ABI, hard softfp, \
-			     $(foreach ARCH, armv7+fp, \
+			     $(foreach ARCH, armv7+fp armv7-r+fp\.sp, \
 			       mthumb/march.$(ARCH)/mfloat-abi.$(ABI)=marm/march.$(ARCH)/mfloat-abi.$(ABI)))
 
 # Softfp but no FP, use the soft-float libraries.
@@ -185,4 +209,3 @@ MULTILIB_REUSE		+= $(foreach MODE, arm thumb, \
 			     $(foreach ARCH, armv7, \
 			       mthumb/march.$(ARCH)/mfloat-abi.soft=m$(MODE)/march.$(ARCH)/mfloat-abi.softfp))
 
-endif		# Not APROFILE.
diff --git a/gcc/config/arm/thumb1.md b/gcc/config/arm/thumb1.md
index cefd6cfcdcd..041e2db343f 100644
--- a/gcc/config/arm/thumb1.md
+++ b/gcc/config/arm/thumb1.md
@@ -43,6 +43,41 @@
 
 
 
+(define_insn "thumb1_movsi_symbol_ref"
+  [(set (match_operand:SI 0 "register_operand" "=l")
+	(match_operand:SI 1 "general_operand" ""))
+   ]
+  "TARGET_THUMB1
+   && arm_disable_literal_pool
+   && GET_CODE (operands[1]) == SYMBOL_REF"
+  "*
+  output_asm_insn (\"movs\\t%0, #:upper8_15:%1\", operands);
+  output_asm_insn (\"lsls\\t%0, #8\", operands);
+  output_asm_insn (\"adds\\t%0, #:upper0_7:%1\", operands);
+  output_asm_insn (\"lsls\\t%0, #8\", operands);
+  output_asm_insn (\"adds\\t%0, #:lower8_15:%1\", operands);
+  output_asm_insn (\"lsls\\t%0, #8\", operands);
+  output_asm_insn (\"adds\\t%0, #:lower0_7:%1\", operands);
+  return \"\";
+  "
+  [(set_attr "length" "14")
+   (set_attr "conds" "clob")]
+)
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "immediate_operand" ""))]
+  "TARGET_THUMB1
+   && arm_disable_literal_pool
+   && GET_CODE (operands[1]) == CONST_INT
+   && !satisfies_constraint_I (operands[1])"
+  [(clobber (const_int 0))]
+  "
+    thumb1_gen_const_int (operands[0], INTVAL (operands[1]));
+    DONE;
+  "
+)
+
 (define_insn "*thumb1_adddi3"
   [(set (match_operand:DI          0 "register_operand" "=l")
 	(plus:DI (match_operand:DI 1 "register_operand" "%0")
@@ -656,8 +691,8 @@
 )
 
 (define_insn "*thumb1_movsi_insn"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,r,l,l,l,>,l, m,*l*h*k")
-	(match_operand:SI 1 "general_operand"      "l, I,j,J,K,>,l,mi,l,*l*h*k"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,r,l,l,l,>,l, l, m,*l*h*k")
+	(match_operand:SI 1 "general_operand"      "l, I,j,J,K,>,l,i, mi,l,*l*h*k"))]
   "TARGET_THUMB1
    && (   register_operand (operands[0], SImode)
        || register_operand (operands[1], SImode))"
@@ -669,14 +704,16 @@
    #
    ldmia\\t%1, {%0}
    stmia\\t%0, {%1}
+   movs\\t%0, #:upper8_15:%1; lsls\\t%0, #8; adds\\t%0, #:upper0_7:%1; lsls\\t%0, #8; adds\\t%0, #:lower8_15:%1; lsls\\t%0, #8; adds\\t%0, #:lower0_7:%1
    ldr\\t%0, %1
    str\\t%1, %0
    mov\\t%0, %1"
-  [(set_attr "length" "2,2,4,4,4,2,2,2,2,2")
-   (set_attr "type" "mov_reg,mov_imm,mov_imm,multiple,multiple,load_4,store_4,load_4,store_4,mov_reg")
-   (set_attr "pool_range" "*,*,*,*,*,*,*,1018,*,*")
-   (set_attr "arch" "t1,t1,v8mb,t1,t1,t1,t1,t1,t1,t1")
-   (set_attr "conds" "set,clob,nocond,*,*,nocond,nocond,nocond,nocond,nocond")])
+  [(set_attr "length" "2,2,4,4,4,2,2,14,2,2,2")
+   (set_attr "type" "mov_reg,mov_imm,mov_imm,multiple,multiple,load_4,store_4,alu_sreg,load_4,store_4,mov_reg")
+   (set_attr "pool_range" "*,*,*,*,*,*,*, *,1018,*,*")
+   (set_attr "arch" "t1,t1,v8mb,t1,t1,t1,t1,t1,t1,t1,t1")
+   (set_attr "required_for_purecode" "no,no,no,no,no,no,no,yes,no,no,no")
+   (set_attr "conds" "set,clob,nocond,*,*,nocond,nocond,nocond,nocond,nocond,nocond")])
 
 ; Split the load of 64-bit constant into two loads for high and low 32-bit parts respectively
 ; to see if we can load them in fewer instructions or fewer cycles.
@@ -829,8 +866,8 @@
    (set_attr "conds" "clob,nocond,nocond,nocond,nocond,clob")])
 
 (define_insn "*thumb1_movhf"
-  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,m,*r,*h")
-	(match_operand:HF     1 "general_operand"      "l,mF,l,*h,*r"))]
+  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,l,m,*r,*h")
+	(match_operand:HF     1 "general_operand"      "l, m,F,l,*h,*r"))]
   "TARGET_THUMB1
    && (	  s_register_operand (operands[0], HFmode)
        || s_register_operand (operands[1], HFmode))"
@@ -855,14 +892,34 @@
 	  }
 	return \"ldrh\\t%0, %1\";
       }
-    case 2: return \"strh\\t%1, %0\";
+    case 2:
+    {
+      int bits;
+      int high;
+      rtx ops[3];
+
+      bits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),
+			     HFmode);
+      ops[0] = operands[0];
+      high = (bits >> 8) & 0xff;
+      ops[1] = GEN_INT (high);
+      ops[2] = GEN_INT (bits & 0xff);
+      if (high != 0)
+	output_asm_insn (\"movs\\t%0, %1\;lsls\\t%0, #8\;adds\\t%0, %2\", ops);
+      else
+	output_asm_insn (\"movs\\t%0, %2\", ops);
+
+      return \"\";
+    }
+    case 3: return \"strh\\t%1, %0\";
     default: return \"mov\\t%0, %1\";
     }
   "
-  [(set_attr "length" "2")
-   (set_attr "type" "mov_reg,load_4,store_4,mov_reg,mov_reg")
-   (set_attr "pool_range" "*,1018,*,*,*")
-   (set_attr "conds" "clob,nocond,nocond,nocond,nocond")])
+  [(set_attr "length" "2,2,6,2,2,2")
+   (set_attr "type" "mov_reg,load_4,mov_reg,store_4,mov_reg,mov_reg")
+   (set_attr "pool_range" "*,1018,*,*,*,*")
+   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,nocond")])
+
 ;;; ??? This should have alternatives for constants.
 (define_insn "*thumb1_movsf_insn"
   [(set (match_operand:SF     0 "nonimmediate_operand" "=l,l,>,l, m,*r,*h")
diff --git a/gcc/config/avr/avr-arch.h b/gcc/config/avr/avr-arch.h
index 7624b2614f8..e6ae9d9cd04 100644
--- a/gcc/config/avr/avr-arch.h
+++ b/gcc/config/avr/avr-arch.h
@@ -126,6 +126,9 @@ typedef struct
 
   /* Flash size in bytes.  */
   int flash_size;
+
+  /* Offset where flash is seen in the RAM address space.  */
+  int flash_pm_offset;
 } avr_mcu_t;
 
 /* AVR device specific features.
diff --git a/gcc/config/avr/avr-devices.c b/gcc/config/avr/avr-devices.c
index 8688675341b..eb8ef382d49 100644
--- a/gcc/config/avr/avr-devices.c
+++ b/gcc/config/avr/avr-devices.c
@@ -117,12 +117,12 @@ avr_texinfo[] =
 const avr_mcu_t
 avr_mcu_types[] =
 {
-#define AVR_MCU(NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, FLASH_SIZE)\
-  { NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, FLASH_SIZE },
+#define AVR_MCU(NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, FLASH_SIZE, PMOFF) \
+  { NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, FLASH_SIZE, PMOFF },
 #include "avr-mcus.def"
 #undef AVR_MCU
     /* End of list.  */
-  { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, 0 }
+  { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, 0, 0 }
 };
 
 
diff --git a/gcc/config/avr/avr-mcus.def b/gcc/config/avr/avr-mcus.def
index 79ee2c20689..0b4c6dea856 100644
--- a/gcc/config/avr/avr-mcus.def
+++ b/gcc/config/avr/avr-mcus.def
@@ -23,8 +23,8 @@
 
    This will regenerate / update the following source files:
 
-   -  $(srcdir)/config/avr/t-multilib
-   -  $(srcdir)/doc/avr-mmcu.texi
+-  $(srcdir)/config/avr/t-multilib
+-  $(srcdir)/doc/avr-mmcu.texi
 
    After that, rebuild everything and check-in the new sources to the repo.
    The device list below should be kept in sync with AVR-LibC.
@@ -36,338 +36,364 @@
 
    Before including this file, define a macro:
 
-   AVR_MCU (NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, N_FLASH)
+	AVR_MCU (NAME, ARCH, ATTR, MACRO, TDATA, TTEXT, FLASH_SIZE, PM_OFFSET)
 
    where the arguments are the fields of avr_mcu_t:
    
-       NAME          Name of the device as specified by -mmcu=<NAME>.  Also
-                     used by DRIVER_SELF_SPECS and gen-avr-mmcu-specs.c for
-                     - the name of the device specific specs file
-                       in -specs=device-specs/spec-<NAME>
-                     - the name of the startup file crt<NAME>.o
-                     - to link the device library by means of -l<NAME>
+	NAME	Name of the device as specified by -mmcu=<NAME>.  Also
+		used by DRIVER_SELF_SPECS and gen-avr-mmcu-specs.c for
+		- the name of the device specific specs file
+		  in -specs=device-specs/spec-<NAME>
+		- the name of the startup file crt<NAME>.o
+		- the name of the device library to be linked with -l<NAME>
 
-       ARCH          Specifies the multilib variant together with AVR_SHORT_SP
+	ARCH	Specifies the multilib variant together with AVR_SHORT_SP
 
-       DEV_ATTRIBUTE Specifies the device specific features
-                     - additional ISA, short SP, errata skip etc.,
+	ATTR	Specifies the device specific features
+		- additional ISA, short SP, errata skip etc.,
 
-       MACRO         If NULL, this is a core and not a device.  If non-NULL,
-                     supply respective built-in macro.
+	MACRO	If NULL, this is a core and not a device.  If non-NULL,
+		supply respective built-in macro.
 
-       DATA_START    First address of SRAM, used in  -Tdata=<DATA_START>.
+	TDATA	First address of SRAM, used in -Tdata=<DATA_START>.
 
-       TEXT_START    First address of Flash, used in -Ttext=<TEXT_START>.
+	TTEXT	First address of Flash, used in -Ttext=<TEXT_START>.
 
-       FLASH_SIZE    Flash size in bytes.
+	FLASH_SIZE
+		Flash size in bytes.
+
+	PM_OFFSET
+		Either 0x0 or the offset where flash memory is mirrored
+		into the RAM address space accessible by LD, LDD and LDS.
+		This is only needed if that value deviates from the
+		value for the respective device family.
 
    "avr2" must be first for the "0" default to work as intended.  */
 
 /* Classic, <= 8K.  */
-AVR_MCU ("avr2",             ARCH_AVR2, AVR_ERRATA_SKIP, NULL,                     0x0060, 0x0, 0x60000)
+AVR_MCU ("avr2",             ARCH_AVR2, AVR_ERRATA_SKIP, NULL,                     0x0060, 0x0, 0x60000, 0)
 
-AVR_MCU ("at90s2313",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2313__",         0x0060, 0x0, 0x800)
-AVR_MCU ("at90s2323",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2323__",         0x0060, 0x0, 0x800)
-AVR_MCU ("at90s2333",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2333__",         0x0060, 0x0, 0x800)
-AVR_MCU ("at90s2343",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2343__",         0x0060, 0x0, 0x800)
-AVR_MCU ("attiny22",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny22__",          0x0060, 0x0, 0x800)
-AVR_MCU ("attiny26",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny26__",          0x0060, 0x0, 0x800)
-AVR_MCU ("at90s4414",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4414__",         0x0060, 0x0, 0x1000)
-AVR_MCU ("at90s4433",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S4433__",         0x0060, 0x0, 0x1000)
-AVR_MCU ("at90s4434",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4434__",         0x0060, 0x0, 0x1000)
-AVR_MCU ("at90s8515",        ARCH_AVR2, AVR_ERRATA_SKIP, "__AVR_AT90S8515__",      0x0060, 0x0, 0x2000)
-AVR_MCU ("at90c8534",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90C8534__",         0x0060, 0x0, 0x2000)
-AVR_MCU ("at90s8535",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S8535__",         0x0060, 0x0, 0x2000)
+AVR_MCU ("at90s2313",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2313__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("at90s2323",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2323__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("at90s2333",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2333__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("at90s2343",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2343__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny22",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny22__",          0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny26",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny26__",          0x0060, 0x0, 0x800, 0)
+AVR_MCU ("at90s4414",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4414__",         0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("at90s4433",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S4433__",         0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("at90s4434",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4434__",         0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("at90s8515",        ARCH_AVR2, AVR_ERRATA_SKIP, "__AVR_AT90S8515__",      0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("at90c8534",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90C8534__",         0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("at90s8535",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S8535__",         0x0060, 0x0, 0x2000, 0)
 /* Classic + MOVW, <= 8K.  */
-AVR_MCU ("avr25",            ARCH_AVR25, AVR_ISA_NONE, NULL,                       0x0060, 0x0, 0x2000)
-AVR_MCU ("ata5272",          ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA5272__",          0x0100, 0x0, 0x2000)
-AVR_MCU ("ata6616c",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA6616C__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("attiny13",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13__",         0x0060, 0x0, 0x400)
-AVR_MCU ("attiny13a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13A__",        0x0060, 0x0, 0x400)
-AVR_MCU ("attiny2313",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313__",       0x0060, 0x0, 0x800)
-AVR_MCU ("attiny2313a",      ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313A__",      0x0060, 0x0, 0x800)
-AVR_MCU ("attiny24",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24__",         0x0060, 0x0, 0x800)
-AVR_MCU ("attiny24a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24A__",        0x0060, 0x0, 0x800)
-AVR_MCU ("attiny4313",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny4313__",       0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny44",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44__",         0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny44a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44A__",        0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny441",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny441__",        0x0100, 0x0, 0x1000)
-AVR_MCU ("attiny84",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84__",         0x0060, 0x0, 0x2000)
-AVR_MCU ("attiny84a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84A__",        0x0060, 0x0, 0x2000)
-AVR_MCU ("attiny25",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny25__",         0x0060, 0x0, 0x800)
-AVR_MCU ("attiny45",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny45__",         0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny85",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny85__",         0x0060, 0x0, 0x2000)
-AVR_MCU ("attiny261",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261__",        0x0060, 0x0, 0x800)
-AVR_MCU ("attiny261a",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261A__",       0x0060, 0x0, 0x800)
-AVR_MCU ("attiny461",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461__",        0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny461a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461A__",       0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny861",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861__",        0x0060, 0x0, 0x2000)
-AVR_MCU ("attiny861a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861A__",       0x0060, 0x0, 0x2000)
-AVR_MCU ("attiny43u",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny43U__",        0x0060, 0x0, 0x1000)
-AVR_MCU ("attiny87",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny87__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("attiny48",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny48__",         0x0100, 0x0, 0x1000)
-AVR_MCU ("attiny88",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny88__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("attiny828",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny828__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("attiny841",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny841__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("at86rf401",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_AT86RF401__",        0x0060, 0x0, 0x800)
+AVR_MCU ("avr25",            ARCH_AVR25, AVR_ISA_NONE, NULL,                       0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("ata5272",          ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA5272__",          0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("ata6616c",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA6616C__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("attiny13",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13__",         0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny13a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13A__",        0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny2313",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313__",       0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny2313a",      ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313A__",      0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny24",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny24a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24A__",        0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny4313",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny4313__",       0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny44",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44__",         0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny44a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44A__",        0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny441",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny441__",        0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("attiny84",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84__",         0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("attiny84a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84A__",        0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("attiny25",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny25__",         0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny45",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny45__",         0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny85",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny85__",         0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("attiny261",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261__",        0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny261a",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261A__",       0x0060, 0x0, 0x800, 0)
+AVR_MCU ("attiny461",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461__",        0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny461a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461A__",       0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny861",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861__",        0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("attiny861a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861A__",       0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("attiny43u",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny43U__",        0x0060, 0x0, 0x1000, 0)
+AVR_MCU ("attiny87",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny87__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("attiny48",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny48__",         0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("attiny88",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny88__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("attiny828",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny828__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("attiny841",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny841__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at86rf401",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_AT86RF401__",        0x0060, 0x0, 0x800, 0)
 /* Classic, > 8K, <= 64K.  */
-AVR_MCU ("avr3",             ARCH_AVR3, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x6000)
-AVR_MCU ("at43usb355",       ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT43USB355__",        0x0060, 0x0, 0x6000)
-AVR_MCU ("at76c711",         ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT76C711__",          0x0060, 0x0, 0x4000)
+AVR_MCU ("avr3",             ARCH_AVR3, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x6000, 0)
+AVR_MCU ("at43usb355",       ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT43USB355__",        0x0060, 0x0, 0x6000, 0)
+AVR_MCU ("at76c711",         ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT76C711__",          0x0060, 0x0, 0x4000, 0)
 /* Classic, == 128K.  */
-AVR_MCU ("avr31",            ARCH_AVR31, AVR_ERRATA_SKIP, NULL,                    0x0060, 0x0, 0x20000)
-AVR_MCU ("atmega103",        ARCH_AVR31, AVR_ERRATA_SKIP, "__AVR_ATmega103__",     0x0060, 0x0, 0x20000)
-AVR_MCU ("at43usb320",       ARCH_AVR31, AVR_ISA_NONE, "__AVR_AT43USB320__",       0x0060, 0x0, 0x10000)
+AVR_MCU ("avr31",            ARCH_AVR31, AVR_ERRATA_SKIP, NULL,                    0x0060, 0x0, 0x20000, 0)
+AVR_MCU ("atmega103",        ARCH_AVR31, AVR_ERRATA_SKIP, "__AVR_ATmega103__",     0x0060, 0x0, 0x20000, 0)
+AVR_MCU ("at43usb320",       ARCH_AVR31, AVR_ISA_NONE, "__AVR_AT43USB320__",       0x0060, 0x0, 0x10000, 0)
 /* Classic + MOVW + JMP/CALL.  */
-AVR_MCU ("avr35",            ARCH_AVR35, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 0x4000)
-AVR_MCU ("ata5505",          ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA5505__",          0x0100, 0x0, 0x4000)
-AVR_MCU ("ata6617c",         ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA6617C__",         0x0100, 0x0, 0x4000)
-AVR_MCU ("ata664251",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA664251__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("at90usb82",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB82__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("at90usb162",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB162__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega8u2",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega8U2__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega16u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega16U2__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega32u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega32U2__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("attiny167",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny167__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("attiny1634",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny1634__",       0x0100, 0x0, 0x4000)
+AVR_MCU ("avr35",            ARCH_AVR35, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata5505",          ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA5505__",          0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata6617c",         ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA6617C__",         0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata664251",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA664251__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("at90usb82",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB82__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90usb162",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB162__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega8u2",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega8U2__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega16u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega16U2__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega32u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega32U2__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("attiny167",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny167__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("attiny1634",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny1634__",       0x0100, 0x0, 0x4000, 0)
 /* Enhanced, <= 8K.  */
-AVR_MCU ("avr4",             ARCH_AVR4, AVR_ISA_NONE,  NULL,                       0x0060, 0x0, 0x2000)
-AVR_MCU ("ata6285",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6285__",          0x0100, 0x0, 0x2000)
-AVR_MCU ("ata6286",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6286__",          0x0100, 0x0, 0x2000)
-AVR_MCU ("ata6289",          ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6289__",           0x0100, 0x0, 0x2000)
-AVR_MCU ("ata6612c",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6612C__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega8",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8__",          0x0060, 0x0, 0x2000)
-AVR_MCU ("atmega8a",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8A__",         0x0060, 0x0, 0x2000)
-AVR_MCU ("atmega48",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48__",         0x0100, 0x0, 0x1000)
-AVR_MCU ("atmega48a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48A__",        0x0100, 0x0, 0x1000)
-AVR_MCU ("atmega48p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48P__",        0x0100, 0x0, 0x1000)
-AVR_MCU ("atmega48pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PA__",       0x0100, 0x0, 0x1000)
-AVR_MCU ("atmega48pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PB__",       0x0100, 0x0, 0x1000)
-AVR_MCU ("atmega88",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega88a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88A__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega88p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88P__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega88pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PA__",       0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega88pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PB__",       0x0100, 0x0, 0x2000)
-AVR_MCU ("atmega8515",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8515__",       0x0060, 0x0, 0x2000)
-AVR_MCU ("atmega8535",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8535__",       0x0060, 0x0, 0x2000)
-AVR_MCU ("atmega8hva",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8HVA__",       0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm1",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM1__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm2",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm2b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2B__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm3",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3__",         0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm3b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3B__",        0x0100, 0x0, 0x2000)
-AVR_MCU ("at90pwm81",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM81__",        0x0100, 0x0, 0x2000)
+AVR_MCU ("avr4",             ARCH_AVR4, AVR_ISA_NONE,  NULL,                       0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("ata6285",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6285__",          0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("ata6286",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6286__",          0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("ata6289",          ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6289__",           0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("ata6612c",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6612C__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega8",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8__",          0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("atmega8a",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8A__",         0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("atmega48",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48__",         0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("atmega48a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48A__",        0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("atmega48p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48P__",        0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("atmega48pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PA__",       0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("atmega48pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PB__",       0x0100, 0x0, 0x1000, 0)
+AVR_MCU ("atmega88",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega88a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88A__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega88p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88P__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega88pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PA__",       0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega88pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PB__",       0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("atmega8515",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8515__",       0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("atmega8535",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8535__",       0x0060, 0x0, 0x2000, 0)
+AVR_MCU ("atmega8hva",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8HVA__",       0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm1",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM1__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm2",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm2b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2B__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm3",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3__",         0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm3b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3B__",        0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("at90pwm81",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM81__",        0x0100, 0x0, 0x2000, 0)
 /* Enhanced, > 8K, <= 64K.  */
-AVR_MCU ("avr5",             ARCH_AVR5, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x4000)
-AVR_MCU ("ata5702m322",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5702M322__",       0x0200, 0x0, 0x10000)
-AVR_MCU ("ata5782",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5782__",           0x0200, 0x8000, 0xd000)
-AVR_MCU ("ata5790",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790__",           0x0100, 0x0, 0x4000)
-AVR_MCU ("ata5790n",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790N__",          0x0100, 0x0, 0x4000)
-AVR_MCU ("ata5791",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5791__",           0x0100, 0x0, 0x4000)
-AVR_MCU ("ata5795",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5795__",           0x0100, 0x0, 0x2000)
-AVR_MCU ("ata5831",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5831__",           0x0200, 0x8000, 0xd000)
-AVR_MCU ("ata6613c",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6613C__",          0x0100, 0x0, 0x4000)
-AVR_MCU ("ata6614q",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6614Q__",          0x0100, 0x0, 0x8000)
-AVR_MCU ("ata8210",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8210__",           0x0200, 0x8000, 0xd000)
-AVR_MCU ("ata8510",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8510__",           0x0200, 0x8000, 0xd000)
-AVR_MCU ("atmega16",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16__",          0x0060, 0x0, 0x4000)
-AVR_MCU ("atmega16a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16A__",         0x0060, 0x0, 0x4000)
-AVR_MCU ("atmega161",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega161__",         0x0060, 0x0, 0x4000)
-AVR_MCU ("atmega162",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega162__",         0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega163",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega163__",         0x0060, 0x0, 0x4000)
-AVR_MCU ("atmega164a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164A__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega164p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164P__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega164pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164PA__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega165",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165__",         0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega165a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165A__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega165p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165P__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega165pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165PA__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega168",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168__",         0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega168a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168A__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega168p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168P__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega168pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PA__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega168pb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PB__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega169",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169__",         0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega169a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169A__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega169p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169P__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega169pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169PA__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega16hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVB__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega16hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVBREVB__",   0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega16m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16M1__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega16u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16U4__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega32a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32A__",         0x0060, 0x0, 0x8000)
-AVR_MCU ("atmega32",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32__",          0x0060, 0x0, 0x8000)
-AVR_MCU ("atmega323",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega323__",         0x0060, 0x0, 0x8000)
-AVR_MCU ("atmega324a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324A__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega324p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324P__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega324pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324PA__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega325",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325__",         0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega325a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325A__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega325p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325P__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega325pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325PA__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3250",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3250a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250A__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3250p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250P__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3250pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250PA__",      0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega328",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328__",         0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega328p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328P__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega328pb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328PB__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega329",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329__",         0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega329a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329A__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega329p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329P__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega329pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329PA__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3290",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3290a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290A__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3290p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290P__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega3290pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290PA__",      0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega32c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32C1__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega32m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32M1__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega32u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U4__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega32u6",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U6__",        0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega406",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega406__",         0x0100, 0x0, 0xa000)
-AVR_MCU ("atmega64",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64__",          0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64A__",         0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega640",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega640__",         0x0200, 0x0, 0x10000)
-AVR_MCU ("atmega644",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644__",         0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega644a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644A__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega644p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644P__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega644pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644PA__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega645",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645__",         0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega645a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645A__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega645p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645P__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega6450",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega6450a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450A__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega6450p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450P__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega649",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649__",         0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega649a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649A__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega649p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649P__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega6490",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega16hva",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA__",       0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega16hva2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA2__",      0x0100, 0x0, 0x4000)
-AVR_MCU ("atmega32hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVB__",       0x0100, 0x0, 0x8000)
-AVR_MCU ("atmega6490a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490A__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega6490p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490P__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64C1__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64M1__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64hve",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE__",       0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64hve2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE2__",      0x0100, 0x0, 0x10000)
-AVR_MCU ("atmega64rfr2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFR2__",      0x0200, 0x0, 0x10000)
-AVR_MCU ("atmega644rfr2",    ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644RFR2__",     0x0200, 0x0, 0x10000)
-AVR_MCU ("atmega32hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVBREVB__",   0x0100, 0x0, 0x8000)
-AVR_MCU ("at90can32",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN32__",         0x0100, 0x0, 0x8000)
-AVR_MCU ("at90can64",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN64__",         0x0100, 0x0, 0x10000)
-AVR_MCU ("at90pwm161",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM161__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("at90pwm216",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM216__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("at90pwm316",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM316__",        0x0100, 0x0, 0x4000)
-AVR_MCU ("at90scr100",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90SCR100__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("at90usb646",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB646__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("at90usb647",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB647__",        0x0100, 0x0, 0x10000)
-AVR_MCU ("at94k",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT94K__",             0x0060, 0x0, 0x8000)
-AVR_MCU ("m3000",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_M3000__",             0x1000, 0x0, 0x10000)
+AVR_MCU ("avr5",             ARCH_AVR5, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x4000, 0)
+AVR_MCU ("ata5702m322",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5702M322__",       0x0200, 0x0, 0x10000, 0)
+AVR_MCU ("ata5782",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5782__",           0x0200, 0x8000, 0xd000, 0)
+AVR_MCU ("ata5790",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790__",           0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata5790n",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790N__",          0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata5791",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5791__",           0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata5795",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5795__",           0x0100, 0x0, 0x2000, 0)
+AVR_MCU ("ata5831",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5831__",           0x0200, 0x8000, 0xd000, 0)
+AVR_MCU ("ata6613c",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6613C__",          0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("ata6614q",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6614Q__",          0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("ata8210",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8210__",           0x0200, 0x8000, 0xd000, 0)
+AVR_MCU ("ata8510",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8510__",           0x0200, 0x8000, 0xd000, 0)
+AVR_MCU ("atmega16",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16__",          0x0060, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16A__",         0x0060, 0x0, 0x4000, 0)
+AVR_MCU ("atmega161",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega161__",         0x0060, 0x0, 0x4000, 0)
+AVR_MCU ("atmega162",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega162__",         0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega163",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega163__",         0x0060, 0x0, 0x4000, 0)
+AVR_MCU ("atmega164a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164A__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega164p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164P__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega164pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164PA__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega165",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165__",         0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega165a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165A__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega165p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165P__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega165pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165PA__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega168",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168__",         0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega168a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168A__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega168p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168P__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega168pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PA__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega168pb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PB__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega169",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169__",         0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega169a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169A__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega169p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169P__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega169pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169PA__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVB__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVBREVB__",   0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16M1__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16U4__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega32a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32A__",         0x0060, 0x0, 0x8000, 0)
+AVR_MCU ("atmega32",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32__",          0x0060, 0x0, 0x8000, 0)
+AVR_MCU ("atmega323",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega323__",         0x0060, 0x0, 0x8000, 0)
+AVR_MCU ("atmega324a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324A__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega324p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324P__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega324pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324PA__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega325",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325__",         0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega325a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325A__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega325p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325P__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega325pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325PA__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3250",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3250a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250A__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3250p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250P__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3250pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250PA__",      0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega328",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328__",         0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega328p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328P__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega328pb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328PB__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega329",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329__",         0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega329a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329A__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega329p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329P__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega329pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329PA__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3290",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3290a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290A__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3290p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290P__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega3290pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290PA__",      0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega32c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32C1__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega32m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32M1__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega32u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U4__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega32u6",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U6__",        0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega406",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega406__",         0x0100, 0x0, 0xa000, 0)
+AVR_MCU ("atmega64",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64__",          0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64A__",         0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega640",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega640__",         0x0200, 0x0, 0x10000, 0)
+AVR_MCU ("atmega644",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644__",         0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega644a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644A__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega644p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644P__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega644pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644PA__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega645",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645__",         0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega645a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645A__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega645p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645P__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega6450",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega6450a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450A__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega6450p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450P__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega649",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649__",         0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega649a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649A__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega649p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649P__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega6490",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega16hva",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA__",       0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega16hva2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA2__",      0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("atmega32hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVB__",       0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("atmega6490a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490A__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega6490p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490P__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64C1__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64M1__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64hve",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE__",       0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64hve2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE2__",      0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("atmega64rfr2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFR2__",      0x0200, 0x0, 0x10000, 0)
+AVR_MCU ("atmega644rfr2",    ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644RFR2__",     0x0200, 0x0, 0x10000, 0)
+AVR_MCU ("atmega32hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVBREVB__",   0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("at90can32",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN32__",         0x0100, 0x0, 0x8000, 0)
+AVR_MCU ("at90can64",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN64__",         0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("at90pwm161",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM161__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("at90pwm216",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM216__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("at90pwm316",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM316__",        0x0100, 0x0, 0x4000, 0)
+AVR_MCU ("at90scr100",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90SCR100__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("at90usb646",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB646__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("at90usb647",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB647__",        0x0100, 0x0, 0x10000, 0)
+AVR_MCU ("at94k",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT94K__",             0x0060, 0x0, 0x8000, 0)
+AVR_MCU ("m3000",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_M3000__",             0x1000, 0x0, 0x10000, 0)
 /* Enhanced, == 128K.  */
-AVR_MCU ("avr51",            ARCH_AVR51, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 0x20000)
-AVR_MCU ("atmega128",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128__",        0x0100, 0x0, 0x20000)
-AVR_MCU ("atmega128a",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128A__",       0x0100, 0x0, 0x20000)
-AVR_MCU ("atmega1280",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1280__",       0x0200, 0x0, 0x20000)
-AVR_MCU ("atmega1281",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1281__",       0x0200, 0x0, 0x20000)
-AVR_MCU ("atmega1284",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284__",       0x0100, 0x0, 0x20000)
-AVR_MCU ("atmega1284p",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284P__",      0x0100, 0x0, 0x20000)
-AVR_MCU ("atmega128rfa1",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFA1__",    0x0200, 0x0, 0x20000)
-AVR_MCU ("atmega128rfr2",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFR2__",    0x0200, 0x0, 0x20000)
-AVR_MCU ("atmega1284rfr2",   ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284RFR2__",   0x0200, 0x0, 0x20000)
-AVR_MCU ("at90can128",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90CAN128__",       0x0100, 0x0, 0x20000)
-AVR_MCU ("at90usb1286",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1286__",      0x0100, 0x0, 0x20000)
-AVR_MCU ("at90usb1287",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1287__",      0x0100, 0x0, 0x20000)
+AVR_MCU ("avr51",            ARCH_AVR51, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("atmega128",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128__",        0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("atmega128a",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128A__",       0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("atmega1280",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1280__",       0x0200, 0x0, 0x20000, 0)
+AVR_MCU ("atmega1281",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1281__",       0x0200, 0x0, 0x20000, 0)
+AVR_MCU ("atmega1284",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284__",       0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("atmega1284p",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284P__",      0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("atmega128rfa1",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFA1__",    0x0200, 0x0, 0x20000, 0)
+AVR_MCU ("atmega128rfr2",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFR2__",    0x0200, 0x0, 0x20000, 0)
+AVR_MCU ("atmega1284rfr2",   ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284RFR2__",   0x0200, 0x0, 0x20000, 0)
+AVR_MCU ("at90can128",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90CAN128__",       0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("at90usb1286",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1286__",      0x0100, 0x0, 0x20000, 0)
+AVR_MCU ("at90usb1287",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1287__",      0x0100, 0x0, 0x20000, 0)
 /* 3-Byte PC.  */
-AVR_MCU ("avr6",             ARCH_AVR6, AVR_ISA_NONE, NULL,                        0x0200, 0x0, 0x40000)
-AVR_MCU ("atmega2560",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2560__",        0x0200, 0x0, 0x40000)
-AVR_MCU ("atmega2561",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2561__",        0x0200, 0x0, 0x40000)
-AVR_MCU ("atmega256rfr2",    ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega256RFR2__",     0x0200, 0x0, 0x40000)
-AVR_MCU ("atmega2564rfr2",   ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2564RFR2__",    0x0200, 0x0, 0x40000)
+AVR_MCU ("avr6",             ARCH_AVR6, AVR_ISA_NONE, NULL,                        0x0200, 0x0, 0x40000, 0)
+AVR_MCU ("atmega2560",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2560__",        0x0200, 0x0, 0x40000, 0)
+AVR_MCU ("atmega2561",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2561__",        0x0200, 0x0, 0x40000, 0)
+AVR_MCU ("atmega256rfr2",    ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega256RFR2__",     0x0200, 0x0, 0x40000, 0)
+AVR_MCU ("atmega2564rfr2",   ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2564RFR2__",    0x0200, 0x0, 0x40000, 0)
 /* Xmega, 16K <= Flash < 64K, RAM <= 64K */
-AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega8e5",       ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega8E5__",   0x2000, 0x0, 0x2800)
-AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16A4__",  0x2000, 0x0, 0x5000)
-AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16D4__",  0x2000, 0x0, 0x5000)
-AVR_MCU ("atxmega16e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16E5__",  0x2000, 0x0, 0x5000)
-AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32A4__",  0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega32c3",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C3__",  0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega32d3",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D3__",  0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D4__",  0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16A4U__", 0x2000, 0x0, 0x5000)
-AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16C4__",  0x2000, 0x0, 0x5000)
-AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32A4U__", 0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C4__",  0x2000, 0x0, 0x9000)
-AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32E5__",  0x2000, 0x0, 0x9000)
+AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega8e5",       ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega8E5__",   0x2000, 0x0, 0x2800, 0)
+AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16A4__",  0x2000, 0x0, 0x5000, 0)
+AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16D4__",  0x2000, 0x0, 0x5000, 0)
+AVR_MCU ("atxmega16e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16E5__",  0x2000, 0x0, 0x5000, 0)
+AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32A4__",  0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega32c3",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C3__",  0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega32d3",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D3__",  0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D4__",  0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16A4U__", 0x2000, 0x0, 0x5000, 0)
+AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16C4__",  0x2000, 0x0, 0x5000, 0)
+AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32A4U__", 0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C4__",  0x2000, 0x0, 0x9000, 0)
+AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32E5__",  0x2000, 0x0, 0x9000, 0)
 /* Xmega, Flash + RAM < 64K, flash visible in RAM address space */
-AVR_MCU ("avrxmega3",        ARCH_AVRXMEGA3, AVR_ISA_NONE,  NULL,                  0x3f00, 0x0, 0x8000)
-AVR_MCU ("attiny212",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny212__",   0x3f80, 0x0, 0x800)
-AVR_MCU ("attiny214",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny214__",   0x3f80, 0x0, 0x800)
-AVR_MCU ("attiny412",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny412__",   0x3f00, 0x0, 0x1000)
-AVR_MCU ("attiny414",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny414__",   0x3f00, 0x0, 0x1000)
-AVR_MCU ("attiny416",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny416__",   0x3f00, 0x0, 0x1000)
-AVR_MCU ("attiny417",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny417__",   0x3f00, 0x0, 0x1000)
-AVR_MCU ("attiny814",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny814__",   0x3e00, 0x0, 0x2000)
-AVR_MCU ("attiny816",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny816__",   0x3e00, 0x0, 0x2000)
-AVR_MCU ("attiny817",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny817__",   0x3e00, 0x0, 0x2000)
-AVR_MCU ("attiny1614",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1614__",  0x3800, 0x0, 0x4000)
-AVR_MCU ("attiny1616",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1616__",  0x3800, 0x0, 0x4000)
-AVR_MCU ("attiny1617",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1617__",  0x3800, 0x0, 0x4000)
-AVR_MCU ("attiny3214",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3214__",  0x3800, 0x0, 0x8000)
-AVR_MCU ("attiny3216",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3216__",  0x3800, 0x0, 0x8000)
-AVR_MCU ("attiny3217",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3217__",  0x3800, 0x0, 0x8000)
+AVR_MCU ("avrxmega3",        ARCH_AVRXMEGA3, AVR_ISA_NONE,  NULL,                  0x3f00, 0x0, 0x8000, 0)
+AVR_MCU ("attiny202",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny202__",   0x3f80, 0x0, 0x800,  0x8000)
+AVR_MCU ("attiny204",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny204__",   0x3f80, 0x0, 0x800,  0x8000)
+AVR_MCU ("attiny402",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny402__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny404",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny404__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny406",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny406__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny804",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny804__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny806",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny806__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny807",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny807__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny1604",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1604__",  0x3c00, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny1606",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1606__",  0x3c00, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny1607",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1607__",  0x3c00, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny212",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny212__",   0x3f80, 0x0, 0x800,  0x8000)
+AVR_MCU ("attiny214",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny214__",   0x3f80, 0x0, 0x800,  0x8000)
+AVR_MCU ("attiny412",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny412__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny414",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny414__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny416",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny416__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny417",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny417__",   0x3f00, 0x0, 0x1000, 0x8000)
+AVR_MCU ("attiny814",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny814__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny816",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny816__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny817",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATtiny817__",   0x3e00, 0x0, 0x2000, 0x8000)
+AVR_MCU ("attiny1614",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1614__",  0x3800, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny1616",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1616__",  0x3800, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny1617",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny1617__",  0x3800, 0x0, 0x4000, 0x8000)
+AVR_MCU ("attiny3214",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3214__",  0x3800, 0x0, 0x8000, 0x8000)
+AVR_MCU ("attiny3216",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3216__",  0x3800, 0x0, 0x8000, 0x8000)
+AVR_MCU ("attiny3217",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATtiny3217__",  0x3800, 0x0, 0x8000, 0x8000)
+AVR_MCU ("atmega808",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATmega808__",   0x3c00, 0x0, 0x2000, 0x4000)
+AVR_MCU ("atmega809",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, "__AVR_ATmega809__",   0x3c00, 0x0, 0x2000, 0x4000)
+AVR_MCU ("atmega1608",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega1608__",  0x3800, 0x0, 0x4000, 0x4000)
+AVR_MCU ("atmega1609",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega1609__",  0x3800, 0x0, 0x4000, 0x4000)
+AVR_MCU ("atmega3208",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega3208__",  0x3800, 0x0, 0x8000, 0x4000)
+AVR_MCU ("atmega3209",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega3209__",  0x3800, 0x0, 0x8000, 0x4000)
+AVR_MCU ("atmega4808",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega4808__",  0x2800, 0x0, 0xc000, 0x4000)
+AVR_MCU ("atmega4809",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  "__AVR_ATmega4809__",  0x2800, 0x0, 0xc000, 0x4000)
 /* Xmega, 64K < Flash <= 128K, RAM <= 64K */
-AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64A3__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D3__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A3U__", 0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A4U__", 0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B1__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B3__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64C3__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D4__",  0x2000, 0x0, 0x11000)
+AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64A3__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D3__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A3U__", 0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A4U__", 0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B1__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B3__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64C3__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D4__",  0x2000, 0x0, 0x11000, 0)
 /* Xmega, 64K < Flash <= 128K, RAM > 64K */
-AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, AVR_ISA_NONE, "__AVR_ATxmega64A1__",  0x2000, 0x0, 0x11000)
-AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, AVR_ISA_RMW,  "__AVR_ATxmega64A1U__", 0x2000, 0x0, 0x11000)
+AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, AVR_ISA_NONE, "__AVR_ATxmega64A1__",  0x2000, 0x0, 0x11000, 0)
+AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, AVR_ISA_RMW,  "__AVR_ATxmega64A1U__", 0x2000, 0x0, 0x11000, 0)
 /* Xmega, 128K < Flash, RAM <= 64K */
-AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 0x60000)
-AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128A3__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D3__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192A3__",     0x2000, 0x0, 0x32000)
-AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192D3__",     0x2000, 0x0, 0x32000)
-AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3__",     0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3B__",    0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3BU__",   0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256D3__",     0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128A3U__",    0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B1__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B3__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128C3__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D4__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192A3U__",    0x2000, 0x0, 0x32000)
-AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192C3__",     0x2000, 0x0, 0x32000)
-AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3U__",    0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256C3__",     0x2000, 0x0, 0x42000)
-AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega384C3__",     0x2000, 0x0, 0x62000)
-AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega384D3__",     0x2000, 0x0, 0x62000)
+AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 0x60000, 0)
+AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128A3__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D3__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192A3__",     0x2000, 0x0, 0x32000, 0)
+AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192D3__",     0x2000, 0x0, 0x32000, 0)
+AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3__",     0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3B__",    0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3BU__",   0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256D3__",     0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128A3U__",    0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B1__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B3__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128C3__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D4__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192A3U__",    0x2000, 0x0, 0x32000, 0)
+AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192C3__",     0x2000, 0x0, 0x32000, 0)
+AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3U__",    0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256C3__",     0x2000, 0x0, 0x42000, 0)
+AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega384C3__",     0x2000, 0x0, 0x62000, 0)
+AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega384D3__",     0x2000, 0x0, 0x62000, 0)
 /* Xmega, 128K < Flash, RAM > 64K RAM.  */
-AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, AVR_ISA_NONE, "__AVR_ATxmega128A1__",     0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A1U__",    0x2000, 0x0, 0x22000)
-AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A4U__",    0x2000, 0x0, 0x22000)
+AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, AVR_ISA_NONE, "__AVR_ATxmega128A1__",     0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A1U__",    0x2000, 0x0, 0x22000, 0)
+AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A4U__",    0x2000, 0x0, 0x22000, 0)
 /* Tiny family */
-AVR_MCU ("avrtiny",          ARCH_AVRTINY, AVR_ISA_NONE, NULL,                     0x0040, 0x0, 0x400)
-AVR_MCU ("attiny4",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny4__",        0x0040, 0x0, 0x200)
-AVR_MCU ("attiny5",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny5__",        0x0040, 0x0, 0x200)
-AVR_MCU ("attiny9",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny9__",        0x0040, 0x0, 0x400)
-AVR_MCU ("attiny10",         ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny10__",       0x0040, 0x0, 0x400)
-AVR_MCU ("attiny20",         ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny20__",       0x0040, 0x0, 0x800)
-AVR_MCU ("attiny40",         ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny40__",       0x0040, 0x0, 0x1000)
+AVR_MCU ("avrtiny",          ARCH_AVRTINY, AVR_ISA_NONE, NULL,                     0x0040, 0x0, 0x400, 0)
+AVR_MCU ("attiny4",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny4__",        0x0040, 0x0, 0x200, 0)
+AVR_MCU ("attiny5",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny5__",        0x0040, 0x0, 0x200, 0)
+AVR_MCU ("attiny9",          ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny9__",        0x0040, 0x0, 0x400, 0)
+AVR_MCU ("attiny10",         ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny10__",       0x0040, 0x0, 0x400, 0)
+AVR_MCU ("attiny20",         ARCH_AVRTINY, AVR_ISA_LDS,  "__AVR_ATtiny20__",       0x0040, 0x0, 0x800, 0)
+AVR_MCU ("attiny40",         ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny40__",       0x0040, 0x0, 0x1000, 0)
 /* Assembler only.  */
-AVR_MCU ("avr1",             ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x400)
-AVR_MCU ("at90s1200",        ARCH_AVR1, AVR_ISA_NONE, "__AVR_AT90S1200__",         0x0060, 0x0, 0x400)
-AVR_MCU ("attiny11",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny11__",          0x0060, 0x0, 0x400)
-AVR_MCU ("attiny12",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny12__",          0x0060, 0x0, 0x400)
-AVR_MCU ("attiny15",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny15__",          0x0060, 0x0, 0x400)
-AVR_MCU ("attiny28",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny28__",          0x0060, 0x0, 0x800)
+AVR_MCU ("avr1",             ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 0x400, 0)
+AVR_MCU ("at90s1200",        ARCH_AVR1, AVR_ISA_NONE, "__AVR_AT90S1200__",         0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny11",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny11__",          0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny12",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny12__",          0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny15",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny15__",          0x0060, 0x0, 0x400, 0)
+AVR_MCU ("attiny28",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny28__",          0x0060, 0x0, 0x800, 0)
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index a9f72b314c2..cb4b14ae379 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -3797,13 +3797,14 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)
           gcc_unreachable();
 
         case 1:
-          return avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          break;
 
         case 2:
           if (REGNO (dest) == REG_Z)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %B0,%a2" CR_TAB
-                                "mov %A0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %B0,%a2" CR_TAB
+                         "mov %A0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %A0,%a2+" CR_TAB
@@ -3832,9 +3833,9 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)
                        "%4lpm %B0,%a2+", xop, plen, 2);
 
           if (REGNO (dest) == REG_Z - 2)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %C0,%a2" CR_TAB
-                                "mov %D0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %C0,%a2" CR_TAB
+                         "mov %D0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %C0,%a2+" CR_TAB
diff --git a/gcc/config/avr/avr.opt b/gcc/config/avr/avr.opt
index 3fc83a2fdb1..702400d4597 100644
--- a/gcc/config/avr/avr.opt
+++ b/gcc/config/avr/avr.opt
@@ -118,3 +118,7 @@ Assume that all data in static storage can be accessed by LDS / STS.  This optio
 nodevicelib
 Driver Target Report RejectNegative
 Do not link against the device-specific library lib<MCU>.a.
+
+nodevicespecs
+Driver Target Report RejectNegative
+Do not use the device-specific specs file device-specs/specs-<MCU>.
diff --git a/gcc/config/avr/driver-avr.c b/gcc/config/avr/driver-avr.c
index 7b9e712be6b..d804ed2cd58 100644
--- a/gcc/config/avr/driver-avr.c
+++ b/gcc/config/avr/driver-avr.c
@@ -26,8 +26,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "diagnostic.h"
 #include "tm.h"
 
-// Remove -nodevicelib from the command line if not needed
-#define X_NODEVLIB "%<nodevicelib"
+// Remove -nodevicelib and -nodevicespecs from the command line if not needed.
+#define X_NODEVLIB "%<nodevicelib %<nodevicespecs"
 
 static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };
 
@@ -102,8 +102,8 @@ avr_devicespecs_file (int argc, const char **argv)
         return X_NODEVLIB;
       }
 
-  return concat ("-specs=device-specs", dir_separator_str, "specs-",
-                 mmcu, "%s"
+  return concat ("%{!nodevicespecs:-specs=device-specs", dir_separator_str,
+		 "specs-", mmcu, "%s} %<nodevicespecs"
 #if defined (WITH_AVRLIBC)
                  " %{mmcu=avr*:" X_NODEVLIB "} %{!mmcu=*:" X_NODEVLIB "}",
 #else
diff --git a/gcc/config/avr/gen-avr-mmcu-specs.c b/gcc/config/avr/gen-avr-mmcu-specs.c
index de861f40583..363d7034626 100644
--- a/gcc/config/avr/gen-avr-mmcu-specs.c
+++ b/gcc/config/avr/gen-avr-mmcu-specs.c
@@ -50,14 +50,6 @@
 #define SPECFILE_USAGE_URL                              \
   "https://gcc.gnu.org/gcc-5/changes.html"
 
-/* Return true iff STR starts with PREFIX.  */
-
-static bool
-str_prefix_p (const char *str, const char *prefix)
-{
-  return strncmp (str, prefix, strlen (prefix)) == 0;
-}
-
 
 static const char header[] =
   "#\n"
@@ -105,7 +97,7 @@ static const char help_dev_lib_name[] =
   "#     #include <avr/io.h>\n"
   "#\n"
   "# will include the desired device header.  For ATmega8A the supplement\n"
-  "# to *cpp would read\n"
+  "# to *cpp_avrlibc would read\n"
   "#\n"
   "#     -D__AVR_DEV_LIB_NAME__=m8a\n"
   "\n";
@@ -140,6 +132,14 @@ print_mcu (const avr_mcu_t *mcu)
   bool rcall = (mcu->dev_attribute & AVR_ISA_RCALL);
   bool is_arch = mcu->macro == NULL;
   bool is_device = ! is_arch;
+  int flash_pm_offset = 0;
+
+  if (arch->flash_pm_offset
+      && mcu->flash_pm_offset
+      && mcu->flash_pm_offset != arch->flash_pm_offset)
+    {
+      flash_pm_offset = mcu->flash_pm_offset;
+    }
 
   if (is_arch
       && (ARCH_AVR2 == arch_id
@@ -253,7 +253,11 @@ print_mcu (const avr_mcu_t *mcu)
 
   fprintf (f, "*link_relax:\n\t%s\n\n", LINK_RELAX_SPEC);
 
-  fprintf (f, "*link_arch:\n\t%s\n\n", LINK_ARCH_SPEC);
+  fprintf (f, "*link_arch:\n\t%s", LINK_ARCH_SPEC);
+  if (is_device
+      && flash_pm_offset)
+    fprintf (f, " --defsym=__RODATA_PM_OFFSET__=0x%x", flash_pm_offset);
+  fprintf (f, "\n\n");
 
   if (is_device)
     {
@@ -281,10 +285,26 @@ print_mcu (const avr_mcu_t *mcu)
 
 #if defined (WITH_AVRLIBC)
       fprintf (f, "%s\n", help_dev_lib_name);
+
+      fprintf (f, "*cpp_avrlibc:\n");
+      fprintf (f, "\t-D__AVR_DEVICE_NAME__=%s", mcu->name);
+      fprintf (f, "\n\n");
 #endif // WITH_AVRLIBC
 
+      fprintf (f, "*cpp_mcu:\n");
+      fprintf (f, "\t-D%s", mcu->macro);
+      if (flash_pm_offset)
+	{
+	  fprintf (f, " -U__AVR_PM_BASE_ADDRESS__");
+	  fprintf (f, " -D__AVR_PM_BASE_ADDRESS__=0x%x", flash_pm_offset);
+	}
+      fprintf (f, "\n\n");
+
       fprintf (f, "*cpp:\n");
-      fprintf (f, "\t-D%s -D__AVR_DEVICE_NAME__=%s", mcu->macro, mcu->name);
+      fprintf (f, "\t%%(cpp_mcu)");
+#if defined (WITH_AVRLIBC)
+      fprintf (f, " %%(cpp_avrlibc)");
+#endif // WITH_AVRLIBC
       fprintf (f, "\n\n");
     }
 
diff --git a/gcc/config/avr/gen-avr-mmcu-texi.c b/gcc/config/avr/gen-avr-mmcu-texi.c
index 8187d21b28d..47074030fae 100644
--- a/gcc/config/avr/gen-avr-mmcu-texi.c
+++ b/gcc/config/avr/gen-avr-mmcu-texi.c
@@ -25,8 +25,8 @@
 
 #include "avr-devices.c"
 
-static const char*
-mcu_name[sizeof avr_mcu_types / sizeof avr_mcu_types[0]];
+static const avr_mcu_t*
+mcus[sizeof avr_mcu_types / sizeof avr_mcu_types[0]];
 
 static int letter (char c)
 {
@@ -38,25 +38,84 @@ static int digit (char c)
   return c >= '0' && c <= '9';
 }
 
+static int
+str_prefix_p (const char *str, const char *prefix)
+{
+  return strncmp (str, prefix, strlen (prefix)) == 0;
+}
+
+
+/* Used by string comparator to group MCUs by their
+   name prefix like "attiny" or "atmega".  */
+
+static int
+c_prefix (const char *str)
+{
+  static const char *const prefixes[] =
+    {
+      "attiny", "atmega", "atxmega", "ata", "at90"
+    };
+
+  int i, n = (int) (sizeof (prefixes) / sizeof (*prefixes));
+
+  for (i = 0; i < n; i++)
+    if (str_prefix_p (str, prefixes[i]))
+      return i;
+
+  return n;
+}
+
+
+/* If A starts a group of digits, return their value as a number.  */
+
+static int
+c_number (const char *a)
+{
+  int val = 0;
+
+  if (digit (*a) && ! digit (*(a-1)))
+    {
+      while (digit (*a))
+	val = 10 * val + (*a++) - '0';
+    }
+
+  return val;
+}
+
+
+/* Compare two MCUs and order them for easy lookup.  */
+
 static int
 comparator (const void *va, const void *vb)
 {
-  const char *a = *(const char* const*) va;
-  const char *b = *(const char* const*) vb;
+  const avr_mcu_t *mcu_a = *(const avr_mcu_t* const*) va;
+  const avr_mcu_t *mcu_b = *(const avr_mcu_t* const*) vb;
+  const char *a = mcu_a->name;
+  const char *b = mcu_b->name;
+
+  // First, group MCUs according to their pure-letter prefix.
+
+  int c = c_prefix (a) - c_prefix (b);
+  if (c)
+    return c;
+
+  // Second, if their prefixes are the same, group according to
+  // their flash size.
+
+  c = (int) mcu_a->flash_size - (int) mcu_b->flash_size;
+  if (c)
+    return c;
+
+  // Third, group according to aligned groups of digits.
 
   while (*a && *b)
     {
-      /* Make letters smaller than digits so that `atmega16a' follows
-         `atmega16' without `atmega161' etc. between them.  */
-      
-      if (letter (*a) && digit (*b))
-        return -1;
-
-      if (digit (*a) && letter (*b))
-        return 1;
+      c = c_number (a) - c_number (b);
+      if (c)
+	return c;
 
       if (*a != *b)
-        return *a - *b;
+	return *a - *b;
       
       a++;
       b++;
@@ -74,21 +133,21 @@ print_mcus (size_t n_mcus)
   if (!n_mcus)
     return;
     
-  qsort (mcu_name, n_mcus, sizeof (char*), comparator);
+  qsort (mcus, n_mcus, sizeof (avr_mcu_t*), comparator);
 
   printf ("@*@var{mcu}@tie{}=");
 
   for (i = 0; i < n_mcus; i++)
     {
-      printf (" @code{%s}%s", mcu_name[i], i == n_mcus-1 ? ".\n\n" : ",");
+      printf (" @code{%s}%s", mcus[i]->name, i == n_mcus-1 ? ".\n\n" : ",");
 
-      if (i && !strcmp (mcu_name[i], mcu_name[i-1]))
-        {
-          /* Sanity-check: Fail on devices that are present more than once.  */
+      if (i && !strcmp (mcus[i]->name, mcus[i-1]->name))
+	{
+	  // Sanity-check: Fail on devices that are present more than once.
 
-          duplicate = 1;
-          fprintf (stderr, "error: duplicate device: %s\n", mcu_name[i]);
-        }
+	  duplicate = 1;
+	  fprintf (stderr, "error: duplicate device: %s\n", mcus[i]->name);
+	}
     }
 
   if (duplicate)
@@ -104,13 +163,13 @@ int main (void)
   printf ("@c Copyright (C) 2012-2019 Free Software Foundation, Inc.\n");
   printf ("@c This is part of the GCC manual.\n");
   printf ("@c For copying conditions, see the file "
-          "gcc/doc/include/fdl.texi.\n\n");
+	  "gcc/doc/include/fdl.texi.\n\n");
 
   printf ("@c This file is generated automatically using\n");
   printf ("@c gcc/config/avr/gen-avr-mmcu-texi.c from:\n");
-  printf ("@c    gcc/config/avr/avr-arch.h\n");
-  printf ("@c    gcc/config/avr/avr-devices.c\n");
-  printf ("@c    gcc/config/avr/avr-mcus.def\n\n");
+  printf ("@c	 gcc/config/avr/avr-arch.h\n");
+  printf ("@c	 gcc/config/avr/avr-devices.c\n");
+  printf ("@c	 gcc/config/avr/avr-mcus.def\n\n");
 
   printf ("@c Please do not edit manually.\n\n");
 
@@ -119,22 +178,21 @@ int main (void)
   for (mcu = avr_mcu_types; mcu->name; mcu++)
     {
       if (mcu->macro == NULL)
-        {
-          arch_id = mcu->arch_id;
-
-          /* Start a new architecture:  Flush the MCUs collected so far.  */
+	{
+	  arch_id = mcu->arch_id;
 
-          print_mcus (n_mcus);
-          n_mcus = 0;
+	  // Start a new architecture:	Flush the MCUs collected so far.
+	  print_mcus (n_mcus);
+	  n_mcus = 0;
 
-          for (i = 0; i < sizeof (avr_texinfo) / sizeof (*avr_texinfo); i++)
-            if (arch_id == avr_texinfo[i].arch_id)
-              printf ("@item %s\n%s\n", mcu->name, avr_texinfo[i].texinfo);
-        }
+	  for (i = 0; i < sizeof (avr_texinfo) / sizeof (*avr_texinfo); i++)
+	    if (arch_id == avr_texinfo[i].arch_id)
+	      printf ("@item %s\n%s\n", mcu->name, avr_texinfo[i].texinfo);
+	}
       else if (arch_id == (enum avr_arch_id) mcu->arch_id)
-        {
-          mcu_name[n_mcus++] = mcu->name;
-        }
+	{
+	  mcus[n_mcus++] = mcu;
+	}
     }
 
   print_mcus (n_mcus);
diff --git a/gcc/config/darwin-driver.c b/gcc/config/darwin-driver.c
index 3d85f29cb3d..b3577c416bc 100644
--- a/gcc/config/darwin-driver.c
+++ b/gcc/config/darwin-driver.c
@@ -210,6 +210,28 @@ darwin_default_min_version (void)
   return new_flag;
 }
 
+/* See if we can find the sysroot from the SDKROOT environment variable.  */
+
+static const char *
+maybe_get_sysroot_from_sdkroot ()
+{
+  const char *maybe_sysroot = getenv ("SDKROOT");
+
+  /* We'll use the same rules as the clang driver, for compatibility.
+     1) The path must be absolute
+     2) Ignore "/", that is the default anyway and we do not want the
+	sysroot semantics to be applied to it.
+     3) It must exist (actually, we'll check it's readable too).  */
+
+   if (maybe_sysroot  == NULL
+       || *maybe_sysroot != '/'
+       || strlen (maybe_sysroot) == 1
+       || access (maybe_sysroot, R_OK) == -1)
+    return NULL;
+
+  return xstrndup (maybe_sysroot, strlen (maybe_sysroot));
+}
+
 /* Translate -filelist and -framework options in *DECODED_OPTIONS
    (size *DECODED_OPTIONS_COUNT) to use -Xlinker so that they are
    considered to be linker inputs in the case that no other inputs are
@@ -234,6 +256,7 @@ darwin_driver_init (unsigned int *decoded_options_count,
   bool appendM64 = false;
   const char *vers_string = NULL;
   bool seen_version_min = false;
+  bool seen_sysroot_p = false;
 
   for (i = 1; i < *decoded_options_count; i++)
     {
@@ -314,6 +337,11 @@ darwin_driver_init (unsigned int *decoded_options_count,
 	  --*decoded_options_count;
 	  break;
 
+	case OPT__sysroot_:
+	case OPT_isysroot:
+	  seen_sysroot_p = true;
+	  break;
+
 	default:
 	  break;
 	}
@@ -375,6 +403,22 @@ darwin_driver_init (unsigned int *decoded_options_count,
 		       &(*decoded_options)[*decoded_options_count - 1]);
     }
 
+  if (! seen_sysroot_p)
+    {
+      /* We will pick up an SDKROOT if we didn't specify a sysroot and treat
+	 it as overriding any configure-time --with-sysroot.  */
+       const char *sdkroot = maybe_get_sysroot_from_sdkroot ();
+       if (sdkroot)
+	{
+	  ++*decoded_options_count;
+	  *decoded_options = XRESIZEVEC (struct cl_decoded_option,
+					 *decoded_options,
+					 *decoded_options_count);
+	  generate_option (OPT__sysroot_, sdkroot, 1, CL_DRIVER,
+			   &(*decoded_options)[*decoded_options_count - 1]);
+	}
+    }
+
   /* We will need to know the OS X version we're trying to build for here
      so that we can figure out the mechanism and source for the sysroot to
      be used.  */
diff --git a/gcc/config/darwin-protos.h b/gcc/config/darwin-protos.h
index e5614b627d7..afeca81f807 100644
--- a/gcc/config/darwin-protos.h
+++ b/gcc/config/darwin-protos.h
@@ -53,8 +53,6 @@ extern void darwin_set_default_type_attributes (tree);
 
 #endif /* TREE_CODE */
 
-extern void machopic_finish (FILE *);
-
 extern int machopic_reloc_rw_mask (void);
 extern section *machopic_select_section (tree, int, unsigned HOST_WIDE_INT);
 
diff --git a/gcc/config/darwin.c b/gcc/config/darwin.c
index b9862353843..a7610829f75 100644
--- a/gcc/config/darwin.c
+++ b/gcc/config/darwin.c
@@ -75,15 +75,9 @@ along with GCC; see the file COPYING3.  If not see
    setting the second word in the .non_lazy_symbol_pointer data
    structure to symbol.  See indirect_data for the code that handles
    the extra indirection, and machopic_output_indirection and its use
-   of MACHO_SYMBOL_STATIC for the code that handles @code{static}
+   of MACHO_SYMBOL_FLAG_STATIC for the code that handles @code{static}
    symbol indirection.  */
 
-/* For darwin >= 9  (OSX 10.5) the linker is capable of making the necessary
-   branch islands and we no longer need to emit darwin stubs.
-   However, if we are generating code for earlier systems (or for use in the 
-   kernel) the stubs might still be required, and this will be set true.  */
-int darwin_emit_branch_islands = false;
-
 typedef struct GTY(()) cdtor_record {
   rtx symbol;
   int priority;		/* [con/de]structor priority */
@@ -105,6 +99,10 @@ int generating_for_darwin_version ;
    for weak or single-definition items.  */
 static bool ld_uses_coal_sects = false;
 
+/* Very old (ld_classic) linkers need a symbol to mark the start of
+   each FDE.  */
+static bool ld_needs_eh_markers = false;
+
 /* Section names.  */
 section * darwin_sections[NUM_DARWIN_SECTIONS];
 
@@ -250,7 +248,7 @@ name_needs_quotes (const char *name)
 int
 machopic_symbol_defined_p (rtx sym_ref)
 {
-  if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_DEFINED)
+  if (MACHO_SYMBOL_DEFINED_P (sym_ref))
     return true;
 
   /* If a symbol references local and is not an extern to this
@@ -259,7 +257,7 @@ machopic_symbol_defined_p (rtx sym_ref)
     {
       /* If the symbol references a variable and the variable is a
 	 common symbol, then this symbol is not defined.  */
-      if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_VARIABLE)
+      if (MACHO_SYMBOL_VARIABLE_P (sym_ref))
 	{
 	  tree decl = SYMBOL_REF_DECL (sym_ref);
 	  if (!decl)
@@ -455,6 +453,13 @@ typedef struct GTY ((for_user)) machopic_indirection
   bool stub_p;
   /* True iff this stub or pointer has been referenced.  */
   bool used;
+  /* True iff a non-lazy symbol pointer should be emitted into the .data
+     section, rather than the non-lazy symbol pointers section.  The cases
+     for which this occurred seem to have been unintentional, and later
+     toolchains emit all of the indirections to the 'usual' section.  We
+     are keeping this in case it is necessary to preserve compatibility with
+     older toolchains.  */
+  bool nlsp_in_data_section;
 } machopic_indirection;
 
 struct indirection_hasher : ggc_ptr_hash<machopic_indirection>
@@ -489,7 +494,7 @@ indirection_hasher::equal (machopic_indirection *s, const char *k)
 /* Return the name of the non-lazy pointer (if STUB_P is false) or
    stub (if STUB_B is true) corresponding to the given name.
 
-  If we have a situation like:
+  PR71767 - If we have a situation like:
 
 global_weak_symbol:
   ....
@@ -498,36 +503,22 @@ Lnon_weak_local:
 
   ld64 will be unable to split this into two atoms (because the "L" makes
   the second symbol 'invisible').  This means that legitimate direct accesses
-  to the second symbol will appear to be non-allowed direct accesses to an
-  atom of type weak, global which are not allowed.
-
-  To avoid this, we make the indirections have a leading 'l' (lower-case L)
-  which has a special meaning: linker can see this and use it to determine
-  atoms, but it is not placed into the final symbol table.
+  to the second symbol will appear to be direct accesses to an atom of type
+  weak, global which are not allowed.
 
-  The implementation here is somewhat heavy-handed in that it will also mark
-  indirections to the __IMPORT,__pointers section the same way which is
-  really unnecessary, since ld64 _can_ split those into atoms as they are
-  fixed size.  FIXME: determine if this is a penalty worth extra code to
-  fix.
+  To avoid this, we make any data-section indirections have a leading 'l'
+  (lower-case L) which has a special meaning: linker can see this and use
+  it to determine  atoms, but it is not placed into the final symbol table.
 
+  Symbols in the non-lazy symbol pointers section (or stubs) do not have this
+  problem because ld64 already knows the size of each entry.
 */
 
 const char *
 machopic_indirection_name (rtx sym_ref, bool stub_p)
 {
-  char *buffer;
   const char *name = XSTR (sym_ref, 0);
-  size_t namelen = strlen (name);
-  machopic_indirection *p;
-  bool needs_quotes;
-  const char *suffix;
-  char L_or_l = 'L';
-  const char *prefix = user_label_prefix;
-  const char *quote = "";
-  tree id;
-
-  id = maybe_get_identifier (name);
+  tree id = maybe_get_identifier (name);
   if (id)
     {
       tree id_orig = id;
@@ -535,43 +526,47 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
       while (IDENTIFIER_TRANSPARENT_ALIAS (id))
 	id = TREE_CHAIN (id);
       if (id != id_orig)
-	{
-	  name = IDENTIFIER_POINTER (id);
-	  namelen = strlen (name);
-	}
+	name = IDENTIFIER_POINTER (id);
     }
 
+  const char *prefix = user_label_prefix;
+  /* If we are emitting the label 'verbatim' then omit the U_L_P and count
+     the name without the leading '*'.  */
   if (name[0] == '*')
     {
       prefix = "";
       ++name;
-      --namelen;
-    }
-
-  needs_quotes = name_needs_quotes (name);
-  if (needs_quotes)
-    {
-      quote = "\"";
     }
 
-  if (stub_p)
-    suffix = STUB_SUFFIX;
-  else
-    {
-      suffix = NON_LAZY_POINTER_SUFFIX;
-      /* Let the linker see this.  */
-      L_or_l = 'l';
-    }
-
-  buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
-		   + strlen (prefix)
-		   + namelen
-		   + strlen (suffix)
-		   + 2 * strlen (quote)
-		   + 1 /* '\0' */);
+  /* Here we are undoing a number of causes that placed some indirections
+     (apparently erroneously) into the .data section.  Specifically, some
+     symbols that are ABI mandated indirections and some hidden symbols
+     were being placed there - which cause difficulties with later
+     versions of ld64.  Iff (after these checks) some symbol still gets an
+     indirection in the data section, we want to adjust the indirection
+     name to be linker visible to deal with PR71767 (notes above).  */
+  bool nlsp_in_data_section =
+       ! MACHO_SYMBOL_MUST_INDIRECT_P (sym_ref)
+    && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref)
+    && (machopic_symbol_defined_p (sym_ref) || SYMBOL_REF_LOCAL_P (sym_ref))
+    && ! indirect_data (sym_ref);
+
+  const char *suffix = stub_p ? STUB_SUFFIX : NON_LAZY_POINTER_SUFFIX;
+  /* If the indirection is in the data section, let the linker see it.  */
+  char L_or_l = (!stub_p && nlsp_in_data_section) ? 'l' : 'L';
+  /* We have mangled symbols with spaces and punctuation which typically
+     need surrounding in quotes for the assembler to consume them.  */
+  const char *quote = name_needs_quotes (name) ? "\"" : "";
+  char *buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
+			     + strlen (prefix)
+			     + strlen (name)
+			     + strlen (suffix)
+			     + 2 * strlen (quote)
+			     + 1 /* '\0' */);
 
   /* Construct the name of the non-lazy pointer or stub.  */
-  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name, suffix, quote);
+  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name,
+	   suffix, quote);
 
   if (!machopic_indirections)
     machopic_indirections = hash_table<indirection_hasher>::create_ggc (37);
@@ -580,10 +575,9 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
     = machopic_indirections->find_slot_with_hash (buffer,
 						  htab_hash_string (buffer),
 						  INSERT);
+  machopic_indirection *p;
   if (*slot)
-    {
-      p = *slot;
-    }
+    p = *slot;
   else
     {
       p = ggc_alloc<machopic_indirection> ();
@@ -591,6 +585,7 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
       p->ptr_name = xstrdup (buffer);
       p->stub_p = stub_p;
       p->used = false;
+      p->nlsp_in_data_section = nlsp_in_data_section;
       *slot = p;
     }
 
@@ -666,7 +661,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 	   /* some other cpu -- writeme!  */
 	   gcc_unreachable ();
 	}
-      else if (defined)
+      else if (defined && ! MACHO_SYMBOL_MUST_INDIRECT_P (orig))
 	{
 	  rtx offset = NULL;
 	  if (DARWIN_PPC || HAVE_lo_sum)
@@ -708,6 +703,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 		  machopic_indirection_name (orig, /*stub_p=*/false)));
 
       SYMBOL_REF_DATA (ptr_ref) = SYMBOL_REF_DATA (orig);
+      SYMBOL_REF_FLAGS (ptr_ref) |= MACHO_SYMBOL_FLAG_INDIRECTION;
 
       ptr_ref = gen_const_mem (Pmode, ptr_ref);
       machopic_define_symbol (ptr_ref);
@@ -790,7 +786,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 rtx
 machopic_indirect_call_target (rtx target)
 {
-  if (! darwin_emit_branch_islands)
+  if (! darwin_symbol_stubs)
     return target;
 
   if (GET_CODE (target) != MEM)
@@ -798,8 +794,7 @@ machopic_indirect_call_target (rtx target)
 
   if (MACHOPIC_INDIRECT
       && GET_CODE (XEXP (target, 0)) == SYMBOL_REF
-      && !(SYMBOL_REF_FLAGS (XEXP (target, 0))
-	   & MACHO_SYMBOL_FLAG_DEFINED))
+      && ! MACHO_SYMBOL_DEFINED_P (XEXP (target, 0)))
     {
       rtx sym_ref = XEXP (target, 0);
       const char *stub_name = machopic_indirection_name (sym_ref,
@@ -808,6 +803,7 @@ machopic_indirect_call_target (rtx target)
 
       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);
       SYMBOL_REF_DATA (XEXP (target, 0)) = SYMBOL_REF_DATA (sym_ref);
+      SYMBOL_REF_FLAGS (XEXP (target, 0)) |= MACHO_SYMBOL_FLAG_INDIRECTION;
       MEM_READONLY_P (target) = 1;
       MEM_NOTRAP_P (target) = 1;
     }
@@ -844,7 +840,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 	{
 	  if (reg == 0)
 	    {
-	      gcc_assert (!reload_in_progress);
+	      gcc_assert (!lra_in_progress);
 	      reg = gen_reg_rtx (Pmode);
 	    }
 
@@ -928,7 +924,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 	      emit_use (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
 #endif
 
-	      if (reload_in_progress)
+	      if (lra_in_progress)
 		df_set_regs_ever_live (REGNO (pic), true);
 	      pic_ref = gen_rtx_PLUS (Pmode, pic,
 				      machopic_gen_offset (XEXP (orig, 0)));
@@ -952,7 +948,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 
 	      if (reg == 0)
 		{
-		  gcc_assert (!reload_in_progress);
+		  gcc_assert (!lra_in_progress);
 		  reg = gen_reg_rtx (Pmode);
 		}
 
@@ -998,7 +994,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 #if 0
 		  emit_use (pic_offset_table_rtx);
 #endif
-		  if (reload_in_progress)
+		  if (lra_in_progress)
 		    df_set_regs_ever_live (REGNO (pic), true);
 		  pic_ref = gen_rtx_PLUS (Pmode,
 					  pic,
@@ -1069,129 +1065,160 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
   return pic_ref;
 }
 
-/* Output the stub or non-lazy pointer in *SLOT, if it has been used.
-   DATA is the FILE* for assembly output.  Called from
-   htab_traverse.  */
+/* Callbacks to output the stub or non-lazy pointers.
+   Each works on the item in *SLOT,if it has been used.
+   DATA is the FILE* for assembly output.
+   Called from htab_traverses, invoked from machopic_finish().  */
 
 int
-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+machopic_output_data_section_indirection (machopic_indirection **slot,
+					  FILE *asm_out_file)
 {
   machopic_indirection *p = *slot;
-  rtx symbol;
-  const char *sym_name;
-  const char *ptr_name;
 
-  if (!p->used)
+  if (!p->used || !p->nlsp_in_data_section)
     return 1;
 
-  symbol = p->symbol;
-  sym_name = XSTR (symbol, 0);
-  ptr_name = p->ptr_name;
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the indirection symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-  if (p->stub_p)
-    {
-      char *sym;
-      char *stub;
-      tree id;
+  switch_to_section (data_section);
+  assemble_align (GET_MODE_ALIGNMENT (Pmode));
+  assemble_label (asm_out_file, ptr_name);
+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
+		    GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
-      id = maybe_get_identifier (sym_name);
-      if (id)
-	{
-	  tree id_orig = id;
+  return 1;
+}
 
-	  while (IDENTIFIER_TRANSPARENT_ALIAS (id))
-	    id = TREE_CHAIN (id);
-	  if (id != id_orig)
-	    sym_name = IDENTIFIER_POINTER (id);
-	}
+int
+machopic_output_stub_indirection (machopic_indirection **slot,
+				  FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      sym = XALLOCAVEC (char, strlen (sym_name) + 2);
-      if (sym_name[0] == '*' || sym_name[0] == '&')
-	strcpy (sym, sym_name + 1);
-      else if (sym_name[0] == '-' || sym_name[0] == '+')
-	strcpy (sym, sym_name);
-      else
-	sprintf (sym, "%s%s", user_label_prefix, sym_name);
+  if (!p->used || !p->stub_p)
+    return 1;
 
-      stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
-      if (ptr_name[0] == '*' || ptr_name[0] == '&')
-	strcpy (stub, ptr_name + 1);
-      else
-	sprintf (stub, "%s%s", user_label_prefix, ptr_name);
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the stub symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-      machopic_output_stub (asm_out_file, sym, stub);
-    }
-  else if (! indirect_data (symbol)
-	   && (machopic_symbol_defined_p (symbol)
-	       || SYMBOL_REF_LOCAL_P (symbol)))
+  tree id = maybe_get_identifier (sym_name);
+  if (id)
     {
-      switch_to_section (data_section);
-      assemble_align (GET_MODE_ALIGNMENT (Pmode));
-      assemble_label (asm_out_file, ptr_name);
-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
-			GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+      tree id_orig = id;
+
+      while (IDENTIFIER_TRANSPARENT_ALIAS (id))
+	id = TREE_CHAIN (id);
+      if (id != id_orig)
+	sym_name = IDENTIFIER_POINTER (id);
     }
+
+  char *sym = XALLOCAVEC (char, strlen (sym_name) + 2);
+  if (sym_name[0] == '*' || sym_name[0] == '&')
+    strcpy (sym, sym_name + 1);
+  else if (sym_name[0] == '-' || sym_name[0] == '+')
+    strcpy (sym, sym_name);
   else
-    {
-      rtx init = const0_rtx;
+    sprintf (sym, "%s%s", user_label_prefix, sym_name);
+
+  char *stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
+  if (ptr_name[0] == '*' || ptr_name[0] == '&')
+    strcpy (stub, ptr_name + 1);
+  else
+    sprintf (stub, "%s%s", user_label_prefix, ptr_name);
 
-      switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+  machopic_output_stub (asm_out_file, sym, stub);
 
-      /* Mach-O symbols are passed around in code through indirect
-	 references and the original symbol_ref hasn't passed through
-	 the generic handling and reference-catching in
-	 output_operand, so we need to manually mark weak references
-	 as such.  */
-      if (SYMBOL_REF_WEAK (symbol))
+  return 1;
+}
+
+int
+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
+
+  if (!p->used || p->stub_p || p->nlsp_in_data_section)
+    return 1;
+
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The nonlazy-stub symbol name.  */
+  const char *ptr_name = p->ptr_name;
+
+  switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+
+  /* Mach-O symbols are passed around in code through indirect references and
+     the original symbol_ref hasn't passed through the generic handling and
+     reference-catching in output_operand, so we need to manually mark weak
+     references as such.  */
+
+  if (SYMBOL_REF_WEAK (symbol))
+    {
+      tree decl = SYMBOL_REF_DECL (symbol);
+      gcc_checking_assert (DECL_P (decl));
+
+      if (decl != NULL_TREE
+	  && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
+	  /* Handle only actual external-only definitions, not
+	     e.g. extern inline code or variables for which
+	     storage has been allocated.  */
+	  && !TREE_STATIC (decl))
 	{
-	  tree decl = SYMBOL_REF_DECL (symbol);
-	  gcc_assert (DECL_P (decl));
-
-	  if (decl != NULL_TREE
-	      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
-	      /* Handle only actual external-only definitions, not
-		 e.g. extern inline code or variables for which
-		 storage has been allocated.  */
-	      && !TREE_STATIC (decl))
-	    {
-	      fputs ("\t.weak_reference ", asm_out_file);
-	      assemble_name (asm_out_file, sym_name);
-	      fputc ('\n', asm_out_file);
-	    }
+	  fputs ("\t.weak_reference ", asm_out_file);
+	  assemble_name (asm_out_file, sym_name);
+	  fputc ('\n', asm_out_file);
 	}
+    }
 
-      assemble_name (asm_out_file, ptr_name);
-      fprintf (asm_out_file, ":\n");
+  assemble_name (asm_out_file, ptr_name);
+  fprintf (asm_out_file, ":\n");
 
-      fprintf (asm_out_file, "\t.indirect_symbol ");
-      assemble_name (asm_out_file, sym_name);
-      fprintf (asm_out_file, "\n");
+  fprintf (asm_out_file, "\t.indirect_symbol ");
+  assemble_name (asm_out_file, sym_name);
+  fprintf (asm_out_file, "\n");
 
-      /* Variables that are marked with MACHO_SYMBOL_STATIC need to
-	 have their symbol name instead of 0 in the second entry of
-	 the non-lazy symbol pointer data structure when they are
-	 defined.  This allows the runtime to rebind newer instances
-	 of the translation unit with the original instance of the
-	 symbol.  */
+  /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to
+     have their symbol name instead of 0 in the second entry of
+     the non-lazy symbol pointer data structure when they are
+     defined.  This allows the runtime to rebind newer instances
+     of the translation unit with the original instance of the
+     symbol.  */
 
-      if ((SYMBOL_REF_FLAGS (symbol) & MACHO_SYMBOL_STATIC)
-	  && machopic_symbol_defined_p (symbol))
-	init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+  rtx init = const0_rtx;
+  if (MACHO_SYMBOL_STATIC_P (symbol) && machopic_symbol_defined_p (symbol))
+    init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
 
-      assemble_integer (init, GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
-    }
+  assemble_integer (init, GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
   return 1;
 }
 
-void
+static void
 machopic_finish (FILE *asm_out_file)
 {
-  if (machopic_indirections)
-    machopic_indirections
-      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);
+  if (!machopic_indirections)
+    return;
+
+  /* First output an symbol indirections that have been placed into .data
+     (we don't expect these now).  */
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_data_section_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_stub_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_indirection> (asm_out_file);
 }
 
 int
@@ -1206,25 +1233,51 @@ machopic_operand_p (rtx op)
 	    && XINT (XEXP (op, 0), 1) == UNSPEC_MACHOPIC_OFFSET);
 }
 
-/* This function records whether a given name corresponds to a defined
-   or undefined function or variable, for machopic_classify_ident to
-   use later.  */
+/* This function:
+   computes and caches a series of flags that characterise the symbol's
+   properties that affect Mach-O code gen (including accidental cases
+   from older toolchains).
+
+   TODO:
+   Here we also need to do enough analysis to determine if a symbol's
+   name needs to be made linker-visible.  This is more tricky - since
+   it depends on whether we've previously seen a global weak definition
+   in the same section.
+   */
 
 void
-darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+darwin_encode_section_info (tree decl, rtx rtl, int first)
 {
-  rtx sym_ref;
+  /* Careful not to prod global register variables.  */
+  if (!MEM_P (rtl))
+    return;
 
-  /* Do the standard encoding things first.  */
+  /* Do the standard encoding things first; this sets:
+     SYMBOL_FLAG_FUNCTION,
+     SYMBOL_FLAG_LOCAL, (binds_local_p)
+     TLS_MODEL, SYMBOL_FLAG_SMALL
+     SYMBOL_FLAG_EXTERNAL.  */
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)
+  if (! VAR_OR_FUNCTION_DECL_P (decl))
     return;
 
-  sym_ref = XEXP (rtl, 0);
-  if (TREE_CODE (decl) == VAR_DECL)
+  rtx sym_ref = XEXP (rtl, 0);
+  if (VAR_P (decl))
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_VARIABLE;
 
+  /* Only really common if there's no initialiser.  */
+  bool really_common_p = (DECL_COMMON (decl)
+			  && (DECL_INITIAL (decl) == NULL
+			      || (!in_lto_p
+				  && DECL_INITIAL (decl) == error_mark_node)));
+
+  /* For Darwin, if we have specified visibility and it's not the default
+     that's counted 'hidden'.  */
+  if (DECL_VISIBILITY_SPECIFIED (decl)
+      && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT)
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_HIDDEN_VIS;
+
   if (!DECL_EXTERNAL (decl)
       && (!TREE_PUBLIC (decl) || !DECL_WEAK (decl))
       && ! lookup_attribute ("weakref", DECL_ATTRIBUTES (decl))
@@ -1235,7 +1288,13 @@ darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;
 
   if (! TREE_PUBLIC (decl))
-    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_STATIC;
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_STATIC;
+
+  /* Short cut check for Darwin 'must indirect' rules.  */
+  if (really_common_p
+      || (DECL_WEAK (decl) && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref))
+      || lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
+     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_MUST_INDIRECT;
 }
 
 void
@@ -1252,12 +1311,13 @@ darwin_mark_decl_preserved (const char *name)
 }
 
 static section *
-darwin_rodata_section (int use_coal, bool zsize)
+darwin_rodata_section (int use_coal, bool zsize, int reloc)
 {
   return (use_coal
 	  ? darwin_sections[const_coal_section]
 	  : (zsize ? darwin_sections[zobj_const_section]
-		   : darwin_sections[const_section]));
+		   : reloc ? darwin_sections[const_data_section]
+			   : darwin_sections[const_section]));
 }
 
 static section *
@@ -1550,7 +1610,7 @@ machopic_select_section (tree decl,
 
     case SECCAT_RODATA:
     case SECCAT_SRODATA:
-      base_section = darwin_rodata_section (use_coal, zsize);
+      base_section = darwin_rodata_section (use_coal, zsize, reloc);
       break;
 
     case SECCAT_RODATA_MERGE_STR:
@@ -2086,11 +2146,11 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)
   static int invok_count = 0;
   static tree last_fun_decl = NULL_TREE;
   
-  /* We use the linker to emit the .eh labels for Darwin 9 and above.  */
-  if (! for_eh || generating_for_darwin_version >= 9)
+  /* Modern linkers can produce distinct FDEs without compiler support.  */
+  if (! for_eh || ! ld_needs_eh_markers)
     return;
 
-  /* FIXME: This only works when the eh for all sections of a function is 
+  /* FIXME: This only works when the eh for all sections of a function are
      emitted at the same time.  If that changes, we would need to use a lookup
      table of some form to determine what to do.  Also, we should emit the
      unadorned label for the partition containing the public label for a
@@ -3148,17 +3208,19 @@ darwin_override_options (void)
 				: (generating_for_darwin_version >= 9) ? 1
 								       : 0);
 
-  /* Objective-C family ABI 2 is only valid for next/m64 at present.  */
   if (global_options_set.x_flag_objc_abi && flag_next_runtime)
     {
-      if (TARGET_64BIT && global_options.x_flag_objc_abi < 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 must be"
-				    " used for %<-m64%> targets with"
-				    " %<-fnext-runtime%>");
-      if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 is not"
-				    " supported on %<-m32%> targets with"
-				    " %<-fnext-runtime%>");
+      if (TARGET_64BIT && global_options.x_flag_objc_abi != 2)
+	/* The Objective-C family ABI 2 is the only valid version NeXT/m64.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> 2 must be used for 64 bit targets"
+		  " with %<-fnext-runtime%>");
+      else if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
+	/* ABI versions 0 and 1 are the only valid versions NeXT/m32.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> %d is not supported for 32 bit"
+		  " targets with %<-fnext-runtime%>",
+		  global_options.x_flag_objc_abi);
     }
 
   /* Don't emit DWARF3/4 unless specifically selected.  This is a 
@@ -3261,11 +3323,44 @@ darwin_override_options (void)
       flag_pic = 2;
     }
 
-  /* It is assumed that branch island stubs are needed for earlier systems.  */
-  if (generating_for_darwin_version < 9)
-    darwin_emit_branch_islands = true;
-  else
-    emit_aligned_common = true; /* Later systems can support aligned common.  */
+  /* Linkers >= ld64-62.1 (at least) are capable of making the necessary PIC
+     indirections and we no longer need to emit pic symbol stubs.
+     However, if we are generating code for earlier ones (or for use in the
+     kernel) the stubs might still be required, and this will be set true.
+     If the user sets it on or off - then that takes precedence.
+
+     Linkers that don't need stubs, don't need the EH symbol markers either.
+  */
+
+  if (!global_options_set.x_darwin_symbol_stubs)
+    {
+      if (darwin_target_linker)
+	{
+	  if (strverscmp (darwin_target_linker, MIN_LD64_OMIT_STUBS) < 0)
+	    {
+	      darwin_symbol_stubs = true;
+	      ld_needs_eh_markers = true;
+	    }
+	}
+      else if (generating_for_darwin_version < 9)
+	{
+	  /* If we don't know the linker version and we're targeting an old
+	     system, we know no better than to assume the use of an earlier
+	     linker.  */
+	  darwin_symbol_stubs = true;
+	  ld_needs_eh_markers = true;
+	}
+    }
+  else if (DARWIN_X86 && darwin_symbol_stubs && TARGET_64BIT)
+    {
+      inform (input_location,
+	      "%<-msymbol-stubs%> is not required for 64b code (ignored)");
+      darwin_symbol_stubs = false;
+    }
+
+  if (generating_for_darwin_version >= 9)
+    /* Later systems can support aligned common.  */
+    emit_aligned_common = true;
 
   /* The c_dialect...() macros are not available to us here.  */
   darwin_running_cxx = (strstr (lang_hooks.name, "C++") != 0);
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
index 0e253cb0dfa..fab9af97afd 100644
--- a/gcc/config/darwin.h
+++ b/gcc/config/darwin.h
@@ -126,6 +126,24 @@ extern GTY(()) int darwin_ms_struct;
   "%{gsplit-dwarf:%ngsplit-dwarf is not supported on this platform} \
      %<gsplit-dwarf"
 
+#if LD64_HAS_EXPORT_DYNAMIC
+#define DARWIN_RDYNAMIC "%{rdynamic:-export_dynamic}"
+#else
+#define DARWIN_RDYNAMIC "%{rdynamic:%nrdynamic is not supported}"
+#endif
+
+/* FIXME: we should check that the linker supports the -pie and -no_pie.
+   options.  */
+#define DARWIN_PIE_SPEC \
+"%{pie|fpie|fPIE:\
+   %{mdynamic-no-pic: \
+     %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
+     :%:version-compare(>= 10.5 mmacosx-version-min= -pie) }} "
+
+#define DARWIN_NOPIE_SPEC \
+"%{no-pie|fno-pie|fno-PIE: \
+   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) }"
+
 #define DARWIN_CC1_SPEC							\
   "%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls " \
   "%{fterminated-vtables: -fapple-kext} %<fterminated-vtables "		\
@@ -156,20 +174,31 @@ extern GTY(()) int darwin_ms_struct;
 #define CPP_SPEC "%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}" \
 	" %{pthread:-D_REENTRANT}"
 
-/* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus
-   precomp, libtool, and fat build additions.
+/* This is a fix for PR41260 by passing -no_compact_unwind on darwin10 and
+   later until the assembler, linker and libunwind are able to deal with the
+   output from GCC.
+
+   FIXME: we should check that the linker supports the option.
+*/
+
+#define DARWIN_NOCOMPACT_UNWIND \
+" %:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) "
+
+/* In Darwin linker specs we can put -lcrt0.o and ld will search the library
+   path for crt0.o or -lcrtx.a and it will search for for libcrtx.a.  As for
+   other ports, we can also put xxx.{o,a}%s and get the appropriate complete
+   startfile absolute directory.  This latter point is important when we want
+   to override ld's rule of .dylib being found ahead of .a and the user wants
+   the convenience library to be linked.  */
+
+/* The LINK_COMMAND spec is mostly a clone of the standard LINK_COMMAND_SPEC,
+   plus precomp, libtool, and fat build additions.
 
    In general, random Darwin linker flags should go into LINK_SPEC
    instead of LINK_COMMAND_SPEC.  The command spec is better for
    specifying the handling of options understood by generic Unix
    linkers, and for positional arguments like libraries.  */
 
-#if LD64_HAS_EXPORT_DYNAMIC
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic:-export_dynamic}"
-#else
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic: %nrdynamic is not supported}"
-#endif
-
 #define LINK_COMMAND_SPEC_A \
    "%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker)" \
@@ -190,10 +219,14 @@ extern GTY(()) int darwin_ms_struct;
       %{%:sanitize(address): -lasan } \
       %{%:sanitize(undefined): -lubsan } \
       %(link_ssp) \
-      " DARWIN_EXPORT_DYNAMIC " %<rdynamic \
       %(link_gcc_c_sequence) \
     }}}\
-    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} }}}}}}}"
+    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} "\
+    DARWIN_PIE_SPEC \
+    DARWIN_NOPIE_SPEC \
+    DARWIN_RDYNAMIC \
+    DARWIN_NOCOMPACT_UNWIND \
+    "}}}}}}} %<pie %<no-pie %<rdynamic "
 
 #define DSYMUTIL "\ndsymutil"
 
@@ -230,8 +263,6 @@ extern GTY(()) int darwin_ms_struct;
 #define STANDARD_STARTFILE_PREFIX_1 ""
 #define STANDARD_STARTFILE_PREFIX_2 ""
 
-#define DARWIN_PIE_SPEC "%{fpie|pie|fPIE:}"
-
 /* Please keep the random linker options in alphabetical order (modulo
    'Z' and 'no' prefixes). Note that options taking arguments may appear
    multiple times on a command line with different arguments each time,
@@ -295,7 +326,6 @@ extern GTY(()) int darwin_ms_struct;
      %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \
      %:version-compare(< 10.5 mmacosx-version-min= suppress)}} \
    %{Zmultiplydefinedunused*:-multiply_defined_unused %*} \
-   " DARWIN_PIE_SPEC " \
    %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules} \
    %{read_only_relocs} \
    %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*} \
@@ -327,45 +357,42 @@ extern GTY(()) int darwin_ms_struct;
 
 /* Support -mmacosx-version-min by supplying different (stub) libgcc_s.dylib
    libraries to link against, and by not linking against libgcc_s on
-   earlier-than-10.3.9.
+   earlier-than-10.3.9.  If we need exceptions, prior to 10.3.9, then we have
+   to link the static eh lib, since there's no shared version on the system.
 
-   Note that by default, -lgcc_eh is not linked against!  This is
-   because in a future version of Darwin the EH frame information may
-   be in a new format, or the fallback routine might be changed; if
-   you want to explicitly link against the static version of those
-   routines, because you know you don't need to unwind through system
-   libraries, you need to explicitly say -static-libgcc.
+   Note that by default, except as above, -lgcc_eh is not linked against.
+   This is because,in general, we need to unwind through system libraries that
+   are linked with the shared unwinder in libunwind (or libgcc_s for 10.4/5).
 
-   If it is linked against, it has to be before -lgcc, because it may
+   The static version of the current libgcc unwinder (which differs from the
+   implementation in libunwind.dylib on systems Darwin10 [10.6]+) can be used
+   by specifying -static-libgcc.
+
+   If libgcc_eh is linked against, it has to be before -lgcc, because it might
    need symbols from -lgcc.  */
+
 #undef REAL_LIBGCC_SPEC
 #define REAL_LIBGCC_SPEC						   \
    "%{static-libgcc|static: -lgcc_eh -lgcc;				   \
-      shared-libgcc|fexceptions|fgnu-runtime:				   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+      shared-libgcc|fexceptions|fobjc-exceptions|fgnu-runtime:		   \
+       %:version-compare(!> 10.3.9 mmacosx-version-min= -lgcc_eh)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc ;								   \
       :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc }"
 
-/* We specify crt0.o as -lcrt0.o so that ld will search the library path.
-
-   crt3.o provides __cxa_atexit on systems that don't have it.  Since
-   it's only used with C++, which requires passing -shared-libgcc, key
-   off that to avoid unnecessarily adding a destructor to every
-   powerpc program built.  */
+/* We specify crt0.o as -lcrt0.o so that ld will search the library path.  */
 
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC							    \
-  "%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
-   %{!Zdynamiclib:%{Zbundle:%{!static:					    \
-	%:version-compare(< 10.6 mmacosx-version-min= -lbundle1.o)	    \
-	%{fgnu-tm: -lcrttms.o}}}					    \
+"%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
+ %{!Zdynamiclib:%{Zbundle:%(darwin_bundle1)}				    \
      %{!Zbundle:%{pg:%{static:-lgcrt0.o}				    \
                      %{!static:%{object:-lgcrt0.o}			    \
                                %{!object:%{preload:-lgcrt0.o}		    \
@@ -377,7 +404,7 @@ extern GTY(()) int darwin_ms_struct;
                                 %{!object:%{preload:-lcrt0.o}		    \
                                   %{!preload: %(darwin_crt1)		    \
 					      %(darwin_crt2)}}}}}}	    \
-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+ %(darwin_crt3)"
 
 /* We want a destructor last in the list.  */
 #define TM_DESTRUCTOR "%{fgnu-tm: -lcrttme.o}"
@@ -385,11 +412,10 @@ extern GTY(()) int darwin_ms_struct;
 
 #define DARWIN_EXTRA_SPECS						\
   { "darwin_crt1", DARWIN_CRT1_SPEC },					\
-  { "darwin_dylib1", DARWIN_DYLIB1_SPEC },
-
-#define DARWIN_DYLIB1_SPEC						\
-  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
-   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
+  { "darwin_crt2", DARWIN_CRT2_SPEC },					\
+  { "darwin_crt3", DARWIN_CRT3_SPEC },					\
+  { "darwin_dylib1", DARWIN_DYLIB1_SPEC },				\
+  { "darwin_bundle1", DARWIN_BUNDLE1_SPEC },
 
 #define DARWIN_CRT1_SPEC						\
   "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
@@ -397,6 +423,24 @@ extern GTY(()) int darwin_ms_struct;
    %:version-compare(>< 10.6 10.8 mmacosx-version-min= -lcrt1.10.6.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
+#define DARWIN_CRT2_SPEC ""
+
+/* crt3.o provides __cxa_atexit on systems that don't have it (and a fix
+   up for faulty versions on 10.4).  Since it's only used with C++, which
+   requires passing -shared-libgcc, key off that to avoid unnecessarily
+   adding a destructor to every program built for 10.4 or earlier.  */
+
+#define DARWIN_CRT3_SPEC \
+"%{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+
+#define DARWIN_DYLIB1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
+   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
+
+#define DARWIN_BUNDLE1_SPEC \
+"%{!static:%:version-compare(< 10.6 mmacosx-version-min= -lbundle1.o)	\
+	   %{fgnu-tm: -lcrttms.o}}"
+
 #ifdef HAVE_AS_MMACOSX_VERSION_MIN_OPTION
 /* Emit macosx version (but only major).  */
 #define ASM_MMACOSX_VERSION_MIN_SPEC \
@@ -762,21 +806,52 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];
 #undef TARGET_ASM_MARK_DECL_PRESERVED
 #define TARGET_ASM_MARK_DECL_PRESERVED darwin_mark_decl_preserved
 
-/* Set on a symbol with SYMBOL_FLAG_FUNCTION or
-   MACHO_SYMBOL_FLAG_VARIABLE to indicate that the function or
-   variable has been defined in this translation unit.
-   When porting Mach-O to new architectures you need to make
-   sure these aren't clobbered by the backend.  */
+/* Any port using this header needs to define the first available
+   subtarget symbol bit: SYMBOL_FLAG_SUBT_DEP.  */
 
-#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_MACH_DEP)
-#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_MACH_DEP) << 1)
+/* Is a variable. */
+#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_SUBT_DEP)
+#define MACHO_SYMBOL_VARIABLE_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_VARIABLE) != 0)
+
+/* Set on a symbol that must be indirected, even when there is a
+   definition in the TU.  The ABI mandates that common symbols are so
+   indirected, as are weak.  If 'fix-and-continue' is operational then
+   data symbols might also be.  */
+
+#define MACHO_SYMBOL_FLAG_MUST_INDIRECT ((SYMBOL_FLAG_SUBT_DEP) << 1)
+#define MACHO_SYMBOL_MUST_INDIRECT_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_MUST_INDIRECT) != 0)
+
+/* Set on a symbol with SYMBOL_FLAG_FUNCTION or MACHO_SYMBOL_FLAG_VARIABLE
+   to indicate that the function or variable is considered defined in this
+   translation unit.  */
+
+#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_SUBT_DEP) << 2)
+#define MACHO_SYMBOL_DEFINED_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_DEFINED) != 0)
+
+/* Set on a symbol that has specified non-default visibility.  */
+
+#define MACHO_SYMBOL_FLAG_HIDDEN_VIS ((SYMBOL_FLAG_SUBT_DEP) << 3)
+#define MACHO_SYMBOL_HIDDEN_VIS_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_HIDDEN_VIS) != 0)
+
+/* Set on a symbol that is a pic stub or symbol indirection (i.e. the
+   L_xxxxx${stub,non_lazy_ptr,lazy_ptr}.  */
+
+#define MACHO_SYMBOL_FLAG_INDIRECTION ((SYMBOL_FLAG_SUBT_DEP) << 5)
+#define MACHO_SYMBOL_INDIRECTION_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_INDIRECTION) != 0)
 
 /* Set on a symbol to indicate when fix-and-continue style code
    generation is being used and the symbol refers to a static symbol
    that should be rebound from new instances of a translation unit to
    the original instance of the data.  */
 
-#define MACHO_SYMBOL_STATIC ((SYMBOL_FLAG_MACH_DEP) << 2)
+#define MACHO_SYMBOL_FLAG_STATIC ((SYMBOL_FLAG_SUBT_DEP) << 6)
+#define MACHO_SYMBOL_STATIC_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_STATIC) != 0)
 
 /* Symbolic names for various things we might know about a symbol.  */
 
@@ -969,8 +1044,12 @@ extern void darwin_driver_init (unsigned int *,struct cl_decoded_option **);
    _tested_ version known to support this so far.  */
 #define MIN_LD64_NO_COAL_SECTS "236.4"
 
+/* From at least version 62.1, ld64 can build symbol indirection stubs as
+   needed, and there is no need for the compiler to emit them.  */
+#define MIN_LD64_OMIT_STUBS "85.2"
+
 #ifndef LD64_VERSION
-#define LD64_VERSION "85.2"
+#define LD64_VERSION "62.1"
 #else
 #define DEF_LD64 LD64_VERSION
 #endif
diff --git a/gcc/config/darwin.opt b/gcc/config/darwin.opt
index 22667def0a1..7f5616cbe07 100644
--- a/gcc/config/darwin.opt
+++ b/gcc/config/darwin.opt
@@ -18,240 +18,382 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-; Various linker options have a -Z added so that they can get to specs
-; processing without interference.  Note that an option name with a
-; prefix that matches another option name, that also takes an
-; argument, being mapped to a -Z linker option, needs to be modified
-; so the prefix is different, otherwise a '*' after the shorter option
-; will match with the longer one.
+; We have a lot of Driver options, many of which are obsolete or very very
+; rarely used so, to keep this file easier to manage:
+
+; Please place all Non-driver options first (in alphabetical order), followed
+; by Driver-only options.
+
+; Non-driver options.
+
+dependency-file
+C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+
+fapple-kext
+Target Report C++ Var(flag_apple_kext)
+Generate code for darwin loadable kernel extensions.
+
+iframework
+Target RejectNegative C ObjC C++ ObjC++ Joined Separate
+-iframework <dir>	Add <dir> to the end of the system framework include path.
+
+mconstant-cfstrings
+Target Report Var(darwin_constant_cfstrings) Init(1)
+Generate compile-time CFString objects.
+
+Wnonportable-cfstrings
+Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
+Warn if constant CFString objects contain non-portable characters.
+
+; Use new-style pic stubs if this is true, x86 only so far.
+matt-stubs
+Target Report Var(darwin_macho_att_stub) Init(1)
+Generate AT&T-style stubs for Mach-O.
+
+mdynamic-no-pic
+Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
+Generate code suitable for executables (NOT shared libs).
+
+mfix-and-continue
+Target Report Var(darwin_fix_and_continue)
+Generate code suitable for fast turn around debugging.
+
+mkernel
+Target Report Var(flag_mkernel)
+Generate code for the kernel or loadable kernel extensions.
+
+; The Init here is for the convenience of GCC developers, so that cc1
+; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
+; driver will always pass a -mmacosx-version-min, so in normal use the
+; Init is never used.
+mmacosx-version-min=
+Target RejectNegative Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
+The earliest MacOS X version on which this program will run.
+
+; Really, only relevant to PowerPC which has a 4 byte bool by default.
+mone-byte-bool
+Target RejectNegative Report Var(darwin_one_byte_bool)
+Set sizeof(bool) to 1.
+
+msymbol-stubs
+Target Report Var(darwin_symbol_stubs) Init(0)
+Force generation of external symbol indirection stubs.
+
+; Some code-gen may be improved / adjusted if the linker is sufficiently modern.
+mtarget-linker=
+Target RejectNegative Joined Report Alias(mtarget-linker)
+
+mtarget-linker
+Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
+The version of ld64 in use for this toolchain.
+
+; Driver options.
 
 all_load
-Driver Alias(Zall_load)
+Driver RejectNegative Alias(Zall_load)
+Loads all members of archive libraries
 
 allowable_client
-Driver Separate Alias(Zallowable_client)
+Driver RejectNegative Separate Alias(Zallowable_client)
+-allowable_client <name>	The output dylib is private to the client(s) named
 
 arch
 Driver RejectNegative Separate
+-arch <name>	Specify that the output file should be generated for architecture  \"name\"
 
 arch_errors_fatal
-Driver Alias(Zarch_errors_fatal)
+Driver RejectNegative Alias(Zarch_errors_fatal)
+Mismatches between file architecture and the \"-arch\" are errors instead of warnings
 
 asm_macosx_version_min=
 Driver RejectNegative Joined
+The earliest MacOS X version on which this program will run (formatted for the assembler)
 
 bind_at_load
-Driver Alias(Zbind_at_load)
+Driver RejectNegative Alias(Zbind_at_load)
+Produce an output file that will bind symbols on load, rather than lazily.
 
 bundle
-Driver Alias(Zbundle)
+Driver RejectNegative Alias(Zbundle)
+Produce a Mach-O bundle (file type MH_BUNDLE)
 
 bundle_loader
-Driver Separate Alias(Zbundle_loader)
+Driver RejectNegative Separate Alias(Zbundle_loader)
+-bundle_loader <executable>	Treat \"executable\" (that will be loading this bundle) as if it was one of the dynamic libraries the bundle is linked against for symbol resolution
 
-dead_strip
-Driver Alias(Zdead_strip)
+client_name
+Driver RejectNegative Separate
+-client_name <name>	Enable the executable being built to link against a private dylib (using allowable_client)
 
-dependency-file
-C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+compatibility_version
+Driver RejectNegative Separate
+-compatibility_version <number>	Set the minimum version for the client interface.  Clients must record a greater number than this or the binding will fail at runtime
+
+current_version
+Driver RejectNegative Separate
+-current_version <number>	Set the current version for the library.
+
+dead_strip
+Driver RejectNegative Alias(Zdead_strip)
+Remove code and data that is unreachable from any exported symbol (including the entry point)
 
 dylib_file
 Driver Separate Alias(Zdylib_file)
 
 dylinker
-Driver
+Driver RejectNegative
+Produce a Mach-O dylinker (file type MH_DYLINKER), only used for building dyld.
+
+dylinker_install_name
+Driver RejectNegative Separate
+-dylinker_install_name <path>	Only used for building dyld.
 
 dynamic
-Driver Alias(Zdynamic)
+Driver RejectNegative Alias(Zdynamic)
+The default (and opposite of -static), implied by user mode executables, shared libraries and bundles.
 
 dynamiclib
-Driver Alias(Zdynamiclib)
+Driver RejectNegative Alias(Zdynamiclib)
+Produce a Mach-O shared library (file type MH_DYLIB), synonym for -shared
 
 exported_symbols_list
-Driver Separate Alias(Zexported_symbols_list)
+Driver RejectNegative Separate Alias(Zexported_symbols_list)
+-exported_symbols_list <filename>	Global symbols in \"filename\" will be exported from the linked output file, any symbols not mentioned will be treated as hidden.
 
 filelist
 Driver RejectNegative Separate
+Supply a list of objects to be linked from a file, rather than the command line
 
 findirect-virtual-calls
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 flat_namespace
 Driver RejectNegative Alias(Zflat_namespace)
+Ignore the normal two-level namespace; resolve symbols in command line order and do not record which library provided the resolved symbol.
 
 force_cpusubtype_ALL
 Driver RejectNegative Alias(Zforce_cpusubtype_ALL)
+For the assembler (and linker) permit any architecture sub-variant to be used without error.
 
 force_flat_namespace
 Driver RejectNegative Alias(Zforce_flat_namespace)
+Set the output object such that, on loading, dyld  will ignore any two-level information and resolve symbols in the discovery order for loaded libs.
 
 framework
 Driver RejectNegative Separate
+-framework <name>	The linker should search for the named framework in the framework search path.
 
 fterminated-vtables
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 gfull
 Driver RejectNegative
+Abbreviation for \"-g -fno-eliminate-unused-debug-symbols\"
 
 gused
 Driver RejectNegative
+Abbreviation for \"-g -feliminate-unused-debug-symbols\"
 
 headerpad_max_install_names
-Driver
+Driver RejectNegative
+Automatically adds space for longer path names in load commands (up to MAXPATHLEN)
 
 image_base
-Driver Separate Alias(Zimage_base)
+Driver RejectNegative Separate Alias(Zimage_base)
+-image_base <address>	Choose a base address for a dylib or bundle.
 
 init
-Driver Separate Alias(Zinit)
+Driver RejectNegative Separate Alias(Zinit)
+-init <symbol_name>	The symbol \"symbol_name\" will be used as the first initialiser for a dylib.
 
 install_name
-Driver Separate Alias(Zinstall_name)
+Driver RejectNegative Separate Alias(Zinstall_name)
+-install_name <name>	Set the install name for a dylib.
 
 keep_private_externs
-Driver
-
-mconstant-cfstrings
-Target Report Var(darwin_constant_cfstrings) Init(1)
-Generate compile-time CFString objects.
+Driver RejectNegative
+Usually \"private extern\" (hidden) symbols are made local when linking, this command suppresses that such that they remain exported.
 
 multi_module
 Driver RejectNegative Alias(Zmulti_module)
+(Obsolete after 10.4) Multi modules are ignored at runtime since MacOS 10.4
 
 multiply_defined
 Driver RejectNegative Separate Alias(Zmultiply_defined)
+(Obsolete after 10.4) -multiply_defined <treatment> Provided a mechanism for warning about symbols defined in multiple dylibs.
 
 multiply_defined_unused
 Driver RejectNegative Separate Alias(Zmultiplydefinedunused)
+(Obsolete after 10.4) -multiply_defined_unused <treatment>	Provided a mechanism for warning about symbols defined in the current executable also being defined in linked dylibs.
 
 no_dead_strip_inits_and_terms
-Driver Alias(Zno_dead_strip_inits_and_terms)
+Driver RejectNegative Alias(Zno_dead_strip_inits_and_terms)
+(Obsolete) The linker never dead strips these items, so the option is not needed.
 
 nofixprebinding
-Driver
+Driver RejectNegative
+(Obsolete after 10.3.9) Set MH_NOPREFIXBINDING, in an exectuable.
 
 nomultidefs
-Driver
+Driver RejectNegative
+(Obsolete after 10.4)	Set MH_NOMULTIDEFS in an umbrella framework.
 
 noprebind
-Driver
+Driver RejectNegative Negative(prebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 noseglinkedit
-Driver
+Driver RejectNegative Negative(seglinkedit)
+(Obsolete) This is the default.
 
 object
-Driver
+Driver RejectNegative
+
+pagezero_size
+Driver RejectNegative Separate
+-pagezero_size size	Allows setting the page 0 size to 4kb for certain special cases.
 
 prebind
-Driver
+Driver RejectNegative Negative(noprebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 prebind_all_twolevel_modules
-Driver
+Driver RejectNegative
+(Obsolete) LD_PREBIND is no longer supported.
 
 preload
-Driver
+Driver RejectNegative
+Produces a Mach-O file suitable for embedded/ROM use.
 
 private_bundle
-Driver
+Driver RejectNegative
+(Obsolete) Allowed linking to proceed with \"-flat_namespace\" when a linked bundle contained a symbol also exported from the main executable.
 
 pthread
-Driver
+Driver RejectNegative
 
 rdynamic
-Driver
+Driver RejectNegative
+Synonym for \"-export-dynamic\" for linker versions that support it.
+
+read_only_relocs
+Driver RejectNegative Separate
+-read_only_relocs <treatment>	This will allow relocs in read-only pages (not advisable).
+
+sectalign
+Driver RejectNegative Separate Args(3)
+-sectalign <segname> <sectname> <value>	Set section \"sectname\" in segment \"segname\" to have alignment \"value\" which must be an integral power of two expressed in hexadecimal form.
+
+sectcreate
+Driver RejectNegative Separate Args(3)
+-sectcreate <segname> <sectname> <file>	Create section \"sectname\" in segment \"segname\" from the contents of \"file\".
+
+sectobjectsymbols
+Driver RejectNegative Separate Args(2)
+(Obsolete) -sectobjectsymbols <segname> <sectname>	Setting a local symbol at the start of a section is no longer supported.
+
+sectorder
+Driver RejectNegative Separate Args(3)
+(Obsolete) -sectorder <segname> <sectname> orderfile	Replaced by a more general option \"-order_file\".
 
 seg_addr_table
-Driver Separate Alias(Zseg_addr_table)
+Driver RejectNegative Separate Alias(Zseg_addr_table)
+-seg_addr_table <file>	Specify the base addresses for dynamic libraries, \"file\" contains a line for each library.
 
+; This is only usable by the ld_classic linker.
 seg_addr_table_filename
-Driver Separate Alias(Zfn_seg_addr_table_filename)
+Driver RejectNegative Separate Alias(Zfn_seg_addr_table_filename)
+(Obsolete, ld_classic only) -seg_addr_table_filename <path>
+
+seg1addr
+Driver RejectNegative Separate
+Synonym for \"image_base\"
 
 segaddr
-Driver Separate Args(2) Alias(Zsegaddr)
+Driver RejectNegative Separate Args(2) Alias(Zsegaddr)
+-segaddr <name> <address>	Set the base address of segment \"name\" to \"address\" which must be aligned to a page boundary (currently 4kb).
+
+; This is only usable by the ld_classic linker.
+segcreate
+Driver RejectNegative Separate Args(3)
+(Obsolete, ld_classic only) -sectcreate segname sectname file
 
 seglinkedit
-Driver
+Driver RejectNegative Negative(noseglinkedit)
+(Obsolete) Object files with LINKEDIT sections are no longer supported.
+
+segprot
+Driver RejectNegative Separate Args(3)
+-segprot <segname> max_prot init_prot	The protection values are \"r\", \"w\", \"x\" or \"-\" the latter meaning \"no access\".
 
 segs_read_only_addr
-Driver Separate Alias(Zsegs_read_only_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_only_addr)
+-segs_read_only_addr address 	Allows specifying the address of the read only portion of a dylib.
 
 segs_read_write_addr
-Driver Separate Alias(Zsegs_read_write_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_write_addr)
+-segs_read_write_addr address 	Allows specifying the address of the read/write portion of a dylib.
 
 single_module
-Driver Alias(Zsingle_module)
+Driver RejectNegative Alias(Zsingle_module)
+(Obsolete)	This is the default.
+
+sub_library
+Driver RejectNegative Separate
+-sub_library <name>	Library named \"name\" will be re-exported (only useful for dylibs).
+
+sub_umbrella
+Driver RejectNegative Separate
+-sub_umbrella <name>	Framework named \"name\" will be re-exported (only useful for dylibs).
 
 twolevel_namespace
-Driver
+Driver RejectNegative
+This is the default
 
 twolevel_namespace_hints
-Driver
+Driver RejectNegative
+Specifies content that can speed up dynamic loading when the binaries are unchanged.
 
 umbrella
-Driver Separate Alias(Zumbrella)
+Driver RejectNegative Separate Alias(Zumbrella)
+-umbrella <framework>	The specified framework will be re-exported.
+
+undefined
+Driver RejectNegative Separate
+-undefined <treatment>	Specify the handling for undefined symbols (default is error).
 
 unexported_symbols_list
-Driver Separate Alias(Zunexported_symbols_list)
+Driver RejectNegative Separate Alias(Zunexported_symbols_list)
+-unexported_symbols_list <filename>	Don't export global symbols listed in filename.
 
 weak_reference_mismatches
-Driver Separate Alias(Zweak_reference_mismatches)
+Driver RejectNegative Separate Alias(Zweak_reference_mismatches)
+-weak_reference_mismatches <treatment>	Specifies what to do if a symbol import conflicts between file (weak in one and not in another) the default is to treat the symbol as non-weak.
 
 whatsloaded
-Driver
+Driver RejectNegative
+Logs the object files the linker loads
 
 whyload
-Driver
+Driver RejectNegative
+Logs which symbol(s) caused an object to be loaded.
+
+;(Obsolete, ignored)	Strip symbols starting with "L", this is the default.
+X
+Driver RejectNegative
 
 y
-Driver Joined
+Driver RejectNegative Joined
+(Obsolete, ignored)	Old support similar to whyload.
 
 Mach
-Driver
-
-Wnonportable-cfstrings
-Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
-Warn if constant CFString objects contain non-portable characters.
-
-; Use new-style pic stubs if this is true, x86 only so far.
-matt-stubs
-Target Report Var(darwin_macho_att_stub) Init(1)
-Generate AT&T-style stubs for Mach-O.
-
-mdynamic-no-pic
-Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
-Generate code suitable for executables (NOT shared libs).
-
-mfix-and-continue
-Target Report Var(darwin_fix_and_continue)
-Generate code suitable for fast turn around debugging.
-
-; The Init here is for the convenience of GCC developers, so that cc1
-; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
-; driver will always pass a -mmacosx-version-min, so in normal use the
-; Init is never used.
-mmacosx-version-min=
-Target Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
-The earliest MacOS X version on which this program will run.
-
-mone-byte-bool
-Target RejectNegative Report Var(darwin_one_byte_bool)
-Set sizeof(bool) to 1.
-
-fapple-kext
-Target Report C++ Var(flag_apple_kext)
-Generate code for darwin loadable kernel extensions.
-
-mkernel
-Target Report Var(flag_mkernel)
-Generate code for the kernel or loadable kernel extensions.
-
-iframework
-Target RejectNegative C ObjC C++ ObjC++ Joined Separate 
--iframework <dir>	Add <dir> to the end of the system framework include path.
+Driver RejectNegative
+(Obsolete and unhandled by ld64, ignored)	ld should produce an executable (only handled by ld_classic).
 
-X
-Driver
+;; These are not "real" options, but placeholders used to hide the real options
+;; from generic options processing... FIXME: they can be eliminated now.
 
 Zall_load
 Driver
@@ -343,62 +485,3 @@ Driver Separate
 Zweak_reference_mismatches
 Driver Separate
 
-client_name
-Driver Separate
-
-compatibility_version
-Driver Separate
-
-current_version
-Driver Separate
-
-dylinker_install_name
-Driver Separate
-
-pagezero_size
-Driver Separate
-
-read_only_relocs
-Driver Separate
-
-sectalign
-Driver Separate Args(3)
-
-sectcreate
-Driver Separate Args(3)
-
-sectobjectsymbols
-Driver Separate Args(2)
-
-sectorder
-Driver Separate Args(3)
-
-seg1addr
-Driver Separate
-
-segcreate
-Driver Separate Args(3)
-
-segprot
-Driver Separate Args(3)
-
-segs_read_only_addr
-Driver Separate
-
-segs_read_write_addr
-Driver Separate
-
-sub_library
-Driver Separate
-
-sub_umbrella
-Driver Separate
-
-; Certain aspects of code-gen may be improved / adjusted if the version of ld64
-; is sufficiently modern.
-mtarget-linker
-Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
-The version of ld64 in use for this toolchain.
-
-undefined
-Driver Separate
diff --git a/gcc/config/darwin10.h b/gcc/config/darwin10.h
index 07a2b465a04..a6d1eba6ebd 100644
--- a/gcc/config/darwin10.h
+++ b/gcc/config/darwin10.h
@@ -18,17 +18,12 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* Fix PR41260 by passing -no_compact_unwind on darwin10 and later until
-   unwinder in libSystem is fixed to digest new epilog unwinding notes.
+/* Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 
-   Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 #undef  LINK_GCC_C_SEQUENCE_SPEC
 #define LINK_GCC_C_SEQUENCE_SPEC \
-"%:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) \
- %{!static:%{!static-libgcc: \
+"%{!static:%{!static-libgcc: \
     %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
- %{fno-pic|fno-PIC|fno-pie|fno-PIE|fapple-kext|mkernel|static|mdynamic-no-pic: \
-   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) } \
  %{!nostdlib:%:version-compare(>< 10.6 10.7 mmacosx-version-min= -ld10-uwfef.o)} \
   %G %{!nolibc:%L}"
 
diff --git a/gcc/config/darwin9.h b/gcc/config/darwin9.h
index ca5c51718c8..1fd1604aed8 100644
--- a/gcc/config/darwin9.h
+++ b/gcc/config/darwin9.h
@@ -35,12 +35,6 @@ along with GCC; see the file COPYING3.  If not see
 /* Tell collect2 to run dsymutil for us as necessary.  */
 #define COLLECT_RUN_DSYMUTIL 1
 
-#undef DARWIN_PIE_SPEC
-#define DARWIN_PIE_SPEC \
-  "%{fpie|pie|fPIE: \
-     %{mdynamic-no-pic: %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
-      :-pie}}"
-
 /* Only ask as for debug data if the debug style is stabs (since as doesn't
    yet generate dwarf.)  */
 
diff --git a/gcc/config/i386/avx2intrin.h b/gcc/config/i386/avx2intrin.h
index 7606efdbf79..c9b6f9bc868 100644
--- a/gcc/config/i386/avx2intrin.h
+++ b/gcc/config/i386/avx2intrin.h
@@ -258,7 +258,7 @@ extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_cmpgt_epi8 (__m256i __A, __m256i __B)
 {
-  return (__m256i) ((__v32qi)__A > (__v32qi)__B);
+  return (__m256i) ((__v32qs)__A > (__v32qs)__B);
 }
 
 extern __inline __m256i
@@ -1736,10 +1736,10 @@ _mm256_mask_i64gather_epi32 (__m128i __src, int const *__base,
 					(int)SCALE)
 
 #define _mm_mask_i32gather_ps(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m128) __builtin_ia32_gathersiv4sf ((__v4sf)(__m128d)SRC,	 \
+  (__m128) __builtin_ia32_gathersiv4sf ((__v4sf)(__m128)SRC,	 \
 					(float const *)BASE,	 \
 					(__v4si)(__m128i)INDEX,	 \
-					(__v4sf)(__m128d)MASK,	 \
+					(__v4sf)(__m128)MASK,	 \
 					(int)SCALE)
 
 #define _mm256_i32gather_ps(BASE, INDEX, SCALE)			       \
@@ -1754,7 +1754,7 @@ _mm256_mask_i64gather_epi32 (__m128i __src, int const *__base,
   (__m256) __builtin_ia32_gathersiv8sf ((__v8sf)(__m256)SRC,	\
 					(float const *)BASE,	\
 					(__v8si)(__m256i)INDEX, \
-					(__v8sf)(__m256d)MASK,	\
+					(__v8sf)(__m256)MASK,	\
 					(int)SCALE)
 
 #define _mm_i64gather_ps(BASE, INDEX, SCALE)				\
@@ -1769,7 +1769,7 @@ _mm256_mask_i64gather_epi32 (__m128i __src, int const *__base,
   (__m128) __builtin_ia32_gatherdiv4sf ((__v4sf)(__m128)SRC,	 \
 					(float const *)BASE,	 \
 					(__v2di)(__m128i)INDEX,	 \
-					(__v4sf)(__m128d)MASK,	 \
+					(__v4sf)(__m128)MASK,	 \
 					(int)SCALE)
 
 #define _mm256_i64gather_ps(BASE, INDEX, SCALE)				\
diff --git a/gcc/config/i386/avx512bitalgintrin.h b/gcc/config/i386/avx512bitalgintrin.h
index 8b4fc8e3f67..8ad8586cc59 100644
--- a/gcc/config/i386/avx512bitalgintrin.h
+++ b/gcc/config/i386/avx512bitalgintrin.h
@@ -61,10 +61,10 @@ _mm512_popcnt_epi16 (__m512i __A)
 
 extern __inline __m512i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_popcnt_epi8 (__m512i __A, __mmask64 __U, __m512i __B)
+_mm512_mask_popcnt_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
 {
   return (__m512i) __builtin_ia32_vpopcountb_v64qi_mask ((__v64qi) __A,
-							 (__v64qi) __B,
+							 (__v64qi) __W,
 							 (__mmask64) __U);
 }
 
@@ -79,10 +79,10 @@ _mm512_maskz_popcnt_epi8 (__mmask64 __U, __m512i __A)
 }
 extern __inline __m512i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_popcnt_epi16 (__m512i __A, __mmask32 __U, __m512i __B)
+_mm512_mask_popcnt_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
 {
   return (__m512i) __builtin_ia32_vpopcountw_v32hi_mask ((__v32hi) __A,
-							(__v32hi) __B,
+							(__v32hi) __W,
 							(__mmask32) __U);
 }
 
@@ -127,10 +127,10 @@ _mm512_mask_bitshuffle_epi64_mask (__mmask64 __M, __m512i __A, __m512i __B)
 
 extern __inline __m256i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_mask_popcnt_epi8 (__m256i __A, __mmask32 __U, __m256i __B)
+_mm256_mask_popcnt_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
 {
   return (__m256i) __builtin_ia32_vpopcountb_v32qi_mask ((__v32qi) __A,
-							 (__v32qi) __B,
+							 (__v32qi) __W,
 							 (__mmask32) __U);
 }
 
@@ -222,10 +222,10 @@ _mm_popcnt_epi16 (__m128i __A)
 
 extern __inline __m256i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_mask_popcnt_epi16 (__m256i __A, __mmask16 __U, __m256i __B)
+_mm256_mask_popcnt_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
 {
   return (__m256i) __builtin_ia32_vpopcountw_v16hi_mask ((__v16hi) __A,
-							(__v16hi) __B,
+							(__v16hi) __W,
 							(__mmask16) __U);
 }
 
@@ -241,10 +241,10 @@ _mm256_maskz_popcnt_epi16 (__mmask16 __U, __m256i __A)
 
 extern __inline __m128i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_popcnt_epi8 (__m128i __A, __mmask16 __U, __m128i __B)
+_mm_mask_popcnt_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
 {
   return (__m128i) __builtin_ia32_vpopcountb_v16qi_mask ((__v16qi) __A,
-							 (__v16qi) __B,
+							 (__v16qi) __W,
 							 (__mmask16) __U);
 }
 
@@ -259,10 +259,10 @@ _mm_maskz_popcnt_epi8 (__mmask16 __U, __m128i __A)
 }
 extern __inline __m128i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_popcnt_epi16 (__m128i __A, __mmask8 __U, __m128i __B)
+_mm_mask_popcnt_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
 {
   return (__m128i) __builtin_ia32_vpopcountw_v8hi_mask ((__v8hi) __A,
-							(__v8hi) __B,
+							(__v8hi) __W,
 							(__mmask8) __U);
 }
 
diff --git a/gcc/config/i386/avx512vbmi2intrin.h b/gcc/config/i386/avx512vbmi2intrin.h
index 2b1e3386618..09ef064eefa 100644
--- a/gcc/config/i386/avx512vbmi2intrin.h
+++ b/gcc/config/i386/avx512vbmi2intrin.h
@@ -151,50 +151,68 @@ _mm512_maskz_shldi_epi64 (__mmask8 __A, __m512i __B, __m512i __C, int __D)
 #else
 #define _mm512_shrdi_epi16(A, B, C) \
   ((__m512i) __builtin_ia32_vpshrd_v32hi ((__v32hi)(__m512i)(A), \
-						(__v32hi)(__m512i)(B),(int)(C))
+					  (__v32hi)(__m512i)(B),(int)(C)))
 #define _mm512_shrdi_epi32(A, B, C) \
   ((__m512i) __builtin_ia32_vpshrd_v16si ((__v16si)(__m512i)(A), \
-	(__v16si)(__m512i)(B),(int)(C))
+					  (__v16si)(__m512i)(B),(int)(C)))
 #define _mm512_mask_shrdi_epi32(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshrd_v16si_mask ((__v16si)(__m512i)(C), \
-	(__v16si)(__m512i)(D), (int)(E), (__v16si)(__m512i)(A),(__mmask16)(B))
+					       (__v16si)(__m512i)(D), \
+					       (int)(E),		\
+					       (__v16si)(__m512i)(A),	\
+					       (__mmask16)(B)))
 #define _mm512_maskz_shrdi_epi32(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshrd_v16si_mask ((__v16si)(__m512i)(B), \
-	(__v16si)(__m512i)(C),(int)(D), \
-	(__v16si)(__m512i)_mm512_setzero_si512 (), (__mmask16)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshrd_v16si_mask ((__v16si)(__m512i)(B),		\
+				     (__v16si)(__m512i)(C),(int)(D),	\
+				     (__v16si)(__m512i)_mm512_setzero_si512 (), \
+				     (__mmask16)(A)))
 #define _mm512_shrdi_epi64(A, B, C) \
   ((__m512i) __builtin_ia32_vpshrd_v8di ((__v8di)(__m512i)(A), \
-	(__v8di)(__m512i)(B),(int)(C))
+					 (__v8di)(__m512i)(B),(int)(C)))
 #define _mm512_mask_shrdi_epi64(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshrd_v8di_mask ((__v8di)(__m512i)(C), \
-	(__v8di)(__m512i)(D), (int)(E), (__v8di)(__m512i)(A),(__mmask8)(B))
+					      (__v8di)(__m512i)(D), (int)(E), \
+					      (__v8di)(__m512i)(A), \
+					      (__mmask8)(B)))
 #define _mm512_maskz_shrdi_epi64(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshrd_v8di_mask ((__v8di)(__m512i)(B), \
-	(__v8di)(__m512i)(C),(int)(D), \
-	(__v8di)(__m512i)_mm512_setzero_si512 (), (__mmask8)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshrd_v8di_mask ((__v8di)(__m512i)(B),		\
+				    (__v8di)(__m512i)(C),(int)(D),	\
+				    (__v8di)(__m512i)_mm512_setzero_si512 (), \
+				    (__mmask8)(A)))
 #define _mm512_shldi_epi16(A, B, C) \
   ((__m512i) __builtin_ia32_vpshld_v32hi ((__v32hi)(__m512i)(A), \
-						(__v32hi)(__m512i)(B),(int)(C))
+					  (__v32hi)(__m512i)(B),(int)(C)))
 #define _mm512_shldi_epi32(A, B, C) \
-  ((__m512i) __builtin_ia32_vpshld_v16si ((__v16si)(__m512i)(A), 	\
-				(__v16si)(__m512i)(B),(int)(C))
+  ((__m512i) __builtin_ia32_vpshld_v16si ((__v16si)(__m512i)(A),	\
+					  (__v16si)(__m512i)(B),(int)(C)))
 #define _mm512_mask_shldi_epi32(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshld_v16si_mask ((__v16si)(__m512i)(C), \
-	(__v16si)(__m512i)(D), (int)(E), (__v16si)(__m512i)(A),(__mmask16)(B))
+					       (__v16si)(__m512i)(D), \
+					       (int)(E),		\
+					       (__v16si)(__m512i)(A), \
+					       (__mmask16)(B)))
 #define _mm512_maskz_shldi_epi32(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshld_v16si_mask ((__v16si)(__m512i)(B), \
-	(__v16si)(__m512i)(C),(int)(D), \
-	(__v16si)(__m512i)_mm512_setzero_si512 (), (__mmask16)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshld_v16si_mask ((__v16si)(__m512i)(B),		\
+				     (__v16si)(__m512i)(C),(int)(D),	\
+				     (__v16si)(__m512i)_mm512_setzero_si512 (), \
+				     (__mmask16)(A)))
 #define _mm512_shldi_epi64(A, B, C) \
   ((__m512i) __builtin_ia32_vpshld_v8di ((__v8di)(__m512i)(A), \
-	(__v8di)(__m512i)(B),(int)(C))
+					 (__v8di)(__m512i)(B), (int)(C)))
 #define _mm512_mask_shldi_epi64(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshld_v8di_mask ((__v8di)(__m512i)(C), \
-	(__v8di)(__m512i)(D), (int)(E), (__v8di)(__m512i)(A),(__mmask8)(B))
+					      (__v8di)(__m512i)(D), (int)(E), \
+					      (__v8di)(__m512i)(A), \
+					      (__mmask8)(B)))
 #define _mm512_maskz_shldi_epi64(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshld_v8di_mask ((__v8di)(__m512i)(B), \
-	(__v8di)(__m512i)(C),(int)(D), \
-	(__v8di)(__m512i)_mm512_setzero_si512 (), (__mmask8)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshld_v8di_mask ((__v8di)(__m512i)(B),		\
+				    (__v8di)(__m512i)(C),(int)(D),	\
+				    (__v8di)(__m512i)_mm512_setzero_si512 (), \
+				    (__mmask8)(A)))
 #endif
 
 extern __inline __m512i
@@ -474,18 +492,28 @@ _mm512_maskz_shldi_epi16 (__mmask32 __A, __m512i __B, __m512i __C, int __D)
 #else
 #define _mm512_mask_shrdi_epi16(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshrd_v32hi_mask ((__v32hi)(__m512i)(C), \
-	(__v32hi)(__m512i)(D), (int)(E), (__v32hi)(__m512i)(A),(__mmask32)(B))
+					       (__v32hi)(__m512i)(D), \
+					       (int)(E),		\
+					       (__v32hi)(__m512i)(A),	\
+					       (__mmask32)(B)))
 #define _mm512_maskz_shrdi_epi16(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshrd_v32hi_mask ((__v32hi)(__m512i)(B), \
-	(__v32hi)(__m512i)(C),(int)(D), \
-	(__v32hi)(__m512i)_mm512_setzero_si512 (), (__mmask32)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshrd_v32hi_mask ((__v32hi)(__m512i)(B),		\
+				     (__v32hi)(__m512i)(C),(int)(D),	\
+				     (__v32hi)(__m512i)_mm512_setzero_si512 (), \
+				     (__mmask32)(A)))
 #define _mm512_mask_shldi_epi16(A, B, C, D, E) \
   ((__m512i) __builtin_ia32_vpshld_v32hi_mask ((__v32hi)(__m512i)(C), \
-	(__v32hi)(__m512i)(D), (int)(E), (__v32hi)(__m512i)(A),(__mmask32)(B))
+					       (__v32hi)(__m512i)(D), \
+					       (int)(E), \
+					       (__v32hi)(__m512i)(A),	\
+					       (__mmask32)(B)))
 #define _mm512_maskz_shldi_epi16(A, B, C, D) \
-  ((__m512i) __builtin_ia32_vpshld_v32hi_mask ((__v32hi)(__m512i)(B),   \
-	(__v32hi)(__m512i)(C),(int)(D), 				\
-	(__v32hi)(__m512i)_mm512_setzero_si512 (), (__mmask32)(A))
+  ((__m512i) \
+   __builtin_ia32_vpshld_v32hi_mask ((__v32hi)(__m512i)(B),		\
+				     (__v32hi)(__m512i)(C),(int)(D),	\
+				     (__v32hi)(__m512i)_mm512_setzero_si512 (), \
+				     (__mmask32)(A)))
 #endif
 
 extern __inline __m512i
diff --git a/gcc/config/i386/avx512vbmi2vlintrin.h b/gcc/config/i386/avx512vbmi2vlintrin.h
index d1276c8e0f2..cc4579faea4 100644
--- a/gcc/config/i386/avx512vbmi2vlintrin.h
+++ b/gcc/config/i386/avx512vbmi2vlintrin.h
@@ -498,124 +498,175 @@ _mm_shldi_epi64 (__m128i __A, __m128i __B, int __C)
 #else
 #define _mm256_shrdi_epi16(A, B, C) \
   ((__m256i) __builtin_ia32_vpshrd_v16hi ((__v16hi)(__m256i)(A), \
-	(__v16hi)(__m256i)(B),(int)(C))
+					  (__v16hi)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shrdi_epi16(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshrd_v16hi_mask ((__v16hi)(__m256i)(C), \
-	(__v16hi)(__m256i)(D), (int)(E), (__v16hi)(__m256i)(A),(__mmask16)(B))
+					       (__v16hi)(__m256i)(D), \
+					       (int)(E),		\
+					       (__v16hi)(__m256i)(A), \
+					       (__mmask16)(B)))
 #define _mm256_maskz_shrdi_epi16(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshrd_v16hi_mask ((__v16hi)(__m256i)(B), \
-	(__v16hi)(__m256i)(C),(int)(D), \
-	(__v16hi)(__m256i)_mm256_setzero_si256 (), (__mmask16)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshrd_v16hi_mask ((__v16hi)(__m256i)(B),		\
+				     (__v16hi)(__m256i)(C),(int)(D),	\
+				     (__v16hi)(__m256i)_mm256_setzero_si256 (), \
+				     (__mmask16)(A)))
 #define _mm256_shrdi_epi32(A, B, C) \
   ((__m256i) __builtin_ia32_vpshrd_v8si ((__v8si)(__m256i)(A), \
-	(__v8si)(__m256i)(B),(int)(C))
+					 (__v8si)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shrdi_epi32(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshrd_v8si_mask ((__v8si)(__m256i)(C), \
-	(__v8si)(__m256i)(D), (int)(E), (__v8si)(__m256i)(A),(__mmask8)(B))
+					      (__v8si)(__m256i)(D), \
+					      (int)(E), \
+					      (__v8si)(__m256i)(A), \
+					      (__mmask8)(B)))
 #define _mm256_maskz_shrdi_epi32(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshrd_v8si_mask ((__v8si)(__m256i)(B), \
-	(__v8si)(__m256i)(C),(int)(D), \
-	(__v8si)(__m256i)_mm256_setzero_si256 (), (__mmask8)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshrd_v8si_mask ((__v8si)(__m256i)(B),		\
+				    (__v8si)(__m256i)(C),(int)(D),	\
+				    (__v8si)(__m256i)_mm256_setzero_si256 (), \
+				    (__mmask8)(A)))
 #define _mm256_shrdi_epi64(A, B, C) \
   ((__m256i) __builtin_ia32_vpshrd_v4di ((__v4di)(__m256i)(A), \
-	(__v4di)(__m256i)(B),(int)(C))
+					 (__v4di)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shrdi_epi64(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshrd_v4di_mask ((__v4di)(__m256i)(C), \
-	(__v4di)(__m256i)(D), (int)(E), (__v4di)(__m256i)(A),(__mmask8)(B))
+					      (__v4di)(__m256i)(D), (int)(E), \
+					      (__v4di)(__m256i)(A), \
+					      (__mmask8)(B)))
 #define _mm256_maskz_shrdi_epi64(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshrd_v4di_mask ((__v4di)(__m256i)(B), \
-	(__v4di)(__m256i)(C),(int)(D), \
-	(__v4di)(__m256i)_mm256_setzero_si256 (), (__mmask8)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshrd_v4di_mask ((__v4di)(__m256i)(B),		\
+				    (__v4di)(__m256i)(C),(int)(D),	\
+				    (__v4di)(__m256i)_mm256_setzero_si256 (), \
+				    (__mmask8)(A)))
 #define _mm_shrdi_epi16(A, B, C) \
   ((__m128i) __builtin_ia32_vpshrd_v8hi ((__v8hi)(__m128i)(A), \
-	(__v8hi)(__m128i)(B),(int)(C))
+					 (__v8hi)(__m128i)(B),(int)(C)))
 #define _mm_mask_shrdi_epi16(A, B, C, D, E) \
   ((__m128i) __builtin_ia32_vpshrd_v8hi_mask ((__v8hi)(__m128i)(C), \
-	(__v8hi)(__m128i)(D), (int)(E), (__v8hi)(__m128i)(A),(__mmask8)(B))
+					      (__v8hi)(__m128i)(D), (int)(E), \
+					      (__v8hi)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shrdi_epi16(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshrd_v8hi_mask ((__v8hi)(__m128i)(B), \
-	(__v8hi)(__m128i)(C),(int)(D), \
-	(__v8hi)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshrd_v8hi_mask ((__v8hi)(__m128i)(B),		\
+				    (__v8hi)(__m128i)(C),(int)(D),	\
+				    (__v8hi)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #define _mm_shrdi_epi32(A, B, C) \
   ((__m128i) __builtin_ia32_vpshrd_v4si ((__v4si)(__m128i)(A), \
-	(__v4si)(__m128i)(B),(int)(C))
+					 (__v4si)(__m128i)(B),(int)(C)))
 #define _mm_mask_shrdi_epi32(A, B, C, D, E) \
-  ((__m128i) __builtin_ia32_vpshrd_v4si_mask ((__v4si)(__m128i)(C), \
-	(__v4si)(__m128i)(D), (int)(E), (__v4si)(__m128i)(A),(__mmask8)(B))
+  ((__m128i) __builtin_ia32_vpshrd_v4si_mask ((__v4si)(__m128i)(C),	\
+					      (__v4si)(__m128i)(D), (int)(E), \
+					      (__v4si)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shrdi_epi32(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshrd_v4si_mask ((__v4si)(__m128i)(B), \
-	(__v4si)(__m128i)(C),(int)(D), \
-	(__v4si)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshrd_v4si_mask ((__v4si)(__m128i)(B),		\
+				    (__v4si)(__m128i)(C),(int)(D),	\
+				    (__v4si)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #define _mm_shrdi_epi64(A, B, C) \
   ((__m128i) __builtin_ia32_vpshrd_v2di ((__v2di)(__m128i)(A), \
-	(__v2di)(__m128i)(B),(int)(C))
+					 (__v2di)(__m128i)(B),(int)(C)))
 #define _mm_mask_shrdi_epi64(A, B, C, D, E) \
   ((__m128i) __builtin_ia32_vpshrd_v2di_mask ((__v2di)(__m128i)(C), \
-	(__v2di)(__m128i)(D), (int)(E), (__v2di)(__m128i)(A),(__mmask8)(B))
+					      (__v2di)(__m128i)(D), (int)(E), \
+					      (__v2di)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shrdi_epi64(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshrd_v2di_mask ((__v2di)(__m128i)(B), \
-	(__v2di)(__m128i)(C),(int)(D), \
-	(__v2di)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshrd_v2di_mask ((__v2di)(__m128i)(B),		\
+				    (__v2di)(__m128i)(C),(int)(D),	\
+				    (__v2di)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #define _mm256_shldi_epi16(A, B, C) \
   ((__m256i) __builtin_ia32_vpshld_v16hi ((__v16hi)(__m256i)(A), \
-						(__v16hi)(__m256i)(B),(int)(C))
+					  (__v16hi)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shldi_epi16(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshld_v16hi_mask ((__v16hi)(__m256i)(C), \
-	(__v16hi)(__m256i)(D), (int)(E), (__v16hi)(__m256i)(A),(__mmask16)(B))
+					       (__v16hi)(__m256i)(D), \
+					       (int)(E),		\
+					       (__v16hi)(__m256i)(A), \
+					       (__mmask16)(B)))
 #define _mm256_maskz_shldi_epi16(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshld_v16hi_mask ((__v16hi)(__m256i)(B), \
-	(__v16hi)(__m256i)(C),(int)(D), \
-	(__v16hi)(__m256i)_mm256_setzero_si256 (), (__mmask16)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshld_v16hi_mask ((__v16hi)(__m256i)(B),		\
+				     (__v16hi)(__m256i)(C),(int)(D),	\
+				     (__v16hi)(__m256i)_mm256_setzero_si256 (), \
+				     (__mmask16)(A)))
 #define _mm256_shldi_epi32(A, B, C) \
   ((__m256i) __builtin_ia32_vpshld_v8si ((__v8si)(__m256i)(A), \
-	(__v8si)(__m256i)(B),(int)(C))
+					 (__v8si)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shldi_epi32(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshld_v8si_mask ((__v8si)(__m256i)(C), \
-	(__v8si)(__m256i)(D), (int)(E), (__v8si)(__m256i)(A),(__mmask8)(B))
+					      (__v8si)(__m256i)(D), (int)(E), \
+					      (__v8si)(__m256i)(A), \
+					      (__mmask8)(B)))
 #define _mm256_maskz_shldi_epi32(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshld_v8si_mask ((__v8si)(__m256i)(B), \
-	(__v8si)(__m256i)(C),(int)(D), \
-	(__v8si)(__m256i)_mm256_setzero_si256 (), (__mmask8)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshld_v8si_mask ((__v8si)(__m256i)(B),		\
+				    (__v8si)(__m256i)(C),(int)(D),	\
+				    (__v8si)(__m256i)_mm256_setzero_si256 (), \
+				    (__mmask8)(A)))
 #define _mm256_shldi_epi64(A, B, C) \
   ((__m256i) __builtin_ia32_vpshld_v4di ((__v4di)(__m256i)(A), \
-	(__v4di)(__m256i)(B),(int)(C))
+					 (__v4di)(__m256i)(B),(int)(C)))
 #define _mm256_mask_shldi_epi64(A, B, C, D, E) \
   ((__m256i) __builtin_ia32_vpshld_v4di_mask ((__v4di)(__m256i)(C), \
-	(__v4di)(__m256i)(D), (int)(E), (__v4di)(__m256i)(A),(__mmask8)(B))
+					      (__v4di)(__m256i)(D), (int)(E), \
+					      (__v4di)(__m256i)(A), \
+					      (__mmask8)(B)))
 #define _mm256_maskz_shldi_epi64(A, B, C, D) \
-  ((__m256i) __builtin_ia32_vpshld_v4di_mask ((__v4di)(__m256i)(B), \
-	(__v4di)(__m256i)(C),(int)(D), \
-	(__v4di)(__m256i)_mm256_setzero_si256 (), (__mmask8)(A))
+  ((__m256i) \
+   __builtin_ia32_vpshld_v4di_mask ((__v4di)(__m256i)(B),		\
+				    (__v4di)(__m256i)(C),(int)(D),	\
+				    (__v4di)(__m256i)_mm256_setzero_si256 (), \
+				    (__mmask8)(A)))
 #define _mm_shldi_epi16(A, B, C) \
   ((__m128i) __builtin_ia32_vpshld_v8hi ((__v8hi)(__m128i)(A), \
-	(__v8hi)(__m128i)(B),(int)(C))
+					 (__v8hi)(__m128i)(B),(int)(C)))
 #define _mm_mask_shldi_epi16(A, B, C, D, E) \
   ((__m128i) __builtin_ia32_vpshld_v8hi_mask ((__v8hi)(__m128i)(C), \
-	(__v8hi)(__m128i)(D), (int)(E), (__v8hi)(__m128i)(A),(__mmask8)(B))
+					      (__v8hi)(__m128i)(D), (int)(E), \
+					      (__v8hi)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shldi_epi16(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshld_v8hi_mask ((__v8hi)(__m128i)(B), \
-	(__v8hi)(__m128i)(C),(int)(D), \
-	(__v8hi)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshld_v8hi_mask ((__v8hi)(__m128i)(B),		\
+				    (__v8hi)(__m128i)(C),(int)(D),	\
+				    (__v8hi)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #define _mm_shldi_epi32(A, B, C) \
   ((__m128i) __builtin_ia32_vpshld_v4si ((__v4si)(__m128i)(A), \
-	(__v4si)(__m128i)(B),(int)(C))
+					 (__v4si)(__m128i)(B),(int)(C)))
 #define _mm_mask_shldi_epi32(A, B, C, D, E) \
   ((__m128i) __builtin_ia32_vpshld_v4si_mask ((__v4si)(__m128i)(C), \
-	(__v4si)(__m128i)(D), (int)(E), (__v4si)(__m128i)(A),(__mmask8)(B))
+					      (__v4si)(__m128i)(D), (int)(E), \
+					      (__v4si)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shldi_epi32(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshld_v4si_mask ((__v4si)(__m128i)(B), \
-	(__v4si)(__m128i)(C),(int)(D), \
-	(__v4si)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshld_v4si_mask ((__v4si)(__m128i)(B),		\
+				    (__v4si)(__m128i)(C),(int)(D),	\
+				    (__v4si)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #define _mm_shldi_epi64(A, B, C) \
   ((__m128i) __builtin_ia32_vpshld_v2di ((__v2di)(__m128i)(A), \
-	(__v2di)(__m128i)(B),(int)(C))
+					 (__v2di)(__m128i)(B),(int)(C)))
 #define _mm_mask_shldi_epi64(A, B, C, D, E) \
   ((__m128i) __builtin_ia32_vpshld_v2di_mask ((__v2di)(__m128i)(C), \
-	(__v2di)(__m128i)(D), (int)(E), (__v2di)(__m128i)(A),(__mmask8)(B))
+					      (__v2di)(__m128i)(D), (int)(E), \
+					      (__v2di)(__m128i)(A), \
+					      (__mmask8)(B)))
 #define _mm_maskz_shldi_epi64(A, B, C, D) \
-  ((__m128i) __builtin_ia32_vpshld_v2di_mask ((__v2di)(__m128i)(B), \
-	(__v2di)(__m128i)(C),(int)(D), \
-	(__v2di)(__m128i)_mm_setzero_si128 (), (__mmask8)(A))
+  ((__m128i) \
+   __builtin_ia32_vpshld_v2di_mask ((__v2di)(__m128i)(B),		\
+				    (__v2di)(__m128i)(C),(int)(D),	\
+				    (__v2di)(__m128i)_mm_setzero_si128 (), \
+				    (__mmask8)(A)))
 #endif
 
 extern __inline __m256i
diff --git a/gcc/config/i386/avx512vpopcntdqintrin.h b/gcc/config/i386/avx512vpopcntdqintrin.h
index 3569430baa7..119bdf41887 100644
--- a/gcc/config/i386/avx512vpopcntdqintrin.h
+++ b/gcc/config/i386/avx512vpopcntdqintrin.h
@@ -43,10 +43,10 @@ _mm512_popcnt_epi32 (__m512i __A)
 
 extern __inline __m512i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_popcnt_epi32 (__m512i __A, __mmask16 __U, __m512i __B)
+_mm512_mask_popcnt_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
 {
   return (__m512i) __builtin_ia32_vpopcountd_v16si_mask ((__v16si) __A,
-							 (__v16si) __B,
+							 (__v16si) __W,
 							 (__mmask16) __U);
 }
 
@@ -69,10 +69,10 @@ _mm512_popcnt_epi64 (__m512i __A)
 
 extern __inline __m512i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_popcnt_epi64 (__m512i __A, __mmask8 __U, __m512i __B)
+_mm512_mask_popcnt_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
 {
   return (__m512i) __builtin_ia32_vpopcountq_v8di_mask ((__v8di) __A,
-							(__v8di) __B,
+							(__v8di) __W,
 							(__mmask8) __U);
 }
 
diff --git a/gcc/config/i386/avx512vpopcntdqvlintrin.h b/gcc/config/i386/avx512vpopcntdqvlintrin.h
index b974d09338a..2765592f0ae 100644
--- a/gcc/config/i386/avx512vpopcntdqvlintrin.h
+++ b/gcc/config/i386/avx512vpopcntdqvlintrin.h
@@ -43,10 +43,10 @@ _mm_popcnt_epi32 (__m128i __A)
 
 extern __inline __m128i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_popcnt_epi32 (__m128i __A, __mmask16 __U, __m128i __B)
+_mm_mask_popcnt_epi32 (__m128i __W, __mmask16 __U, __m128i __A)
 {
   return (__m128i) __builtin_ia32_vpopcountd_v4si_mask ((__v4si) __A,
-							 (__v4si) __B,
+							 (__v4si) __W,
 							 (__mmask16) __U);
 }
 
@@ -69,10 +69,10 @@ _mm256_popcnt_epi32 (__m256i __A)
 
 extern __inline __m256i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_mask_popcnt_epi32 (__m256i __A, __mmask16 __U, __m256i __B)
+_mm256_mask_popcnt_epi32 (__m256i __W, __mmask16 __U, __m256i __A)
 {
   return (__m256i) __builtin_ia32_vpopcountd_v8si_mask ((__v8si) __A,
-							 (__v8si) __B,
+							 (__v8si) __W,
 							 (__mmask16) __U);
 }
 
@@ -95,10 +95,10 @@ _mm_popcnt_epi64 (__m128i __A)
 
 extern __inline __m128i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_popcnt_epi64 (__m128i __A, __mmask8 __U, __m128i __B)
+_mm_mask_popcnt_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
 {
   return (__m128i) __builtin_ia32_vpopcountq_v2di_mask ((__v2di) __A,
-							(__v2di) __B,
+							(__v2di) __W,
 							(__mmask8) __U);
 }
 
@@ -121,10 +121,10 @@ _mm256_popcnt_epi64 (__m256i __A)
 
 extern __inline __m256i
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_mask_popcnt_epi64 (__m256i __A, __mmask8 __U, __m256i __B)
+_mm256_mask_popcnt_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
 {
   return (__m256i) __builtin_ia32_vpopcountq_v4di_mask ((__v4di) __A,
-							(__v4di) __B,
+							(__v4di) __W,
 							(__mmask8) __U);
 }
 
@@ -144,4 +144,3 @@ _mm256_maskz_popcnt_epi64 (__mmask8 __U, __m256i __A)
 #endif /* __DISABLE_AVX512VPOPCNTDQVL__ */
 
 #endif /* _AVX512VPOPCNTDQVLINTRIN_H_INCLUDED */
-
diff --git a/gcc/config/i386/avxintrin.h b/gcc/config/i386/avxintrin.h
index 29115a11a0d..3301451e4de 100644
--- a/gcc/config/i386/avxintrin.h
+++ b/gcc/config/i386/avxintrin.h
@@ -47,6 +47,7 @@ typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
 typedef short __v16hi __attribute__ ((__vector_size__ (32)));
 typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
 typedef char __v32qi __attribute__ ((__vector_size__ (32)));
+typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));
 typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));
 
 /* The Intel API is flexible enough that we must allow aliasing with other
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
index 1e96350fa71..bdb36f00959 100644
--- a/gcc/config/i386/darwin.h
+++ b/gcc/config/i386/darwin.h
@@ -90,14 +90,12 @@ along with GCC; see the file COPYING3.  If not see
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
-#undef TARGET_MACHO_BRANCH_ISLANDS
-#define TARGET_MACHO_BRANCH_ISLANDS darwin_emit_branch_islands
+/* Generate pic symbol indirection stubs if this is true.  */
+#undef TARGET_MACHO_SYMBOL_STUBS
+#define TARGET_MACHO_SYMBOL_STUBS (darwin_symbol_stubs)
 
 /* For compatibility with OSX system tools, use the new style of pic stub
-   if this is set.  */
+   if this is set (default).  */
 #undef  MACHOPIC_ATT_STUB
 #define MACHOPIC_ATT_STUB (darwin_macho_att_stub)
 
@@ -245,7 +243,7 @@ extern int darwin_emit_branch_islands;
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO)				\
   do {									\
-    if (TARGET_MACHO_BRANCH_ISLANDS 					\
+    if (TARGET_MACHO_SYMBOL_STUBS 					\
 	&& MACHOPIC_INDIRECT && !TARGET_64BIT)				\
       {									\
 	const char *name = machopic_mcount_stub_name ();		\
@@ -326,10 +324,8 @@ extern int darwin_emit_branch_islands;
         }								\
     }
 
-/* This needs to move since i386 uses the first flag and other flags are
-   used in Mach-O.  */
-#undef MACHO_SYMBOL_FLAG_VARIABLE
-#define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP << 5)
 
 #undef MACHOPIC_NL_SYMBOL_PTR_SECTION
 #define MACHOPIC_NL_SYMBOL_PTR_SECTION \
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
index f9e7b33b0dd..1683d842c65 100644
--- a/gcc/config/i386/emmintrin.h
+++ b/gcc/config/i386/emmintrin.h
@@ -1308,7 +1308,7 @@ _mm_xor_si128 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qs)__A == (__v16qs)__B);
+  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index 6580890edc0..5dedeb2d18b 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -818,11 +818,11 @@ BDESC (OPTION_MASK_ISA_SSE3, 0, CODE_FOR_sse3_hsubv2df3, "__builtin_ia32_hsubpd"
 
 /* SSSE3 */
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv16qi2, "__builtin_ia32_pabsb128", IX86_BUILTIN_PABSB128, UNKNOWN, (int) V16QI_FTYPE_V16QI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv8hi2, "__builtin_ia32_pabsw128", IX86_BUILTIN_PABSW128, UNKNOWN, (int) V8HI_FTYPE_V8HI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv4si2, "__builtin_ia32_pabsd128", IX86_BUILTIN_PABSD128, UNKNOWN, (int) V4SI_FTYPE_V4SI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
 
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_ssse3_phaddwv8hi3, "__builtin_ia32_phaddw128", IX86_BUILTIN_PHADDW128, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI)
 BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_phaddwv4hi3, "__builtin_ia32_phaddw", IX86_BUILTIN_PHADDW, UNKNOWN, (int) V4HI_FTYPE_V4HI_V4HI)
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 2b37296e537..1bca5a7eea6 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -5423,7 +5423,25 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],
 	      ret = false;
 	    }
 	  else
-	    p_strings[opt] = xstrdup (p + opt_len);
+	    {
+	      p_strings[opt] = xstrdup (p + opt_len);
+	      if (opt == IX86_FUNCTION_SPECIFIC_ARCH)
+		{
+		  /* If arch= is set,  clear all bits in x_ix86_isa_flags,
+		     except for ISA_64BIT, ABI_64, ABI_X32, and CODE16
+		     and all bits in x_ix86_isa_flags2.  */
+		  opts->x_ix86_isa_flags &= (OPTION_MASK_ISA_64BIT
+					     | OPTION_MASK_ABI_64
+					     | OPTION_MASK_ABI_X32
+					     | OPTION_MASK_CODE16);
+		  opts->x_ix86_isa_flags_explicit &= (OPTION_MASK_ISA_64BIT
+						      | OPTION_MASK_ABI_64
+						      | OPTION_MASK_ABI_X32
+						      | OPTION_MASK_CODE16);
+		  opts->x_ix86_isa_flags2 = 0;
+		  opts->x_ix86_isa_flags2_explicit = 0;
+		}
+	    }
 	}
 
       else if (type == ix86_opt_enum)
@@ -5498,18 +5516,8 @@ ix86_valid_target_attribute_tree (tree args,
       /* If we are using the default tune= or arch=, undo the string assigned,
 	 and use the default.  */
       if (option_strings[IX86_FUNCTION_SPECIFIC_ARCH])
-	{
-	  opts->x_ix86_arch_string
-	    = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_ARCH]);
-
-	  /* If arch= is set,  clear all bits in x_ix86_isa_flags,
-	     except for ISA_64BIT, ABI_64, ABI_X32, and CODE16.  */
-	  opts->x_ix86_isa_flags &= (OPTION_MASK_ISA_64BIT
-				     | OPTION_MASK_ABI_64
-				     | OPTION_MASK_ABI_X32
-				     | OPTION_MASK_CODE16);
-	  opts->x_ix86_isa_flags2 = 0;
-	}
+	opts->x_ix86_arch_string
+	  = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_ARCH]);
       else if (!orig_arch_specified)
 	opts->x_ix86_arch_string = NULL;
 
@@ -8657,7 +8665,7 @@ function_arg_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,
 
 static rtx
 function_arg_ms_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,
-		    machine_mode orig_mode, bool named,
+		    machine_mode orig_mode, bool named, const_tree type,
 		    HOST_WIDE_INT bytes)
 {
   unsigned int regno;
@@ -8677,7 +8685,10 @@ function_arg_ms_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,
   if (TARGET_SSE && (mode == SFmode || mode == DFmode))
     {
       if (named)
-	regno = cum->regno + FIRST_SSE_REG;
+	{
+	  if (type == NULL_TREE || !AGGREGATE_TYPE_P (type))
+	    regno = cum->regno + FIRST_SSE_REG;
+	}
       else
 	{
 	  rtx t1, t2;
@@ -8765,7 +8776,7 @@ ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,
       enum calling_abi call_abi = cum ? cum->call_abi : ix86_abi;
 
       if (call_abi == MS_ABI)
-	arg = function_arg_ms_64 (cum, mode, omode, named, bytes);
+	arg = function_arg_ms_64 (cum, mode, omode, named, type, bytes);
       else
 	arg = function_arg_64 (cum, mode, omode, type, named);
     }
@@ -9823,6 +9834,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
   tree ptrtype;
   machine_mode nat_mode;
   unsigned int arg_boundary;
+  unsigned int type_align;
 
   /* Only 64bit target needs something special.  */
   if (is_va_list_char_pointer (TREE_TYPE (valist)))
@@ -9880,6 +9892,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
   /* Pull the value out of the saved registers.  */
 
   addr = create_tmp_var (ptr_type_node, "addr");
+  type_align = TYPE_ALIGN (type);
 
   if (container)
     {
@@ -10050,6 +10063,9 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
 	  t = build2 (PLUS_EXPR, TREE_TYPE (gpr), gpr,
 		      build_int_cst (TREE_TYPE (gpr), needed_intregs * 8));
 	  gimplify_assign (gpr, t, pre_p);
+	  /* The GPR save area guarantees only 8-byte alignment.  */
+	  if (!need_temp)
+	    type_align = MIN (type_align, 64);
 	}
 
       if (needed_sseregs)
@@ -10094,6 +10110,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
   if (container)
     gimple_seq_add_stmt (pre_p, gimple_build_label (lab_over));
 
+  type = build_aligned_type (type, type_align);
   ptrtype = build_pointer_type_for_mode (type, ptr_mode, true);
   addr = fold_convert (ptrtype, addr);
 
@@ -16960,7 +16977,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)
       break;
 
     case SYMBOL_REF:
-      if (TARGET_64BIT || ! TARGET_MACHO_BRANCH_ISLANDS)
+      if (TARGET_64BIT || ! TARGET_MACHO_SYMBOL_STUBS)
 	output_addr_const (file, x);
       else
 	{
@@ -30272,9 +30289,14 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 	 the stack, we need to skip the first insn which pushes the
 	 (call-saved) register static chain; this push is 1 byte.  */
       offset += 5;
+      int skip = MEM_P (chain) ? 1 : 0;
+      /* Skip ENDBR32 at the entry of the target function.  */
+      if (need_endbr
+	  && !cgraph_node::get (fndecl)->only_called_directly_p ())
+	skip += 4;
       disp = expand_binop (SImode, sub_optab, fnaddr,
 			   plus_constant (Pmode, XEXP (m_tramp, 0),
-					  offset - (MEM_P (chain) ? 1 : 0)),
+					  offset - skip),
 			   NULL_RTX, 1, OPTAB_DIRECT);
       emit_move_insn (mem, disp);
     }
@@ -33401,8 +33423,13 @@ ix86_fold_builtin (tree fndecl, int n_args,
 		    countt = build_int_cst (integer_type_node, count);
 		}
 	      tree_vector_builder builder;
-	      builder.new_unary_operation (TREE_TYPE (args[0]), args[0],
-					   false);
+	      if (mask != HOST_WIDE_INT_M1U || is_vshift)
+		builder.new_vector (TREE_TYPE (args[0]),
+				    TYPE_VECTOR_SUBPARTS (TREE_TYPE (args[0])),
+				    1);
+	      else
+		builder.new_unary_operation (TREE_TYPE (args[0]), args[0],
+					     false);
 	      unsigned int cnt = builder.encoded_nelts ();
 	      for (unsigned int i = 0; i < cnt; ++i)
 		{
@@ -44377,11 +44404,15 @@ ix86_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &/*inputs*/,
 	    {
 	      x = force_reg (dest_mode, const0_rtx);
 
-	      emit_insn (gen_movstrictqi
-			 (gen_lowpart (QImode, x), destqi));
+	      emit_insn (gen_movstrictqi (gen_lowpart (QImode, x), destqi));
 	    }
 	  else
-	    x = gen_rtx_ZERO_EXTEND (dest_mode, destqi);
+	    {
+	      x = gen_rtx_ZERO_EXTEND (dest_mode, destqi);
+	      if (dest_mode == GET_MODE (dest)
+		  && !register_operand (dest, GET_MODE (dest)))
+		x = force_reg (dest_mode, x);
+	    }
 	}
 
       if (dest_mode != GET_MODE (dest))
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 2cb16d9fbf6..14e5a392f62 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -640,7 +640,7 @@ extern tree x86_mfence;
 /* Replace MACH-O, ifdefs by in-line tests, where possible. 
    (a) Macros defined in config/i386/darwin.h  */
 #define TARGET_MACHO 0
-#define TARGET_MACHO_BRANCH_ISLANDS 0
+#define TARGET_MACHO_SYMBOL_STUBS 0
 #define MACHOPIC_ATT_STUB 0
 /* (b) Macros defined in config/darwin.h  */
 #define MACHO_DYNAMIC_NO_PIC_P 0
@@ -1082,9 +1082,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
      6,   6,    6,    6,    6,    6,    6,    6,		\
 /*xmm16,xmm17,xmm18,xmm19,xmm20,xmm21,xmm22,xmm23*/		\
-     6,    6,     6,    6,    6,    6,    6,    6,		\
+     1,    1,     1,    1,    1,    1,    1,    1,		\
 /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/		\
-     6,    6,     6,    6,    6,    6,    6,    6,		\
+     1,    1,     1,    1,    1,    1,    1,    1,		\
  /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/			\
      1,   1,   1,   1,   1,   1,   1,   1 }
 
@@ -2205,6 +2205,31 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];
 #define ASM_OUTPUT_FUNCTION_LABEL(FILE, NAME, DECL) \
   ix86_asm_output_function_label ((FILE), (NAME), (DECL))
 
+/* A C statement (sans semicolon) to output a reference to SYMBOL_REF SYM.
+   If not defined, assemble_name will be used to output the name of the
+   symbol.  This macro may be used to modify the way a symbol is referenced
+   depending on information encoded by TARGET_ENCODE_SECTION_INFO.  */
+
+#ifndef ASM_OUTPUT_SYMBOL_REF
+#define ASM_OUTPUT_SYMBOL_REF(FILE, SYM) \
+  do {							\
+    const char *name					\
+      = assemble_name_resolve (XSTR (x, 0));		\
+    /* In -masm=att wrap identifiers that start with $	\
+       into parens.  */					\
+    if (ASSEMBLER_DIALECT == ASM_ATT			\
+	&& name[0] == '$'				\
+	&& user_label_prefix[0] == '\0')		\
+      {							\
+	fputc ('(', (FILE));				\
+	assemble_name_raw ((FILE), name);		\
+	fputc (')', (FILE));				\
+      }							\
+    else						\
+      assemble_name_raw ((FILE), name);			\
+  } while (0)
+#endif
+
 /* Under some conditions we need jump tables in the text section,
    because the assembler cannot handle label differences between
    sections.  This is the case for x86_64 on Mach-O for example.  */
@@ -2380,7 +2405,7 @@ const wide_int_bitmask PTA_CANNONLAKE = PTA_SKYLAKE | PTA_AVX512F
   | PTA_AVX512VBMI | PTA_AVX512IFMA | PTA_SHA;
 const wide_int_bitmask PTA_ICELAKE_CLIENT = PTA_CANNONLAKE | PTA_AVX512VNNI
   | PTA_GFNI | PTA_VAES | PTA_AVX512VBMI2 | PTA_VPCLMULQDQ | PTA_AVX512BITALG
-  | PTA_RDPID | PTA_CLWB;
+  | PTA_RDPID | PTA_CLWB | PTA_AVX512VPOPCNTDQ;
 const wide_int_bitmask PTA_ICELAKE_SERVER = PTA_ICELAKE_CLIENT | PTA_PCONFIG
   | PTA_WBNOINVD;
 const wide_int_bitmask PTA_KNL = PTA_BROADWELL | PTA_AVX512PF | PTA_AVX512ER
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index f8915440ff3..698c31a0a97 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -3653,7 +3653,7 @@
     }
 }
   [(set (attr "isa")
-     (cond [(eq_attr "alternative" "14,15")
+     (cond [(eq_attr "alternative" "9,10")
 	      (const_string "sse2")
 	   ]
 	   (const_string "*")))
@@ -15422,10 +15422,10 @@
 
 (define_insn "atan2xf3"
   [(set (match_operand:XF 0 "register_operand" "=f")
-        (unspec:XF [(match_operand:XF 1 "register_operand" "0")
-	            (match_operand:XF 2 "register_operand" "f")]
+        (unspec:XF [(match_operand:XF 2 "register_operand" "0")
+	            (match_operand:XF 1 "register_operand" "f")]
 	           UNSPEC_FPATAN))
-   (clobber (match_scratch:XF 3 "=2"))]
+   (clobber (match_scratch:XF 3 "=1"))]
   "TARGET_USE_FANCY_MATH_387
    && flag_unsafe_math_optimizations"
   "fpatan"
@@ -15449,7 +15449,7 @@
   emit_insn (gen_extend<mode>xf2 (op2, operands[2]));
   emit_insn (gen_extend<mode>xf2 (op1, operands[1]));
 
-  emit_insn (gen_atan2xf3 (op0, op2, op1));
+  emit_insn (gen_atan2xf3 (op0, op1, op2));
   emit_insn (gen_truncxf<mode>2 (operands[0], op0));
   DONE;
 })
diff --git a/gcc/config/i386/intelmic-mkoffload.c b/gcc/config/i386/intelmic-mkoffload.c
index 2a3e912ee74..0b12edc72c1 100644
--- a/gcc/config/i386/intelmic-mkoffload.c
+++ b/gcc/config/i386/intelmic-mkoffload.c
@@ -453,8 +453,6 @@ prepare_target_image (const char *target_compiler, int argc, char **argv)
   if (verbose)
     obstack_ptr_grow (&argv_obstack, "-v");
   obstack_ptr_grow (&argv_obstack, "-xlto");
-  obstack_ptr_grow (&argv_obstack, "-shared");
-  obstack_ptr_grow (&argv_obstack, "-fPIC");
   obstack_ptr_grow (&argv_obstack, opt1);
   for (int i = 1; i < argc; i++)
     {
@@ -466,6 +464,9 @@ prepare_target_image (const char *target_compiler, int argc, char **argv)
   if (!out_obj_filename)
     fatal_error (input_location, "output file not specified");
   obstack_ptr_grow (&argv_obstack, opt2);
+  /* NB: Put -fPIC and -shared the last to create shared library.  */
+  obstack_ptr_grow (&argv_obstack, "-fPIC");
+  obstack_ptr_grow (&argv_obstack, "-shared");
   obstack_ptr_grow (&argv_obstack, "-o");
   obstack_ptr_grow (&argv_obstack, target_so_filename);
   compile_for_target (&argv_obstack);
diff --git a/gcc/config/i386/mmx.md b/gcc/config/i386/mmx.md
index b566cc80020..15e4c84b54f 100644
--- a/gcc/config/i386/mmx.md
+++ b/gcc/config/i386/mmx.md
@@ -626,13 +626,13 @@
 (define_insn "*vec_extractv2sf_1"
   [(set (match_operand:SF 0 "nonimmediate_operand"     "=y,x,x,y,x,f,r")
 	(vec_select:SF
-	  (match_operand:V2SF 1 "nonimmediate_operand" " 0,x,x,o,o,o,o")
+	  (match_operand:V2SF 1 "nonimmediate_operand" " 0,x,0,o,o,o,o")
 	  (parallel [(const_int 1)])))]
   "TARGET_MMX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    punpckhdq\t%0, %0
    %vmovshdup\t{%1, %0|%0, %1}
-   shufps\t{$0xe5, %1, %0|%0, %1, 0xe5}
+   shufps\t{$0xe5, %0, %0|%0, %0, 0xe5}
    #
    #
    #
@@ -1320,13 +1320,13 @@
 (define_insn "*vec_extractv2si_1"
   [(set (match_operand:SI 0 "nonimmediate_operand"     "=y,x,x,y,x,r")
 	(vec_select:SI
-	  (match_operand:V2SI 1 "nonimmediate_operand" " 0,x,x,o,o,o")
+	  (match_operand:V2SI 1 "nonimmediate_operand" " 0,x,0,o,o,o")
 	  (parallel [(const_int 1)])))]
   "TARGET_MMX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    punpckhdq\t%0, %0
    %vpshufd\t{$0xe5, %1, %0|%0, %1, 0xe5}
-   shufps\t{$0xe5, %1, %0|%0, %1, 0xe5}
+   shufps\t{$0xe5, %0, %0|%0, %0, 0xe5}
    #
    #
    #"
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 46ec4602eb7..18cc39ae521 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -1610,7 +1610,7 @@
   [(set (match_operand:SWI1248_AVX512BWDQ 0 "register_operand" "=k")
 	(any_lshift:SWI1248_AVX512BWDQ
 	  (match_operand:SWI1248_AVX512BWDQ 1 "register_operand" "k")
-	  (match_operand:QI 2 "immediate_operand" "n")))
+	  (match_operand 2 "const_0_to_255_operand" "n")))
    (unspec [(const_int 0)] UNSPEC_MASKOP)]
   "TARGET_AVX512F"
   "k<mshift><mskmodesuffix>\t{%2, %1, %0|%0, %1, %2}"
@@ -2625,7 +2625,7 @@
 ;; Modes handled by reduc_sm{in,ax}* patterns.
 (define_mode_iterator REDUC_SSE_SMINMAX_MODE
   [(V4SF "TARGET_SSE") (V2DF "TARGET_SSE")
-   (V2DI "TARGET_SSE") (V4SI "TARGET_SSE") (V8HI "TARGET_SSE")
+   (V2DI "TARGET_SSE4_2") (V4SI "TARGET_SSE") (V8HI "TARGET_SSE")
    (V16QI "TARGET_SSE")])
 
 (define_expand "reduc_<code>_scal_<mode>"
@@ -3180,13 +3180,19 @@
 	  (match_operand:<avx512fmaskmode> 3 "register_operand")))]
   "TARGET_AVX512BW")
 
+;; As vcondv4div4df and vcondv8siv8sf are enabled already with TARGET_AVX,
+;; and their condition can be folded late into a constant, we need to
+;; support vcond_mask_v4div4di and vcond_mask_v8siv8si for TARGET_AVX.
+(define_mode_iterator VI_256_AVX2 [(V32QI "TARGET_AVX2") (V16HI "TARGET_AVX2")
+				   V8SI V4DI])
+
 (define_expand "vcond_mask_<mode><sseintvecmodelower>"
-  [(set (match_operand:VI_256 0 "register_operand")
-	(vec_merge:VI_256
-	  (match_operand:VI_256 1 "nonimmediate_operand")
-	  (match_operand:VI_256 2 "nonimm_or_0_operand")
+  [(set (match_operand:VI_256_AVX2 0 "register_operand")
+	(vec_merge:VI_256_AVX2
+	  (match_operand:VI_256_AVX2 1 "nonimmediate_operand")
+	  (match_operand:VI_256_AVX2 2 "nonimm_or_0_operand")
 	  (match_operand:<sseintvecmode> 3 "register_operand")))]
-  "TARGET_AVX2"
+  "TARGET_AVX"
 {
   ix86_expand_sse_movcc (operands[0], operands[3],
 			 operands[1], operands[2]);
@@ -3914,12 +3920,12 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*<sd_mask_codefor>fma_fmadd_<mode><sd_maskz_name>_bcst_1"
-  [(set (match_operand:VF_AVX512 0 "register_operand" "=v,v")
+  [(set (match_operand:VF_AVX512 0 "register_operand" "=v")
 	(fma:VF_AVX512
-	  (match_operand:VF_AVX512 1 "register_operand" "0,v")
-	  (match_operand:VF_AVX512 2 "register_operand" "v,0")
+	  (match_operand:VF_AVX512 1 "register_operand" "%0")
+	  (match_operand:VF_AVX512 2 "register_operand" "v")
 	  (vec_duplicate:VF_AVX512
-	    (match_operand:<ssescalarmode> 3 "memory_operand" "m,m"))))]
+	    (match_operand:<ssescalarmode> 3 "memory_operand" "m"))))]
   "TARGET_AVX512F && <sd_mask_mode512bit_condition>"
   "vfmadd213<ssemodesuffix>\t{%3<avx512bcst>, %2, %0<sd_mask_op4>|%0<sd_mask_op4>, %2, %3<avx512bcst>}"
   [(set_attr "type" "ssemuladd")
@@ -4031,13 +4037,13 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*<sd_mask_codefor>fma_fmsub_<mode><sd_maskz_name>_bcst_1"
-  [(set (match_operand:VF_AVX512 0 "register_operand" "=v,v")
+  [(set (match_operand:VF_AVX512 0 "register_operand" "=v")
 	(fma:VF_AVX512
-	  (match_operand:VF_AVX512 1 "register_operand" "0,v")
-	  (match_operand:VF_AVX512 2 "register_operand" "v,0")
+	  (match_operand:VF_AVX512 1 "register_operand" "%0")
+	  (match_operand:VF_AVX512 2 "register_operand" "v")
 	  (neg:VF_AVX512
 	    (vec_duplicate:VF_AVX512
-	      (match_operand:<ssescalarmode> 3 "memory_operand" "m,m")))))]
+	      (match_operand:<ssescalarmode> 3 "memory_operand" "m")))))]
   "TARGET_AVX512F && <sd_mask_mode512bit_condition>"
   "vfmsub213<ssemodesuffix>\t{%3<avx512bcst>, %2, %0<sd_mask_op4>|%0<sd_mask_op4>, %2, %3<avx512bcst>}"
   [(set_attr "type" "ssemuladd")
@@ -4153,13 +4159,13 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*<sd_mask_codefor>fma_fnmadd_<mode><sd_maskz_name>_bcst_1"
-  [(set (match_operand:VF_AVX512 0 "register_operand" "=v,v")
+  [(set (match_operand:VF_AVX512 0 "register_operand" "=v")
 	(fma:VF_AVX512
 	  (neg:VF_AVX512
-	    (match_operand:VF_AVX512 1 "register_operand" "0,v"))
-	  (match_operand:VF_AVX512 2 "register_operand" "v,0")
+	    (match_operand:VF_AVX512 1 "register_operand" "%0"))
+	  (match_operand:VF_AVX512 2 "register_operand" "v")
 	  (vec_duplicate:VF_AVX512
-	    (match_operand:<ssescalarmode> 3 "memory_operand" "m,m"))))]
+	    (match_operand:<ssescalarmode> 3 "memory_operand" "m"))))]
   "TARGET_AVX512F && <sd_mask_mode512bit_condition>"
   "vfnmadd213<ssemodesuffix>\t{%3<avx512bcst>, %2, %0<sd_mask_op4>|%0<sd_mask_op4>, %2, %3<avx512bcst>}"
   [(set_attr "type" "ssemuladd")
@@ -4277,14 +4283,14 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*<sd_mask_codefor>fma_fnmsub_<mode><sd_maskz_name>_bcst_1"
-  [(set (match_operand:VF_AVX512 0 "register_operand" "=v,v")
+  [(set (match_operand:VF_AVX512 0 "register_operand" "=v")
 	(fma:VF_AVX512
 	  (neg:VF_AVX512
-	    (match_operand:VF_AVX512 1 "register_operand" "0,v"))
-	  (match_operand:VF_AVX512 2 "register_operand" "v,0")
+	    (match_operand:VF_AVX512 1 "register_operand" "%0"))
+	  (match_operand:VF_AVX512 2 "register_operand" "v")
 	  (neg:VF_AVX512
 	    (vec_duplicate:VF_AVX512
-	      (match_operand:<ssescalarmode> 3 "memory_operand" "m,m")))))]
+	      (match_operand:<ssescalarmode> 3 "memory_operand" "m")))))]
   "TARGET_AVX512F && <sd_mask_mode512bit_condition>"
   "vfnmsub213<ssemodesuffix>\t{%3<avx512bcst>, %2, %0<sd_mask_op4>|%0<sd_mask_op4>, %2, %3<avx512bcst>}"
   [(set_attr "type" "ssemuladd")
@@ -8214,13 +8220,16 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
 
+(define_mode_iterator VI48F_256_DQ
+  [V8SI V8SF (V4DI "TARGET_AVX512DQ") (V4DF "TARGET_AVX512DQ")])
+
 (define_expand "avx512vl_vextractf128<mode>"
   [(match_operand:<ssehalfvecmode> 0 "nonimmediate_operand")
-   (match_operand:VI48F_256 1 "register_operand")
+   (match_operand:VI48F_256_DQ 1 "register_operand")
    (match_operand:SI 2 "const_0_to_1_operand")
    (match_operand:<ssehalfvecmode> 3 "nonimm_or_0_operand")
    (match_operand:QI 4 "register_operand")]
-  "TARGET_AVX512DQ && TARGET_AVX512VL"
+  "TARGET_AVX512VL"
 {
   rtx (*insn)(rtx, rtx, rtx, rtx);
   rtx dest = operands[0];
@@ -8288,14 +8297,19 @@
                      (const_int 4) (const_int 5)
                      (const_int 6) (const_int 7)])))]
   "TARGET_AVX512F
-   && <mask_mode512bit_condition>
+   && <mask_avx512dq_condition>
    && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>
       || (!TARGET_AVX512VL
 	  && !REG_P (operands[0])
 	  && EXT_REX_SSE_REG_P (operands[1])))
-    return "vextract<shuffletype>32x8\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
+    {
+      if (TARGET_AVX512DQ)
+	return "vextract<shuffletype>32x8\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
+      else
+	return "vextract<shuffletype>64x4\t{$0x0, %1, %0|%0, %1, 0x0}";
+    }
   else
     return "#";
 }
@@ -8405,7 +8419,7 @@
 	  (parallel [(const_int 0) (const_int 1)
 		     (const_int 2) (const_int 3)])))]
   "TARGET_AVX
-   && <mask_avx512vl_condition> && <mask_avx512dq_condition>
+   && <mask_avx512vl_condition>
    && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>)
@@ -16241,7 +16255,7 @@
     }
 })
 
-(define_insn "abs<mode>2"
+(define_insn "ssse3_abs<mode>2"
   [(set (match_operand:MMXMODEI 0 "register_operand" "=y")
 	(abs:MMXMODEI
 	  (match_operand:MMXMODEI 1 "nonimmediate_operand" "ym")))]
@@ -21116,7 +21130,7 @@
   [(set (match_operand:<avx512fmaskmode> 0 "register_operand" "=k")
           (unspec:<avx512fmaskmode>
             [(match_operand:VF_AVX512VL 1 "register_operand" "v")
-             (match_operand:QI 2 "const_0_to_255_operand" "n")]
+             (match_operand 2 "const_0_to_255_operand" "n")]
              UNSPEC_FPCLASS))]
    "TARGET_AVX512DQ"
    "vfpclass<ssemodesuffix>\t{%2, %1, %0<mask_scalar_merge_operand3>|%0<mask_scalar_merge_operand3>, %1, %2}";
@@ -21130,7 +21144,7 @@
 	(and:<avx512fmaskmode>
 	  (unspec:<avx512fmaskmode>
 	    [(match_operand:VF_128 1 "register_operand" "v")
-             (match_operand:QI 2 "const_0_to_255_operand" "n")]
+             (match_operand 2 "const_0_to_255_operand" "n")]
 	    UNSPEC_FPCLASS)
 	  (const_int 1)))]
    "TARGET_AVX512DQ"
@@ -21735,7 +21749,7 @@
 	(unspec:VI1_AVX512F
 	  [(match_operand:VI1_AVX512F 1 "register_operand" "%0,x,v")
 	   (match_operand:VI1_AVX512F 2 "nonimmediate_operand" "xBm,xm,vm")
-	   (match_operand:QI 3 "const_0_to_255_operand" "n,n,n")]
+	   (match_operand 3 "const_0_to_255_operand" "n,n,n")]
 	  UNSPEC_GF2P8AFFINEINV))]
   "TARGET_GFNI"
   "@
@@ -21753,7 +21767,7 @@
 	(unspec:VI1_AVX512F
 	  [(match_operand:VI1_AVX512F 1 "register_operand" "%0,x,v")
 	   (match_operand:VI1_AVX512F 2 "nonimmediate_operand" "xBm,xm,vm")
-	   (match_operand:QI 3 "const_0_to_255_operand" "n,n,n")]
+	   (match_operand 3 "const_0_to_255_operand" "n,n,n")]
 	  UNSPEC_GF2P8AFFINE))]
   "TARGET_GFNI"
   "@
diff --git a/gcc/config/i386/xopintrin.h b/gcc/config/i386/xopintrin.h
index d1d1e061cdd..d2726154f33 100644
--- a/gcc/config/i386/xopintrin.h
+++ b/gcc/config/i386/xopintrin.h
@@ -814,25 +814,25 @@ _mm256_permute2_ps (__m256 __X, __m256 __Y, __m256i __C, const int __I)
 #define _mm_permute2_pd(X, Y, C, I)					\
   ((__m128d) __builtin_ia32_vpermil2pd ((__v2df)(__m128d)(X),		\
 					(__v2df)(__m128d)(Y),		\
-					(__v2di)(__m128d)(C),		\
+					(__v2di)(__m128i)(C),		\
 					(int)(I)))
 
 #define _mm256_permute2_pd(X, Y, C, I)					\
   ((__m256d) __builtin_ia32_vpermil2pd256 ((__v4df)(__m256d)(X),	\
 					   (__v4df)(__m256d)(Y),	\
-					   (__v4di)(__m256d)(C),	\
+					   (__v4di)(__m256i)(C),	\
 					   (int)(I)))
 
 #define _mm_permute2_ps(X, Y, C, I)					\
   ((__m128) __builtin_ia32_vpermil2ps ((__v4sf)(__m128)(X),		\
 				       (__v4sf)(__m128)(Y),		\
-				       (__v4si)(__m128)(C),		\
+				       (__v4si)(__m128i)(C),		\
 				       (int)(I)))
 
 #define _mm256_permute2_ps(X, Y, C, I)					\
   ((__m256) __builtin_ia32_vpermil2ps256 ((__v8sf)(__m256)(X),		\
 					  (__v8sf)(__m256)(Y),  	\
-					  (__v8si)(__m256)(C),		\
+					  (__v8si)(__m256i)(C),		\
  					  (int)(I)))
 #endif /* __OPTIMIZE__ */
 
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 2dfc7c73cce..d758fbf1be6 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -4849,7 +4849,7 @@ mips_split_move (rtx dest, rtx src, enum mips_split_type split_type, rtx insn_)
      can forward SRC for DEST.  This is most useful if the next insn is a
      simple store.   */
   rtx_insn *insn = (rtx_insn *)insn_;
-  struct mips_address_info addr;
+  struct mips_address_info addr = {};
   if (insn)
     {
       rtx_insn *next = next_nonnote_nondebug_insn_bb (insn);
@@ -4862,7 +4862,7 @@ mips_split_move (rtx dest, rtx src, enum mips_split_type split_type, rtx insn_)
 		{
 		  rtx tmp = XEXP (src, 0);
 		  mips_classify_address (&addr, tmp, GET_MODE (tmp), true);
-		  if (REGNO (addr.reg) != REGNO (dest))
+		  if (addr.reg && !reg_overlap_mentioned_p (dest, addr.reg))
 		    validate_change (next, &SET_SRC (set), src, false);
 		}
 	      else
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 2ae1f7e0440..3cfb1a751e9 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -5836,8 +5836,8 @@
   "ISA_HAS_ROR"
 {
   if (CONST_INT_P (operands[2]))
-    gcc_assert (INTVAL (operands[2]) >= 0
-		&& INTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode));
+    operands[2] = GEN_INT (INTVAL (operands[2])
+                           & (GET_MODE_BITSIZE (<MODE>mode) - 1));
 
   return "<d>ror\t%0,%1,%2";
 }
@@ -7588,7 +7588,7 @@
 ;; __builtin_mips_get_fcsr: move the FCSR into operand 0.
 (define_expand "mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT_ABI"
 {
   if (TARGET_MIPS16)
@@ -7600,7 +7600,7 @@
 
 (define_insn "*mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand" "=d")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT"
   "cfc1\t%0,$31")
 
diff --git a/gcc/config/nios2/nios2.c b/gcc/config/nios2/nios2.c
index 1f00b8abbda..5f62e643be2 100644
--- a/gcc/config/nios2/nios2.c
+++ b/gcc/config/nios2/nios2.c
@@ -2373,6 +2373,22 @@ nios2_in_small_data_p (const_tree exp)
 	  if (nios2_small_section_name_p (section))
 	    return true;
 	}
+      else if (flexible_array_type_p (TREE_TYPE (exp))
+	       && (!TREE_PUBLIC (exp) || DECL_EXTERNAL (exp)))
+	{
+	  /* We really should not consider any objects of any flexibly-sized
+	     type to be small data, but pre-GCC 10 did not test
+	     for this and just fell through to the next case.  Thus older
+	     code compiled with -mgpopt=global could contain GP-relative
+	     accesses to objects defined in this compilation unit with
+	     external linkage.  We retain the possible small-data treatment
+	     of such definitions for backward ABI compatibility, but
+	     no longer generate GP-relative accesses for external
+	     references (so that the ABI could be changed in the future
+	     with less potential impact), or objects with internal
+	     linkage.  */
+	  return false;
+	}
       else
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
diff --git a/gcc/config/nios2/nios2.h b/gcc/config/nios2/nios2.h
index 9dec57d67ae..88671652707 100644
--- a/gcc/config/nios2/nios2.h
+++ b/gcc/config/nios2/nios2.h
@@ -467,10 +467,10 @@ while (0)
    the linker seems to want the alignment of data objects
    to depend on their types.  We do exactly that here.  */
 
-#undef  ASM_OUTPUT_ALIGNED_LOCAL
-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)               \
+#undef  ASM_OUTPUT_ALIGNED_DECL_LOCAL
+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)	\
 do {                                                                    \
-  if ((SIZE) <= nios2_section_threshold)                                \
+ if (targetm.in_small_data_p (DECL))					\
     switch_to_section (sbss_section);					\
   else                                                                  \
     switch_to_section (bss_section);					\
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 707ae5822c3..84a8cae22e4 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -206,6 +206,7 @@ static bool pa_hard_regno_mode_ok (unsigned int, machine_mode);
 static bool pa_modes_tieable_p (machine_mode, machine_mode);
 static bool pa_can_change_mode_class (machine_mode, machine_mode, reg_class_t);
 static HOST_WIDE_INT pa_starting_frame_offset (void);
+static section* pa_elf_select_rtx_section(machine_mode, rtx, unsigned HOST_WIDE_INT) ATTRIBUTE_UNUSED;
 
 /* The following extra sections are only used for SOM.  */
 static GTY(()) section *som_readonly_data_section;
@@ -7856,7 +7857,7 @@ pa_attr_length_call (rtx_insn *insn, int sibcall)
 
   /* 64-bit plabel sequence.  */
   else if (TARGET_64BIT && !local_call)
-    length += sibcall ? 28 : 24;
+    length += 24;
 
   /* non-pic long absolute branch sequence.  */
   else if ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)
@@ -7928,38 +7929,24 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)
 	  xoperands[0] = pa_get_deferred_plabel (call_dest);
 	  xoperands[1] = gen_label_rtx ();
 
-	  /* If this isn't a sibcall, we put the load of %r27 into the
-	     delay slot.  We can't do this in a sibcall as we don't
-	     have a second call-clobbered scratch register available.
-	     We don't need to do anything when generating fast indirect
-	     calls.  */
-	  if (seq_length != 0 && !sibcall)
+	  /* Put the load of %r27 into the delay slot.  We don't need to
+	     do anything when generating fast indirect calls.  */
+	  if (seq_length != 0)
 	    {
 	      final_scan_insn (NEXT_INSN (insn), asm_out_file,
 			       optimize, 0, NULL);
 
 	      /* Now delete the delay insn.  */
 	      SET_INSN_DELETED (NEXT_INSN (insn));
-	      seq_length = 0;
 	    }
 
 	  output_asm_insn ("addil LT'%0,%%r27", xoperands);
 	  output_asm_insn ("ldd RT'%0(%%r1),%%r1", xoperands);
 	  output_asm_insn ("ldd 0(%%r1),%%r1", xoperands);
-
-	  if (sibcall)
-	    {
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      output_asm_insn ("ldd 16(%%r1),%%r1", xoperands);
-	      output_asm_insn ("bve (%%r1)", xoperands);
-	    }
-	  else
-	    {
-	      output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
-	      output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      seq_length = 1;
-	    }
+	  output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
+	  output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
+	  output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
+	  seq_length = 1;
 	}
       else
 	{
@@ -8052,20 +8039,22 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)
 		    {
 		      output_asm_insn ("addil LT'%0,%%r19", xoperands);
 		      output_asm_insn ("ldw RT'%0(%%r1),%%r1", xoperands);
-		      output_asm_insn ("ldw 0(%%r1),%%r1", xoperands);
+		      output_asm_insn ("ldw 0(%%r1),%%r22", xoperands);
 		    }
 		  else
 		    {
 		      output_asm_insn ("addil LR'%0-$global$,%%r27",
 				       xoperands);
-		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r1",
+		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r22",
 				       xoperands);
 		    }
 
-		  output_asm_insn ("bb,>=,n %%r1,30,.+16", xoperands);
-		  output_asm_insn ("depi 0,31,2,%%r1", xoperands);
-		  output_asm_insn ("ldw 4(%%sr0,%%r1),%%r19", xoperands);
-		  output_asm_insn ("ldw 0(%%sr0,%%r1),%%r1", xoperands);
+		  output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
+		  output_asm_insn ("depi 0,31,2,%%r22", xoperands);
+		  /* Should this be an ordered load to ensure the target
+	             address is loaded before the global pointer?  */
+		  output_asm_insn ("ldw 0(%%r22),%%r1", xoperands);
+		  output_asm_insn ("ldw 4(%%r22),%%r19", xoperands);
 
 		  if (!sibcall && !TARGET_PA_20)
 		    {
@@ -8158,10 +8147,6 @@ pa_attr_length_indirect_call (rtx_insn *insn)
   if (TARGET_PORTABLE_RUNTIME)
     return 16;
 
-  /* Inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    return 20;
-
   if (!TARGET_LONG_CALLS
       && ((TARGET_PA_20 && !TARGET_SOM && distance < 7600000)
 	  || distance < MAX_PCREL17F_OFFSET))
@@ -8171,12 +8156,15 @@ pa_attr_length_indirect_call (rtx_insn *insn)
   if (!flag_pic)
     return 12;
 
-  /* Inline version of $$dyncall.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20)
-    return 20;
-
+  /* Inline versions of $$dyncall.  */
   if (!optimize_size)
-    return 36;
+    {
+      if (TARGET_NO_SPACE_REGS)
+	return 28;
+
+      if (TARGET_PA_20)
+	return 32;
+    }
 
   /* Long PIC pc-relative call.  */
   return 20;
@@ -8214,22 +8202,6 @@ pa_output_indirect_call (rtx_insn *insn, rtx call_dest)
       return "blr %%r0,%%r2\n\tbv,n %%r0(%%r31)";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
-      pa_output_arg_descriptor (insn);
-      if (TARGET_NO_SPACE_REGS)
-	{
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
-	}
-      return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
-    }
-
   /* Now the normal case -- we can reach $$dyncall directly or
      we're sure that we can get there via a long-branch stub. 
 
@@ -8258,35 +8230,40 @@ pa_output_indirect_call (rtx_insn *insn, rtx call_dest)
       return "ble R'$$dyncall(%%sr4,%%r2)\n\tcopy %%r31,%%r2";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  The long PIC
-     pc-relative call sequence is five instructions.  The inline PA 2.0
-     version of $$dyncall is also five instructions.  The PA 1.X versions
-     are longer but still an overall win.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20 || !optimize_size)
+  /* The long PIC pc-relative call sequence is five instructions.  So,
+     let's use an inline version of $$dyncall when the calling sequence
+     has a roughly similar number of instructions and we are not optimizing
+     for size.  We need two instructions to load the return pointer plus
+     the $$dyncall implementation.  */
+  if (!optimize_size)
     {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
       if (TARGET_NO_SPACE_REGS)
 	{
 	  pa_output_arg_descriptor (insn);
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 20(%%r2),%%r2\n\t"
+			   "extru,<> %%r22,30,1,%%r0\n\t"
+			   "bv,n %%r0(%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bv %%r0(%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
       if (TARGET_PA_20)
 	{
 	  pa_output_arg_descriptor (insn);
-	  return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 24(%%r2),%%r2\n\t"
+			   "stw %%r2,-24(%%sp)\n\t"
+			   "extru,<> %r22,30,1,%%r0\n\t"
+			   "bve,n (%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bve (%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
-      output_asm_insn ("bl .+8,%%r2\n\t"
-		       "ldo 16(%%r2),%%r2\n\t"
-		       "ldsid (%%r22),%%r1\n\t"
-		       "mtsp %%r1,%%sr0", xoperands);
-      pa_output_arg_descriptor (insn);
-      return "be 0(%%sr0,%%r22)\n\tstw %%r2,-24(%%sp)";
     }
- 
+
   /* We need a long PIC call to $$dyncall.  */
   xoperands[0] = gen_rtx_SYMBOL_REF (Pmode, "$$dyncall");
   xoperands[1] = gen_rtx_REG (Pmode, 2);
@@ -9366,7 +9343,7 @@ pa_function_value (const_tree valtype,
       HOST_WIDE_INT valsize = int_size_in_bytes (valtype);
 
       /* Handle aggregates that fit exactly in a word or double word.  */
-      if ((valsize & (UNITS_PER_WORD - 1)) == 0)
+      if (valsize == UNITS_PER_WORD || valsize == 2 * UNITS_PER_WORD)
 	return gen_rtx_REG (TYPE_MODE (valtype), 28);
 
       if (TARGET_64BIT)
@@ -9871,6 +9848,26 @@ pa_select_section (tree exp, int reloc,
     return data_section;
 }
 
+/* Implement pa_elf_select_rtx_section.  If X is a function label operand
+   and the function is in a COMDAT group, place the plabel reference in the
+   .data.rel.ro.local section.  The linker ignores references to symbols in
+   discarded sections from this section.  */
+   
+static section *
+pa_elf_select_rtx_section (machine_mode mode, rtx x,
+			   unsigned HOST_WIDE_INT align)
+{
+  if (function_label_operand (x, VOIDmode))
+    {
+      tree decl = SYMBOL_REF_DECL (x);
+
+      if (!decl || (DECL_P (decl) && DECL_COMDAT_GROUP (decl)))
+	return get_named_section (NULL, ".data.rel.ro.local", 1);
+    }
+
+  return default_elf_select_rtx_section (mode, x, align);
+}
+
 /* Implement pa_reloc_rw_mask.  */
 
 static int
@@ -10048,7 +10045,7 @@ pa_modes_tieable_p (machine_mode mode1, machine_mode mode2)
 
 /* Length in units of the trampoline instruction code.  */
 
-#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 32 : 40))
+#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 36 : 48))
 
 
 /* Output assembler code for a block containing the constant parts
@@ -10069,27 +10066,46 @@ pa_asm_trampoline_template (FILE *f)
 {
   if (!TARGET_64BIT)
     {
-      fputs ("\tldw	36(%r22),%r21\n", f);
-      fputs ("\tbb,>=,n	%r21,30,.+16\n", f);
-      if (ASSEMBLER_DIALECT == 0)
-	fputs ("\tdepi	0,31,2,%r21\n", f);
-      else
-	fputs ("\tdepwi	0,31,2,%r21\n", f);
-      fputs ("\tldw	4(%r21),%r19\n", f);
-      fputs ("\tldw	0(%r21),%r21\n", f);
       if (TARGET_PA_20)
 	{
-	  fputs ("\tbve	(%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tmfia	%r20\n", f);
+	  fputs ("\tldw		48(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
+	  fputs ("\tbve		(%r21)\n", f);
+	  fputs ("\tldw		52(%r1),%r29\n", f);
+	  fputs ("\t.word	0\n", f);
 	  fputs ("\t.word	0\n", f);
 	  fputs ("\t.word	0\n", f);
 	}
       else
 	{
+	  if (ASSEMBLER_DIALECT == 0)
+	    {
+	      fputs ("\tbl	.+8,%r20\n", f);
+	      fputs ("\tdepi	0,31,2,%r20\n", f);
+	    }
+	  else
+	    {
+	      fputs ("\tb,l	.+8,%r20\n", f);
+	      fputs ("\tdepwi	0,31,2,%r20\n", f);
+	    }
+	  fputs ("\tldw		40(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  if (ASSEMBLER_DIALECT == 0)
+	    fputs ("\tdepi	0,31,2,%r22\n", f);
+	  else
+	    fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
 	  fputs ("\tldsid	(%r21),%r1\n", f);
 	  fputs ("\tmtsp	%r1,%sr0\n", f);
-	  fputs ("\tbe	0(%sr0,%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tbe		0(%sr0,%r21)\n", f);
+	  fputs ("\tldw		44(%r20),%r29\n", f);
 	}
       fputs ("\t.word	0\n", f);
       fputs ("\t.word	0\n", f);
@@ -10103,11 +10119,11 @@ pa_asm_trampoline_template (FILE *f)
       fputs ("\t.dword 0\n", f);
       fputs ("\t.dword 0\n", f);
       fputs ("\tmfia	%r31\n", f);
-      fputs ("\tldd	24(%r31),%r1\n", f);
-      fputs ("\tldd	24(%r1),%r27\n", f);
-      fputs ("\tldd	16(%r1),%r1\n", f);
-      fputs ("\tbve	(%r1)\n", f);
+      fputs ("\tldd	24(%r31),%r27\n", f);
       fputs ("\tldd	32(%r31),%r31\n", f);
+      fputs ("\tldd	16(%r27),%r1\n", f);
+      fputs ("\tbve	(%r1)\n", f);
+      fputs ("\tldd	24(%r27),%r27\n", f);
       fputs ("\t.dword 0  ; fptr\n", f);
       fputs ("\t.dword 0  ; static link\n", f);
     }
@@ -10117,10 +10133,10 @@ pa_asm_trampoline_template (FILE *f)
    FNADDR is an RTX for the address of the function's pure code.
    CXT is an RTX for the static chain value for the function.
 
-   Move the function address to the trampoline template at offset 36.
-   Move the static chain value to trampoline template at offset 40.
-   Move the trampoline address to trampoline template at offset 44.
-   Move r19 to trampoline template at offset 48.  The latter two
+   Move the function address to the trampoline template at offset 48.
+   Move the static chain value to trampoline template at offset 52.
+   Move the trampoline address to trampoline template at offset 56.
+   Move r19 to trampoline template at offset 60.  The latter two
    words create a plabel for the indirect call to the trampoline.
 
    A similar sequence is used for the 64-bit port but the plabel is
@@ -10146,15 +10162,15 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 
   if (!TARGET_64BIT)
     {
-      tmp = adjust_address (m_tramp, Pmode, 36);
+      tmp = adjust_address (m_tramp, Pmode, 48);
       emit_move_insn (tmp, fnaddr);
-      tmp = adjust_address (m_tramp, Pmode, 40);
+      tmp = adjust_address (m_tramp, Pmode, 52);
       emit_move_insn (tmp, chain_value);
 
       /* Create a fat pointer for the trampoline.  */
-      tmp = adjust_address (m_tramp, Pmode, 44);
+      tmp = adjust_address (m_tramp, Pmode, 56);
       emit_move_insn (tmp, r_tramp);
-      tmp = adjust_address (m_tramp, Pmode, 48);
+      tmp = adjust_address (m_tramp, Pmode, 60);
       emit_move_insn (tmp, gen_rtx_REG (Pmode, 19));
 
       /* fdc and fic only use registers for the address to flush,
@@ -10206,20 +10222,20 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
     }
 
 #ifdef HAVE_ENABLE_EXECUTE_STACK
-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
 		     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);
 #endif
 }
 
 /* Perform any machine-specific adjustment in the address of the trampoline.
    ADDR contains the address that was passed to pa_trampoline_init.
-   Adjust the trampoline address to point to the plabel at offset 44.  */
+   Adjust the trampoline address to point to the plabel at offset 56.  */
 
 static rtx
 pa_trampoline_adjust_address (rtx addr)
 {
   if (!TARGET_64BIT)
-    addr = memory_address (Pmode, plus_constant (Pmode, addr, 46));
+    addr = memory_address (Pmode, plus_constant (Pmode, addr, 58));
   return addr;
 }
 
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index 561efa51882..24739e56f97 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -689,7 +689,7 @@ extern int may_call_alloca;
 
 /* Length in units of the trampoline for entering a nested function.  */
 
-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 52)
+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 64)
 
 /* Alignment required by the trampoline.  */
 
@@ -1293,13 +1293,12 @@ do {									     \
 #endif
 
 /* The maximum offset in bytes for a PA 1.X pc-relative call to the
-   head of the preceding stub table.  The selected offsets have been
-   chosen so that approximately one call stub is allocated for every
-   86.7 instructions.  A long branch stub is two instructions when
-   not generating PIC code.  For HP-UX and ELF targets, PIC stubs are
-   seven and four instructions, respectively.  */  
-#define MAX_PCREL17F_OFFSET \
-  (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
+   head of the preceding stub table.  A long branch stub is two or three
+   instructions for non-PIC and PIC, respectively.  Import stubs are
+   seven and five instructions for HP-UX and ELF targets, respectively.
+   The default stub group size for ELF targets is 217856 bytes.
+   FIXME: We need an option to set the maximum offset.  */  
+#define MAX_PCREL17F_OFFSET (TARGET_HPUX ? 198164 : 217856)
 
 #define NEED_INDICATE_EXEC_STACK 0
 
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 84630ad536d..18f8e127d3d 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -765,7 +765,7 @@
 
 (define_insn "scc"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 3 "comparison_operator"
+	(match_operator:SI 3 "ordered_comparison_operator"
 			   [(match_operand:SI 1 "reg_or_0_operand" "rM")
 			    (match_operand:SI 2 "arith11_operand" "rI")]))]
   ""
@@ -775,7 +775,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(match_operator:DI 3 "comparison_operator"
+	(match_operator:DI 3 "ordered_comparison_operator"
 			   [(match_operand:DI 1 "reg_or_0_operand" "rM")
 			    (match_operand:DI 2 "arith11_operand" "rI")]))]
   "TARGET_64BIT"
@@ -785,10 +785,10 @@
 
 (define_insn "iorscc"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (match_operator:SI 3 "comparison_operator"
+	(ior:SI (match_operator:SI 3 "ordered_comparison_operator"
 				   [(match_operand:SI 1 "reg_or_0_operand" "rM")
 				    (match_operand:SI 2 "arith11_operand" "rI")])
-		(match_operator:SI 6 "comparison_operator"
+		(match_operator:SI 6 "ordered_comparison_operator"
 				   [(match_operand:SI 4 "reg_or_0_operand" "rM")
 				    (match_operand:SI 5 "arith11_operand" "rI")])))]
   ""
@@ -798,10 +798,10 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(ior:DI (match_operator:DI 3 "comparison_operator"
+	(ior:DI (match_operator:DI 3 "ordered_comparison_operator"
 				   [(match_operand:DI 1 "reg_or_0_operand" "rM")
 				    (match_operand:DI 2 "arith11_operand" "rI")])
-		(match_operator:DI 6 "comparison_operator"
+		(match_operator:DI 6 "ordered_comparison_operator"
 				   [(match_operand:DI 4 "reg_or_0_operand" "rM")
 				    (match_operand:DI 5 "arith11_operand" "rI")])))]
   "TARGET_64BIT"
@@ -813,7 +813,7 @@
 ;; from an scc insn (negscc and incscc).
 (define_insn "negscc"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(neg:SI (match_operator:SI 3 "comparison_operator"
+	(neg:SI (match_operator:SI 3 "ordered_comparison_operator"
 	       [(match_operand:SI 1 "reg_or_0_operand" "rM")
 		(match_operand:SI 2 "arith11_operand" "rI")])))]
   ""
@@ -823,7 +823,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(neg:DI (match_operator:DI 3 "comparison_operator"
+	(neg:DI (match_operator:DI 3 "ordered_comparison_operator"
 	       [(match_operand:DI 1 "reg_or_0_operand" "rM")
 		(match_operand:DI 2 "arith11_operand" "rI")])))]
   "TARGET_64BIT"
@@ -904,7 +904,7 @@
 
 (define_insn "incscc"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
- 	(plus:SI (match_operator:SI 4 "comparison_operator"
+ 	(plus:SI (match_operator:SI 4 "ordered_comparison_operator"
 		    [(match_operand:SI 2 "register_operand" "r,r")
 		     (match_operand:SI 3 "arith11_operand" "rI,rI")])
 		 (match_operand:SI 1 "register_operand" "0,?r")))]
@@ -917,7 +917,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,r")
- 	(plus:DI (match_operator:DI 4 "comparison_operator"
+ 	(plus:DI (match_operator:DI 4 "ordered_comparison_operator"
 		    [(match_operand:DI 2 "register_operand" "r,r")
 		     (match_operand:DI 3 "arith11_operand" "rI,rI")])
 		 (match_operand:DI 1 "register_operand" "0,?r")))]
@@ -1062,7 +1062,7 @@
 (define_insn "decscc"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	(minus:SI (match_operand:SI 1 "register_operand" "0,?r")
-		  (match_operator:SI 4 "comparison_operator"
+		  (match_operator:SI 4 "ordered_comparison_operator"
 		     [(match_operand:SI 2 "register_operand" "r,r")
 		      (match_operand:SI 3 "arith11_operand" "rI,rI")])))]
   ""
@@ -1075,7 +1075,7 @@
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,r")
 	(minus:DI (match_operand:DI 1 "register_operand" "0,?r")
-		  (match_operator:DI 4 "comparison_operator"
+		  (match_operator:DI 4 "ordered_comparison_operator"
 		     [(match_operand:DI 2 "register_operand" "r,r")
 		      (match_operand:DI 3 "arith11_operand" "rI,rI")])))]
   "TARGET_64BIT"
@@ -1242,7 +1242,7 @@
 (define_expand "movsicc"
   [(set (match_operand:SI 0 "register_operand" "")
 	(if_then_else:SI
-	 (match_operand 1 "comparison_operator" "")
+	 (match_operand 1 "ordered_comparison_operator" "")
 	 (match_operand:SI 2 "reg_or_cint_move_operand" "")
 	 (match_operand:SI 3 "reg_or_cint_move_operand" "")))]
   ""
@@ -1264,7 +1264,7 @@
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
 	(if_then_else:SI
-	 (match_operator 2 "comparison_operator"
+	 (match_operator 2 "ordered_comparison_operator"
 	    [(match_operand:SI 3 "register_operand" "r,r,r,r")
 	     (match_operand:SI 4 "arith11_operand" "rI,rI,rI,rI")])
 	 (match_operand:SI 1 "reg_or_cint_move_operand" "0,J,N,K")
@@ -1281,7 +1281,7 @@
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r")
 	(if_then_else:SI
-	 (match_operator 5 "comparison_operator"
+	 (match_operator 5 "ordered_comparison_operator"
 	    [(match_operand:SI 3 "register_operand" "r,r,r,r,r,r,r,r")
 	     (match_operand:SI 4 "arith11_operand" "rI,rI,rI,rI,rI,rI,rI,rI")])
 	 (match_operand:SI 1 "reg_or_cint_move_operand" "0,0,0,0,r,J,N,K")
@@ -1302,7 +1302,7 @@
 (define_expand "movdicc"
   [(set (match_operand:DI 0 "register_operand" "")
 	(if_then_else:DI
-	 (match_operand 1 "comparison_operator" "")
+	 (match_operand 1 "ordered_comparison_operator" "")
 	 (match_operand:DI 2 "reg_or_cint_move_operand" "")
 	 (match_operand:DI 3 "reg_or_cint_move_operand" "")))]
   "TARGET_64BIT"
@@ -1318,7 +1318,7 @@
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,r,r,r,r")
 	(if_then_else:DI
-	 (match_operator 2 "comparison_operator"
+	 (match_operator 2 "ordered_comparison_operator"
 	    [(match_operand:DI 3 "register_operand" "r,r,r,r,r")
 	     (match_operand:DI 4 "arith11_operand" "rI,rI,rI,rI,rI")])
 	 (match_operand:DI 1 "reg_or_cint_move_operand" "0,r,J,N,K")
@@ -1336,7 +1336,7 @@
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r")
 	(if_then_else:DI
-	 (match_operator 5 "comparison_operator"
+	 (match_operator 5 "ordered_comparison_operator"
 	    [(match_operand:DI 3 "register_operand" "r,r,r,r,r,r,r,r")
 	     (match_operand:DI 4 "arith11_operand" "rI,rI,rI,rI,rI,rI,rI,rI")])
 	 (match_operand:DI 1 "reg_or_cint_move_operand" "0,0,0,0,r,J,N,K")
@@ -1413,7 +1413,7 @@
 (define_insn ""
   [(set (pc)
 	(if_then_else
-	 (match_operator 3 "comparison_operator"
+	 (match_operator 3 "ordered_comparison_operator"
 			 [(match_operand:SI 1 "reg_or_0_operand" "rM")
 			  (match_operand:SI 2 "arith5_operand" "rL")])
 	 (label_ref (match_operand 0 "" ""))
@@ -1442,7 +1442,7 @@
 (define_insn ""
   [(set (pc)
 	(if_then_else
-	 (match_operator 3 "comparison_operator"
+	 (match_operator 3 "ordered_comparison_operator"
 			 [(match_operand:SI 1 "reg_or_0_operand" "rM")
 			  (match_operand:SI 2 "arith5_operand" "rL")])
 	 (pc)
@@ -1469,7 +1469,7 @@
 (define_insn ""
   [(set (pc)
 	(if_then_else
-	 (match_operator 3 "comparison_operator"
+	 (match_operator 3 "ordered_comparison_operator"
 			 [(match_operand:DI 1 "reg_or_0_operand" "rM")
 			  (match_operand:DI 2 "reg_or_0_operand" "rM")])
 	 (label_ref (match_operand 0 "" ""))
@@ -1498,7 +1498,7 @@
 (define_insn ""
   [(set (pc)
 	(if_then_else
-	 (match_operator 3 "comparison_operator"
+	 (match_operator 3 "ordered_comparison_operator"
 			 [(match_operand:DI 1 "reg_or_0_operand" "rM")
 			  (match_operand:DI 2 "reg_or_0_operand" "rM")])
 	 (pc)
@@ -9062,7 +9062,7 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 (define_insn "decrement_and_branch_until_zero"
   [(set (pc)
 	(if_then_else
-	  (match_operator 2 "comparison_operator"
+	  (match_operator 2 "ordered_comparison_operator"
 	   [(plus:SI
 	      (match_operand:SI 0 "reg_before_reload_operand" "+!r,!*f,*Q")
 	      (match_operand:SI 1 "int5_operand" "L,L,L"))
@@ -10091,23 +10091,55 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
    (set_attr "length" "4,16")])
 
 ;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
-;; we need a memory barrier to enforce program order for memory references.
-;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
-;; barrier when generating PA 1.x code.
+;; we need memory barriers to enforce program order for memory references
+;; when the TLB and PSW O bits are not set.  We assume all PA 2.0 systems
+;; are weakly ordered since neither HP-UX or Linux set the PSW O bit.  Since
+;; we want PA 1.x code to be PA 2.0 compatible, we also need barriers when
+;; generating PA 1.x code even though all PA 1.x systems are strongly ordered.
+
+;; When barriers are needed, we use a strongly ordered ldcw instruction as
+;; the barrier.  Most PA 2.0 targets are cache coherent.  In that case, we
+;; can use the coherent cache control hint and avoid aligning the ldcw
+;; address.  In spite of its description, it is not clear that the sync
+;; instruction works as a barrier.
 
 (define_expand "memory_barrier"
-  [(set (match_dup 0)
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
+  [(parallel
+     [(set (match_dup 0) (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+      (clobber (match_dup 1))])]
   ""
 {
-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  /* We don't need a barrier if the target uses ordered memory references.  */
+  if (TARGET_ORDERED)
+    FAIL;
+  operands[1] = gen_reg_rtx (Pmode);
+  operands[0] = gen_rtx_MEM (BLKmode, operands[1]);
   MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "*memory_barrier"
+(define_insn "*memory_barrier_coherent"
   [(set (match_operand:BLK 0 "" "")
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
-  ""
-  "sync"
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+   (clobber (match_operand 1 "pmode_register_operand" "=r"))]
+  "TARGET_PA_20 && TARGET_COHERENT_LDCW"
+  "ldcw,co 0(%%sp),%1"
   [(set_attr "type" "binary")
    (set_attr "length" "4")])
+
+(define_insn "*memory_barrier_64"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
+  "TARGET_64BIT"
+  "ldo 15(%%sp),%1\n\tdepd %%r0,63,3,%1\n\tldcw 0(%1),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "12")])
+
+(define_insn "*memory_barrier_32"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
+  ""
+  "ldo 15(%%sp),%1\n\t{dep|depw} %%r0,31,3,%1\n\tldcw 0(%1),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "12")])
diff --git a/gcc/config/pa/pa.opt b/gcc/config/pa/pa.opt
index b32b3d8abc0..4cb81109933 100644
--- a/gcc/config/pa/pa.opt
+++ b/gcc/config/pa/pa.opt
@@ -45,6 +45,10 @@ mcaller-copies
 Target Report Mask(CALLER_COPIES)
 Caller copies function arguments passed by hidden reference.
 
+mcoherent-ldcw
+Target Report Var(TARGET_COHERENT_LDCW) Init(1)
+Use ldcw/ldcd coherent cache-control hint.
+
 mdisable-fpregs
 Target Report Mask(DISABLE_FPREGS)
 Disable FP regs.
@@ -90,6 +94,10 @@ mno-space-regs
 Target RejectNegative Report Mask(NO_SPACE_REGS)
 Disable space regs.
 
+mordered
+Target Report Var(TARGET_ORDERED) Init(0)
+Assume memory references are ordered and barriers are not needed.
+
 mpa-risc-1-0
 Target RejectNegative
 Generate PA1.0 code.
diff --git a/gcc/config/pa/pa32-linux.h b/gcc/config/pa/pa32-linux.h
index 30e338fdbc6..3e22c362d59 100644
--- a/gcc/config/pa/pa32-linux.h
+++ b/gcc/config/pa/pa32-linux.h
@@ -76,3 +76,8 @@ call_ ## FUNC (void)					\
    rodata when generating non-PIC code.  */
 #undef JUMP_TABLES_IN_TEXT_SECTION
 #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
+
+/* We need to override default selection to put references to functions
+   in COMDAT groups in .data.rel.ro.local.  */
+#undef TARGET_ASM_SELECT_RTX_SECTION
+#define TARGET_ASM_SELECT_RTX_SECTION pa_elf_select_rtx_section
diff --git a/gcc/config/pa/predicates.md b/gcc/config/pa/predicates.md
index 90b578ed984..25247f1f0e8 100644
--- a/gcc/config/pa/predicates.md
+++ b/gcc/config/pa/predicates.md
@@ -662,8 +662,8 @@
   (and (match_code "symbol_ref")
        (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC")))
 
-;; True iff this is a comparison operator.  This allows the use of
-;; MATCH_OPERATOR to recognize all the branch insns.
+;; True iff OP is an operator suitable for use in a double-word cmpib
+;; instruction.
 
 (define_predicate "cmpib_comparison_operator"
   (match_code "eq,ne,lt,le,leu,gt,gtu,ge"))
diff --git a/gcc/config/pa/som.h b/gcc/config/pa/som.h
index adefc99a1e3..3ef543428ff 100644
--- a/gcc/config/pa/som.h
+++ b/gcc/config/pa/som.h
@@ -98,8 +98,8 @@ do {								\
 
 
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \
-    do { tree fntype = TREE_TYPE (TREE_TYPE (DECL));			\
-	 tree tree_type = TREE_TYPE (DECL);				\
+    do { tree tree_type = TREE_TYPE (DECL);				\
+	 tree fntype = TREE_TYPE (tree_type);				\
 	 tree parm;							\
 	 int i;								\
 	 if (TREE_PUBLIC (DECL) || TARGET_GAS)				\
@@ -121,9 +121,11 @@ do {								\
 	       {							\
 		 tree type = DECL_ARG_TYPE (parm);			\
 		 machine_mode mode = TYPE_MODE (type);			\
-		 if (mode == SFmode && ! TARGET_SOFT_FLOAT)		\
+		 if (!AGGREGATE_TYPE_P (type)				\
+		     && mode == SFmode && ! TARGET_SOFT_FLOAT)		\
 		   fprintf (FILE, ",ARGW%d=FR", i++);			\
-		 else if (mode == DFmode && ! TARGET_SOFT_FLOAT)	\
+		 else if (!AGGREGATE_TYPE_P (type)			\
+			  && mode == DFmode && ! TARGET_SOFT_FLOAT)	\
 		   {							\
 		     if (i <= 2)					\
 		       {						\
@@ -158,9 +160,13 @@ do {								\
 		 for (; i < 4; i++)					\
 		   fprintf (FILE, ",ARGW%d=GR", i);			\
 	       }							\
-	     if (TYPE_MODE (fntype) == DFmode && ! TARGET_SOFT_FLOAT)	\
+	     if (!AGGREGATE_TYPE_P (fntype)				\
+		 && TYPE_MODE (fntype) == DFmode			\
+		 && ! TARGET_SOFT_FLOAT)				\
 	       fputs (DFMODE_RETURN_STRING, FILE);			\
-	     else if (TYPE_MODE (fntype) == SFmode && ! TARGET_SOFT_FLOAT) \
+	     else if (!AGGREGATE_TYPE_P (fntype)			\
+		      && TYPE_MODE (fntype) == SFmode			\
+		      && ! TARGET_SOFT_FLOAT)				\
 	       fputs (SFMODE_RETURN_STRING, FILE);			\
 	     else if (fntype != void_type_node)				\
 	       fputs (",RTNVAL=GR", FILE);				\
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index 8b510f87df8..1bfc65e6d9f 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -44,10 +44,10 @@ extern int riscv_const_insns (rtx);
 extern int riscv_split_const_insns (rtx);
 extern int riscv_load_store_insns (rtx, rtx_insn *);
 extern rtx riscv_emit_move (rtx, rtx);
-extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *);
+extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *, bool);
 extern bool riscv_split_symbol_type (enum riscv_symbol_type);
 extern rtx riscv_unspec_address (rtx, enum riscv_symbol_type);
-extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT);
+extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT, bool);
 extern bool riscv_legitimize_move (machine_mode, rtx, rtx);
 extern rtx riscv_subword (rtx, bool);
 extern bool riscv_split_64bit_move_p (rtx, rtx);
@@ -88,4 +88,6 @@ extern void riscv_init_builtins (void);
 /* Routines implemented in riscv-common.c.  */
 extern std::string riscv_arch_str ();
 
+extern bool riscv_hard_regno_rename_ok (unsigned, unsigned);
+
 #endif /* ! GCC_RISCV_PROTOS_H */
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index 35219956c80..b3297a38114 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -508,8 +508,8 @@ riscv_split_integer (HOST_WIDE_INT val, machine_mode mode)
   unsigned HOST_WIDE_INT hival = sext_hwi ((val - loval) >> 32, 32);
   rtx hi = gen_reg_rtx (mode), lo = gen_reg_rtx (mode);
 
-  riscv_move_integer (hi, hi, hival);
-  riscv_move_integer (lo, lo, loval);
+  riscv_move_integer (hi, hi, hival, FALSE);
+  riscv_move_integer (lo, lo, loval, FALSE);
 
   hi = gen_rtx_fmt_ee (ASHIFT, mode, hi, GEN_INT (32));
   hi = force_reg (mode, hi);
@@ -1021,9 +1021,12 @@ riscv_force_binary (machine_mode mode, enum rtx_code code, rtx x, rtx y)
    are allowed, copy it into a new register, otherwise use DEST.  */
 
 static rtx
-riscv_force_temporary (rtx dest, rtx value)
+riscv_force_temporary (rtx dest, rtx value, bool in_splitter)
 {
-  if (can_create_pseudo_p ())
+  /* We can't call gen_reg_rtx from a splitter, because this might realloc
+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the
+     combine undo buffer.  */
+  if (can_create_pseudo_p () && !in_splitter)
     return force_reg (Pmode, value);
   else
     {
@@ -1082,7 +1085,7 @@ static rtx
 riscv_unspec_offset_high (rtx temp, rtx addr, enum riscv_symbol_type symbol_type)
 {
   addr = gen_rtx_HIGH (Pmode, riscv_unspec_address (addr, symbol_type));
-  return riscv_force_temporary (temp, addr);
+  return riscv_force_temporary (temp, addr, FALSE);
 }
 
 /* Load an entry from the GOT for a TLS GD access.  */
@@ -1130,7 +1133,8 @@ static rtx riscv_tls_add_tp_le (rtx dest, rtx base, rtx sym)
    is guaranteed to be a legitimate address for mode MODE.  */
 
 bool
-riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
+riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out,
+		    bool in_splitter)
 {
   enum riscv_symbol_type symbol_type;
 
@@ -1146,7 +1150,7 @@ riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
       case SYMBOL_ABSOLUTE:
 	{
 	  rtx high = gen_rtx_HIGH (Pmode, copy_rtx (addr));
-	  high = riscv_force_temporary (temp, high);
+	  high = riscv_force_temporary (temp, high, in_splitter);
 	  *low_out = gen_rtx_LO_SUM (Pmode, high, addr);
 	}
 	break;
@@ -1205,8 +1209,9 @@ riscv_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)
 	 overflow, so we need to force a sign-extension check.  */
       high = gen_int_mode (CONST_HIGH_PART (offset), Pmode);
       offset = CONST_LOW_PART (offset);
-      high = riscv_force_temporary (temp, high);
-      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg));
+      high = riscv_force_temporary (temp, high, FALSE);
+      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg),
+				   FALSE);
     }
   return plus_constant (Pmode, reg, offset);
 }
@@ -1315,7 +1320,7 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
     return riscv_legitimize_tls_address (x);
 
   /* See if the address can split into a high part and a LO_SUM.  */
-  if (riscv_split_symbol (NULL, x, mode, &addr))
+  if (riscv_split_symbol (NULL, x, mode, &addr, FALSE))
     return riscv_force_address (addr, mode);
 
   /* Handle BASE + OFFSET using riscv_add_offset.  */
@@ -1337,17 +1342,23 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
 /* Load VALUE into DEST.  TEMP is as for riscv_force_temporary.  */
 
 void
-riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)
+riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value,
+		    bool in_splitter)
 {
   struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS];
   machine_mode mode;
   int i, num_ops;
   rtx x;
 
+  /* We can't call gen_reg_rtx from a splitter, because this might realloc
+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the
+     combine undo buffer.  */
+  bool can_create_pseudo = can_create_pseudo_p () && ! in_splitter;
+
   mode = GET_MODE (dest);
   num_ops = riscv_build_integer (codes, value, mode);
 
-  if (can_create_pseudo_p () && num_ops > 2 /* not a simple constant */
+  if (can_create_pseudo && num_ops > 2 /* not a simple constant */
       && num_ops >= riscv_split_integer_cost (value))
     x = riscv_split_integer (value, mode);
   else
@@ -1357,7 +1368,7 @@ riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)
 
       for (i = 1; i < num_ops; i++)
 	{
-	  if (!can_create_pseudo_p ())
+	  if (!can_create_pseudo)
 	    x = riscv_emit_set (temp, x);
 	  else
 	    x = force_reg (mode, x);
@@ -1381,12 +1392,12 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
   /* Split moves of big integers into smaller pieces.  */
   if (splittable_const_int_operand (src, mode))
     {
-      riscv_move_integer (dest, dest, INTVAL (src));
+      riscv_move_integer (dest, dest, INTVAL (src), FALSE);
       return;
     }
 
   /* Split moves of symbolic constants into high/low pairs.  */
-  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src))
+  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src, FALSE))
     {
       riscv_emit_set (dest, src);
       return;
@@ -1407,7 +1418,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
   if (offset != const0_rtx
       && (targetm.cannot_force_const_mem (mode, src) || can_create_pseudo_p ()))
     {
-      base = riscv_force_temporary (dest, base);
+      base = riscv_force_temporary (dest, base, FALSE);
       riscv_emit_move (dest, riscv_add_offset (NULL, base, INTVAL (offset)));
       return;
     }
@@ -1416,7 +1427,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
 
   /* When using explicit relocs, constant pool references are sometimes
      not legitimate addresses.  */
-  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0));
+  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0), FALSE);
   riscv_emit_move (dest, src);
 }
 
@@ -1601,7 +1612,10 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN
 
     case ZERO_EXTRACT:
       /* This is an SImode shift.  */
-      if (outer_code == SET && (INTVAL (XEXP (x, 2)) > 0)
+      if (outer_code == SET
+	  && CONST_INT_P (XEXP (x, 1))
+	  && CONST_INT_P (XEXP (x, 2))
+	  && (INTVAL (XEXP (x, 2)) > 0)
 	  && (INTVAL (XEXP (x, 1)) + INTVAL (XEXP (x, 2)) == 32))
 	{
 	  *total = COSTS_N_INSNS (SINGLE_SHIFT_COST);
@@ -3078,7 +3092,8 @@ riscv_print_operand_reloc (FILE *file, rtx op, bool hi_reloc)
 	break;
 
       default:
-	gcc_unreachable ();
+	output_operand_lossage ("invalid use of '%%%c'", hi_reloc ? 'h' : 'R');
+	return;
     }
 
   fprintf (file, "%s(", reloc);
@@ -4892,6 +4907,19 @@ riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
   return mode;
 }
 
+/* Return nonzero if register FROM_REGNO can be renamed to register
+   TO_REGNO.  */
+
+bool
+riscv_hard_regno_rename_ok (unsigned from_regno ATTRIBUTE_UNUSED,
+			    unsigned to_regno)
+{
+  /* Interrupt functions can only use registers that have already been
+     saved by the prologue, even if they would normally be
+     call-clobbered.  */
+  return !cfun->machine->interrupt_handler_p || df_regs_ever_live_p (to_regno);
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index c93743f9549..5130dc826d7 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -908,4 +908,6 @@ extern unsigned riscv_stack_boundary;
 #define SWSP_REACH (4LL << C_SxSP_BITS)
 #define SDSP_REACH (8LL << C_SxSP_BITS)
 
+#define HARD_REGNO_RENAME_OK(FROM, TO) riscv_hard_regno_rename_ok (FROM, TO)
+
 #endif /* ! GCC_RISCV_H */
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index a8bac170e72..e40535c9e40 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -1051,7 +1051,9 @@
   "@
    #
    lwu\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0)
 	(ashift:DI (match_dup 1) (const_int 32)))
    (set (match_dup 0)
@@ -1068,7 +1070,9 @@
   "@
    #
    lhu\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0)
 	(ashift:GPR (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
@@ -1117,7 +1121,9 @@
   "@
    #
    l<SHORT:size>\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))
    (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 2)))]
 {
@@ -1278,7 +1284,7 @@
   ""
   [(const_int 0)]
 {
-  riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]));
+  riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]), TRUE);
   DONE;
 })
 
@@ -1287,11 +1293,11 @@
   [(set (match_operand:P 0 "register_operand")
 	(match_operand:P 1))
    (clobber (match_operand:P 2 "register_operand"))]
-  "riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)"
+  "riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL, TRUE)"
   [(set (match_dup 0) (match_dup 3))]
 {
   riscv_split_symbol (operands[2], operands[1],
-		     MAX_MACHINE_MODE, &operands[3]);
+		      MAX_MACHINE_MODE, &operands[3], TRUE);
 })
 
 ;; 64-bit integer moves
@@ -1765,15 +1771,20 @@
 ;; Handle AND with 2^N-1 for N from 12 to XLEN.  This can be split into
 ;; two logical shifts.  Otherwise it requires 3 instructions: lui,
 ;; xor/addi/srli, and.
+
+;; Generating a temporary for the shift output gives better combiner results;
+;; and also fixes a problem where op0 could be a paradoxical reg and shifting
+;; by amounts larger than the size of the SUBREG_REG doesn't work.
 (define_split
   [(set (match_operand:GPR 0 "register_operand")
 	(and:GPR (match_operand:GPR 1 "register_operand")
-		 (match_operand:GPR 2 "p2m1_shift_operand")))]
+		 (match_operand:GPR 2 "p2m1_shift_operand")))
+   (clobber (match_operand:GPR 3 "register_operand"))]
   ""
- [(set (match_dup 0)
+ [(set (match_dup 3)
        (ashift:GPR (match_dup 1) (match_dup 2)))
   (set (match_dup 0)
-       (lshiftrt:GPR (match_dup 0) (match_dup 2)))]
+       (lshiftrt:GPR (match_dup 3) (match_dup 2)))]
 {
   /* Op2 is a VOIDmode constant, so get the mode size from op1.  */
   operands[2] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[1]))
@@ -1785,12 +1796,13 @@
 (define_split
   [(set (match_operand:DI 0 "register_operand")
 	(and:DI (match_operand:DI 1 "register_operand")
-		(match_operand:DI 2 "high_mask_shift_operand")))]
+		(match_operand:DI 2 "high_mask_shift_operand")))
+   (clobber (match_operand:DI 3 "register_operand"))]
   "TARGET_64BIT"
-  [(set (match_dup 0)
+  [(set (match_dup 3)
 	(lshiftrt:DI (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
-	(ashift:DI (match_dup 0) (match_dup 2)))]
+	(ashift:DI (match_dup 3) (match_dup 2)))]
 {
   operands[2] = GEN_INT (ctz_hwi (INTVAL (operands[2])));
 })
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 4a1150e0994..654d756647c 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -80,9 +80,6 @@
    UNSPEC_VUPKHPX
    UNSPEC_VUPKLPX
    UNSPEC_CONVERT_4F32_8I16
-   UNSPEC_DARN
-   UNSPEC_DARN_32
-   UNSPEC_DARN_RAW
    UNSPEC_DST
    UNSPEC_DSTT
    UNSPEC_DSTST
@@ -161,9 +158,6 @@
    UNSPEC_BCDADD
    UNSPEC_BCDSUB
    UNSPEC_BCD_OVERFLOW
-   UNSPEC_CMPRB
-   UNSPEC_CMPRB2
-   UNSPEC_CMPEQB
    UNSPEC_VRLMI
    UNSPEC_VRLNM
 ])
@@ -566,7 +560,7 @@
   [(set_attr "type" "vecsimple")])
 
 ;;
-(define_insn "altivec_vavgu<VI_char>"
+(define_insn "uavg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -575,7 +569,7 @@
   "vavgu<VI_char> %0,%1,%2"
   [(set_attr "type" "vecsimple")])
 
-(define_insn "altivec_vavgs<VI_char>"
+(define_insn "avg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -4101,223 +4095,6 @@
   "bcd<bcd_add_sub>. %0,%1,%2,%3"
   [(set_attr "type" "vecsimple")])
 
-(define_insn "darn_32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]
-  "TARGET_P9_MISC"
-  "darn %0,0"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn_raw"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,2"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,1"
-  [(set_attr "type" "integer")])
-
-;; Test byte within range.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Return in target register operand 0 a value of 1 if lo <= vv and
-;; vv <= hi.  Otherwise, set register operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
-;; 3 bits of the target CR register are all set to 0.
-(define_insn "*cmprb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))]
-  "TARGET_P9_MISC"
-  "cmprb %0,0,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Set operand 0 register to -1 if the LT bit (0x8) of condition
-;; register operand 1 is on.  Otherwise, set operand 0 register to 1
-;; if the GT bit (0x4) of condition register operand 1 is on.
-;; Otherwise, set operand 0 to 0.  Note that the result stored into
-;; register operand 0 is non-zero iff either the LT or GT bits are on
-;; within condition register operand 1.
-(define_insn "setb_signed"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gt (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-(define_insn "setb_unsigned"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gtu (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-;; Test byte within two ranges.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
-;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
-;; operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb2"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the ranges specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
-;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
-;; CR register are all set to 0.
-(define_insn "*cmprb2_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))]
-  "TARGET_P9_MISC"
-  "cmprb %0,1,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Test byte membership within set of 8 bytes.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Return in target register operand 0 a value of 1 if vv equals one
-;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
-;; register operand 0 to 0.  Note that the 8 byte values held within
-;; operand 2 need not be unique.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation requires that operands
-;; 0 and 1 have mode SI as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmpeqb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:DI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPEQB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
-;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
-;; set the GT bit to zero.  The other 3 bits of the target CR register
-;; are all set to 0.
-(define_insn "*cmpeqb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		     (match_operand:DI 2 "gpc_reg_operand" "r")]
-	  UNSPEC_CMPEQB))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "cmpeqb %0,%1,%2"
-  [(set_attr "type" "logical")])
-
 (define_expand "bcd<bcd_add_sub>_<code>"
   [(parallel [(set (reg:CCFP CR6_REGNO)
 		   (compare:CCFP
diff --git a/gcc/config/rs6000/darwin.h b/gcc/config/rs6000/darwin.h
index d3a59f42c37..165aca29838 100644
--- a/gcc/config/rs6000/darwin.h
+++ b/gcc/config/rs6000/darwin.h
@@ -53,19 +53,28 @@
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
-      if (!TARGET_64BIT) builtin_define ("__ppc__");	\
-      if (!TARGET_64BIT) builtin_define ("__PPC__");	\
-      if (TARGET_64BIT) builtin_define ("__ppc64__");	\
-      if (TARGET_64BIT) builtin_define ("__PPC64__");	\
       builtin_define ("__POWERPC__");			\
+      builtin_define ("__PPC__");			\
+      if (TARGET_64BIT)					\
+	{						\
+	  builtin_define ("__ppc64__");			\
+	  builtin_define ("__PPC64__");			\
+	  builtin_define ("__powerpc64__");		\
+	  builtin_assert ("cpu=powerpc64");		\
+	  builtin_assert ("machine=powerpc64");		\
+	}						\
+      else						\
+	{						\
+	  builtin_define ("__ppc__");			\
+	  builtin_define_std ("PPC");			\
+	  builtin_assert ("cpu=powerpc");		\
+	  builtin_assert ("machine=powerpc");		\
+	}						\
       builtin_define ("__NATURAL_ALIGNMENT__");		\
       darwin_cpp_builtins (pfile);			\
     }							\
   while (0)
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
 #define SUBTARGET_OVERRIDE_OPTIONS darwin_rs6000_override_options ()
 
 #define C_COMMON_OVERRIDE_OPTIONS do {					\
@@ -127,9 +136,42 @@ extern int darwin_emit_branch_islands;
    %:version-compare(>< 10.5 10.7 mmacosx-version-min= -lcrt1.10.5.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
-/* crt2.o is at least partially required for 10.3.x and earlier.  */
+/* crt2.o is at least partially required for 10.3.x and earlier.
+   It deals with registration of the unwind frames, where this is not
+   automatically provided by the system.  So we need it for any case that
+   might use exceptions.  */
+#undef DARWIN_CRT2_SPEC
 #define DARWIN_CRT2_SPEC \
-  "%{!m64:%:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s)}"
+"%{!m64:%{shared-libgcc|static-libstdc++|fexceptions|fobjc-exceptions|fgnu-runtime: \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s) \
+  }}"
+
+/* crt3 deals with providing cxa_atexit on earlier systems (or fixing it up,
+   for broken versions).  It's only needed for c++ code, so we can make it
+   conditional on shared-libgcc since that's forced on for c++.  */
+#undef DARWIN_CRT3_SPEC
+#define DARWIN_CRT3_SPEC \
+"%{!m64:%{shared-libgcc|static-libstdc++:							\
+   %:version-compare(>< 10.4 10.5 mmacosx-version-min= crt3.o%s) \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt3_2.o%s) \
+  }}"
+
+/* As for crt1, we need to force the dylib crt for 10.6.  */
+#undef DARWIN_DYLIB1_SPEC
+#define DARWIN_DYLIB1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
+   %:version-compare(>< 10.5 10.7 mmacosx-version-min= -ldylib1.10.5.o)"
+
+/* Likewise, the bundle crt.  */
+#undef DARWIN_BUNDLE1_SPEC
+#define DARWIN_BUNDLE1_SPEC \
+"%{!static:%:version-compare(< 10.7 mmacosx-version-min= -lbundle1.o)	\
+	   %{fgnu-tm: -lcrttms.o}}"
+
+/* The PPC regs save/restore functions are leaves and could, conceivably
+   be used by the tm destructor.  */
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC TM_DESTRUCTOR " -lef_ppc"
 
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS			\
@@ -138,12 +180,6 @@ extern int darwin_emit_branch_islands;
   { "darwin_crt2", DARWIN_CRT2_SPEC },		\
   { "darwin_subarch", DARWIN_SUBARCH_SPEC },
 
-/* We need to jam the dylib crt to 10.5 for 10.6 (Rosetta) use.  */
-#undef DARWIN_DYLIB1_SPEC
-#define DARWIN_DYLIB1_SPEC						\
-  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
-   %:version-compare(>< 10.5 10.7 mmacosx-version-min= -ldylib1.10.5.o)"
-
 /* Output a .machine directive.  */
 #undef TARGET_ASM_FILE_START
 #define TARGET_ASM_FILE_START rs6000_darwin_file_start
@@ -279,9 +315,9 @@ extern int darwin_emit_branch_islands;
 /* This is supported in cctools 465 and later.  The macro test
    above prevents using it in earlier build environments.  */
 #define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)          \
-  if ((LOG) != 0)                                             \
+  if ((LOG) > 0)                                             \
     {                                                         \
-      if ((MAX_SKIP) == 0)                                    \
+      if ((MAX_SKIP) <= 0)                                    \
         fprintf ((FILE), "\t.p2align %d\n", (LOG));           \
       else                                                    \
         fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
@@ -456,6 +492,9 @@ do {									\
    this will need to be modified similar to the x86 case.  */
 #define TARGET_FOLD_BUILTIN SUBTARGET_FOLD_BUILTIN
 
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP)
+
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define RS6000_USE_DWARF_NUMBERING
 
diff --git a/gcc/config/rs6000/darwin.md b/gcc/config/rs6000/darwin.md
index 471058dd417..a1a46a9e7ea 100644
--- a/gcc/config/rs6000/darwin.md
+++ b/gcc/config/rs6000/darwin.md
@@ -122,33 +122,6 @@ You should have received a copy of the GNU General Public License
   [(set_attr "type" "store")])
 
 ;; 64-bit MachO load/store support
-(define_insn "movdi_low"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,*!d")
-        (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   ld %0,lo16(%2)(%1)
-   lfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")])
-
-(define_insn "movsi_low_st"
-  [(set (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" "")))
-	(match_operand:SI 0 "gpc_reg_operand" "r"))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "stw %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")])
-
-(define_insn "movdi_low_st"
-  [(set (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" "")))
-	(match_operand:DI 0 "gpc_reg_operand" "r,*!d"))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   std %0,lo16(%2)(%1)
-   stfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")])
 
 ;; Mach-O PIC trickery.
 (define_expand "macho_high"
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index 5cc80dea66c..07f272df858 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -1053,8 +1053,7 @@
     return 1;
 
   /* Allow any integer constant.  */
-  if (GET_MODE_CLASS (mode) == MODE_INT
-      && CONST_SCALAR_INT_P (op))
+  if (SCALAR_INT_MODE_P (mode) && CONST_SCALAR_INT_P (op))
     return 1;
 
   /* Allow easy vector constants.  */
@@ -1154,6 +1153,16 @@
 (define_predicate "signed_comparison_operator"
   (match_code "lt,gt,le,ge"))
 
+;; Return 1 if OP is a signed comparison or an equality operator.
+(define_predicate "signed_or_equality_comparison_operator"
+  (ior (match_operand 0 "equality_operator")
+       (match_operand 0 "signed_comparison_operator")))
+
+;; Return 1 if OP is an unsigned comparison or an equality operator.
+(define_predicate "unsigned_or_equality_comparison_operator"
+  (ior (match_operand 0 "equality_operator")
+       (match_operand 0 "unsigned_comparison_operator")))
+
 ;; Return 1 if OP is a comparison operation that is valid for an SCC insn --
 ;; it must be a positive comparison.
 (define_predicate "scc_comparison_operator"
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 0a2bdb79e15..0feee7cafca 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -1002,12 +1002,12 @@ BU_ALTIVEC_2 (VADDUWS,	      "vadduws",	CONST,	altivec_vadduws)
 BU_ALTIVEC_2 (VADDSWS,	      "vaddsws",	CONST,	altivec_vaddsws)
 BU_ALTIVEC_2 (VAND,	      "vand",		CONST,	andv4si3)
 BU_ALTIVEC_2 (VANDC,	      "vandc",		CONST,	andcv4si3)
-BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	altivec_vavgub)
-BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	altivec_vavgsb)
-BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	altivec_vavguh)
-BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	altivec_vavgsh)
-BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	altivec_vavguw)
-BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	altivec_vavgsw)
+BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	uavgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	avgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	uavgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	avgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	uavgv4si3_ceil)
+BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	avgv4si3_ceil)
 BU_ALTIVEC_2 (VCFUX,	      "vcfux",		CONST,	altivec_vcfux)
 BU_ALTIVEC_2 (VCFSX,	      "vcfsx",		CONST,	altivec_vcfsx)
 BU_ALTIVEC_2 (VCMPBFP,	      "vcmpbfp",	CONST,	altivec_vcmpbfp)
@@ -1177,26 +1177,26 @@ BU_ALTIVEC_X (MTVSCR,		"mtvscr",	    MISC)
 BU_ALTIVEC_X (MFVSCR,		"mfvscr",	    MISC)
 BU_ALTIVEC_X (DSSALL,		"dssall",	    MISC)
 BU_ALTIVEC_X (DSS,		"dss",		    MISC)
-BU_ALTIVEC_X (LVSL,		"lvsl",		    MEM)
-BU_ALTIVEC_X (LVSR,		"lvsr",		    MEM)
-BU_ALTIVEC_X (LVEBX,		"lvebx",	    MEM)
-BU_ALTIVEC_X (LVEHX,		"lvehx",	    MEM)
-BU_ALTIVEC_X (LVEWX,		"lvewx",	    MEM)
-BU_ALTIVEC_X (LVXL,		"lvxl",		    MEM)
-BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    MEM)
-BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    MEM)
-BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    MEM)
-BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    MEM)
-BU_ALTIVEC_X (LVX,		"lvx",		    MEM)
-BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    MEM)
-BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    MEM)
-BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    MEM)
-BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    MEM)
-BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    MEM)
-BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    MEM)
-BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    MEM)
+BU_ALTIVEC_X (LVSL,		"lvsl",		    PURE)
+BU_ALTIVEC_X (LVSR,		"lvsr",		    PURE)
+BU_ALTIVEC_X (LVEBX,		"lvebx",	    PURE)
+BU_ALTIVEC_X (LVEHX,		"lvehx",	    PURE)
+BU_ALTIVEC_X (LVEWX,		"lvewx",	    PURE)
+BU_ALTIVEC_X (LVXL,		"lvxl",		    PURE)
+BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    PURE)
+BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    PURE)
+BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    PURE)
+BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    PURE)
+BU_ALTIVEC_X (LVX,		"lvx",		    PURE)
+BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    PURE)
+BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    PURE)
+BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    PURE)
+BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    PURE)
+BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    PURE)
+BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    PURE)
+BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    PURE)
 BU_ALTIVEC_X (STVX,		"stvx",		    MEM)
 BU_ALTIVEC_X (STVX_V2DF,	"stvx_v2df",	    MEM)
 BU_ALTIVEC_X (STVX_V2DI,	"stvx_v2di",	    MEM)
@@ -1204,10 +1204,10 @@ BU_ALTIVEC_X (STVX_V4SF,	"stvx_v4sf",	    MEM)
 BU_ALTIVEC_X (STVX_V4SI,	"stvx_v4si",	    MEM)
 BU_ALTIVEC_X (STVX_V8HI,	"stvx_v8hi",	    MEM)
 BU_ALTIVEC_X (STVX_V16QI,	"stvx_v16qi",	    MEM)
-BU_ALTIVEC_C (LVLX,		"lvlx",		    MEM)
-BU_ALTIVEC_C (LVLXL,		"lvlxl",	    MEM)
-BU_ALTIVEC_C (LVRX,		"lvrx",		    MEM)
-BU_ALTIVEC_C (LVRXL,		"lvrxl",	    MEM)
+BU_ALTIVEC_C (LVLX,		"lvlx",		    PURE)
+BU_ALTIVEC_C (LVLXL,		"lvlxl",	    PURE)
+BU_ALTIVEC_C (LVRX,		"lvrx",		    PURE)
+BU_ALTIVEC_C (LVRXL,		"lvrxl",	    PURE)
 BU_ALTIVEC_X (STVEBX,		"stvebx",	    MEM)
 BU_ALTIVEC_X (STVEHX,		"stvehx",	    MEM)
 BU_ALTIVEC_X (STVEWX,		"stvewx",	    MEM)
@@ -1718,15 +1718,15 @@ BU_VSX_P (XVCMPGEDP_P,	      "xvcmpgedp_p",	CONST,	vector_ge_v2df_p)
 BU_VSX_P (XVCMPGTDP_P,	      "xvcmpgtdp_p",	CONST,	vector_gt_v2df_p)
 
 /* VSX builtins that are handled as special cases.  */
-BU_VSX_X (LXSDX,	      "lxsdx",		MEM)
-BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	MEM)
-BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	MEM)
-BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	MEM)
-BU_VSX_X (LXVDSX,	      "lxvdsx",		MEM)
-BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	MEM)
-BU_VSX_X (LXVW4X_V4SI,        "lxvw4x_v4si",	MEM)
-BU_VSX_X (LXVW4X_V8HI,        "lxvw4x_v8hi",	MEM)
-BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	MEM)
+BU_VSX_X (LXSDX,	      "lxsdx",		PURE)
+BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	PURE)
+BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	PURE)
+BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	PURE)
+BU_VSX_X (LXVDSX,	      "lxvdsx",		PURE)
+BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	PURE)
+BU_VSX_X (LXVW4X_V4SI,	      "lxvw4x_v4si",	PURE)
+BU_VSX_X (LXVW4X_V8HI,	      "lxvw4x_v8hi",	PURE)
+BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	PURE)
 BU_VSX_X (STXSDX,	      "stxsdx",		MEM)
 BU_VSX_X (STXVD2X_V1TI,	      "stxvd2x_v1ti",	MEM)
 BU_VSX_X (STXVD2X_V2DF,	      "stxvd2x_v2df",	MEM)
@@ -1735,13 +1735,13 @@ BU_VSX_X (STXVW4X_V4SF,	      "stxvw4x_v4sf",	MEM)
 BU_VSX_X (STXVW4X_V4SI,	      "stxvw4x_v4si",	MEM)
 BU_VSX_X (STXVW4X_V8HI,	      "stxvw4x_v8hi",	MEM)
 BU_VSX_X (STXVW4X_V16QI,      "stxvw4x_v16qi",	MEM)
-BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  MEM)
-BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  MEM)
-BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", MEM)
+BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  PURE)
+BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  PURE)
+BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", PURE)
 BU_VSX_X (ST_ELEMREV_V1TI,    "st_elemrev_v1ti",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DF,    "st_elemrev_v2df",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DI,    "st_elemrev_v2di",  MEM)
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index c3b98315503..d30e5dec980 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -791,6 +791,11 @@ rtx_is_swappable_p (rtx op, unsigned int *special)
 	  case UNSPEC_REDUC_PLUS:
 	  case UNSPEC_REDUC:
 	    return 1;
+	  case UNSPEC_VPMSUM:
+	    /* vpmsumd is not swappable, but vpmsum[bhw] are.  */
+	    if (GET_MODE (op) == V2DImode)
+	      return 0;
+	    break;
 	  }
       }
 
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index cb8d737976b..87d60078bb0 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -7671,6 +7671,104 @@ address_offset (rtx op)
   return NULL_RTX;
 }
 
+/* This tests that a lo_sum {constant, symbol, symbol+offset} is valid for
+   the mode.  If we can't find (or don't know) the alignment of the symbol
+   we assume (optimistically) that it's sufficiently aligned [??? maybe we
+   should be pessimistic].  Offsets are validated in the same way as for
+   reg + offset.  */
+static bool
+darwin_rs6000_legitimate_lo_sum_const_p (rtx x, machine_mode mode)
+{
+  /* We should not get here with this.  */
+  gcc_checking_assert (! mode_supports_dq_form (mode));
+
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+
+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_MACHOPIC_OFFSET)
+    x =  XVECEXP (x, 0, 0);
+
+  rtx sym = NULL_RTX;
+  unsigned HOST_WIDE_INT offset = 0;
+
+  if (GET_CODE (x) == PLUS)
+    {
+      sym = XEXP (x, 0);
+      if (! SYMBOL_REF_P (sym))
+	return false;
+      if (!CONST_INT_P (XEXP (x, 1)))
+	return false;
+      offset = INTVAL (XEXP (x, 1));
+    }
+  else if (SYMBOL_REF_P (x))
+    sym = x;
+  else if (CONST_INT_P (x))
+    offset = INTVAL (x);
+  else if (GET_CODE (x) == LABEL_REF)
+    offset = 0; // We assume code labels are Pmode aligned
+  else
+    return false; // not sure what we have here.
+
+  /* If we don't know the alignment of the thing to which the symbol refers,
+     we assume optimistically it is "enough".
+     ??? maybe we should be pessimistic instead.  */
+  unsigned align = 0;
+
+  if (sym)
+    {
+      tree decl = SYMBOL_REF_DECL (sym);
+#if TARGET_MACHO
+      if (MACHO_SYMBOL_INDIRECTION_P (sym))
+      /* The decl in an indirection symbol is the original one, which might
+	 be less aligned than the indirection.  Our indirections are always
+	 pointer-aligned.  */
+	;
+      else
+#endif
+      if (decl && DECL_ALIGN (decl))
+	align = DECL_ALIGN_UNIT (decl);
+   }
+
+  unsigned int extra = 0;
+  switch (mode)
+    {
+    case E_DFmode:
+    case E_DDmode:
+    case E_DImode:
+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg
+	 addressing.  */
+      if (VECTOR_MEM_VSX_P (mode))
+	return false;
+
+      if (!TARGET_POWERPC64)
+	extra = 4;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    case E_TFmode:
+    case E_IFmode:
+    case E_KFmode:
+    case E_TDmode:
+    case E_TImode:
+    case E_PTImode:
+      extra = 8;
+      if (!TARGET_POWERPC64)
+	extra = 12;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  /* We only care if the access(es) would cause a change to the high part.  */
+  offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;
+  return IN_RANGE (offset, -(HOST_WIDE_INT_1 << 15),
+                            (HOST_WIDE_INT_1 << 15) - 1 - extra);
+}
+
 /* Return true if the MEM operand is a memory operand suitable for use
    with a (full width, possibly multiple) gpr load/store.  On
    powerpc64 this means the offset must be divisible by 4.
@@ -7705,7 +7803,13 @@ mem_operand_gpr (rtx op, machine_mode mode)
       && legitimate_indirect_address_p (XEXP (addr, 0), false))
     return true;
 
-  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  /* We need to look through Mach-O PIC unspecs to determine if a lo_sum is
+     really OK.  Doing this early avoids teaching all the other machinery
+     about them.  */
+  if (TARGET_MACHO && GET_CODE (addr) == LO_SUM)
+    return darwin_rs6000_legitimate_lo_sum_const_p (XEXP (addr, 1), mode);
+
+  /* Only allow offsettable addresses.  See PRs 83969 and 84279.  */
   if (!rs6000_offsettable_memref_p (op, mode, false))
     return false;
 
@@ -21330,7 +21434,7 @@ print_operand (FILE *file, rtx x, int code)
 	{
 	  const char *name = XSTR (x, 0);
 #if TARGET_MACHO
-	  if (darwin_emit_branch_islands
+	  if (darwin_symbol_stubs
 	      && MACHOPIC_INDIRECT
 	      && machopic_classify_symbol (x) == MACHOPIC_UNDEFINED_FUNCTION)
 	    name = machopic_indirection_name (x, /*stub_p=*/true);
@@ -23151,6 +23255,11 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)
 
   /* At this point we know we can use fsel.  */
 
+  /* Don't allow compare_mode other than SFmode or DFmode, for others there
+     is no fsel instruction.  */
+  if (compare_mode != SFmode && compare_mode != DFmode)
+    return 0;
+
   /* Reduce the comparison to a comparison against zero.  */
   if (! is_against_zero)
     {
@@ -25729,10 +25838,14 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)
 						    stack_limit_rtx,
 						    GEN_INT (size)));
 
-	  emit_insn (gen_elf_high (tmp_reg, toload));
-	  emit_insn (gen_elf_low (tmp_reg, tmp_reg, toload));
-	  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,
-				    const0_rtx));
+	  /* We cannot use r0 with elf_low.  Lamely solve this problem by
+	     moving registers around.  */
+	  rtx r11_reg = gen_rtx_REG (Pmode, 11);
+	  emit_move_insn (tmp_reg, r11_reg);
+	  emit_insn (gen_elf_high (r11_reg, toload));
+	  emit_insn (gen_elf_low (r11_reg, r11_reg, toload));
+	  emit_insn (gen_cond_trap (LTU, stack_reg, r11_reg, const0_rtx));
+	  emit_move_insn (r11_reg, tmp_reg);
 	}
       else
 	warning (0, "stack limit expression is not supported");
@@ -37762,25 +37875,31 @@ rs6000_can_inline_p (tree caller, tree callee)
   tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);
   tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);
 
-  /* If callee has no option attributes, then it is ok to inline.  */
+  /* If the callee has no option attributes, then it is ok to inline.  */
   if (!callee_tree)
     ret = true;
 
-  /* If caller has no option attributes, but callee does then it is not ok to
-     inline.  */
-  else if (!caller_tree)
-    ret = false;
-
   else
     {
-      struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);
+      HOST_WIDE_INT caller_isa;
       struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);
+      HOST_WIDE_INT callee_isa = callee_opts->x_rs6000_isa_flags;
+      HOST_WIDE_INT explicit_isa = callee_opts->x_rs6000_isa_flags_explicit;
 
-      /* Callee's options should a subset of the caller's, i.e. a vsx function
-	 can inline an altivec function but a non-vsx function can't inline a
-	 vsx function.  */
-      if ((caller_opts->x_rs6000_isa_flags & callee_opts->x_rs6000_isa_flags)
-	  == callee_opts->x_rs6000_isa_flags)
+      /* If the caller has option attributes, then use them.
+	 Otherwise, use the command line options.  */
+      if (caller_tree)
+	caller_isa = TREE_TARGET_OPTION (caller_tree)->x_rs6000_isa_flags;
+      else
+	caller_isa = rs6000_isa_flags;
+
+      /* The callee's options must be a subset of the caller's options, i.e.
+	 a vsx function may inline an altivec function, but a no-vsx function
+	 must not inline a vsx function.  However, for those options that the
+	 callee has explicitly enabled or disabled, then we must enforce that
+	 the callee's and caller's options match exactly; see PR70010.  */
+      if (((caller_isa & callee_isa) == callee_isa)
+	  && (caller_isa & explicit_isa) == (callee_isa & explicit_isa))
 	ret = true;
     }
 
@@ -38273,7 +38392,8 @@ rs6000_call_darwin_1 (rtx value, rtx func_desc, rtx tlsarg,
   if ((cookie_val & CALL_LONG) != 0
       && GET_CODE (func_desc) == SYMBOL_REF)
     {
-      if (darwin_emit_branch_islands && TARGET_32BIT)
+      /* FIXME: the longcall opt should not hang off picsymbol stubs.  */
+      if (darwin_symbol_stubs && TARGET_32BIT)
 	make_island = true; /* Do nothing yet, retain the CALL_LONG flag.  */
       else
 	{
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index ad80592765d..a768f5dd511 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -137,6 +137,9 @@
    UNSPEC_LSQ
    UNSPEC_FUSION_GPR
    UNSPEC_STACK_CHECK
+   UNSPEC_CMPRB
+   UNSPEC_CMPRB2
+   UNSPEC_CMPEQB
    UNSPEC_ADD_ROUND_TO_ODD
    UNSPEC_SUB_ROUND_TO_ODD
    UNSPEC_MUL_ROUND_TO_ODD
@@ -164,6 +167,9 @@
    UNSPECV_EH_RR		; eh_reg_restore
    UNSPECV_ISYNC		; isync instruction
    UNSPECV_MFTB			; move from time base
+   UNSPECV_DARN			; darn 1 (deliver a random number)
+   UNSPECV_DARN_32		; darn 2
+   UNSPECV_DARN_RAW		; darn 0
    UNSPECV_NLGR			; non-local goto receiver
    UNSPECV_MFFS			; Move from FPSCR
    UNSPECV_MFFSL		; Move from FPSCR light instruction version
@@ -5930,7 +5936,7 @@
       /* Insert new RN mode into FSCPR.  */
       emit_insn (gen_rs6000_mffs (tmp_df));
       tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);
-      emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0xFFFFFFF8FFFFFFFF)));
+      emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0xFFFFFFF8FFFFFFFFULL)));
       emit_insn (gen_iordi3 (tmp_di, tmp_di, tmp_rn));
 
       /* Need to write to field 7.  The fields are [0:15].  The equation to
@@ -6424,12 +6430,6 @@
   ""
   "")
 
-(define_expand "one_cmpl<mode>2"
-  [(set (match_operand:BOOL_128 0 "vlogical_operand")
-        (not:BOOL_128 (match_operand:BOOL_128 1 "vlogical_operand")))]
-  ""
-  "")
-
 (define_expand "nor<mode>3"
   [(set (match_operand:BOOL_128 0 "vlogical_operand")
 	(and:BOOL_128
@@ -6724,7 +6724,7 @@
 	 (const_string "16")))])
 
 ;; 128-bit one's complement
-(define_insn_and_split "*one_cmpl<mode>3_internal"
+(define_insn_and_split "one_cmpl<mode>2"
   [(set (match_operand:BOOL_128 0 "vlogical_operand" "=<BOOL_REGS_OUTPUT>")
 	(not:BOOL_128
 	  (match_operand:BOOL_128 1 "vlogical_operand" "<BOOL_REGS_UNARY>")))]
@@ -6818,13 +6818,6 @@
 ;; do the load 16-bits at a time.  We could do this by loading from memory,
 ;; and this is even supposed to be faster, but it is simpler not to get
 ;; integers in the TOC.
-(define_insn "movsi_low"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-        (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "lwz %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")])
 
 ;;		MR           LA           LWZ          LFIWZX       LXSIWZX
 ;;		STW          STFIWX       STXSIWX      LI           LIS
@@ -10662,6 +10655,10 @@
 
   emit_call_insn (gen_call (operands[0], const0_rtx, const0_rtx));
 
+  for (int i = 0; i < XVECLEN (operands[2], 0); i++)
+    emit_clobber (SET_SRC (XVECEXP (operands[2], 0, i)));
+  emit_insn (gen_blockage ());
+
   for (i = 0; i < XVECLEN (operands[2], 0); i++)
     {
       rtx set = XVECEXP (operands[2], 0, i);
@@ -14322,7 +14319,225 @@
    "xscmpuqp %0,%1,%2"
   [(set_attr "type" "veccmp")
    (set_attr "size" "128")])
+
+;; Miscellaneous ISA 3.0 (power9) instructions
+
+(define_insn "darn_32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec_volatile:SI [(const_int 0)] UNSPECV_DARN_32))]
+  "TARGET_P9_MISC"
+  "darn %0,0"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn_raw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN_RAW))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,2"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,1"
+  [(set_attr "type" "integer")])
+
+;; Test byte within range.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Return in target register operand 0 a value of 1 if lo <= vv and
+;; vv <= hi.  Otherwise, set register operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
+;; 3 bits of the target CR register are all set to 0.
+(define_insn "*cmprb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))]
+  "TARGET_P9_MISC"
+  "cmprb %0,0,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Set operand 0 register to -1 if the LT bit (0x8) of condition
+;; register operand 1 is on.  Otherwise, set operand 0 register to 1
+;; if the GT bit (0x4) of condition register operand 1 is on.
+;; Otherwise, set operand 0 to 0.  Note that the result stored into
+;; register operand 0 is non-zero iff either the LT or GT bits are on
+;; within condition register operand 1.
+(define_insn "setb_signed"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gt (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+(define_insn "setb_unsigned"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gtu (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+;; Test byte within two ranges.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
+;; operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb2"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the ranges specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
+;; CR register are all set to 0.
+(define_insn "*cmprb2_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))]
+  "TARGET_P9_MISC"
+  "cmprb %0,1,%1,%2"
+  [(set_attr "type" "logical")])
 
+;; Test byte membership within set of 8 bytes.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Return in target register operand 0 a value of 1 if vv equals one
+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
+;; register operand 0 to 0.  Note that the 8 byte values held within
+;; operand 2 need not be unique.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation requires that operands
+;; 0 and 1 have mode SI as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmpeqb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:DI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPEQB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
+;; set the GT bit to zero.  The other 3 bits of the target CR register
+;; are all set to 0.
+(define_insn "*cmpeqb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		     (match_operand:DI 2 "gpc_reg_operand" "r")]
+	  UNSPEC_CMPEQB))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "cmpeqb %0,%1,%2"
+  [(set_attr "type" "logical")])
 
 
 (include "sync.md")
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index 70bcfe02e22..0b62dd04bde 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -493,6 +493,101 @@
     FAIL;
 })
 
+;; To support vector condition vectorization, define vcond_mask and vec_cmp.
+
+;; Same mode for condition true/false values and predicate operand.
+(define_expand "vcond_mask_<mode><mode>"
+  [(match_operand:VEC_I 0 "vint_operand")
+   (match_operand:VEC_I 1 "vint_operand")
+   (match_operand:VEC_I 2 "vint_operand")
+   (match_operand:VEC_I 3 "vint_operand")]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+{
+  emit_insn (gen_vector_select_<mode> (operands[0], operands[2], operands[1],
+                                  operands[3]));
+  DONE;
+})
+
+;; For signed integer vectors comparison.
+(define_expand "vec_cmp<mode><mode>"
+  [(set (match_operand:VEC_I 0 "vint_operand")
+        (match_operator 1 "signed_or_equality_comparison_operator"
+          [(match_operand:VEC_I 2 "vint_operand")
+           (match_operand:VEC_I 3 "vint_operand")]))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+{
+  enum rtx_code code = GET_CODE (operands[1]);
+  rtx tmp = gen_reg_rtx (<MODE>mode);
+  switch (code)
+    {
+    case NE:
+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));
+      emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));
+      break;
+    case EQ:
+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));
+      break;
+    case GE:
+      emit_insn (gen_vector_nlt<mode> (operands[0],operands[2], operands[3],
+                                       tmp));
+      break;
+    case GT:
+      emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[3]));
+      break;
+    case LE:
+      emit_insn (gen_vector_ngt<mode> (operands[0], operands[2], operands[3],
+                                       tmp));
+      break;
+    case LT:
+      emit_insn (gen_vector_gt<mode> (operands[0], operands[3], operands[2]));
+      break;
+    default:
+      gcc_unreachable ();
+      break;
+    }
+  DONE;
+})
+
+;; For unsigned integer vectors comparison.
+(define_expand "vec_cmpu<mode><mode>"
+  [(set (match_operand:VEC_I 0 "vint_operand")
+        (match_operator 1 "unsigned_or_equality_comparison_operator"
+          [(match_operand:VEC_I 2 "vint_operand")
+           (match_operand:VEC_I 3 "vint_operand")]))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+{
+  enum rtx_code code = GET_CODE (operands[1]);
+  rtx tmp = gen_reg_rtx (<MODE>mode);
+  switch (code)
+    {
+    case NE:
+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));
+      emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));
+      break;
+    case EQ:
+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));
+      break;
+    case GEU:
+      emit_insn (gen_vector_nltu<mode> (operands[0], operands[2], operands[3],
+                                        tmp));
+      break;
+    case GTU:
+      emit_insn (gen_vector_gtu<mode> (operands[0], operands[2], operands[3]));
+      break;
+    case LEU:
+      emit_insn (gen_vector_ngtu<mode> (operands[0], operands[2], operands[3],
+                                        tmp));
+      break;
+    case LTU:
+      emit_insn (gen_vector_gtu<mode> (operands[0], operands[3], operands[2]));
+      break;
+    default:
+      gcc_unreachable ();
+      break;
+    }
+  DONE;
+})
+
 (define_expand "vector_eq<mode>"
   [(set (match_operand:VEC_C 0 "vlogical_operand")
 	(eq:VEC_C (match_operand:VEC_C 1 "vlogical_operand")
diff --git a/gcc/config/s390/8561.md b/gcc/config/s390/8561.md
index e5a345f4dba..2442349271b 100644
--- a/gcc/config/s390/8561.md
+++ b/gcc/config/s390/8561.md
@@ -1,4 +1,4 @@
-;; Scheduling description for arch13.
+;; Scheduling description for z15.
 ;;   Copyright (C) 2019 Free Software Foundation, Inc.
 ;;   Contributed by Robin Dapp (rdapp@linux.ibm.com)
 ;; This file is part of GCC.
@@ -17,12 +17,12 @@
 ;; along with GCC; see the file COPYING3.  If not see
 ;; <http://www.gnu.org/licenses/>.
 
-(define_attr "arch13_unit_fpd" ""
+(define_attr "z15_unit_fpd" ""
 (cond [(eq_attr "mnemonic" "ddb,ddbr,deb,debr,dxbr,sqdb,sqdbr,sqeb,\
 sqebr,sqxbr,vfddb,vfdsb,vfsqdb,vfsqsb,wfddb,wfdsb,wfdxb,wfsqdb,wfsqxb")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxa" ""
+(define_attr "z15_unit_fxa" ""
 (cond [(eq_attr "mnemonic" "a,afi,ag,agf,agfi,agfr,agh,aghi,aghik,\
 agr,agrk,ah,ahi,ahik,ahy,al,alc,alcg,alcgr,alcr,alfi,alg,algf,algfi,algfr,\
 alghsik,algr,algrk,alhsik,alr,alrk,aly,ar,ark,ay,bras,brasl,etnd,exrl,flogr,\
@@ -39,7 +39,7 @@ slgrk,sll,sllg,sllk,slr,slrk,sly,sr,sra,srag,srak,srk,srl,srlg,srlk,sy,x,xg,\
 xgr,xgrk,xihf,xilf,xr,xrk,xy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxb" ""
+(define_attr "z15_unit_fxb" ""
 (cond [(eq_attr "mnemonic" "agsi,algsi,alsi,asi,b,bc,bcr,bi,br,brcl,\
 c,cfi,cg,cgf,cgfi,cgfr,cgfrl,cgh,cghi,cghrl,cghsi,cgit,cgr,cgrl,cgrt,ch,\
 chi,chrl,chsi,chy,cit,cl,clfhsi,clfi,clfit,clg,clgf,clgfi,clgfr,clgfrl,\
@@ -52,11 +52,11 @@ tmhl,tml,tmlh,tmll,tmy,vlgvb,vlgvf,vlgvg,vlgvh,vlr,vlvgb,vlvgf,vlvgg,vlvgh,\
 vlvgp,vst,vstef,vsteg,vstl,vstrl,vstrlr,xi,xiy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxd" ""
+(define_attr "z15_unit_fxd" ""
 (cond [(eq_attr "mnemonic" "dlgr,dlr,dr,dsgfr,dsgr")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_lsu" ""
+(define_attr "z15_unit_lsu" ""
 (cond [(eq_attr "mnemonic" "a,adb,aeb,ag,agf,agh,agsi,ah,ahy,al,alc,\
 alcg,alg,algf,algsi,alsi,aly,asi,ay,c,cdb,ceb,cg,cgf,cgfrl,cgh,cghrl,cghsi,\
 cgrl,ch,chrl,chsi,chy,cl,clc,clfhsi,clg,clgf,clgfrl,clghrl,clghsi,clgrl,\
@@ -73,7 +73,7 @@ vllezf,vllezg,vllezh,vllezlf,vlrepb,vlrepf,vlrepg,vlreph,vlrl,vlrlr,vst,\
 vstef,vsteg,vstl,vstrl,vstrlr,x,xg,xi,xiy,xy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_vfu" ""
+(define_attr "z15_unit_vfu" ""
 (cond [(eq_attr "mnemonic" "adb,adbr,adtr,aeb,aebr,axbr,axtr,cdb,\
 cdbr,cdtr,ceb,cebr,cpsdr,cxbr,cxtr,ddtr,dxtr,fidbr,fidbra,fidtr,fiebr,\
 fiebra,fixbr,fixbra,fixtr,lcdbr,lcebr,lcxbr,ldeb,ldebr,ldetr,le,ledbr,ledtr,\
@@ -115,7 +115,7 @@ wflpxb,wfmadb,wfmasb,wfmaxb,wfmaxxb,wfmdb,wfminxb,wfmsb,wfmsdb,wfmssb,wfmsxb,\
 wfmxb,wfnmaxb,wfnmsxb,wfsdb,wfssb,wfsxb,wldeb,wledb")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_cracked" ""
+(define_attr "z15_cracked" ""
 (cond [(eq_attr "mnemonic" "bas,basr,cdfbr,cdftr,cdgbr,cdgtr,cdlfbr,\
 cdlftr,cdlgbr,cdlgtr,cefbr,cegbr,celfbr,celgbr,cfdbr,cfebr,cfxbr,cgdbr,cgdtr,\
 cgebr,cgxbr,cgxtr,chhsi,clfdbr,clfdtr,clfebr,clfxbr,clfxtr,clgdbr,clgdtr,\
@@ -123,13 +123,13 @@ clgebr,clgxbr,clgxtr,cs,csg,csy,d,efpc,ex,lcgfr,lngfr,lpgfr,lpq,lxr,lzxr,\
 rxsbg,stpq,vgef,vgeg,vscef,vsceg,vsteb,vsteh")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_expanded" ""
+(define_attr "z15_expanded" ""
 (cond [(eq_attr "mnemonic" "cds,cdsg,cdsy,cxfbr,cxftr,cxgbr,cxgtr,\
 cxlfbr,cxlftr,cxlgbr,cxlgtr,dl,dlg,dsg,dsgf,lam,lm,lmg,lmy,sldl,srda,srdl,\
 stam,stm,stmg,stmy,tbegin,tbeginc")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_groupalone" ""
+(define_attr "z15_groupalone" ""
 (cond [(eq_attr "mnemonic" "alc,alcg,alcgr,alcr,axbr,axtr,clc,cxbr,\
 cxtr,dlgr,dlr,dr,dsgfr,dsgr,dxbr,dxtr,fixbr,fixbra,fixtr,flogr,lcxbr,lnxbr,\
 lpxbr,ltxbr,ltxtr,lxdb,lxdbr,lxdtr,lxeb,lxebr,m,madb,maeb,maebr,mfy,mg,mgrk,\
@@ -137,11 +137,11 @@ ml,mlg,mlgr,mlr,mr,msdb,mseb,msebr,mvc,mxbr,mxtr,nc,oc,ppa,sfpc,slb,slbg,\
 slbgr,slbr,sqxbr,sxbr,sxtr,tabort,tcxb,tdcxt,tend,xc")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_endgroup" ""
+(define_attr "z15_endgroup" ""
 (cond [(eq_attr "mnemonic" "bras,brasl,exrl,ipm")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_groupoftwo" ""
+(define_attr "z15_groupoftwo" ""
 (cond [(eq_attr "mnemonic" "vacccq,vacq,vfmadb,vfmasb,vfmsdb,vfmssb,\
 vfnmadb,vfnmasb,vfnmsdb,vfnmssb,vgfmab,vgfmaf,vgfmag,vgfmah,vmaeb,vmaef,vmaeh,\
 vmahb,vmahf,vmahh,vmalb,vmaleb,vmalef,vmaleh,vmalf,vmalhb,vmalhf,vmalhh,\
@@ -149,8 +149,8 @@ vmalhw,vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,vmslg,vperm,vsbcbiq,vsbiq,vsel,\
 wfmadb,wfmasb,wfmaxb,wfmsdb,wfmssb,wfmsxb,wfnmaxb,wfnmsxb")
  (const_int 1)] (const_int 0)))
 
-(define_insn_reservation "arch13_0" 0
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_0" 0
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "a,afi,ag,agfi,aghi,aghik,agr,agrk,ahi,ahik,al,\
 alfi,alg,algf,algfi,algfr,alghsik,algr,algrk,alhsik,alr,alrk,aly,ar,ark,ay,\
 b,bc,bcr,bi,br,bras,brasl,brcl,c,cfi,cg,cgfi,cghi,cghsi,cgit,cgr,cgrl,\
@@ -168,8 +168,8 @@ sllk,slr,slrk,sly,sr,sra,srag,srak,srda,srdl,srk,srl,srlg,srlk,sy,tm,tmh,\
 tmhh,tmhl,tml,tmlh,tmll,tmy,vlr,vlvgb,vlvgf,vlvgg,vlvgh,x,xg,xgr,xgrk,xihf,\
 xilf,xr,xrk,xy")) "nothing")
 
-(define_insn_reservation "arch13_1" 1
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_1" 1
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "agf,agfr,agh,agsi,ah,ahy,algsi,alsi,asi,cgf,\
 cgfr,cgfrl,cgh,cghrl,ch,chrl,chy,clm,clmy,cpsdr,laa,laag,lan,lang,lao,laog,\
 lax,laxg,le,ler,ley,loc,locg,locghi,locgr,lochi,locr,mvghi,mvhhi,mvhi,mvi,\
@@ -196,8 +196,8 @@ wfcedb,wfcesb,wfcexb,wfchdb,wfchedb,wfchesb,wfchexb,wfchsb,wfchxb,wflcdb,\
 wflcsb,wflcxb,wflndb,wflnsb,wflnxb,wflpdb,wflpsb,wflpxb,wfmaxxb,wfminxb,xi,\
 xiy")) "nothing")
 
-(define_insn_reservation "arch13_2" 2
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_2" 2
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdb,cdbr,ceb,cebr,ear,ipm,l,lcbb,lcdbr,lcebr,ld,\
 lde,ldy,lg,lgdr,lgrl,llc,llgc,llgf,llgfrl,llgh,llghrl,llgt,llh,llhrl,lm,\
 lmg,lmy,lndbr,lnebr,lpdbr,lpebr,lrl,ltdbr,ltebr,ly,popcnt,sar,tcdb,tceb,\
@@ -208,8 +208,8 @@ vistrh,vlgvb,vlgvf,vlgvg,vlgvh,vllezb,vllezf,vllezg,vllezh,vllezlf,vlrepb,\
 vlrepf,vlrepg,vlreph,vlrl,vlvgp,vpklsfs,vpklsgs,vpklshs,vpksfs,vpksgs,vpkshs,\
 wfcdb,wfcexbs,wfchexbs,wfchxbs,wfcsb")) "nothing")
 
-(define_insn_reservation "arch13_3" 3
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_3" 3
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cds,cdsy,mgh,mghi,mh,mhi,mhy,std,stdy,ste,stey,\
 vcksm,vfeezbs,vfeezfs,vfeezhs,vgfmab,vgfmaf,vgfmag,vgfmah,vgfmb,vgfmf,vgfmg,\
 vgfmh,vistrbs,vistrfs,vistrhs,vl,vlbb,vll,vlrlr,vmaeb,vmaef,vmaeh,vmahb,\
@@ -218,14 +218,14 @@ vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,vmeb,vmef,vmeh,vmhb,vmhf,vmhh,vmlb,\
 vmleb,vmlef,vmleh,vmlf,vmlhb,vmlhf,vmlhh,vmlhw,vmlob,vmlof,vmloh,vmob,vmof,\
 vmoh,vsumb,vsumgf,vsumgh,vsumh,vsumqf,vsumqg,vtm")) "nothing")
 
-(define_insn_reservation "arch13_4" 4
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_4" 4
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "bas,basr,chhsi,clc,ex,lam,lcgfr,lngfr,lpgfr,lxr,\
 lzxr,ms,msfi,msgf,msgfi,msgfr,msr,msy,mvc,nc,oc,ppa,rxsbg,tabort,tbegin,\
 tbeginc,tend,vst,vstef,vsteg,vstl,vstrl,vstrlr,xc")) "nothing")
 
-(define_insn_reservation "arch13_5" 5
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_5" 5
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "adb,adbr,aeb,aebr,alc,alcg,alcgr,alcr,cs,csg,\
 csy,fidbr,fidbra,fiebr,fiebra,ldeb,ldebr,ledbr,madbr,mdb,mdbr,meeb,meebr,\
 msdbr,msrkc,sdb,sdbr,seb,sebr,slb,slbg,slbgr,slbr,stm,stmg,stmy,vfadb,vfasb,\
@@ -233,53 +233,53 @@ vfidb,vfisb,vfmadb,vfmasb,vfmdb,vfmsb,vfmsdb,vfmssb,vfnmadb,vfnmasb,vfnmsdb,\
 vfnmssb,vfsdb,vfssb,vldeb,vledb,vmslg,wfadb,wfasb,wfidb,wfisb,wflld,wfmadb,\
 wfmasb,wfmdb,wfmsb,wfmsdb,wfmssb,wfsdb,wfssb,wldeb,wledb")) "nothing")
 
-(define_insn_reservation "arch13_6" 6
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_6" 6
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "msg,msgr,sfpc")) "nothing")
 
-(define_insn_reservation "arch13_7" 7
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_7" 7
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "adtr,cdtr,fidtr,ldetr,ltdtr,msgrkc,sdtr,tdcdt,\
 tdcet,vgef,vgeg")) "nothing")
 
-(define_insn_reservation "arch13_8" 8
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_8" 8
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdsg,flogr,lpq,stpq,vsteb,vsteh")) "nothing")
 
-(define_insn_reservation "arch13_9" 9
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_9" 9
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdfbr,cdgbr,cdlfbr,cdlgbr,cefbr,cegbr,celfbr,\
 celgbr,cxfbr,cxgbr,cxlfbr,cxlgbr,m,madb,maeb,maebr,mfy,ml,mlr,mr,msdb,mseb,\
 msebr,stam,wfaxb,wfixb,wfsxb")) "nothing")
 
-(define_insn_reservation "arch13_10" 10
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_10" 10
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "lxdb,lxdbr,lxeb,lxebr,vscef,vsceg")) "nothing")
 
-(define_insn_reservation "arch13_11" 11
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_11" 11
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cfdbr,cfebr,cgdbr,cgebr,clfdbr,clfebr,clgdbr,\
 clgebr,mg,mgrk,mlg,mlgr")) "nothing")
 
-(define_insn_reservation "arch13_12" 12
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_12" 12
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cxbr,cxftr,cxlftr,cxtr,tcxb,tdcxt")) "nothing")
 
-(define_insn_reservation "arch13_13" 13
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_13" 13
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "axbr,axtr,fixbr,fixbra,fixtr,lcxbr,lnxbr,lpxbr,\
 ltxbr,ltxtr,lxdtr,sxbr,sxtr")) "nothing")
 
-(define_insn_reservation "arch13_14" 14
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_14" 14
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cfxbr,cgxbr,clfxbr,clgxbr,ledtr")) "nothing")
 
-(define_insn_reservation "arch13_16" 16
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_16" 16
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdftr,cdlftr")) "nothing")
 
-(define_insn_reservation "arch13_20" 20
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_20" 20
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdgtr,cdlgtr,cgdtr,cgxtr,clfdtr,clfxtr,clgdtr,\
 clgxtr,cxgtr,cxlgtr,d,ddb,ddbr,ddtr,deb,debr,dl,dlg,dlgr,dlr,dr,dsg,dsgf,\
 dsgfr,dsgr,dxbr,dxtr,efpc,mdtr,mxbr,mxtr,sqdb,sqdbr,sqeb,sqebr,sqxbr,vfddb,\
diff --git a/gcc/config/s390/driver-native.c b/gcc/config/s390/driver-native.c
index a386d633a87..6bc7d590668 100644
--- a/gcc/config/s390/driver-native.c
+++ b/gcc/config/s390/driver-native.c
@@ -121,10 +121,10 @@ s390_host_detect_local_cpu (int argc, const char **argv)
 	      break;
 	    case 0x8561:
 	    case 0x8562:
-	      cpu = "arch13";
+	      cpu = "z15";
 	      break;
 	    default:
-	      cpu = "arch13";
+	      cpu = "z15";
 	      break;
 	    }
 	}
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index fbf7d9f50e8..3f39b9d3b88 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -281,7 +281,7 @@
 #define B_HTM   (1 << 1)  /* Builtins requiring the transactional execution facility.  */
 #define B_VX    (1 << 2)  /* Builtins requiring the z13 vector extensions.  */
 #define B_VXE   (1 << 3)  /* Builtins requiring the z14 vector extensions.  */
-#define B_VXE2  (1 << 4)  /* Builtins requiring the arch13 vector extensions.  */
+#define B_VXE2  (1 << 4)  /* Builtins requiring the z15 vector extensions.  */
 #define B_DEP   (1 << 5)  /* Builtin has been deprecated and a warning should be issued.  */
 
 /* B_DEF defines a standard (not overloaded) builtin
diff --git a/gcc/config/s390/s390-c.c b/gcc/config/s390/s390-c.c
index 97debdc3905..c2f9b507011 100644
--- a/gcc/config/s390/s390-c.c
+++ b/gcc/config/s390/s390-c.c
@@ -905,6 +905,12 @@ s390_resolve_overloaded_builtin (location_t loc,
       return error_mark_node;
     }
 
+  if (!TARGET_VXE2 && (ob_flags & B_VXE2))
+    {
+      error_at (loc, "%qF requires z15 or higher", ob_fndecl);
+      return error_mark_node;
+    }
+
   ob_fcode -= S390_BUILTIN_MAX;
 
   for (b_arg_chain = TYPE_ARG_TYPES (TREE_TYPE (ob_fndecl));
@@ -983,6 +989,15 @@ s390_resolve_overloaded_builtin (location_t loc,
       return error_mark_node;
     }
 
+
+  if (!TARGET_VXE2
+      && bflags_overloaded_builtin_var[last_match_index] & B_VXE2)
+    {
+      error_at (loc, "%qs matching variant requires z15 or higher",
+		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
+      return error_mark_node;
+    }
+
   if (bflags_overloaded_builtin_var[last_match_index] & B_DEP)
     warning_at (loc, 0, "%qs matching variant is deprecated.",
 		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
diff --git a/gcc/config/s390/s390-opts.h b/gcc/config/s390/s390-opts.h
index ab41cb883f3..502edea719b 100644
--- a/gcc/config/s390/s390-opts.h
+++ b/gcc/config/s390/s390-opts.h
@@ -37,7 +37,7 @@ enum processor_type
   PROCESSOR_2827_ZEC12,
   PROCESSOR_2964_Z13,
   PROCESSOR_3906_Z14,
-  PROCESSOR_8561_ARCH13,
+  PROCESSOR_8561_Z15,
   PROCESSOR_NATIVE,
   PROCESSOR_max
 };
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index fc4571d0d0c..db3f94978ec 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -337,7 +337,7 @@ const struct s390_processor processor_table[] =
   { "zEC12",  "zEC12",  PROCESSOR_2827_ZEC12,  &zEC12_cost,  10 },
   { "z13",    "z13",    PROCESSOR_2964_Z13,    &zEC12_cost,  11 },
   { "z14",    "arch12", PROCESSOR_3906_Z14,    &zEC12_cost,  12 },
-  { "arch13", "",       PROCESSOR_8561_ARCH13, &zEC12_cost,  13 },
+  { "z15",    "arch13", PROCESSOR_8561_Z15,    &zEC12_cost,  13 },
   { "native", "",       PROCESSOR_NATIVE,      NULL,         0  }
 };
 
@@ -811,6 +811,12 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 	  error ("Builtin %qF requires z14 or higher.", fndecl);
 	  return const0_rtx;
 	}
+
+      if ((bflags & B_VXE2) && !TARGET_VXE2)
+	{
+	  error ("Builtin %qF requires z15 or higher.", fndecl);
+	  return const0_rtx;
+	}
     }
   if (fcode >= S390_OVERLOADED_BUILTIN_VAR_OFFSET
       && fcode < S390_ALL_BUILTIN_MAX)
@@ -1782,7 +1788,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
       if (*code == EQ)
 	new_code = reversed_comparison_code_parts (GET_CODE (*op0),
 						   XEXP (*op0, 0),
-						   XEXP (*op1, 0), NULL);
+						   XEXP (*op0, 1), NULL);
       else
 	new_code = GET_CODE (*op0);
 
@@ -1795,7 +1801,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
     }
 
   /* ~a==b -> ~(a^b)==0   ~a!=b -> ~(a^b)!=0 */
-  if (TARGET_ARCH13
+  if (TARGET_Z15
       && (*code == EQ || *code == NE)
       && (GET_MODE (*op0) == DImode || GET_MODE (*op0) == SImode)
       && GET_CODE (*op0) == NOT)
@@ -1807,7 +1813,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
     }
 
   /* a&b == -1 -> ~a|~b == 0    a|b == -1 -> ~a&~b == 0  */
-  if (TARGET_ARCH13
+  if (TARGET_Z15
       && (*code == EQ || *code == NE)
       && (GET_CODE (*op0) == AND || GET_CODE (*op0) == IOR)
       && (GET_MODE (*op0) == DImode || GET_MODE (*op0) == SImode)
@@ -3529,7 +3535,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 
 	/* It is a real IF-THEN-ELSE.  An additional move will be
 	   needed to implement that.  */
-	if (!TARGET_ARCH13
+	if (!TARGET_Z15
 	    && reload_completed
 	    && !rtx_equal_p (dst, then)
 	    && !rtx_equal_p (dst, els))
@@ -3551,7 +3557,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
     case IOR:
 
       /* nnrk, nngrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (mode == SImode || mode == DImode)
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && GET_CODE (XEXP (x, 1)) == NOT)
@@ -3598,7 +3604,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 
     case AND:
       /* nork, nogrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (mode == SImode || mode == DImode)
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && GET_CODE (XEXP (x, 1)) == NOT)
@@ -3770,7 +3776,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
       *total = COSTS_N_INSNS (1);
 
       /* nxrk, nxgrk ~(a^b)==0 */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && XEXP (x, 1) == const0_rtx
 	  && GET_CODE (XEXP (XEXP (x, 0), 0)) == XOR
@@ -3785,7 +3791,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 	}
 
       /* nnrk, nngrk, nork, nogrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (GET_CODE (XEXP (x, 0)) == AND || GET_CODE (XEXP (x, 0)) == IOR)
 	  && XEXP (x, 1) == const0_rtx
 	  && (GET_MODE (XEXP (x, 0)) == SImode || GET_MODE (XEXP (x, 0)) == DImode)
@@ -14440,16 +14446,16 @@ s390_get_sched_attrmask (rtx_insn *insn)
       if (get_attr_z14_groupoftwo (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;
       break;
-    case PROCESSOR_8561_ARCH13:
-      if (get_attr_arch13_cracked (insn))
+    case PROCESSOR_8561_Z15:
+      if (get_attr_z15_cracked (insn))
 	mask |= S390_SCHED_ATTR_MASK_CRACKED;
-      if (get_attr_arch13_expanded (insn))
+      if (get_attr_z15_expanded (insn))
 	mask |= S390_SCHED_ATTR_MASK_EXPANDED;
-      if (get_attr_arch13_endgroup (insn))
+      if (get_attr_z15_endgroup (insn))
 	mask |= S390_SCHED_ATTR_MASK_ENDGROUP;
-      if (get_attr_arch13_groupalone (insn))
+      if (get_attr_z15_groupalone (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPALONE;
-      if (get_attr_arch13_groupoftwo (insn))
+      if (get_attr_z15_groupoftwo (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;
       break;
     default:
@@ -14487,15 +14493,15 @@ s390_get_unit_mask (rtx_insn *insn, int *units)
       if (get_attr_z14_unit_vfu (insn))
 	mask |= 1 << 3;
       break;
-    case PROCESSOR_8561_ARCH13:
+    case PROCESSOR_8561_Z15:
       *units = 4;
-      if (get_attr_arch13_unit_lsu (insn))
+      if (get_attr_z15_unit_lsu (insn))
 	mask |= 1 << 0;
-      if (get_attr_arch13_unit_fxa (insn))
+      if (get_attr_z15_unit_fxa (insn))
 	mask |= 1 << 1;
-      if (get_attr_arch13_unit_fxb (insn))
+      if (get_attr_z15_unit_fxb (insn))
 	mask |= 1 << 2;
-      if (get_attr_arch13_unit_vfu (insn))
+      if (get_attr_z15_unit_vfu (insn))
 	mask |= 1 << 3;
       break;
     default:
@@ -14511,7 +14517,7 @@ s390_is_fpd (rtx_insn *insn)
     return false;
 
   return get_attr_z13_unit_fpd (insn) || get_attr_z14_unit_fpd (insn)
-    || get_attr_arch13_unit_fpd (insn);
+    || get_attr_z15_unit_fpd (insn);
 }
 
 static bool
@@ -14521,7 +14527,7 @@ s390_is_fxd (rtx_insn *insn)
     return false;
 
   return get_attr_z13_unit_fxd (insn) || get_attr_z14_unit_fxd (insn)
-    || get_attr_arch13_unit_fxd (insn);
+    || get_attr_z15_unit_fxd (insn);
 }
 
 /* Returns TRUE if INSN is a long-running instruction.  */
@@ -15968,13 +15974,19 @@ s390_support_vector_misalignment (machine_mode mode ATTRIBUTE_UNUSED,
 static HOST_WIDE_INT
 s390_vector_alignment (const_tree type)
 {
+  tree size = TYPE_SIZE (type);
+
   if (!TARGET_VX_ABI)
     return default_vector_alignment (type);
 
   if (TYPE_USER_ALIGN (type))
     return TYPE_ALIGN (type);
 
-  return MIN (64, tree_to_shwi (TYPE_SIZE (type)));
+  if (tree_fits_uhwi_p (size)
+      && tree_to_uhwi (size) < BIGGEST_ALIGNMENT)
+    return tree_to_uhwi (size);
+
+  return BIGGEST_ALIGNMENT;
 }
 
 /* Implement TARGET_CONSTANT_ALIGNMENT.  Alignment on even addresses for
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index 969f58a2ba0..f7023d985f1 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -41,12 +41,12 @@ enum processor_flags
   PF_Z14 = 2048,
   PF_VXE = 4096,
   PF_VXE2 = 8192,
-  PF_ARCH13 = 16384
+  PF_Z15 = 16384
 };
 
 /* This is necessary to avoid a warning about comparing different enum
    types.  */
-#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_8561_ARCH13 ? PROCESSOR_8561_ARCH13 : s390_tune ))
+#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_8561_Z15 ? PROCESSOR_8561_Z15 : s390_tune ))
 
 /* These flags indicate that the generated code should run on a cpu
    providing the respective hardware facility regardless of the
@@ -100,10 +100,10 @@ enum processor_flags
 	(s390_arch_flags & PF_VXE)
 #define TARGET_CPU_VXE_P(opts) \
 	(opts->x_s390_arch_flags & PF_VXE)
-#define TARGET_CPU_ARCH13 \
-	(s390_arch_flags & PF_ARCH13)
-#define TARGET_CPU_ARCH13_P(opts) \
-	(opts->x_s390_arch_flags & PF_ARCH13)
+#define TARGET_CPU_Z15 \
+	(s390_arch_flags & PF_Z15)
+#define TARGET_CPU_Z15_P(opts) \
+	(opts->x_s390_arch_flags & PF_Z15)
 #define TARGET_CPU_VXE2 \
 	(s390_arch_flags & PF_VXE2)
 #define TARGET_CPU_VXE2_P(opts) \
@@ -160,9 +160,9 @@ enum processor_flags
 	(TARGET_VX && TARGET_CPU_VXE)
 #define TARGET_VXE_P(opts)						\
 	(TARGET_VX_P (opts) && TARGET_CPU_VXE_P (opts))
-#define TARGET_ARCH13 (TARGET_ZARCH && TARGET_CPU_ARCH13)
-#define TARGET_ARCH13_P(opts)						\
-	(TARGET_ZARCH_P (opts->x_target_flags) && TARGET_CPU_ARCH13_P (opts))
+#define TARGET_Z15 (TARGET_ZARCH && TARGET_CPU_Z15)
+#define TARGET_Z15_P(opts)						\
+	(TARGET_ZARCH_P (opts->x_target_flags) && TARGET_CPU_Z15_P (opts))
 #define TARGET_VXE2					\
 	(TARGET_VX && TARGET_CPU_VXE2)
 #define TARGET_VXE2_P(opts)						\
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 714d8b00a80..5a3496ac92e 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -513,11 +513,11 @@
 ;; Processor type.  This attribute must exactly match the processor_type
 ;; enumeration in s390.h.
 
-(define_attr "cpu" "z900,z990,z9_109,z9_ec,z10,z196,zEC12,z13,z14,arch13"
+(define_attr "cpu" "z900,z990,z9_109,z9_ec,z10,z196,zEC12,z13,z14,z15"
   (const (symbol_ref "s390_tune_attr")))
 
 (define_attr "cpu_facility"
-  "standard,ieee,zarch,cpu_zarch,longdisp,extimm,dfp,z10,z196,zEC12,vx,z13,z14,vxe,arch13,vxe2"
+  "standard,ieee,zarch,cpu_zarch,longdisp,extimm,dfp,z10,z196,zEC12,vx,z13,z14,vxe,z15,vxe2"
   (const_string "standard"))
 
 (define_attr "enabled" ""
@@ -575,8 +575,8 @@
 	      (match_test "TARGET_VXE"))
 	 (const_int 1)
 
-	 (and (eq_attr "cpu_facility" "arch13")
-	      (match_test "TARGET_ARCH13"))
+	 (and (eq_attr "cpu_facility" "z15")
+	      (match_test "TARGET_Z15"))
 	 (const_int 1)
 
          (and (eq_attr "cpu_facility" "vxe2")
@@ -613,7 +613,7 @@
 ;; Pipeline description for z14
 (include "3906.md")
 
-;; Pipeline description for arch13
+;; Pipeline description for z15
 (include "8561.md")
 
 ;; Predicates
@@ -642,7 +642,7 @@
 (define_mode_iterator DD_DF [DF DD])
 (define_mode_iterator TD_TF [TF TD])
 
-; 32 bit int<->fp conversion instructions are available since VXE2 (arch13).
+; 32 bit int<->fp conversion instructions are available since VXE2 (z15).
 (define_mode_iterator VX_CONV_BFP [DF (SF "TARGET_VXE2")])
 (define_mode_iterator VX_CONV_INT [DI (SI "TARGET_VXE2")])
 
@@ -6749,7 +6749,7 @@
    stoc<g>%C1\t%3,%0
    stoc<g>%D1\t%4,%0"
   [(set_attr "op_type" "RRF,RRF,RRF,RSY,RSY,RIE,RIE,RSY,RSY")
-   (set_attr "cpu_facility" "*,*,arch13,*,*,z13,z13,*,*")])
+   (set_attr "cpu_facility" "*,*,z15,*,*,z13,z13,*,*")])
 
 ;;
 ;;- Multiply instructions.
@@ -7568,7 +7568,7 @@
 	(and:GPR (not:GPR (match_operand:GPR 1 "nonimmediate_operand" ""))
 		 (match_operand:GPR 2 "general_operand" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "!TARGET_ARCH13
+  "!TARGET_Z15
    && ! reload_completed
    && (GET_CODE (operands[0]) != MEM
       /* Ensure that s390_logical_operator_ok_p will succeed even
@@ -7925,7 +7925,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(ANDOR:GPR (not:GPR (match_dup 1))
 		   (match_dup 2)))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7937,7 +7937,7 @@
 		    (match_operand:GPR 2 "register_operand" "d"))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7947,7 +7947,7 @@
 	(ANDOR:GPR (not:GPR (match_operand:GPR 1 "register_operand" "d"))
 		   (match_operand:GPR 2 "register_operand" "d")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7965,7 +7965,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(ANDOR:GPR (not:GPR (match_dup 1))
 		   (not:GPR (match_dup 2))))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -7977,7 +7977,7 @@
 		    (not:GPR (match_operand:GPR 2 "register_operand" "d")))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -7987,7 +7987,7 @@
 	(ANDOR:GPR (not:GPR (match_operand:GPR 1 "register_operand" "d"))
 		   (not:GPR (match_operand:GPR 2 "register_operand" "d"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8371,7 +8371,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(xor:GPR (not:GPR (match_dup 1))
 		    (match_dup 2)))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8383,7 +8383,7 @@
 			   (match_operand:GPR 2 "register_operand" "d")))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8393,7 +8393,7 @@
 	(not:GPR (xor:GPR (match_operand:GPR 1 "register_operand" "d")
 			  (match_operand:GPR 2 "register_operand" "d"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -11351,34 +11351,34 @@
 ; Population count instruction
 ;
 
-(define_insn "*popcountdi_arch13_cc"
+(define_insn "*popcountdi_z15_cc"
   [(set (reg CC_REGNUM)
 	(compare (popcount:DI (match_operand:DI 1 "register_operand" "d"))
 		 (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d")
 	(match_dup 1))]
-  "TARGET_ARCH13 && s390_match_ccmode (insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode (insn, CCTmode)"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-(define_insn "*popcountdi_arch13_cconly"
+(define_insn "*popcountdi_z15_cconly"
   [(set (reg CC_REGNUM)
 	(compare (popcount:DI (match_operand:DI 1 "register_operand" "d"))
 		 (const_int 0)))
    (clobber (match_scratch:DI 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-(define_insn "*popcountdi_arch13"
+(define_insn "*popcountdi_z15"
   [(set (match_operand:DI 0 "register_operand" "=d")
 	(popcount:DI (match_operand:DI 1 "register_operand" "d")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-; The pre-arch13 popcount instruction counts the bits of op1 in 8 byte
+; The pre-z15 popcount instruction counts the bits of op1 in 8 byte
 ; portions and stores the result in the corresponding bytes in op0.
 (define_insn "*popcount<mode>_z196"
   [(set (match_operand:INT 0 "register_operand" "=d")
@@ -11422,7 +11422,7 @@
      (clobber (reg:CC CC_REGNUM))])]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcountdi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11453,7 +11453,7 @@
 
 ; popcount always counts on the full 64 bit. With the z196 version
 ; counting bits per byte we just ignore the upper 4 bytes.  With the
-; arch13 version we have to zero out the upper 32 bits first.
+; z15 version we have to zero out the upper 32 bits first.
 (define_expand "popcountsi2"
   [(set (match_dup 2)
 	(zero_extend:DI (match_operand:SI 1 "register_operand")))
@@ -11463,7 +11463,7 @@
 	(subreg:SI (match_dup 3) 4))]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcountsi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11501,7 +11501,7 @@
 	(subreg:HI (match_dup 3) 6))]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcounthi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11516,7 +11516,7 @@
 ; For popcount on a single byte the old z196 style popcount
 ; instruction is ideal.  Since it anyway does a byte-wise popcount we
 ; just use it instead of zero extending the QImode input to DImode and
-; using the arch13 popcount variant.
+; using the z15 popcount variant.
 (define_expand "popcountqi2"
   [; popcnt op0, op1
    (parallel [(set (match_operand:QI 0 "register_operand" "")
diff --git a/gcc/config/s390/s390.opt b/gcc/config/s390/s390.opt
index 639f1679a56..6a6e1f75736 100644
--- a/gcc/config/s390/s390.opt
+++ b/gcc/config/s390/s390.opt
@@ -110,7 +110,10 @@ EnumValue
 Enum(processor_type) String(arch12) Value(PROCESSOR_3906_Z14)
 
 EnumValue
-Enum(processor_type) String(arch13) Value(PROCESSOR_8561_ARCH13)
+Enum(processor_type) String(z15) Value(PROCESSOR_8561_Z15)
+
+EnumValue
+Enum(processor_type) String(arch13) Value(PROCESSOR_8561_Z15)
 
 EnumValue
 Enum(processor_type) String(native) Value(PROCESSOR_NATIVE) DriverOnly
diff --git a/gcc/config/s390/vector.md b/gcc/config/s390/vector.md
index 140ef474a92..6ca503b0d44 100644
--- a/gcc/config/s390/vector.md
+++ b/gcc/config/s390/vector.md
@@ -70,7 +70,7 @@
 
 (define_mode_iterator V_128_NOSINGLE [V16QI V8HI V4SI V4SF V2DI V2DF])
 
-; 32 bit int<->fp vector conversion instructions are available since VXE2 (arch13).
+; 32 bit int<->fp vector conversion instructions are available since VXE2 (z15).
 (define_mode_iterator VX_VEC_CONV_BFP [V2DF (V4SF "TARGET_VXE2")])
 (define_mode_iterator VX_VEC_CONV_INT [V2DI (V4SI "TARGET_VXE2")])
 
@@ -295,9 +295,9 @@
 ; However, this would probably be slower.
 
 (define_insn "mov<mode>"
-  [(set (match_operand:V_8 0 "nonimmediate_operand" "=v,v,d,v,R,  v,  v,  v,  v,d,  Q,  S,  Q,  S,  d,  d,d,d,d,R,T")
-        (match_operand:V_8 1 "general_operand"      " v,d,v,R,v,j00,jm1,jyy,jxx,d,j00,j00,jm1,jm1,j00,jm1,R,T,b,d,d"))]
-  ""
+  [(set (match_operand:V_8 0 "nonimmediate_operand" "=v,v,d,v,R,  v,  v,  v,  v,d,  Q,  S,  Q,  S,  d,  d,d,R,T")
+        (match_operand:V_8 1 "general_operand"      " v,d,v,R,v,j00,jm1,jyy,jxx,d,j00,j00,jm1,jm1,j00,jm1,T,d,d"))]
+  "TARGET_VX"
   "@
    vlr\t%v0,%v1
    vlvgb\t%v0,%1,0
@@ -315,12 +315,10 @@
    mviy\t%0,-1
    lhi\t%0,0
    lhi\t%0,-1
-   lh\t%0,%1
-   lhy\t%0,%1
-   lhrl\t%0,%1
+   llc\t%0,%1
    stc\t%1,%0
    stcy\t%1,%0"
-  [(set_attr "op_type"      "VRR,VRS,VRS,VRX,VRX,VRI,VRI,VRI,VRI,RR,SI,SIY,SI,SIY,RI,RI,RX,RXY,RIL,RX,RXY")])
+  [(set_attr "op_type"      "VRR,VRS,VRS,VRX,VRX,VRI,VRI,VRI,VRI,RR,SI,SIY,SI,SIY,RI,RI,RXY,RX,RXY")])
 
 (define_insn "mov<mode>"
   [(set (match_operand:V_16 0 "nonimmediate_operand" "=v,v,d,v,R,  v,  v,  v,  v,d,  Q,  Q,  d,  d,d,d,d,R,T,b")
diff --git a/gcc/config/s390/vx-builtins.md b/gcc/config/s390/vx-builtins.md
index 3020bc94d3e..5ec3fb4fe58 100644
--- a/gcc/config/s390/vx-builtins.md
+++ b/gcc/config/s390/vx-builtins.md
@@ -2147,7 +2147,7 @@
   "<vw>fmax<sdx>b\t%v0,%v1,%v2,%b3"
   [(set_attr "op_type" "VRR")])
 
-; The element reversal builtins introduced with arch13 have been made
+; The element reversal builtins introduced with z15 have been made
 ; available also for older CPUs down to z13.
 (define_expand "eltswap<mode>"
   [(set (match_operand:VEC_HW                 0 "nonimmediate_operand" "")
@@ -2181,8 +2181,8 @@
    vster<bhfgq>\t%v1,%v0"
   [(set_attr "op_type" "*,VRX,VRX")])
 
-; arch13 has instructions for doing element reversal from mem to reg
-; or the other way around.  For reg to reg or on pre arch13 machines
+; z15 has instructions for doing element reversal from mem to reg
+; or the other way around.  For reg to reg or on pre z15 machines
 ; we have to emulate it with vector permute.
 (define_insn_and_split "*eltswap<mode>_emu"
   [(set (match_operand:VEC_HW                 0 "nonimmediate_operand" "=vR")
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 8dc79a764df..11440988f1a 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -664,6 +664,9 @@ static const struct attribute_spec sh_attribute_table[] =
 #undef TARGET_CONSTANT_ALIGNMENT
 #define TARGET_CONSTANT_ALIGNMENT constant_alignment_word_strings
 
+#undef  TARGET_HAVE_SPECULATION_SAFE_VALUE
+#define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 
@@ -737,7 +740,7 @@ got_mode_name:;
     {
       if (tokens[i] == "strict")
 	ret.strict = true;
-      else if (tokens[i].find ("gbr-offset=") == 0)
+      else if (!tokens[i].compare (0, strlen ("gbr-offset="), "gbr-offset="))
 	{
 	  std::string offset_str = tokens[i].substr (strlen ("gbr-offset="));
 	  ret.tcb_gbr_offset = integral_argument (offset_str.c_str ());
@@ -958,11 +961,13 @@ sh_option_override (void)
   if (flag_unsafe_math_optimizations)
     {
       /* Enable fsca insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSCA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSCA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSCA = 1;
 
       /* Enable fsrra insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSRRA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSRRA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSRRA = 1;
     }
 
@@ -12087,9 +12092,11 @@ sh_extending_set_of_reg::use_as_extended_reg (rtx_insn* use_at_insn) const
 	rtx r = gen_reg_rtx (SImode);
 	rtx_insn* i0;
 	if (from_mode == QImode)
-	  i0 = emit_insn_after (gen_extendqisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendqisi2 (r, set_src), insn));
 	else if (from_mode == HImode)
-	  i0 = emit_insn_after (gen_extendhisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendhisi2 (r, set_src), insn));
 	else
 	  gcc_unreachable ();
 
@@ -12507,7 +12514,7 @@ static void
 sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,
 		  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)
 {
-  if ((TARGET_SH4A_FP || TARGET_SH4_300)
+  if ((TARGET_SH4A_FP || TARGET_FPU_SH4_300)
       && prev_mode != FP_MODE_NONE && prev_mode != mode)
     {
       emit_insn (gen_toggle_pr ());
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
index 0204872eae7..9372fcfa699 100644
--- a/gcc/config/sh/sh.h
+++ b/gcc/config/sh/sh.h
@@ -69,6 +69,8 @@ extern int code_for_indirect_jump_scratch;
    FPU is disabled (which makes it compatible with SH4al-dsp).  */
 #define TARGET_SH4A_FP (TARGET_SH4A && TARGET_FPU_ANY)
 
+/* True if the FPU is a SH4-300 variant.  */
+#define TARGET_FPU_SH4_300 (TARGET_FPU_ANY && TARGET_SH4_300)
 
 /* This is not used by the SH2E calling convention  */
 #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index 83543778619..fdb80d5d9d6 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -9163,7 +9163,7 @@
 	(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_PR)))
    (set (reg:SI FPSCR_MODES_REG)
 	(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]
-  "TARGET_SH4A_FP"
+  "TARGET_SH4A_FP || TARGET_FPU_SH4_300"
   "fpchg"
   [(set_attr "type" "fpscr_toggle")])
 
@@ -9391,15 +9391,31 @@
 (define_expand "negsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negsf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negsf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negsf2_i"
+(define_insn "negsf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "negsf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "sqrtsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(sqrt:SF (match_operand:SF 1 "fp_arith_reg_operand" "")))]
@@ -9489,15 +9505,31 @@
 (define_expand "abssf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_abssf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_abssf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*abssf2_i"
+(define_insn "abssf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "abssf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "adddf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(plus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -9673,12 +9705,28 @@
 (define_expand "negdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negdf2_i"
+(define_insn "negdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
+(define_insn "negdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
@@ -9704,15 +9752,31 @@
 (define_expand "absdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_absdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_absdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*absdf2_i"
+(define_insn "absdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "absdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
 (define_expand "extendsfdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(float_extend:DF (match_operand:SF 1 "fpul_operand" "")))]
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index 9bdae7b9faa..ef1adb69ede 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -69,6 +69,7 @@ extern void sparc_split_reg_mem (rtx, rtx, machine_mode);
 extern void sparc_split_mem_reg (rtx, rtx, machine_mode);
 extern int sparc_split_reg_reg_legitimate (rtx, rtx);
 extern void sparc_split_reg_reg (rtx, rtx, machine_mode);
+extern const char *output_load_pcrel_sym (rtx *);
 extern const char *output_ubranch (rtx, rtx_insn *);
 extern const char *output_cbranch (rtx, rtx, int, int, int, rtx_insn *);
 extern const char *output_return (rtx_insn *);
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 93479ab6bdc..a993aab7639 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -3972,11 +3972,8 @@ eligible_for_call_delay (rtx_insn *trial)
   if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)
     return 0;
 
-  /* Binutils allows
-       call __tls_get_addr, %tgd_call (foo)
-        add %l7, %o0, %o0, %tgd_add (foo)
-     while Sun as/ld does not.  */
-  if (TARGET_GNU_TLS || !TARGET_TLS)
+  /* The only problematic cases are TLS sequences with Sun as/ld.  */
+  if ((TARGET_GNU_TLS && HAVE_GNU_LD) || !TARGET_TLS)
     return 1;
 
   pat = PATTERN (trial);
@@ -4243,9 +4240,11 @@ sparc_cannot_force_const_mem (machine_mode mode, rtx x)
 }
 
 /* Global Offset Table support.  */
-static GTY(()) rtx got_helper_rtx = NULL_RTX;
-static GTY(()) rtx got_register_rtx = NULL_RTX;
 static GTY(()) rtx got_symbol_rtx = NULL_RTX;
+static GTY(()) rtx got_register_rtx = NULL_RTX;
+static GTY(()) rtx got_helper_rtx = NULL_RTX;
+
+static GTY(()) bool got_helper_needed = false;
 
 /* Return the SYMBOL_REF for the Global Offset Table.  */
 
@@ -4258,27 +4257,6 @@ sparc_got (void)
   return got_symbol_rtx;
 }
 
-#ifdef HAVE_GAS_HIDDEN
-# define USE_HIDDEN_LINKONCE 1
-#else
-# define USE_HIDDEN_LINKONCE 0
-#endif
-
-static void
-get_pc_thunk_name (char name[32], unsigned int regno)
-{
-  const char *reg_name = reg_names[regno];
-
-  /* Skip the leading '%' as that cannot be used in a
-     symbol name.  */
-  reg_name += 1;
-
-  if (USE_HIDDEN_LINKONCE)
-    sprintf (name, "__sparc_get_pc_thunk.%s", reg_name);
-  else
-    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC", regno);
-}
-
 /* Wrapper around the load_pcrel_sym{si,di} patterns.  */
 
 static rtx
@@ -4298,30 +4276,78 @@ gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2)
   return insn;
 }
 
+/* Output the load_pcrel_sym{si,di} patterns.  */
+
+const char *
+output_load_pcrel_sym (rtx *operands)
+{
+  if (flag_delayed_branch)
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" add\t%0, %%lo(%a1+4), %0", operands);
+    }
+  else
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-8), %0", operands);
+      output_asm_insn ("add\t%0, %%lo(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" nop", NULL);
+    }
+
+  if (operands[2] == got_helper_rtx)
+    got_helper_needed = true;
+
+  return "";
+}
+
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
 /* Emit code to load the GOT register.  */
 
 void
 load_got_register (void)
 {
-  if (!got_register_rtx)
-    got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+  rtx insn;
 
   if (TARGET_VXWORKS_RTP)
-    emit_insn (gen_vxworks_load_got ());
+    {
+      if (!got_register_rtx)
+	got_register_rtx = pic_offset_table_rtx;
+
+      insn = gen_vxworks_load_got ();
+    }
   else
     {
+      if (!got_register_rtx)
+	got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+
       /* The GOT symbol is subject to a PC-relative relocation so we need a
 	 helper function to add the PC value and thus get the final value.  */
       if (!got_helper_rtx)
 	{
 	  char name[32];
-	  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);
+
+	  /* Skip the leading '%' as that cannot be used in a symbol name.  */
+	  if (USE_HIDDEN_LINKONCE)
+	    sprintf (name, "__sparc_get_pc_thunk.%s",
+		     reg_names[REGNO (got_register_rtx)] + 1);
+	  else
+	    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC",
+					 REGNO (got_register_rtx));
+
 	  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
 	}
 
-      emit_insn (gen_load_pcrel_sym (got_register_rtx, sparc_got (),
-				     got_helper_rtx));
+      insn
+	= gen_load_pcrel_sym (got_register_rtx, sparc_got (), got_helper_rtx);
     }
+
+  emit_insn (insn);
 }
 
 /* Ensure that we are not using patterns that are not OK with PIC.  */
@@ -4457,7 +4483,7 @@ sparc_pic_register_p (rtx x)
     return true;
 
   if (!HARD_REGISTER_P (pic_offset_table_rtx)
-      && (HARD_REGISTER_P (x) || lra_in_progress)
+      && (HARD_REGISTER_P (x) || lra_in_progress || reload_in_progress)
       && ORIGINAL_REGNO (x) == REGNO (pic_offset_table_rtx))
     return true;
 
@@ -5486,7 +5512,7 @@ save_local_or_in_reg_p (unsigned int regno, int leaf_function)
     return true;
 
   /* GOT register (%l7) if needed.  */
-  if (regno == GLOBAL_OFFSET_TABLE_REGNUM && got_register_rtx)
+  if (got_register_rtx && regno == REGNO (got_register_rtx))
     return true;
 
   /* If the function accesses prior frames, the frame pointer and the return
@@ -12529,10 +12555,9 @@ static void
 sparc_file_end (void)
 {
   /* If we need to emit the special GOT helper function, do so now.  */
-  if (got_helper_rtx)
+  if (got_helper_needed)
     {
       const char *name = XSTR (got_helper_rtx, 0);
-      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];
 #ifdef DWARF2_UNWIND_INFO
       bool do_cfi;
 #endif
@@ -12569,17 +12594,22 @@ sparc_file_end (void)
 #ifdef DWARF2_UNWIND_INFO
       do_cfi = dwarf2out_do_cfi_asm ();
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_startproc\n");
+	output_asm_insn (".cfi_startproc", NULL);
 #endif
       if (flag_delayed_branch)
-	fprintf (asm_out_file, "\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" add\t%%o7, %0, %0", &got_register_rtx);
+	}
       else
-	fprintf (asm_out_file, "\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("add\t%%o7, %0, %0", &got_register_rtx);
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" nop", NULL);
+	}
 #ifdef DWARF2_UNWIND_INFO
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_endproc\n");
+	output_asm_insn (".cfi_endproc", NULL);
 #endif
     }
 
@@ -13085,7 +13115,10 @@ sparc_init_pic_reg (void)
   edge entry_edge;
   rtx_insn *seq;
 
-  if (!crtl->uses_pic_offset_table)
+  /* In PIC mode, we need to always initialize the PIC register if optimization
+     is enabled, because we are called from IRA and LRA may later force things
+     to the constant pool for optimization purposes.  */
+  if (!flag_pic || (!crtl->uses_pic_offset_table && !optimize))
     return;
 
   start_sequence ();
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index 015065ffb81..4b09fc86b78 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -736,6 +736,13 @@ along with GCC; see the file COPYING3.  If not see
    register window instruction in the prologue.  */
 #define HARD_REGNO_RENAME_OK(FROM, TO) ((FROM) != 1)
 
+/* Select a register mode required for caller save of hard regno REGNO.
+   Contrary to what is documented, the default is not the smallest suitable
+   mode but the largest suitable mode for the given (REGNO, NREGS) pair and
+   it quickly creates paradoxical subregs that can be problematic.  */
+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \
+  ((MODE) == VOIDmode ? choose_hard_reg_mode (REGNO, NREGS, false) : (MODE))
+
 /* Specify the registers used for certain standard purposes.
    The values of these macros are register numbers.  */
 
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 7af62d599b9..0a6e27ffa83 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -1604,10 +1604,7 @@
    (clobber (reg:P O7_REG))]
   "REGNO (operands[0]) == INTVAL (operands[3])"
 {
-  if (flag_delayed_branch)
-    return "sethi\t%%hi(%a1-4), %0\n\tcall\t%a2\n\t add\t%0, %%lo(%a1+4), %0";
-  else
-    return "sethi\t%%hi(%a1-8), %0\n\tadd\t%0, %%lo(%a1-4), %0\n\tcall\t%a2\n\t nop";
+  return output_load_pcrel_sym (operands);
 }
   [(set (attr "type") (const_string "multi"))
    (set (attr "length")
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index 19bd616d67f..ee5612441e2 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -2865,7 +2865,8 @@ xtensa_expand_prologue (void)
 			    gen_rtx_SET (mem, reg));
 	    }
 	}
-      if (total_size > 1024)
+      if (total_size > 1024
+	  || (!callee_save_size && total_size > 128))
 	{
 	  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);
 	  emit_move_insn (tmp_reg, GEN_INT (total_size -
diff --git a/gcc/configure b/gcc/configure
index 481071b4265..a065ba23728 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -701,6 +701,7 @@ build_exeext
 all_selected_languages
 all_languages
 all_lang_makefrags
+all_lang_configurefrags
 all_gtfiles
 all_compilers
 srcdir
@@ -18646,7 +18647,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18649 "configure"
+#line 18650 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18752,7 +18753,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18755 "configure"
+#line 18756 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -23045,7 +23046,7 @@ if test $in_tree_ld != yes ; then
       ld_vers=`echo $ld_ver | sed -n \
 	  -e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*.*\)$,\1,p'`
     fi
-    ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
+    ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)\(-*\)\([01][0-9]\)\2\([0-3][0-9]\).*$,\1\3\4,p'`
     ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
     ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
     ld_vers_patch=`expr "$ld_vers" : '[0-9]*\.[0-9]*\.\([0-9]*\)'`
@@ -29559,7 +29560,8 @@ lang_tree_files=
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -29645,6 +29647,7 @@ do
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -29815,6 +29818,7 @@ fi
 
 
 
+
 
 
 # Echo link setup.
diff --git a/gcc/configure.ac b/gcc/configure.ac
index ce2825580c6..3a7251102ef 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2658,7 +2658,7 @@ if test $in_tree_ld != yes ; then
       ld_vers=`echo $ld_ver | sed -n \
 	  -e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*.*\)$,\1,p'`
     fi
-    ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
+    ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)\(-*\)\([01][0-9]\)\2\([0-3][0-9]\).*$,\1\3\4,p'`
     ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
     ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
     ld_vers_patch=`expr "$ld_vers" : '[0-9]*\.[0-9]*\.\([0-9]*\)'`
@@ -6188,7 +6188,8 @@ lang_tree_files=
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -6276,6 +6277,7 @@ changequote([,])dnl
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -6383,6 +6385,7 @@ AC_SUBST(subdirs)
 AC_SUBST(srcdir)
 AC_SUBST(all_compilers)
 AC_SUBST(all_gtfiles)
+AC_SUBST(all_lang_configurefrags)
 AC_SUBST(all_lang_makefrags)
 AC_SUBST(all_languages)
 AC_SUBST(all_selected_languages)
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index c977850d067..c697ff3a442 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,587 @@
+2020-03-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88395
+	PR c++/93551
+	* constraint.cc (constraints_satisfied_p): Use push_tinst_level.
+
+2020-03-05  Martin Sebor  <msebor@redhat.com>
+
+	Backport from trunk.
+	2020-02-21  Martin Sebor  <msebor@redhat.com>
+
+	PR gcov-profile/93753
+	* class.c (check_flexarrays): Tighten up a test for potential members
+	of anonymous structs or unions.
+
+2020-03-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90338
+	* pt.c (invalid_nontype_parm_type_p): Check complain for non-literal
+	and mutable errors.
+
+2020-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91607
+	* constexpr.c (constexpr_call_hasher::equal): Use
+	same_type_ignoring_top_level_qualifiers_p.
+
+2020-03-04  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90938
+	* tree.c (type_initializer_zero_p): Fail for structs initialized
+	with non-structs.
+
+2020-03-04  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2020-01-24  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/93299 - ICE in tsubst_copy with parenthesized expression.
+	* pt.c (tsubst_copy): Handle a REF_PARENTHESIZED_P VIEW_CONVERT_EXPR.
+
+2020-03-04  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2020-02-26  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/93676 - value-init crash in template.
+	* init.c (build_new_1): Don't call build_vec_init in a template.
+
+2020-03-04  Jason Merrill  <jason@redhat.com>
+	    Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90505 - mismatch in template argument deduction.
+	* pt.c (tsubst): Don't reduce the template level of template
+	parameters when tf_partial.
+
+2020-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90432
+	* init.c (perform_member_init): Don't do aggregate initialization of
+	empty field.
+	* constexpr.c (cx_check_missing_mem_inits): Don't enforce
+	initialization of empty field.
+
+2020-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90997
+	* semantics.c (finish_call_expr): Don't call
+	instantiate_non_dependent_expr before warn_for_memset.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86917
+	* constexpr.c (cxx_eval_vec_init_1): Handle CONSTRUCTOR.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91953
+	* constexpr.c (potential_constant_expression_1) [PARM_DECL]: Allow
+	empty class type.
+	[COMPONENT_REF]: A member function reference doesn't use the object
+	as an rvalue.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88256
+	* cp-gimplify.c (predeclare_vla): New.
+	(cp_genericize_r) [NOP_EXPR]: Call it.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93442
+	* parser.c (cp_parser_lambda_expression): Clear in_discarded_stmt.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90732 - ICE with VLA capture and generic lambda.
+	* pt.c (tsubst_lambda_expr): Repeat add_capture for VLAs.
+
+2020-03-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90333
+	PR c++/89640
+	PR c++/60503
+	* parser.c (cp_parser_type_specifier_seq): Don't parse attributes in
+	a trailing return type.
+	(cp_parser_lambda_declarator_opt): Parse C++11 attributes before
+	parens.
+
+2020-02-26  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/92745 - bogus error when initializing array of vectors.
+	* decl.c (reshape_init_r): For a nested compound literal, do
+	call reshape_init_{class,array,vector}.
+
+2020-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90951
+	* constexpr.c (cxx_eval_array_reference): {}-initialize missing
+	elements instead of value-initializing them.
+
+2020-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93140
+	* pt.c (tsubst_decl) [PARM_DECL]: Check cp_unevaluated_operand in
+	handling of TREE_CHAIN for empty pack.
+
+2020-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92852
+	* constexpr.c (maybe_constant_value): Don't unshare if the cached
+	value is the same as the argument.
+
+2020-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/61414
+	* class.c (enum_min_precision): Change prec type from int to int &.
+
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93557
+	* semantics.c (cp_build_vec_convert): Call decay_conversion on arg
+	prior to passing it to c_build_vec_convert.
+
+	2020-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91118
+	* cp-gimplify.c (cxx_omp_predetermined_sharing): Return
+	OMP_CLAUSE_DEFAULT_SHARED for typeinfo decls.
+
+2020-01-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90546
+	* call.c (build_user_type_conversion_1): Allow a template conversion
+	returning an rvalue reference to bind directly to an lvalue.
+
+	PR c++/90731
+	* decl.c (grokdeclarator): Propagate eh spec from typedef.
+
+	PR c++/90966
+	* pt.c (tsubst_copy) [STRING_CST]: Don't use fold_convert.
+
+	PR c++/93279 - ICE with lambda in member operator.
+	* name-lookup.c (maybe_save_operator_binding): Don't remember
+	class-scope bindings.
+
+2020-01-27  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/91826
+	* name-lookup.c (is_ancestor): Allow CHILD to be a namespace alias.
+
+2020-01-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92852 - ICE with generic lambda and reference var.
+	* constexpr.c (maybe_constant_value): Likewise.
+
+2020-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93228
+	* parser.c (cp_parser_template_name): Look up deprecated attribute
+	in DECL_TEMPLATE_RESULT or its type's attributes.
+
+	2019-12-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92438
+	* parser.c (cp_parser_constructor_declarator_p): If open paren
+	is followed by RID_ATTRIBUTE, skip over the attribute tokens and
+	try to parse type specifier.
+
+	2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92992
+	* call.c (convert_arg_to_ellipsis): For decltype(nullptr) arguments
+	that have side-effects use cp_build_compound_expr.
+
+2020-01-21  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91476 - anon-namespace reference temp clash between TUs.
+	* call.c (make_temporary_var_for_ref_to_temp): Clear TREE_PUBLIC
+	if DECL is in the anonymous namespace.
+
+2020-01-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92531 - ICE with noexcept(lambda).
+	* pt.c (uses_template_parms): Don't try to enumerate all the
+	expression cases.
+
+2020-01-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93286 - ICE with __is_constructible and variadic template.
+	* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.
+	(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.
+
+2020-01-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* cp-objcp-common.c (identifier_global_tag): Return NULL_TREE if name
+	has not been found, rather than error_mark_node.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-12-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92831 - CWG 1299, not extending temporary lifetime for ?:
+	* cp-tree.h (extend_ref_init_temps): Add a new argument with NULL
+	default arg.
+	* call.c (set_up_extended_ref_temp): Add COND_GUARD argument, pass it
+	down to extend_ref_init_temps.  Before pushing cleanup, if COND_GUARD
+	is non-NULL, create a bool temporary if needed, initialize to false
+	and guard the cleanup with the temporary being true.
+	(extend_ref_init_temps_1): Add COND_GUARD argument, pass it down
+	to recursive calls and set_up_extended_ref_temp.  Handle COND_EXPR.
+	(extend_ref_init_temps): Add COND_GUARD argument, pass it down to
+	recursive calls and to extend_ref_init_temps_1.
+
+	2019-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92732
+	* typeck2.c (digest_nsdmi_init): For bitfields, use
+	DECL_BIT_FIELD_TYPE instead of TREE_TYPE.
+
+	PR c++/92695
+	* constexpr.c (cxx_bind_parameters_in_call): For virtual calls,
+	adjust the first argument to point to the derived object rather
+	than its base.
+
+	2019-12-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92695
+	* constexpr.c (cxx_eval_constant_expression) <case OBJ_TYPE_REF>: Use
+	STRIP_NOPS before checking for ADDR_EXPR.
+
+	2019-11-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60228
+	* parser.c (cp_parser_omp_declare_reduction_exprs): If
+	processing_template_decl, wrap the combiner or initializer
+	into EXPR_STMT.
+	* decl.c (start_preparsed_function): Don't start a lambda scope
+	for DECL_OMP_DECLARE_REDUCTION_P functions.
+	(finish_function): Don't finish a lambda scope for
+	DECL_OMP_DECLARE_REDUCTION_P functions, nor cp_fold_function
+	them nor cp_genericize them.
+	* mangle.c (decl_mangling_context): Look through
+	DECL_OMP_DECLARE_REDUCTION_P functions.
+	* semantics.c (expand_or_defer_fn_1): For DECL_OMP_DECLARE_REDUCTION_P
+	functions, use tentative linkage, don't keep their bodies with
+	-fkeep-inline-functions and return false at the end.
+
+	2019-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92695
+	* decl2.c (mark_used): Don't call note_vague_linkage_fn for pure
+	virtual functions, even if they are declared inline.
+
+	2019-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92524
+	* tree.c (replace_placeholders_r): Don't walk constructor elts with
+	RANGE_EXPR indexes.
+
+	2019-11-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92648
+	* parser.c (cp_parser_std_attribute): For unknown attributes,
+	skip balanced token seq instead of trying to parse
+	attribute-argument-clause as expression list.
+
+	PR c++/61414
+	* class.c (enum_to_min_precision): New hash_map.
+	(enum_min_precision): New function.
+	(check_bitfield_decl): Use it.
+
+	2019-11-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* cp-objcp-common.c (identifier_global_tag): Define.
+
+	2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+		    Jason Merrill  <jason@redhat.com>
+
+	PR c++/90842
+	* parser.c (cp_parser_decl_specifier_seq): For concept or typedef
+	break early if CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR.
+	For type specifiers, set CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS
+	if CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR is set.
+
+2019-12-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/57082 - new X{} and private destructor.
+	* init.c (build_new_1): Also pass tf_no_cleanup to
+	build_special_member_call.
+
+2019-12-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92859 - ADL and bit-field.
+	* name-lookup.c: Use unlowered_expr_type.
+
+2019-12-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92446 - deduction of class NTTP.
+	* pt.c (deducible_expression): Look through VIEW_CONVERT_EXPR.
+
+2019-11-06  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92150 - partial specialization with class NTTP.
+	* pt.c (unify): Handle VIEW_CONVERT_EXPR.
+
+2019-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90767
+	* call.c (complain_about_no_candidates_for_method_call): If
+	conv->from is not a type, pass to complain_about_bad_argument
+	lvalue_type of conv->from.
+
+	Backported from mainline
+	2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92504
+	* semantics.c (handle_omp_for_class_iterator): Don't call
+	cp_fully_fold on cond.
+
+2019-11-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-10-29  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90998 - ICE with copy elision in init by ctor and -Wconversion.
+	* call.c (joust): Don't attempt to warn if ->second_conv is null.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92343
+	* constexpr.c (potential_constant_expression_1): Return true rather
+	than false for PREDICT_EXPR.
+
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90947
+	* cp-tree.h (type_initializer_zero_p): Declare.
+	* decl.c (reshape_init_array_1): Formatting fix.
+	* tree.c (type_initializer_zero_p): New function.  Moved from
+	../tree.c, use next_initializable_field, formatting fix.  Return
+	false for TYPE_NON_AGGREGATE_CLASS types.
+
+	2019-10-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85887
+	* decl.c (expand_static_init): Drop ECF_LEAF from __cxa_guard_acquire
+	and __cxa_guard_release.
+
+	2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92015
+	* constexpr.c (cxx_eval_component_reference, cxx_eval_bit_field_ref):
+	Use STRIP_ANY_LOCATION_WRAPPER on CONSTRUCTOR elts.
+
+2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92201
+	* cp-gimplify.c (cp_gimplify_expr): If gimplify_to_rvalue changes the
+	function pointer type, re-add cast to the original one.
+
+2018-10-26  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+
+	2019-06-01  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/85254
+	* class.c (fixup_type_variants): Handle CLASSTYPE_FINAL.
+
+2019-10-24  Marek Polacek  <polacek@redhat.com>
+
+	* decl.c (reshape_init_r): Add missing space.
+
+2019-10-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-10-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr.
+	* typeck.c (maybe_warn_about_returning_address_of_local): Avoid
+	recursing on null initializer and return false instead.
+
+	PR c++/92062 - ODR-use ignored for static member of class template.
+	* pt.c (has_value_dependent_address): Strip location wrappers.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91974
+	* cp-gimplify.c (cp_gimplify_expr) <case CALL_EXPR>: For
+	-fstrong-eval-order ensure CALL_EXPR_FN side-effects are evaluated
+	before any arguments.  Additionally, ensure CALL_EXPR_FN that isn't
+	invariant nor OBJ_TYPE_REF nor SSA_NAME is forced into a temporary.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* parser.c (cp_parser_omp_var_list_no_open): Parse predefined
+	variables.
+	* semantics.c (finish_omp_clauses): Allow predefined variables in
+	shared and firstprivate clauses, even when they are predetermined
+	shared.
+	* cp-gimplify.c (cxx_omp_predetermined_sharing_1): Return
+	OMP_CLAUSE_DEFAULT_SHARED for predefined variables.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* parser.c (cp_parser_omp_clause_dist_schedule): Comment out the
+	check_no_duplicate_clause call, instead emit a warning for duplicate
+	dist_schedule clauses.
+
+2019-10-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/91606
+	* decl.c (build_ptrmemfunc_type): Mark pointer-to-member
+	fat pointer structure members as DECL_NONADDRESSABLE_P.
+
+2019-10-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-15  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91740 - ICE with constexpr call and ?: in ARRAY_REF.
+	* pt.c (build_non_dependent_expr): Call build_non_dependent_expr for
+	the first operand.
+
+2019-09-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91923 - failure-to-SFINAE with class type NTTP in C++17.
+	* pt.c (invalid_nontype_parm_type_p): Only emit errors when
+	tf_error.
+
+2019-09-10  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91705 - constexpr evaluation rejects ++/-- on floats.
+	* constexpr.c (cxx_eval_increment_expression): Call fold_simple on
+	the offset.
+
+2019-09-01  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91129 - wrong error with binary op in template argument.
+	* typeck.c (warn_for_null_address): Use fold_for_warn instead of
+	fold_non_dependent_expr.
+	(cp_build_binary_op): Likewise.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* parser.c (cp_parser_initial_pragma): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-08-23  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-08-23  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91521 - wrong error with operator->.
+	* decl.c (grokdeclarator): Return error_mark_node for an invalid
+	trailing return type.
+
+2019-08-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90393 - ICE with throw in ?:
+	* call.c (build_conditional_expr_1): Revert changes from
+	PR c++/64372 and c++/86205.
+
+2019-08-15  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-08-07  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+	* parser.c (cp_parser_constructor_declarator_p): Handle the scenario
+	when a parameter declaration begins with [[attribute]].
+
+	2019-08-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/87519 - bogus warning with -Wsign-conversion.
+	* typeck.c (cp_build_binary_op): Use same_type_p instead of comparing
+	the types directly.
+
+	2019-08-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90473 - wrong code with nullptr in default argument.
+	* call.c (null_ptr_cst_p): Update quote from the standard.
+	* decl.c (check_default_argument): Don't return nullptr when the arg
+	has side-effects.
+
+	2019-06-14  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90884 - stray note with -Wctor-dtor-privacy.
+	* class.c (maybe_warn_about_overly_private_class): Guard the call to
+	inform.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backported from mainline
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* decl.c (reshape_init_array_1): Avoid truncating initializer
+	lists containing string literals.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-12  Tom Honermann  <tom@honermann.net>
+
+	* parser.c (cp_parser_template_declaration_after_parameters): Enable
+	class template argument deduction for non-type template parameters
+	in literal operator templates.
+
+2019-08-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91378 - ICE with noexcept and auto return type.
+	* pt.c (maybe_instantiate_noexcept): push_to_top_level.
+
+	PR c++/90538 - multiple expansions of capture packs
+	* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.
+	* lambda.c (add_capture): Copy parameter packs from init.
+	(lambda_capture_field_type): Always use auto for init-capture.
+	* pt.c (uses_parameter_packs): Return tree.
+	(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.
+	(gen_elem_of_pack_expansion_instantiation): Don't push
+	local_specialization_stack.
+	(prepend_one_capture): New.
+	(tsubst_lambda_expr): Use it.  Don't touch local_specializations.
+	(do_auto_deduction): Avoid redundant error.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -16,7 +600,7 @@
 
 	Backported from mainline
 	2019-08-02  Marek Polacek  <polacek@redhat.com>
-	
+
 	PR c++/91230 - wrong error with __PRETTY_FUNCTION__ and generic lambda.
 	* pt.c (value_dependent_expression_p): Consider __PRETTY_FUNCTION__
 	inside a template function value-dependent.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 9e22a146a16..f365a5a7f7b 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -530,9 +530,8 @@ null_ptr_cst_p (tree t)
 
   /* [conv.ptr]
 
-     A null pointer constant is an integral constant expression
-     (_expr.const_) rvalue of integer type that evaluates to zero or
-     an rvalue of type std::nullptr_t. */
+     A null pointer constant is an integer literal ([lex.icon]) with value
+     zero or a prvalue of type std::nullptr_t.  */
   if (NULLPTR_TYPE_P (type))
     return true;
 
@@ -4035,6 +4034,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 						       EXPR_LOCATION (expr));
 	    }
 	  else if (TYPE_REF_P (totype) && !ics->rvaluedness_matches_p
+		   /* Limit this to non-templates for now (PR90546).  */
+		   && !cand->template_decl
 		   && TREE_CODE (TREE_TYPE (totype)) != FUNCTION_TYPE)
 	    {
 	      /* If we are called to convert to a reference type, we are trying
@@ -5186,46 +5187,56 @@ build_conditional_expr_1 (const op_location_t &loc,
   arg3_type = unlowered_expr_type (arg3);
   if (VOID_TYPE_P (arg2_type) || VOID_TYPE_P (arg3_type))
     {
-      /* 'void' won't help in resolving an overloaded expression on the
-	 other side, so require it to resolve by itself.  */
-      if (arg2_type == unknown_type_node)
-	{
-	  arg2 = resolve_nondeduced_context_or_error (arg2, complain);
-	  arg2_type = TREE_TYPE (arg2);
-	}
-      if (arg3_type == unknown_type_node)
-	{
-	  arg3 = resolve_nondeduced_context_or_error (arg3, complain);
-	  arg3_type = TREE_TYPE (arg3);
-	}
+      /* Do the conversions.  We don't these for `void' type arguments
+	 since it can't have any effect and since decay_conversion
+	 does not handle that case gracefully.  */
+      if (!VOID_TYPE_P (arg2_type))
+	arg2 = decay_conversion (arg2, complain);
+      if (!VOID_TYPE_P (arg3_type))
+	arg3 = decay_conversion (arg3, complain);
+      arg2_type = TREE_TYPE (arg2);
+      arg3_type = TREE_TYPE (arg3);
 
       /* [expr.cond]
 
 	 One of the following shall hold:
 
 	 --The second or the third operand (but not both) is a
-	   throw-expression (_except.throw_); the result is of the type
-	   and value category of the other.
+	   throw-expression (_except.throw_); the result is of the
+	   type of the other and is an rvalue.
 
 	 --Both the second and the third operands have type void; the
-	   result is of type void and is a prvalue.  */
+	   result is of type void and is an rvalue.
+
+	 We must avoid calling force_rvalue for expressions of type
+	 "void" because it will complain that their value is being
+	 used.  */
       if (TREE_CODE (arg2) == THROW_EXPR
 	  && TREE_CODE (arg3) != THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg3_type))
+	    {
+	      arg3 = force_rvalue (arg3, complain);
+	      if (arg3 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg3_type = TREE_TYPE (arg3);
 	  result_type = arg3_type;
-	  is_glvalue = glvalue_p (arg3);
 	}
       else if (TREE_CODE (arg2) != THROW_EXPR
 	       && TREE_CODE (arg3) == THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg2_type))
+	    {
+	      arg2 = force_rvalue (arg2, complain);
+	      if (arg2 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg2_type = TREE_TYPE (arg2);
 	  result_type = arg2_type;
-	  is_glvalue = glvalue_p (arg2);
 	}
       else if (VOID_TYPE_P (arg2_type) && VOID_TYPE_P (arg3_type))
-	{
-	  result_type = void_type_node;
-	  is_glvalue = false;
-	}
+	result_type = void_type_node;
       else
 	{
           if (complain & tf_error)
@@ -5244,6 +5255,7 @@ build_conditional_expr_1 (const op_location_t &loc,
 	  return error_mark_node;
 	}
 
+      is_glvalue = false;
       goto valid_operands;
     }
   /* [expr.cond]
@@ -5361,6 +5373,10 @@ build_conditional_expr_1 (const op_location_t &loc,
       && same_type_p (arg2_type, arg3_type))
     {
       result_type = arg2_type;
+      if (processing_template_decl)
+	/* Let lvalue_kind know this was a glvalue.  */
+	result_type = cp_build_reference_type (result_type, xvalue_p (arg2));
+
       arg2 = mark_lvalue_use (arg2);
       arg3 = mark_lvalue_use (arg3);
       goto valid_operands;
@@ -5558,13 +5574,6 @@ build_conditional_expr_1 (const op_location_t &loc,
     return error_mark_node;
 
  valid_operands:
-  if (processing_template_decl && is_glvalue)
-    {
-      /* Let lvalue_kind know this was a glvalue.  */
-      tree arg = (result_type == arg2_type ? arg2 : arg3);
-      result_type = cp_build_reference_type (result_type, xvalue_p (arg));
-    }
-
   result = build3_loc (loc, COND_EXPR, result_type, arg1, arg2, arg3);
 
   /* If the ARG2 and ARG3 are the same and don't have side-effects,
@@ -7536,7 +7545,12 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)
       arg = convert_to_real_nofold (double_type_node, arg);
     }
   else if (NULLPTR_TYPE_P (arg_type))
-    arg = null_pointer_node;
+    {
+      if (TREE_SIDE_EFFECTS (arg))
+	arg = cp_build_compound_expr (arg, null_pointer_node, complain);
+      else
+	arg = null_pointer_node;
+    }
   else if (INTEGRAL_OR_ENUMERATION_TYPE_P (arg_type))
     {
       if (SCOPED_ENUM_P (arg_type))
@@ -9551,8 +9565,11 @@ complain_about_no_candidates_for_method_call (tree instance,
 	  if (const conversion_info *conv
 		= maybe_get_bad_conversion_for_unmatched_call (candidate))
 	    {
+	      tree from_type = conv->from;
+	      if (!TYPE_P (conv->from))
+		from_type = lvalue_type (conv->from);
 	      complain_about_bad_argument (conv->loc,
-					   conv->from, conv->to_type,
+					   from_type, conv->to_type,
 					   candidate->fn, conv->n_arg);
 	      return;
 	    }
@@ -10732,7 +10749,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,
      either between a constructor and a conversion op, or between two
      conversion ops.  */
   if ((complain & tf_warning)
-      && winner && warn_conversion && cand1->second_conv
+      /* In C++17, the constructor might have been elided, which means that
+	 an originally null ->second_conv could become non-null.  */
+      && winner && warn_conversion && cand1->second_conv && cand2->second_conv
       && (!DECL_CONSTRUCTOR_P (cand1->fn) || !DECL_CONSTRUCTOR_P (cand2->fn))
       && winner != compare_ics (cand1->second_conv, cand2->second_conv))
     {
@@ -11412,6 +11431,8 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)
 
       TREE_STATIC (var) = TREE_STATIC (decl);
       TREE_PUBLIC (var) = TREE_PUBLIC (decl);
+      if (decl_anon_ns_mem_p (decl))
+	TREE_PUBLIC (var) = 0;
       if (vague_linkage_p (decl))
 	comdat_linkage (var);
 
@@ -11437,7 +11458,7 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)
 
 static tree
 set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,
-			  tree *initp)
+			  tree *initp, tree *cond_guard)
 {
   tree init;
   tree type;
@@ -11468,7 +11489,8 @@ set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,
 
   /* Recursively extend temps in this initializer.  */
   TARGET_EXPR_INITIAL (expr)
-    = extend_ref_init_temps (decl, TARGET_EXPR_INITIAL (expr), cleanups);
+    = extend_ref_init_temps (decl, TARGET_EXPR_INITIAL (expr), cleanups,
+			     cond_guard);
 
   /* Any reference temp has a non-trivial initializer.  */
   DECL_NONTRIVIALLY_INITIALIZED_P (var) = true;
@@ -11509,7 +11531,29 @@ set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,
 	{
 	  tree cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);
 	  if (cleanup)
-	    vec_safe_push (*cleanups, cleanup);
+	    {
+	      if (cond_guard && cleanup != error_mark_node)
+		{
+		  if (*cond_guard == NULL_TREE)
+		    {
+		      *cond_guard = build_decl (input_location, VAR_DECL,
+						NULL_TREE, boolean_type_node);
+		      DECL_ARTIFICIAL (*cond_guard) = 1;
+		      DECL_IGNORED_P (*cond_guard) = 1;
+		      DECL_CONTEXT (*cond_guard) = current_function_decl;
+		      layout_decl (*cond_guard, 0);
+		      add_decl_expr (*cond_guard);
+		      tree set = cp_build_modify_expr (UNKNOWN_LOCATION,
+						       *cond_guard, NOP_EXPR,
+						       boolean_false_node,
+						       tf_warning_or_error);
+		      finish_expr_stmt (set);
+		    }
+		  cleanup = build3 (COND_EXPR, void_type_node,
+				    *cond_guard, cleanup, NULL_TREE);
+		}
+	      vec_safe_push (*cleanups, cleanup);
+	    }
 	}
 
       /* We must be careful to destroy the temporary only
@@ -11614,7 +11658,8 @@ initialize_reference (tree type, tree expr,
    which is bound either to a reference or a std::initializer_list.  */
 
 static tree
-extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)
+extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups,
+			 tree *cond_guard)
 {
   tree sub = init;
   tree *p;
@@ -11622,20 +11667,52 @@ extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)
   if (TREE_CODE (sub) == COMPOUND_EXPR)
     {
       TREE_OPERAND (sub, 1)
-        = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups);
+	= extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups,
+				   cond_guard);
+      return init;
+    }
+  if (TREE_CODE (sub) == COND_EXPR)
+    {
+      tree cur_cond_guard = NULL_TREE;
+      if (TREE_OPERAND (sub, 1))
+	TREE_OPERAND (sub, 1)
+	  = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups,
+				     &cur_cond_guard);
+      if (cur_cond_guard)
+	{
+	  tree set = cp_build_modify_expr (UNKNOWN_LOCATION, cur_cond_guard,
+					   NOP_EXPR, boolean_true_node,
+					   tf_warning_or_error);
+	  TREE_OPERAND (sub, 1)
+	    = cp_build_compound_expr (set, TREE_OPERAND (sub, 1),
+				      tf_warning_or_error);
+	}
+      cur_cond_guard = NULL_TREE;
+      if (TREE_OPERAND (sub, 2))
+	TREE_OPERAND (sub, 2)
+	  = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 2), cleanups,
+				     &cur_cond_guard);
+      if (cur_cond_guard)
+	{
+	  tree set = cp_build_modify_expr (UNKNOWN_LOCATION, cur_cond_guard,
+					   NOP_EXPR, boolean_true_node,
+					   tf_warning_or_error);
+	  TREE_OPERAND (sub, 2)
+	    = cp_build_compound_expr (set, TREE_OPERAND (sub, 2),
+				      tf_warning_or_error);
+	}
       return init;
     }
   if (TREE_CODE (sub) != ADDR_EXPR)
     return init;
   /* Deal with binding to a subobject.  */
   for (p = &TREE_OPERAND (sub, 0);
-       (TREE_CODE (*p) == COMPONENT_REF
-	|| TREE_CODE (*p) == ARRAY_REF); )
+       TREE_CODE (*p) == COMPONENT_REF || TREE_CODE (*p) == ARRAY_REF; )
     p = &TREE_OPERAND (*p, 0);
   if (TREE_CODE (*p) == TARGET_EXPR)
     {
       tree subinit = NULL_TREE;
-      *p = set_up_extended_ref_temp (decl, *p, cleanups, &subinit);
+      *p = set_up_extended_ref_temp (decl, *p, cleanups, &subinit, cond_guard);
       recompute_tree_invariant_for_addr_expr (sub);
       if (init != sub)
 	init = fold_convert (TREE_TYPE (init), sub);
@@ -11650,13 +11727,14 @@ extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)
    lifetime to match that of DECL.  */
 
 tree
-extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)
+extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups,
+		       tree *cond_guard)
 {
   tree type = TREE_TYPE (init);
   if (processing_template_decl)
     return init;
   if (TYPE_REF_P (type))
-    init = extend_ref_init_temps_1 (decl, init, cleanups);
+    init = extend_ref_init_temps_1 (decl, init, cleanups, cond_guard);
   else
     {
       tree ctor = init;
@@ -11669,7 +11747,8 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)
 	      /* The temporary array underlying a std::initializer_list
 		 is handled like a reference temporary.  */
 	      tree array = CONSTRUCTOR_ELT (ctor, 0)->value;
-	      array = extend_ref_init_temps_1 (decl, array, cleanups);
+	      array = extend_ref_init_temps_1 (decl, array, cleanups,
+					       cond_guard);
 	      CONSTRUCTOR_ELT (ctor, 0)->value = array;
 	    }
 	  else
@@ -11678,7 +11757,8 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)
 	      constructor_elt *p;
 	      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ctor);
 	      FOR_EACH_VEC_SAFE_ELT (elts, i, p)
-		p->value = extend_ref_init_temps (decl, p->value, cleanups);
+		p->value = extend_ref_init_temps (decl, p->value, cleanups,
+						  cond_guard);
 	    }
 	  recompute_constructor_flags (ctor);
 	  if (decl_maybe_constant_var_p (decl) && TREE_CONSTANT (ctor))
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index a47777cdd9e..6b57184e081 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -1907,6 +1907,7 @@ fixup_type_variants (tree t)
 	= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);
 
       TYPE_POLYMORPHIC_P (variants) = TYPE_POLYMORPHIC_P (t);
+      CLASSTYPE_FINAL (variants) = CLASSTYPE_FINAL (t);
 
       TYPE_BINFO (variants) = TYPE_BINFO (t);
 
@@ -2149,10 +2150,10 @@ maybe_warn_about_overly_private_class (tree t)
 
       if (!nonprivate_ctor)
 	{
-	  warning (OPT_Wctor_dtor_privacy,
-		   "%q#T only defines private constructors and has no friends",
-		   t);
-	  if (copy_or_move)
+	  bool w = warning (OPT_Wctor_dtor_privacy,
+			    "%q#T only defines private constructors and has "
+			    "no friends", t);
+	  if (w && copy_or_move)
 	    inform (DECL_SOURCE_LOCATION (copy_or_move),
 		    "%q#D is public, but requires an existing %q#T object",
 		    copy_or_move, t);
@@ -3197,6 +3198,60 @@ add_implicitly_declared_members (tree t, tree* access_decls,
     }
 }
 
+/* Cache of enum_min_precision values.  */
+static GTY((deletable)) hash_map<tree, int> *enum_to_min_precision;
+
+/* Return the minimum precision of a bit-field needed to store all
+   enumerators of ENUMERAL_TYPE TYPE.  */
+
+static int
+enum_min_precision (tree type)
+{
+  type = TYPE_MAIN_VARIANT (type);
+  /* For unscoped enums without fixed underlying type and without mode
+     attribute we can just use precision of the underlying type.  */
+  if (UNSCOPED_ENUM_P (type)
+      && !ENUM_FIXED_UNDERLYING_TYPE_P (type)
+      && !lookup_attribute ("mode", TYPE_ATTRIBUTES (type)))
+    return TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type));
+
+  if (enum_to_min_precision == NULL)
+    enum_to_min_precision = hash_map<tree, int>::create_ggc (37);
+
+  bool existed;
+  int &prec = enum_to_min_precision->get_or_insert (type, &existed);
+  if (existed)
+    return prec;
+
+  tree minnode, maxnode;
+  if (TYPE_VALUES (type))
+    {
+      minnode = maxnode = NULL_TREE;
+      for (tree values = TYPE_VALUES (type);
+	   values; values = TREE_CHAIN (values))
+	{
+	  tree decl = TREE_VALUE (values);
+	  tree value = DECL_INITIAL (decl);
+	  if (value == error_mark_node)
+	    value = integer_zero_node;
+	  if (!minnode)
+	    minnode = maxnode = value;
+	  else if (tree_int_cst_lt (maxnode, value))
+	    maxnode = value;
+	  else if (tree_int_cst_lt (value, minnode))
+	    minnode = value;
+	}
+    }
+  else
+    minnode = maxnode = integer_zero_node;
+
+  signop sgn = tree_int_cst_sgn (minnode) >= 0 ? UNSIGNED : SIGNED;
+  int lowprec = tree_int_cst_min_precision (minnode, sgn);
+  int highprec = tree_int_cst_min_precision (maxnode, sgn);
+  prec = MAX (lowprec, highprec);
+  return prec;
+}
+
 /* FIELD is a bit-field.  We are finishing the processing for its
    enclosing type.  Issue any appropriate messages and set appropriate
    flags.  Returns false if an error has been diagnosed.  */
@@ -3258,7 +3313,7 @@ check_bitfield_decl (tree field)
 		    "width of %qD exceeds its type", field);
       else if (TREE_CODE (type) == ENUMERAL_TYPE)
 	{
-	  int prec = TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type));
+	  int prec = enum_min_precision (type);
 	  if (compare_tree_int (w, prec) < 0)
 	    warning_at (DECL_SOURCE_LOCATION (field), 0,
 			"%qD is too small to hold all values of %q#T",
@@ -6882,6 +6937,8 @@ check_flexarrays (tree t, flexmems_t *fmem /* = NULL */,
   /* Is the type unnamed (and therefore a member of it potentially
      an anonymous struct or union)?  */
   bool maybe_anon_p = TYPE_UNNAMED_P (t);
+  if (tree ctx = maybe_anon_p ? TYPE_CONTEXT (t) : NULL_TREE)
+    maybe_anon_p = RECORD_OR_UNION_TYPE_P (ctx);
 
   /* Search the members of the current (possibly derived) class, skipping
      unnamed structs and unions since those could be anonymous.  */
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index f6f21b33396..bab5935a4eb 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -821,6 +821,9 @@ cx_check_missing_mem_inits (tree ctype, tree body, bool complain)
 		return true;
 	      continue;
 	    }
+	  if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field)))
+	    /* An empty field doesn't need an initializer.  */
+	    continue;
 	  ftype = strip_array_types (TREE_TYPE (field));
 	  if (type_has_constexpr_default_constructor (ftype))
 	    {
@@ -1085,7 +1088,8 @@ constexpr_call_hasher::equal (constexpr_call *lhs, constexpr_call *rhs)
     {
       tree lhs_arg = TREE_VALUE (lhs_bindings);
       tree rhs_arg = TREE_VALUE (rhs_bindings);
-      gcc_assert (same_type_p (TREE_TYPE (lhs_arg), TREE_TYPE (rhs_arg)));
+      gcc_assert (same_type_ignoring_top_level_qualifiers_p
+		  (TREE_TYPE (lhs_arg), TREE_TYPE (rhs_arg)));
       if (!cp_tree_equal (lhs_arg, rhs_arg))
         return false;
       lhs_bindings = TREE_CHAIN (lhs_bindings);
@@ -1419,6 +1423,28 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,
 	    arg = adjust_temp_type (type, arg);
 	  if (!TREE_CONSTANT (arg))
 	    *non_constant_args = true;
+
+	  /* For virtual calls, adjust the this argument, so that it is
+	     the object on which the method is called, rather than
+	     one of its bases.  */
+	  if (i == 0 && DECL_VIRTUAL_P (fun))
+	    {
+	      tree addr = arg;
+	      STRIP_NOPS (addr);
+	      if (TREE_CODE (addr) == ADDR_EXPR)
+		{
+		  tree obj = TREE_OPERAND (addr, 0);
+		  while (TREE_CODE (obj) == COMPONENT_REF
+			 && DECL_FIELD_IS_BASE (TREE_OPERAND (obj, 1))
+			 && !same_type_ignoring_top_level_qualifiers_p
+					(TREE_TYPE (obj), DECL_CONTEXT (fun)))
+		    obj = TREE_OPERAND (obj, 0);
+		  if (obj != TREE_OPERAND (addr, 0))
+		    arg = build_fold_addr_expr_with_type (obj,
+							  TREE_TYPE (arg));
+		}
+	    }
+
 	  *p = build_tree_list (parms, arg);
 	  p = &TREE_CHAIN (*p);
 	}
@@ -2640,8 +2666,16 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,
     }
 
   /* If it's within the array bounds but doesn't have an explicit
-     initializer, it's value-initialized.  */
-  tree val = build_value_init (elem_type, tf_warning_or_error);
+     initializer, it's initialized from {}.  But use build_value_init
+     directly for non-aggregates to avoid creating a garbage CONSTRUCTOR.  */
+  tree val;
+  if (CP_AGGREGATE_TYPE_P (elem_type))
+    {
+      tree empty_ctor = build_constructor (init_list_type_node, NULL);
+      val = digest_init (elem_type, empty_ctor, tf_warning_or_error);
+    }
+  else
+    val = build_value_init (elem_type, tf_warning_or_error);
   return cxx_eval_constant_expression (ctx, val, lval, non_constant_p,
 				       overflow_p);
 }
@@ -2703,7 +2737,10 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,
 	  : field == part)
 	{
 	  if (value)
-	    return value;
+	    {
+	      STRIP_ANY_LOCATION_WRAPPER (value);
+	      return value;
+	    }
 	  else
 	    /* We're in the middle of initializing it.  */
 	    break;
@@ -2793,6 +2830,7 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,
   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)
     {
       tree bitpos = bit_position (field);
+      STRIP_ANY_LOCATION_WRAPPER (value);
       if (bitpos == start && DECL_SIZE (field) == TREE_OPERAND (t, 1))
 	return value;
       if (TREE_CODE (TREE_TYPE (field)) == INTEGER_TYPE
@@ -3101,6 +3139,10 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,
   unsigned HOST_WIDE_INT i;
   tsubst_flags_t complain = ctx->quiet ? tf_none : tf_warning_or_error;
 
+  if (init && TREE_CODE (init) == CONSTRUCTOR)
+    return cxx_eval_bare_aggregate (ctx, init, lval,
+				    non_constant_p, overflow_p);
+
   /* For the default constructor, build up a call to the default
      constructor of the element type.  We only need to handle class types
      here, as for a constructor to be constexpr, all members must be
@@ -3973,6 +4015,10 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,
   tree offset = TREE_OPERAND (t, 1);
   gcc_assert (TREE_CONSTANT (offset));
 
+  /* OFFSET is constant, but perhaps not constant enough.  We need to
+     e.g. bash FLOAT_EXPRs to REAL_CSTs.  */
+  offset = fold_simple (offset);
+
   /* The operand as an lvalue.  */
   op = cxx_eval_constant_expression (ctx, op, true,
 				     non_constant_p, overflow_p);
@@ -5116,6 +5162,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	tree obj = OBJ_TYPE_REF_OBJECT (t);
 	obj = cxx_eval_constant_expression (ctx, obj, lval, non_constant_p,
 					    overflow_p);
+	STRIP_NOPS (obj);
 	/* We expect something in the form of &x.D.2103.D.2094; get x. */
 	if (TREE_CODE (obj) != ADDR_EXPR
 	    || !DECL_P (get_base_address (TREE_OPERAND (obj, 0))))
@@ -5551,7 +5598,15 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)
   if (cv_cache == NULL)
     cv_cache = hash_map<tree, tree>::create_ggc (101);
   if (tree *cached = cv_cache->get (t))
-    return *cached;
+    {
+      r = *cached;
+      if (r != t)
+	{
+	  r = unshare_expr_without_location (r);
+	  protected_set_expr_location (r, EXPR_LOCATION (t));
+	}
+      return r;
+    }
 
   r = cxx_eval_outermost_constant_expr (t, true, true, false, decl);
   gcc_checking_assert (r == t
@@ -5917,6 +5972,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
     case LABEL_DECL:
     case LABEL_EXPR:
     case CASE_LABEL_EXPR:
+    case PREDICT_EXPR:
     case CONST_DECL:
     case SIZEOF_EXPR:
     case ALIGNOF_EXPR:
@@ -5948,8 +6004,13 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
       return true;
 
     case PARM_DECL:
-      if (now)
+      if (now && want_rval)
 	{
+	  tree type = TREE_TYPE (t);
+	  if (dependent_type_p (type)
+	      || is_really_empty_class (type, /*ignore_vptr*/false))
+	    /* An empty class has no data to read.  */
+	    return true;
 	  if (flags & tf_error)
 	    error ("%qE is not a constant expression", t);
 	  return false;
@@ -6190,10 +6251,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 #endif
       return RECUR (t, any);
 
-    case REALPART_EXPR:
-    case IMAGPART_EXPR:
     case COMPONENT_REF:
-    case BIT_FIELD_REF:
     case ARROW_EXPR:
     case OFFSET_REF:
       /* -- a class member access unless its postfix-expression is
@@ -6202,6 +6260,15 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 	 postfix-expression being a potential constant expression.  */
       if (type_unknown_p (t))
 	return true;
+      if (is_overloaded_fn (t))
+	/* In a template, a COMPONENT_REF of a function expresses ob.fn(),
+	   which uses ob as an lvalue.  */
+	want_rval = false;
+      gcc_fallthrough ();
+
+    case REALPART_EXPR:
+    case IMAGPART_EXPR:
+    case BIT_FIELD_REF:
       return RECUR (TREE_OPERAND (t, 0), want_rval);
 
     case EXPR_PACK_EXPANSION:
@@ -6751,7 +6818,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 
     case CLEANUP_STMT:
     case EMPTY_CLASS_EXPR:
-    case PREDICT_EXPR:
       return false;
 
     case GOTO_EXPR:
diff --git a/gcc/cp/constraint.cc b/gcc/cp/constraint.cc
index 9884eb0db50..cbd9c141809 100644
--- a/gcc/cp/constraint.cc
+++ b/gcc/cp/constraint.cc
@@ -2390,7 +2390,11 @@ constraints_satisfied_p (tree decl)
       ci = get_constraints (decl);
     }
 
+  if (!push_tinst_level (decl))
+    return true;
   tree eval = satisfy_associated_constraints (ci, args);
+  pop_tinst_level ();
+
   return eval == boolean_true_node;
 }
 
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index 17d10456341..4be45abca88 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -816,6 +816,27 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 
     case CALL_EXPR:
       ret = GS_OK;
+      if (flag_strong_eval_order == 2
+	  && CALL_EXPR_FN (*expr_p)
+	  && cp_get_callee_fndecl_nofold (*expr_p) == NULL_TREE)
+	{
+	  tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*expr_p));
+	  enum gimplify_status t
+	    = gimplify_expr (&CALL_EXPR_FN (*expr_p), pre_p, NULL,
+			     is_gimple_call_addr, fb_rvalue);
+	  if (t == GS_ERROR)
+	    ret = GS_ERROR;
+	  else if (is_gimple_variable (CALL_EXPR_FN (*expr_p))
+		   && TREE_CODE (CALL_EXPR_FN (*expr_p)) != SSA_NAME)
+	    CALL_EXPR_FN (*expr_p)
+	      = get_initialized_tmp_var (CALL_EXPR_FN (*expr_p), pre_p,
+					 NULL);
+	  /* GIMPLE considers most pointer conversion useless, but for
+	     calls we actually care about the exact function pointer type.  */
+	  if (t != GS_ERROR && TREE_TYPE (CALL_EXPR_FN (*expr_p)) != fnptrtype)
+	    CALL_EXPR_FN (*expr_p)
+	      = build1 (NOP_EXPR, fnptrtype, CALL_EXPR_FN (*expr_p));
+	}
       if (!CALL_EXPR_FN (*expr_p))
 	/* Internal function call.  */;
       else if (CALL_EXPR_REVERSE_ARGS (*expr_p))
@@ -1110,6 +1131,36 @@ cp_fold_function (tree fndecl)
   cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &pset, NULL);
 }
 
+/* If EXPR involves an anonymous VLA type, prepend a DECL_EXPR for that type
+   to trigger gimplify_type_sizes; otherwise a cast to pointer-to-VLA confuses
+   the middle-end (c++/88256).  */
+
+static tree
+predeclare_vla (tree expr)
+{
+  tree type = TREE_TYPE (expr);
+  if (type == error_mark_node)
+    return expr;
+
+  /* We need to strip pointers for gimplify_type_sizes.  */
+  tree vla = type;
+  while (POINTER_TYPE_P (vla))
+    {
+      if (TYPE_NAME (vla))
+	return expr;
+      vla = TREE_TYPE (vla);
+    }
+  if (TYPE_NAME (vla) || !variably_modified_type_p (vla, NULL_TREE))
+    return expr;
+
+  tree decl = build_decl (input_location, TYPE_DECL, NULL_TREE, vla);
+  DECL_ARTIFICIAL (decl) = 1;
+  TYPE_NAME (vla) = decl;
+  tree dexp = build_stmt (input_location, DECL_EXPR, decl);
+  expr = build2 (COMPOUND_EXPR, type, dexp, expr);
+  return expr;
+}
+
 /* Perform any pre-gimplification lowering of C++ front end trees to
    GENERIC.  */
 
@@ -1563,6 +1614,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
       break;
 
     case NOP_EXPR:
+      *stmt_p = predeclare_vla (*stmt_p);
       if (!wtd->no_sanitize_p
 	  && sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT)
 	  && TYPE_REF_P (TREE_TYPE (stmt)))
@@ -2050,6 +2102,9 @@ cxx_omp_predetermined_sharing_1 (tree decl)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))
 	return OMP_CLAUSE_DEFAULT_SHARED;
+
+      if (c_omp_predefined_variable (decl))
+	return OMP_CLAUSE_DEFAULT_SHARED;
     }
 
   /* this may not be specified in data-sharing clauses, still we need
@@ -2083,6 +2138,10 @@ cxx_omp_predetermined_sharing (tree decl)
 	   && DECL_OMP_PRIVATIZED_MEMBER (decl)))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  /* Similarly for typeinfo symbols.  */
+  if (VAR_P (decl) && DECL_ARTIFICIAL (decl) && DECL_TINFO_P (decl))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
 
diff --git a/gcc/cp/cp-objcp-common.c b/gcc/cp/cp-objcp-common.c
index 47651040008..4118ab8a31d 100644
--- a/gcc/cp/cp-objcp-common.c
+++ b/gcc/cp/cp-objcp-common.c
@@ -352,6 +352,18 @@ identifier_global_value (tree name)
   return get_global_binding (name);
 }
 
+/* Similarly, but return struct/class/union NAME instead.  */
+
+tree
+identifier_global_tag (tree name)
+{
+  tree ret = lookup_qualified_name (global_namespace, name, /*prefer_type*/2,
+				    /*complain*/false);
+  if (ret == error_mark_node)
+    return NULL_TREE;
+  return ret;
+}
+
 /* Register c++-specific dumps.  */
 
 void
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index ff4ce068a83..f7c3eea4cdf 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -423,7 +423,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];
       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)
       DECL_FINAL_P (in FUNCTION_DECL)
       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)
-      DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)
       CONSTRUCTOR_IS_DEPENDENT (in CONSTRUCTOR)
       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)
       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)
@@ -4471,12 +4470,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)
   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag
 
 /* These flags indicate that we want different semantics from normal
-   decltype: lambda capture just drops references, init capture
-   uses auto semantics, lambda proxies look through implicit dereference.  */
+   decltype: lambda capture just drops references,
+   lambda proxies look through implicit dereference.  */
 #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \
   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))
-#define DECLTYPE_FOR_INIT_CAPTURE(NODE) \
-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \
   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_REF_CAPTURE(NODE) \
@@ -6232,7 +6229,9 @@ extern tree convert_for_arg_passing		(tree, tree, tsubst_flags_t);
 extern bool is_properly_derived_from		(tree, tree);
 extern tree initialize_reference		(tree, tree, int,
 						 tsubst_flags_t);
-extern tree extend_ref_init_temps		(tree, tree, vec<tree, va_gc>**);
+extern tree extend_ref_init_temps		(tree, tree,
+						 vec<tree, va_gc>**,
+						 tree * = NULL);
 extern tree make_temporary_var_for_ref_to_temp	(tree, tree);
 extern bool type_has_extended_temps		(tree);
 extern tree strip_top_quals			(tree);
@@ -6779,7 +6778,7 @@ extern bool maybe_instantiate_noexcept		(tree, tsubst_flags_t = tf_warning_or_er
 extern tree instantiate_decl			(tree, bool, bool);
 extern int comp_template_parms			(const_tree, const_tree);
 extern bool builtin_pack_fn_p			(tree);
-extern bool uses_parameter_packs                (tree);
+extern tree uses_parameter_packs                (tree);
 extern bool template_parameter_pack_p           (const_tree);
 extern bool function_parameter_pack_p		(const_tree);
 extern bool function_parameter_expanded_from_pack_p (tree, tree);
@@ -7328,6 +7327,11 @@ extern tree cxx_copy_lang_qualifiers		(const_tree, const_tree);
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
+/* Analogous to initializer_zerop but also examines the type for
+   which the initializer is being used.  Unlike initializer_zerop,
+   considers empty strings to be zero initializers for arrays and
+   non-zero for pointers.  */
+extern bool type_initializer_zero_p		(tree, tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index b57ded813b6..39d55589ef3 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -4474,13 +4474,27 @@ cp_fname_init (const char* name, tree *type_p)
 static tree
 cp_make_fname_decl (location_t loc, tree id, int type_dep)
 {
-  const char *const name = (type_dep && in_template_function ()
-			    ? NULL : fname_as_string (type_dep));
+  const char * name = NULL;
+  bool release_name = false;
+  if (!(type_dep && in_template_function ()))
+    {
+      if (current_function_decl == NULL_TREE)
+	name = "top level";
+      else if (type_dep == 1) /* __PRETTY_FUNCTION__ */
+	name = cxx_printable_name (current_function_decl, 2);
+      else if (type_dep == 0) /* __FUNCTION__ */
+	{
+	  name = fname_as_string (type_dep);
+	  release_name = true;
+	}
+      else
+	gcc_unreachable ();
+    }
   tree type;
   tree init = cp_fname_init (name, &type);
   tree decl = build_decl (loc, VAR_DECL, id, type);
 
-  if (name)
+  if (release_name)
     free (CONST_CAST (char *, name));
 
   /* As we're using pushdecl_with_scope, we must set the context.  */
@@ -5836,8 +5850,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
       /* Pointers initialized to strings must be treated as non-zero
 	 even if the string is empty.  */
       tree init_type = TREE_TYPE (elt_init);
-      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type))
-	  || !initializer_zerop (elt_init))
+      if (POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)
+	  || !type_initializer_zero_p (elt_type, elt_init))
 	last_nonzero = index;
 
       /* This can happen with an invalid initializer (c++/54501).  */
@@ -6114,7 +6128,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,
 			       (CONSTRUCTOR_ELT (stripped_init,0)->value))))
 		{
 		  if (complain & tf_error)
-		    error ("too many braces around scalar initializer"
+		    error ("too many braces around scalar initializer "
 		           "for type %qT", type);
 		  init = error_mark_node;
 		}
@@ -6210,14 +6224,13 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,
 	       by the front end.  Here we have e.g. {.__pfn=0B, .__delta=0},
 	       which is missing outermost braces.  We should warn below, and
 	       one of the routines below will wrap it in additional { }.  */;
-	  /* For a nested compound literal, there is no need to reshape since
-	     we called reshape_init in finish_compound_literal, before calling
-	     digest_init.  */
-	  else if (COMPOUND_LITERAL_P (stripped_init)
-		   /* Similarly, a CONSTRUCTOR of the target's type is a
-		      previously digested initializer.  */
-		   || same_type_ignoring_top_level_qualifiers_p (type,
-								 init_type))
+	  /* For a nested compound literal, proceed to specialized routines,
+	     to handle initialization of arrays and similar.  */
+	  else if (COMPOUND_LITERAL_P (stripped_init))
+	    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (stripped_init));
+	  /* A CONSTRUCTOR of the target's type is a previously
+	     digested initializer.  */
+	  else if (same_type_ignoring_top_level_qualifiers_p (type, init_type))
 	    {
 	      ++d->cur;
 	      gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (stripped_init));
@@ -8407,14 +8420,14 @@ expand_static_init (tree decl, tree init)
 	      (acquire_name, build_function_type_list (integer_type_node,
 						       TREE_TYPE (guard_addr),
 						       NULL_TREE),
-	       NULL_TREE, ECF_NOTHROW | ECF_LEAF);
+	       NULL_TREE, ECF_NOTHROW);
 	  if (!release_fn || !abort_fn)
 	    vfntype = build_function_type_list (void_type_node,
 						TREE_TYPE (guard_addr),
 						NULL_TREE);
 	  if (!release_fn)
 	    release_fn = push_library_fn (release_name, vfntype, NULL_TREE,
-					   ECF_NOTHROW | ECF_LEAF);
+					  ECF_NOTHROW);
 	  if (!abort_fn)
 	    abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE,
 					ECF_NOTHROW | ECF_LEAF);
@@ -9539,10 +9552,12 @@ build_ptrmemfunc_type (tree type)
   TYPE_PTRMEMFUNC_FLAG (t) = 1;
 
   field = build_decl (input_location, FIELD_DECL, pfn_identifier, type);
+  DECL_NONADDRESSABLE_P (field) = 1;
   fields = field;
 
   field = build_decl (input_location, FIELD_DECL, delta_identifier, 
 		      delta_type_node);
+  DECL_NONADDRESSABLE_P (field) = 1;
   DECL_CHAIN (field) = fields;
   fields = field;
 
@@ -11435,6 +11450,8 @@ grokdeclarator (const cp_declarator *declarator,
 		else if (late_return_type
 			 && sfk != sfk_conversion)
 		  {
+		    if (late_return_type == error_mark_node)
+		      return error_mark_node;
 		    if (cxx_dialect < cxx11)
 		      /* Not using maybe_warn_cpp0x because this should
 			 always be an error.  */
@@ -12163,6 +12180,7 @@ grokdeclarator (const cp_declarator *declarator,
 	  memfn_quals |= type_memfn_quals (type);
 	  rqual = type_memfn_rqual (type);
 	  type_quals = TYPE_UNQUALIFIED;
+	  raises = TYPE_RAISES_EXCEPTIONS (type);
 	}
     }
 
@@ -13042,7 +13060,9 @@ check_default_argument (tree decl, tree arg, tsubst_flags_t complain)
   /* Avoid redundant -Wzero-as-null-pointer-constant warnings at
      the call sites.  */
   if (TYPE_PTR_OR_PTRMEM_P (decl_type)
-      && null_ptr_cst_p (arg))
+      && null_ptr_cst_p (arg)
+      /* Don't lose side-effects as in PR90473.  */
+      && !TREE_SIDE_EFFECTS (arg))
     return nullptr_node;
 
   /* [dcl.fct.default]
@@ -15612,7 +15632,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)
       && !implicit_default_ctor_p (decl1))
     cp_ubsan_maybe_initialize_vtbl_ptrs (current_class_ptr);
 
-  start_lambda_scope (decl1);
+  if (!DECL_OMP_DECLARE_REDUCTION_P (decl1))
+    start_lambda_scope (decl1);
 
   return true;
 }
@@ -16020,7 +16041,8 @@ finish_function (bool inline_p)
   if (fndecl == NULL_TREE)
     return error_mark_node;
 
-  finish_lambda_scope ();
+  if (!DECL_OMP_DECLARE_REDUCTION_P (fndecl))
+    finish_lambda_scope ();
 
   if (c_dialect_objc ())
     objc_finish_function ();
@@ -16137,7 +16159,7 @@ finish_function (bool inline_p)
     invoke_plugin_callbacks (PLUGIN_PRE_GENERICIZE, fndecl);
 
   /* Perform delayed folding before NRV transformation.  */
-  if (!processing_template_decl)
+  if (!processing_template_decl && !DECL_OMP_DECLARE_REDUCTION_P (fndecl))
     cp_fold_function (fndecl);
 
   /* Set up the named return value optimization, if we can.  Candidate
@@ -16260,7 +16282,8 @@ finish_function (bool inline_p)
   if (!processing_template_decl)
     {
       struct language_function *f = DECL_SAVED_FUNCTION_DATA (fndecl);
-      cp_genericize (fndecl);
+      if (!DECL_OMP_DECLARE_REDUCTION_P (fndecl))
+	cp_genericize (fndecl);
       /* Clear out the bits we don't need.  */
       f->x_current_class_ptr = NULL;
       f->x_current_class_ref = NULL;
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 6f23ee1cd3f..a46cbce08f4 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -5501,8 +5501,11 @@ mark_used (tree decl, tsubst_flags_t complain)
 	vec_safe_push (no_linkage_decls, decl);
     }
 
-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl)
-      && !DECL_INITIAL (decl) && !DECL_ARTIFICIAL (decl))
+  if (TREE_CODE (decl) == FUNCTION_DECL
+      && DECL_DECLARED_INLINE_P (decl)
+      && !DECL_INITIAL (decl)
+      && !DECL_ARTIFICIAL (decl)
+      && !DECL_PURE_VIRTUAL_P (decl))
     /* Remember it, so we can check it was defined.  */
     note_vague_linkage_fn (decl);
 
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 59e1f351fc6..fcc91fc9172 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -860,6 +860,11 @@ perform_member_init (tree member, tree init)
 	}
       if (init == error_mark_node)
 	return;
+      if (DECL_SIZE (member) && integer_zerop (DECL_SIZE (member))
+	  && !TREE_SIDE_EFFECTS (init))
+	/* Don't add trivial initialization of an empty base/field, as they
+	   might not be ordered the way the back-end expects.  */
+	return;
       /* A FIELD_DECL doesn't really have a suitable lifetime, but
 	 make_temporary_var_for_ref_to_temp will treat it as automatic and
 	 set_up_extended_ref_temp wants to use the decl in a warning.  */
@@ -3443,13 +3448,17 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 	  explicit_value_init_p = true;
 	}
 
-      if (processing_template_decl && explicit_value_init_p)
+      if (processing_template_decl)
 	{
+	  /* Avoid an ICE when converting to a base in build_simple_base_path.
+	     We'll throw this all away anyway, and build_new will create
+	     a NEW_EXPR.  */
+	  tree t = fold_convert (build_pointer_type (elt_type), data_addr);
 	  /* build_value_init doesn't work in templates, and we don't need
 	     the initializer anyway since we're going to throw it away and
 	     rebuild it at instantiation time, so just build up a single
 	     constructor call to get any appropriate diagnostics.  */
-	  init_expr = cp_build_fold_indirect_ref (data_addr);
+	  init_expr = cp_build_fold_indirect_ref (t);
 	  if (type_build_ctor_call (elt_type))
 	    init_expr = build_special_member_call (init_expr,
 						   complete_ctor_identifier,
@@ -3512,7 +3521,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 						     complete_ctor_identifier,
 						     init, elt_type,
 						     LOOKUP_NORMAL,
-                                                     complain);
+						     complain|tf_no_cleanup);
 	    }
 	  else if (explicit_value_init_p)
 	    {
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index 93664181b47..edfd2f75853 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -220,16 +220,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
   tree type;
   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));
 
-  if (!is_this && type_dependent_expression_p (expr))
-    {
-      type = cxx_make_type (DECLTYPE_TYPE);
-      DECLTYPE_TYPE_EXPR (type) = expr;
-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;
-      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
-      SET_TYPE_STRUCTURAL_EQUALITY (type);
-    }
-  else if (!is_this && explicit_init_p)
+  if (!is_this && explicit_init_p)
     {
       tree auto_node = make_auto ();
       
@@ -240,6 +231,14 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
 	type = build_reference_type (type);
       type = do_auto_deduction (type, expr, auto_node);
     }
+  else if (!is_this && type_dependent_expression_p (expr))
+    {
+      type = cxx_make_type (DECLTYPE_TYPE);
+      DECLTYPE_TYPE_EXPR (type) = expr;
+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
+      SET_TYPE_STRUCTURAL_EQUALITY (type);
+    }
   else
     {
       type = non_reference (unlowered_expr_type (expr));
@@ -602,7 +601,16 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,
   name = get_identifier (buf);
 
   if (variadic)
-    type = make_pack_expansion (type);
+    {
+      type = make_pack_expansion (type);
+      if (explicit_init_p)
+	/* With an explicit initializer 'type' is auto, which isn't really a
+	   parameter pack in this context.  We will want as many fields as we
+	   have elements in the expansion of the initializer, so use its packs
+	   instead.  */
+	PACK_EXPANSION_PARAMETER_PACKS (type)
+	  = uses_parameter_packs (initializer);
+    }
 
   /* Make member variable.  */
   member = build_decl (input_location, FIELD_DECL, name, type);
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index a5fd66fe0de..6f194375261 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -874,7 +874,16 @@ decl_mangling_context (tree decl)
   else if (template_type_parameter_p (decl))
      /* template type parms have no mangling context.  */
       return NULL_TREE;
-  return CP_DECL_CONTEXT (decl);
+
+  tcontext = CP_DECL_CONTEXT (decl);
+
+  /* Ignore the artificial declare reduction functions.  */
+  if (tcontext
+      && TREE_CODE (tcontext) == FUNCTION_DECL
+      && DECL_OMP_DECLARE_REDUCTION_P (tcontext))
+    return decl_mangling_context (tcontext);
+
+  return tcontext;
 }
 
 /* <name> ::= <unscoped-name>
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 4ca976c812d..8999c5ad4a7 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -909,7 +909,7 @@ name_lookup::adl_expr (tree expr)
 
   if (TREE_TYPE (expr) != unknown_type_node)
     {
-      adl_type (TREE_TYPE (expr));
+      adl_type (unlowered_expr_type (expr));
       return;
     }
 
@@ -4117,38 +4117,46 @@ is_nested_namespace (tree ancestor, tree descendant, bool inline_only)
   return ancestor == descendant;
 }
 
-/* Returns true if ROOT (a namespace, class, or function) encloses
-   CHILD.  CHILD may be either a class type or a namespace.  */
+/* Returns true if ROOT (a non-alias namespace, class, or function)
+   encloses CHILD.  CHILD may be either a class type or a namespace
+   (maybe alias).  */
 
 bool
 is_ancestor (tree root, tree child)
 {
-  gcc_assert ((TREE_CODE (root) == NAMESPACE_DECL
-	       || TREE_CODE (root) == FUNCTION_DECL
-	       || CLASS_TYPE_P (root)));
-  gcc_assert ((TREE_CODE (child) == NAMESPACE_DECL
-	       || CLASS_TYPE_P (child)));
+  gcc_checking_assert ((TREE_CODE (root) == NAMESPACE_DECL
+			&& !DECL_NAMESPACE_ALIAS (root))
+		       || TREE_CODE (root) == FUNCTION_DECL
+		       || CLASS_TYPE_P (root));
+  gcc_checking_assert (TREE_CODE (child) == NAMESPACE_DECL
+		       || CLASS_TYPE_P (child));
 
-  /* The global namespace encloses everything.  */
+  /* The global namespace encloses everything.  Early-out for the
+     common case.  */
   if (root == global_namespace)
     return true;
 
-  /* Search until we reach namespace scope.  */
+  /* Search CHILD until we reach namespace scope.  */
   while (TREE_CODE (child) != NAMESPACE_DECL)
     {
       /* If we've reached the ROOT, it encloses CHILD.  */
       if (root == child)
 	return true;
+
       /* Go out one level.  */
       if (TYPE_P (child))
 	child = TYPE_NAME (child);
       child = CP_DECL_CONTEXT (child);
     }
 
-  if (TREE_CODE (root) == NAMESPACE_DECL)
-    return is_nested_namespace (root, child);
+  if (TREE_CODE (root) != NAMESPACE_DECL)
+    /* Failed to meet the non-namespace we were looking for.  */
+    return false;
 
-  return false;
+  if (tree alias = DECL_NAMESPACE_ALIAS (child))
+    child = alias;
+
+  return is_nested_namespace (root, child);
 }
 
 /* Enter the class or namespace scope indicated by T suitable for name
@@ -5656,7 +5664,7 @@ get_std_name_hint (const char *name)
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5718,7 +5726,7 @@ get_std_name_hint (const char *name)
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
@@ -7618,6 +7626,12 @@ maybe_save_operator_binding (tree e)
 
   if (!fns && (fns = op_unqualified_lookup (fnname)))
     {
+      tree fn = get_first_fn (fns);
+      if (DECL_CLASS_SCOPE_P (fn))
+	/* We don't need to remember class-scope functions, normal unqualified
+	   lookup will find them again.  */
+	return;
+
       bindings = tree_cons (fnname, fns, bindings);
       if (attr)
 	TREE_VALUE (attr) = bindings;
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index a7218e752b1..e1c02d7b718 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -2650,6 +2650,7 @@ static bool cp_parser_init_statement_p
   (cp_parser *);
 static bool cp_parser_skip_to_closing_square_bracket
   (cp_parser *);
+static size_t cp_parser_skip_balanced_tokens (cp_parser *, size_t);
 
 /* Concept-related syntactic transformations */
 
@@ -10452,6 +10453,10 @@ cp_parser_lambda_expression (cp_parser* parser)
     parser->implicit_template_scope = 0;
     parser->auto_is_implicit_function_template_parm_p = false;
 
+    /* The body of a lambda in a discarded statement is not discarded.  */
+    bool discarded = in_discarded_stmt;
+    in_discarded_stmt = 0;
+
     /* By virtue of defining a local class, a lambda expression has access to
        the private variables of enclosing classes.  */
 
@@ -10482,6 +10487,8 @@ cp_parser_lambda_expression (cp_parser* parser)
 
     type = finish_struct (type, /*attributes=*/NULL_TREE);
 
+    in_discarded_stmt = discarded;
+
     parser->num_template_parameter_lists = saved_num_template_parameter_lists;
     parser->in_statement = in_statement;
     parser->in_switch_statement_p = in_switch_statement_p;
@@ -10851,6 +10858,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)
       ++parser->num_template_parameter_lists;
     }
 
+  /* Committee discussion supports allowing attributes here.  */
+  lambda_specs.attributes = cp_parser_attributes_opt (parser);
+
   /* The parameter-declaration-clause is optional (unless
      template-parameter-list was given), but must begin with an
      opening parenthesis if present.  */
@@ -10960,7 +10970,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)
 
     fco = grokmethod (&return_type_specs,
 		      declarator,
-		      gnu_attrs);
+		      chainon (gnu_attrs, lambda_specs.attributes));
     if (fco != error_mark_node)
       {
 	DECL_INITIALIZED_IN_CLASS_P (fco) = 1;
@@ -13998,6 +14008,10 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
         case RID_CONCEPT:
           ds = ds_concept;
           cp_lexer_consume_token (parser->lexer);
+
+	  if (flags & CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR)
+	    break;
+
 	  /* In C++20 a concept definition is just 'concept name = expr;'
 	     Support that syntax by pretending we've seen 'bool'.  */
 	  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)
@@ -14025,6 +14039,10 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 	  ds = ds_typedef;
 	  /* Consume the token.  */
 	  cp_lexer_consume_token (parser->lexer);
+
+	  if (flags & CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR)
+	    break;
+
 	  /* A constructor declarator cannot appear in a typedef.  */
 	  constructor_possible_p = false;
 	  /* The "typedef" keyword can only occur in a declaration; we
@@ -14120,6 +14138,9 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 	  bool is_cv_qualifier;
 	  tree type_spec;
 
+	  if (flags & CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR)
+	    flags |= CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS;
+
 	  type_spec
 	    = cp_parser_type_specifier (parser, flags,
 					decl_specs,
@@ -16720,7 +16741,17 @@ cp_parser_template_name (cp_parser* parser,
     {
       if (TREE_DEPRECATED (decl)
 	  && deprecated_state != DEPRECATED_SUPPRESS)
-	warn_deprecated_use (decl, NULL_TREE);
+	{
+	  tree d = DECL_TEMPLATE_RESULT (decl);
+	  tree attr;
+	  if (TREE_CODE (d) == TYPE_DECL)
+	    attr = lookup_attribute ("deprecated",
+				     TYPE_ATTRIBUTES (TREE_TYPE (d)));
+	  else
+	    attr = lookup_attribute ("deprecated",
+				     DECL_ATTRIBUTES (d));
+	  warn_deprecated_use (decl, attr);
+	}
     }
   else
     {
@@ -21970,6 +22001,18 @@ cp_parser_type_specifier_seq (cp_parser* parser,
       /* Check for attributes first.  */
       if (cp_next_tokens_can_be_attribute_p (parser))
 	{
+	  /* GNU attributes at the end of a declaration apply to the
+	     declaration as a whole, not to the trailing return type.  So look
+	     ahead to see if these attributes are at the end.  */
+	  if (seen_type_specifier && is_trailing_return
+	      && cp_next_tokens_can_be_gnu_attribute_p (parser))
+	    {
+	      size_t n = cp_parser_skip_attributes_opt (parser, 1);
+	      cp_token *tok = cp_lexer_peek_nth_token (parser->lexer, n);
+	      if (tok->type == CPP_SEMICOLON || tok->type == CPP_COMMA
+		  || tok->type == CPP_EQ || tok->type == CPP_OPEN_BRACE)
+		break;
+	    }
 	  type_specifier_seq->attributes
 	    = attr_chainon (type_specifier_seq->attributes,
 			    cp_parser_attributes_opt (parser));
@@ -26178,6 +26221,17 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)
       /* A GNU attribute that takes an identifier in parameter.  */
       attr_flag = id_attr;
 
+    const attribute_spec *as
+      = lookup_attribute_spec (TREE_PURPOSE (attribute));
+    if (as == NULL)
+      {
+	/* For unknown attributes, just skip balanced tokens instead of
+	   trying to parse the arguments.  */
+	for (size_t n = cp_parser_skip_balanced_tokens (parser, 1) - 1; n; --n)
+	  cp_lexer_consume_token (parser->lexer);
+	return attribute;
+      }
+
     vec = cp_parser_parenthesized_expression_list
       (parser, attr_flag, /*cast_p=*/false,
        /*allow_expansion_p=*/true,
@@ -27596,12 +27650,29 @@ cp_parser_constructor_declarator_p (cp_parser *parser, cp_parser_flags flags,
 	  /* A parameter declaration begins with a decl-specifier,
 	     which is either the "attribute" keyword, a storage class
 	     specifier, or (usually) a type-specifier.  */
-	  && !cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer))
+	  && (!cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer)
+	      /* GNU attributes can actually appear both at the start of
+		 a parameter and parenthesized declarator.
+		 S (__attribute__((unused)) int);
+		 is a constructor, but
+		 S (__attribute__((unused)) foo) (int);
+		 is a function declaration.  */
+	      || (cp_parser_allow_gnu_extensions_p (parser)
+		  && cp_next_tokens_can_be_gnu_attribute_p (parser)))
+	  /* A parameter declaration can also begin with [[attribute]].  */
+	  && !cp_next_tokens_can_be_std_attribute_p (parser))
 	{
 	  tree type;
 	  tree pushed_scope = NULL_TREE;
 	  unsigned saved_num_template_parameter_lists;
 
+	  if (cp_next_tokens_can_be_gnu_attribute_p (parser))
+	    {
+	      unsigned int n = cp_parser_skip_gnu_attributes_opt (parser, 1);
+	      while (--n)
+		cp_lexer_consume_token (parser->lexer);
+	    }
+
 	  /* Names appearing in the type-specifier should be looked up
 	     in the scope of the class.  */
 	  if (current_class_type)
@@ -27911,7 +27982,10 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,
 	    {
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 0);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (CLASS_TYPE_P (TREE_TYPE (parm)))
+	      if (TREE_CODE (parm) != PARM_DECL)
+		ok = false;
+	      else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (parm))
+		       && !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		/* OK, C++20 string literal operator template.  We don't need
 		   to warn in lower dialects here because we will have already
 		   warned about the template parameter.  */;
@@ -27925,7 +27999,7 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,
 	      tree type = INNERMOST_TEMPLATE_PARMS (parm_type);
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 1);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (parm == error_mark_node
+	      if (TREE_CODE (parm) != PARM_DECL
 		  || TREE_TYPE (parm) != TREE_TYPE (type)
 		  || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		ok = false;
@@ -32463,6 +32537,14 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 	    decl = TREE_OPERAND (decl, 0);
 	  cp_lexer_consume_token (parser->lexer);
 	}
+      else if (cp_parser_is_keyword (token, RID_FUNCTION_NAME)
+	       || cp_parser_is_keyword (token, RID_PRETTY_FUNCTION_NAME)
+	       || cp_parser_is_keyword (token, RID_C99_FUNCTION_NAME))
+	{
+	  cp_id_kind idk;
+	  decl = cp_parser_primary_expression (parser, false, false, false,
+					       &idk);
+	}
       else
 	{
 	  name = cp_parser_id_expression (parser, /*template_p=*/false,
@@ -34891,8 +34973,10 @@ cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,
   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))
     goto resync_fail;
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE, "dist_schedule",
-			     location);
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule", location); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (location, 0, "too many %qs clauses", "dist_schedule");
   OMP_CLAUSE_CHAIN (c) = list;
   return c;
 
@@ -39438,6 +39522,8 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)
   combiner = cp_parser_expression (parser);
   finish_expr_stmt (combiner);
   block = finish_omp_structured_block (block);
+  if (processing_template_decl)
+    block = build_stmt (input_location, EXPR_STMT, block);
   add_stmt (block);
 
   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
@@ -39542,6 +39628,8 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)
 
       block = finish_omp_structured_block (block);
       cp_walk_tree (&block, cp_remove_omp_priv_cleanup_stmt, omp_priv, NULL);
+      if (processing_template_decl)
+	block = build_stmt (input_location, EXPR_STMT, block);
       add_stmt (block);
 
       if (ctor)
@@ -40746,7 +40834,10 @@ cp_parser_initial_pragma (cp_token *first_token)
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (cp_parser_pragma_kind (first_token) != PRAGMA_GCC_PCH_PREPROCESS)
-    return;
+    {
+      c_common_no_more_pch ();
+      return;
+    }
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (first_token->type == CPP_STRING)
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index a2a986b1db1..4787747b6ff 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -3875,7 +3875,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)
 }
 
 /* Determines if the expression or type T uses any parameter packs.  */
-bool
+tree
 uses_parameter_packs (tree t)
 {
   tree parameter_packs = NULL_TREE;
@@ -3885,7 +3885,7 @@ uses_parameter_packs (tree t)
   ppd.type_pack_expansion_p = false;
   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);
   delete ppd.visited;
-  return parameter_packs != NULL_TREE;
+  return parameter_packs;
 }
 
 /* Turn ARG, which may be an expression, type, or a TREE_LIST
@@ -6353,6 +6353,8 @@ check_valid_ptrmem_cst_expr (tree type, tree expr,
 static bool
 has_value_dependent_address (tree op)
 {
+  STRIP_ANY_LOCATION_WRAPPER (op);
+
   /* We could use get_inner_reference here, but there's no need;
      this is only relevant for template non-type arguments, which
      can only be expressed as &id-expression.  */
@@ -10119,22 +10121,11 @@ uses_template_parms (tree t)
 		   || uses_template_parms (TREE_CHAIN (t)));
   else if (TREE_CODE (t) == TYPE_DECL)
     dependent_p = dependent_type_p (TREE_TYPE (t));
-  else if (DECL_P (t)
-	   || EXPR_P (t)
-	   || TREE_CODE (t) == TEMPLATE_PARM_INDEX
-	   || TREE_CODE (t) == OVERLOAD
-	   || BASELINK_P (t)
-	   || identifier_p (t)
-	   || TREE_CODE (t) == TRAIT_EXPR
-	   || TREE_CODE (t) == CONSTRUCTOR
-	   || CONSTANT_CLASS_P (t))
+  else if (t == error_mark_node)
+    dependent_p = false;
+  else
     dependent_p = (type_dependent_expression_p (t)
 		   || value_dependent_expression_p (t));
-  else
-    {
-      gcc_assert (t == error_mark_node);
-      dependent_p = false;
-    }
 
   processing_template_decl = saved_processing_template_decl;
 
@@ -11757,10 +11748,6 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
       ARGUMENT_PACK_SELECT_INDEX (aps) = index;
     }
 
-  // Any local specialization bindings arising from this substitution
-  // cannot be reused for a different INDEX.
-  local_specialization_stack lss (lss_copy);
-
   /* Substitute into the PATTERN with the (possibly altered)
      arguments.  */
   if (pattern == in_decl)
@@ -13508,7 +13495,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 
                 /* Zero-length parameter packs are boring. Just substitute
                    into the chain.  */
-                if (len == 0)
+		if (len == 0 && !cp_unevaluated_operand)
                   RETURN (tsubst (TREE_CHAIN (t), args, complain,
 				  TREE_CHAIN (t)));
               }
@@ -14643,6 +14630,11 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	     about the template parameter in question.  */
 	  return t;
 
+	/* Like with 'auto', don't reduce the level of template parameters
+	   to avoid mismatches when deducing their types.  */
+	if (complain & tf_partial)
+	  return t;
+
 	/* If we get here, we must have been looking at a parm for a
 	   more deeply nested template.  Make a new version of this
 	   template parameter, but with a lower level.  */
@@ -14758,6 +14750,71 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	if (t == void_list_node)
 	  return t;
 
+	if ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))
+	    || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))
+	  {
+	    /* We have pack expansions, so expand those and
+	       create a new list out of it.  */
+
+	    /* Expand the argument expressions.  */
+	    tree purposevec = NULL_TREE;
+	    if (TREE_PURPOSE (t))
+	      purposevec = tsubst_pack_expansion (TREE_PURPOSE (t), args,
+						  complain, in_decl);
+	    if (purposevec == error_mark_node)
+	      return error_mark_node;
+
+	    tree valuevec = NULL_TREE;
+	    if (TREE_VALUE (t))
+	      valuevec = tsubst_pack_expansion (TREE_VALUE (t), args,
+						complain, in_decl);
+	    if (valuevec == error_mark_node)
+	      return error_mark_node;
+
+	    /* Build the rest of the list.  */
+	    tree chain = TREE_CHAIN (t);
+	    if (chain && chain != void_type_node)
+	      chain = tsubst (chain, args, complain, in_decl);
+	    if (chain == error_mark_node)
+	      return error_mark_node;
+
+	    /* Determine the number of arguments.  */
+	    int len = -1;
+	    if (purposevec && TREE_CODE (purposevec) == TREE_VEC)
+	      {
+		len = TREE_VEC_LENGTH (purposevec);
+		gcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));
+	      }
+	    else if (TREE_CODE (valuevec) == TREE_VEC)
+	      len = TREE_VEC_LENGTH (valuevec);
+	    else
+	      {
+		/* Since we only performed a partial substitution into
+		   the argument pack, we only RETURN (a single list
+		   node.  */
+		if (purposevec == TREE_PURPOSE (t)
+		    && valuevec == TREE_VALUE (t)
+		    && chain == TREE_CHAIN (t))
+		  return t;
+
+		return tree_cons (purposevec, valuevec, chain);
+	      }
+
+	    /* Convert the argument vectors into a TREE_LIST.  */
+	    for (int i = len; i-- > 0; )
+	      {
+		purpose = (purposevec ? TREE_VEC_ELT (purposevec, i)
+			   : NULL_TREE);
+		value = (valuevec ? TREE_VEC_ELT (valuevec, i)
+			 : NULL_TREE);
+
+		/* Build the list (backwards).  */
+		chain = hash_tree_cons (purpose, value, chain);
+	      }
+
+	    return chain;
+	  }
+
 	purpose = TREE_PURPOSE (t);
 	if (purpose)
 	  {
@@ -15130,24 +15187,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 				      /*function_p*/false,
 				      /*integral_constant_expression*/false);
 
-	if (DECLTYPE_FOR_INIT_CAPTURE (t))
-	  {
-	    if (type == NULL_TREE)
-	      {
-		if (complain & tf_error)
-		  error ("empty initializer in lambda init-capture");
-		type = error_mark_node;
-	      }
-	    else if (TREE_CODE (type) == TREE_LIST)
-	      type = build_x_compound_expr_from_list (type, ELK_INIT, complain);
-	  }
-
 	--cp_unevaluated_operand;
 	--c_inhibit_evaluation_warnings;
 
 	if (DECLTYPE_FOR_LAMBDA_CAPTURE (t))
 	  type = lambda_capture_field_type (type,
-					    DECLTYPE_FOR_INIT_CAPTURE (t),
+					    false /*explicit_init*/,
 					    DECLTYPE_FOR_REF_CAPTURE (t));
 	else if (DECLTYPE_FOR_LAMBDA_PROXY (t))
 	  type = lambda_proxy_type (type);
@@ -15789,6 +15834,14 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 		  return op;
 		}
 	    }
+	  /* force_paren_expr can also create a VIEW_CONVERT_EXPR.  */
+	  else if (code == VIEW_CONVERT_EXPR && REF_PARENTHESIZED_P (t))
+	    {
+	      op = tsubst_copy (op, args, complain, in_decl);
+	      op = build1 (code, TREE_TYPE (op), op);
+	      REF_PARENTHESIZED_P (op) = true;
+	      return op;
+	    }
 	  /* We shouldn't see any other uses of these in templates.  */
 	  gcc_unreachable ();
 	}
@@ -16147,7 +16200,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 
     case INTEGER_CST:
     case REAL_CST:
-    case STRING_CST:
     case COMPLEX_CST:
       {
 	/* Instantiate any typedefs in the type.  */
@@ -16157,6 +16209,18 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	return r;
       }
 
+    case STRING_CST:
+      {
+	tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
+	r = t;
+	if (type != TREE_TYPE (t))
+	  {
+	    r = copy_node (t);
+	    TREE_TYPE (r) = type;
+	  }
+	return r;
+      }
+
     case PTRMEM_CST:
       /* These can sometimes show up in a partial instantiation, but never
 	 involve template parms.  */
@@ -18014,6 +18078,33 @@ tsubst_non_call_postfix_expression (tree t, tree args,
   return t;
 }
 
+/* Subroutine of tsubst_lambda_expr: add the FIELD/INIT capture pair to the
+   LAMBDA_EXPR_CAPTURE_LIST passed in LIST.  Do deduction for a previously
+   dependent init-capture.  */
+
+static void
+prepend_one_capture (tree field, tree init, tree &list,
+		     tsubst_flags_t complain)
+{
+  if (tree auto_node = type_uses_auto (TREE_TYPE (field)))
+    {
+      tree type = NULL_TREE;
+      if (!init)
+	{
+	  if (complain & tf_error)
+	    error ("empty initializer in lambda init-capture");
+	  init = error_mark_node;
+	}
+      else if (TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, ELK_INIT, complain);
+      if (!type)
+	type = do_auto_deduction (TREE_TYPE (field), init, auto_node, complain);
+      TREE_TYPE (field) = type;
+      cp_apply_type_quals_to_decl (cp_type_quals (type), field);
+    }
+  list = tree_cons (field, init, list);
+}
+
 /* T is a LAMBDA_EXPR.  Generate a new LAMBDA_EXPR for the current
    instantiation context.  Instantiating a pack expansion containing a lambda
    might result in multiple lambdas all based on the same lambda in the
@@ -18025,17 +18116,8 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
   tree oldfn = lambda_function (t);
   in_decl = oldfn;
 
-  /* If we have already specialized this lambda expr, reuse it.  See
-     PR c++/87322.  */
-  if (local_specializations)
-    if (tree r = retrieve_local_specialization (t))
-      return r;
-
   tree r = build_lambda_expr ();
 
-  if (local_specializations)
-    register_local_specialization (r, t);
-
   LAMBDA_EXPR_LOCATION (r)
     = LAMBDA_EXPR_LOCATION (t);
   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)
@@ -18061,6 +18143,36 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
        cap = TREE_CHAIN (cap))
     {
       tree ofield = TREE_PURPOSE (cap);
+      tree init = TREE_VALUE (cap);
+      if (PACK_EXPANSION_P (init))
+	init = tsubst_pack_expansion (init, args, complain, in_decl);
+      else
+	init = tsubst_copy_and_build (init, args, complain, in_decl,
+				      /*fn*/false, /*constexpr*/false);
+
+      if (init == error_mark_node)
+	return error_mark_node;
+
+      if (init && TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, ELK_INIT, complain);
+
+      if (!processing_template_decl
+	  && init && TREE_CODE (init) != TREE_VEC
+	  && variably_modified_type_p (TREE_TYPE (init), NULL_TREE))
+	{
+	  /* For a VLA, simply tsubsting the field type won't work, we need to
+	     go through add_capture again.  XXX do we want to do this for all
+	     captures?  */
+	  tree name = (get_identifier
+		       (IDENTIFIER_POINTER (DECL_NAME (ofield)) + 2));
+	  tree ftype = TREE_TYPE (ofield);
+	  bool by_ref = (TYPE_REF_P (ftype)
+			 || (TREE_CODE (ftype) == DECLTYPE_TYPE
+			     && DECLTYPE_FOR_REF_CAPTURE (ftype)));
+	  add_capture (r, name, init, by_ref, !DECL_NORMAL_CAPTURE_P (ofield));
+	  continue;
+	}
+
       if (PACK_EXPANSION_P (ofield))
 	ofield = PACK_EXPANSION_PATTERN (ofield);
       tree field = tsubst_decl (ofield, args, complain);
@@ -18075,28 +18187,21 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
       if (field == error_mark_node)
 	return error_mark_node;
 
-      tree init = TREE_VALUE (cap);
-      if (PACK_EXPANSION_P (init))
-	init = tsubst_pack_expansion (init, args, complain, in_decl);
-      else
-	init = tsubst_copy_and_build (init, args, complain, in_decl,
-				      /*fn*/false, /*constexpr*/false);
-
       if (TREE_CODE (field) == TREE_VEC)
 	{
 	  int len = TREE_VEC_LENGTH (field);
 	  gcc_assert (TREE_CODE (init) == TREE_VEC
 		      && TREE_VEC_LENGTH (init) == len);
 	  for (int i = 0; i < len; ++i)
-	    LAMBDA_EXPR_CAPTURE_LIST (r)
-	      = tree_cons (TREE_VEC_ELT (field, i),
-			   TREE_VEC_ELT (init, i),
-			   LAMBDA_EXPR_CAPTURE_LIST (r));
+	    prepend_one_capture (TREE_VEC_ELT (field, i),
+				 TREE_VEC_ELT (init, i),
+				 LAMBDA_EXPR_CAPTURE_LIST (r),
+				 complain);
 	}
       else
 	{
-	  LAMBDA_EXPR_CAPTURE_LIST (r)
-	    = tree_cons (field, init, LAMBDA_EXPR_CAPTURE_LIST (r));
+	  prepend_one_capture (field, init, LAMBDA_EXPR_CAPTURE_LIST (r),
+			       complain);
 
 	  if (id_equal (DECL_NAME (field), "__this"))
 	    LAMBDA_EXPR_THIS_CAPTURE (r) = field;
@@ -19525,13 +19630,8 @@ tsubst_copy_and_build (tree t,
       {
 	tree type1 = tsubst (TRAIT_EXPR_TYPE1 (t), args,
 			     complain, in_decl);
-
-	tree type2 = TRAIT_EXPR_TYPE2 (t);
-	if (type2 && TREE_CODE (type2) == TREE_LIST)
-	  type2 = RECUR (type2);
-	else if (type2)
-	  type2 = tsubst (type2, args, complain, in_decl);
-	
+	tree type2 = tsubst (TRAIT_EXPR_TYPE2 (t), args,
+			     complain, in_decl);
 	RETURN (finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2));
       }
 
@@ -20571,7 +20671,7 @@ static bool
 deducible_expression (tree expr)
 {
   /* Strip implicit conversions.  */
-  while (CONVERT_EXPR_P (expr))
+  while (CONVERT_EXPR_P (expr) || TREE_CODE (expr) == VIEW_CONVERT_EXPR)
     expr = TREE_OPERAND (expr, 0);
   return (TREE_CODE (expr) == TEMPLATE_PARM_INDEX);
 }
@@ -22041,8 +22141,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
   /* I don't think this will do the right thing with respect to types.
      But the only case I've seen it in so far has been array bounds, where
      signedness is the only information lost, and I think that will be
-     okay.  */
-  while (CONVERT_EXPR_P (parm))
+     okay.  VIEW_CONVERT_EXPR can appear with class NTTP, thanks to
+     finish_id_expression_1, and are also OK.  */
+  while (CONVERT_EXPR_P (parm) || TREE_CODE (parm) == VIEW_CONVERT_EXPR)
     parm = TREE_OPERAND (parm, 0);
 
   if (arg == error_mark_node)
@@ -24321,12 +24422,11 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 	}
       else if (push_tinst_level (fn))
 	{
+	  push_to_top_level ();
 	  push_access_scope (fn);
 	  push_deferring_access_checks (dk_no_deferred);
 	  input_location = DECL_SOURCE_LOCATION (fn);
 
-	  tree save_ccp = current_class_ptr;
-	  tree save_ccr = current_class_ref;
 	  /* If needed, set current_class_ptr for the benefit of
 	     tsubst_copy/PARM_DECL.  */
 	  tree tdecl = DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (fn));
@@ -24352,9 +24452,6 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 					/*function_p=*/false,
 					/*i_c_e_p=*/true);
 
-	  current_class_ptr = save_ccp;
-	  current_class_ref = save_ccr;
-
 	  /* Build up the noexcept-specification.  */
 	  spec = build_noexcept_spec (noex, tf_warning_or_error);
 
@@ -24364,6 +24461,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 	  pop_deferring_access_checks ();
 	  pop_access_scope (fn);
 	  pop_tinst_level ();
+	  pop_from_top_level ();
 	}
       else
 	spec = noexcept_false_spec;
@@ -25232,8 +25330,9 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)
     {
       if (cxx_dialect < cxx2a)
 	{
-	  error ("non-type template parameters of class type only available "
-		 "with %<-std=c++2a%> or %<-std=gnu++2a%>");
+	  if (complain & tf_error)
+	    error ("non-type template parameters of class type only available "
+		   "with %<-std=c++2a%> or %<-std=gnu++2a%>");
 	  return true;
 	}
       if (dependent_type_p (type))
@@ -25242,15 +25341,20 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)
 	return true;
       if (!literal_type_p (type))
 	{
-	  error ("%qT is not a valid type for a template non-type parameter "
-		 "because it is not literal", type);
-	  explain_non_literal_class (type);
+	  if (complain & tf_error)
+	    {
+	      auto_diagnostic_group d;
+	      error ("%qT is not a valid type for a template non-type parameter "
+		     "because it is not literal", type);
+	      explain_non_literal_class (type);
+	    }
 	  return true;
 	}
       if (cp_has_mutable_p (type))
 	{
-	  error ("%qT is not a valid type for a template non-type parameter "
-		 "because it has a mutable member", type);
+	  if (complain & tf_error)
+	    error ("%qT is not a valid type for a template non-type parameter "
+		   "because it has a mutable member", type);
 	  return true;
 	}
       /* FIXME check op<=> and strong structural equality once spaceship is
@@ -26715,7 +26819,7 @@ build_non_dependent_expr (tree expr)
   if (TREE_CODE (expr) == COND_EXPR)
     return build3 (COND_EXPR,
 		   TREE_TYPE (expr),
-		   TREE_OPERAND (expr, 0),
+		   build_non_dependent_expr (TREE_OPERAND (expr, 0)),
 		   (TREE_OPERAND (expr, 1)
 		    ? build_non_dependent_expr (TREE_OPERAND (expr, 1))
 		    : build_non_dependent_expr (TREE_OPERAND (expr, 0))),
@@ -27615,6 +27719,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,
     }
   else
     {
+      if (error_operand_p (init))
+	return error_mark_node;
+
       tree parms = build_tree_list (NULL_TREE, type);
       tree tparms;
 
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 6d40b145fcb..4bfb5d15293 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -2577,7 +2577,6 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,
 	      tree arg2 = (*orig_args)[2];
 	      int literal_mask = ((literal_integer_zerop (arg1) << 1)
 				  | (literal_integer_zerop (arg2) << 2));
-	      arg2 = instantiate_non_dependent_expr (arg2);
 	      warn_for_memset (input_location, arg0, arg2, literal_mask);
 	    }
 
@@ -4338,7 +4337,7 @@ expand_or_defer_fn_1 (tree fn)
       if (DECL_INTERFACE_KNOWN (fn))
 	/* We've already made a decision as to how this function will
 	   be handled.  */;
-      else if (!at_eof)
+      else if (!at_eof || DECL_OMP_DECLARE_REDUCTION_P (fn))
 	tentative_decl_linkage (fn);
       else
 	import_export_decl (fn);
@@ -4349,6 +4348,7 @@ expand_or_defer_fn_1 (tree fn)
 	 be emitted; there may be callers in other DLLs.  */
       if (DECL_DECLARED_INLINE_P (fn)
 	  && !DECL_REALLY_EXTERN (fn)
+	  && !DECL_OMP_DECLARE_REDUCTION_P (fn)
 	  && (flag_keep_inline_functions
 	      || (flag_keep_inline_dllexport
 		  && lookup_attribute ("dllexport", DECL_ATTRIBUTES (fn)))))
@@ -4381,6 +4381,9 @@ expand_or_defer_fn_1 (tree fn)
       return false;
     }
 
+  if (DECL_OMP_DECLARE_REDUCTION_P (fn))
+    return false;
+
   return true;
 }
 
@@ -7790,6 +7793,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 	    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 	      break;
 	    case OMP_CLAUSE_DEFAULT_SHARED:
+	      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
+		   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)
+		  && c_omp_predefined_variable (t))
+		/* The __func__ variable and similar function-local predefined
+		   variables may be listed in a shared or firstprivate
+		   clause.  */
+		break;
 	      if (VAR_P (t)
 		  && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
 		  && TREE_STATIC (t)
@@ -8187,7 +8197,6 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,
   if (init && EXPR_HAS_LOCATION (init))
     elocus = EXPR_LOCATION (init);
 
-  cond = cp_fully_fold (cond);
   switch (TREE_CODE (cond))
     {
     case GT_EXPR:
@@ -10026,7 +10035,8 @@ cp_build_vec_convert (tree arg, location_t loc, tree type,
 
   tree ret = NULL_TREE;
   if (!type_dependent_expression_p (arg) && !dependent_type_p (type))
-    ret = c_build_vec_convert (cp_expr_loc_or_loc (arg, input_location), arg,
+    ret = c_build_vec_convert (cp_expr_loc_or_loc (arg, input_location),
+			       decay_conversion (arg, complain),
 			       loc, type, (complain & tf_error) != 0);
 
   if (!processing_template_decl)
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 1339e9fd204..3f3583c825d 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -3123,6 +3123,11 @@ replace_placeholders_r (tree* t, int* walk_subtrees, void* data_)
 	    tree type = TREE_TYPE (*valp);
 	    tree subob = obj;
 
+	    /* Elements with RANGE_EXPR index shouldn't have any
+	       placeholders in them.  */
+	    if (ce->index && TREE_CODE (ce->index) == RANGE_EXPR)
+	      continue;
+
 	    if (TREE_CODE (*valp) == CONSTRUCTOR
 		&& AGGREGATE_TYPE_P (type))
 	      {
@@ -5487,6 +5492,76 @@ maybe_warn_zero_as_null_pointer_constant (tree expr, location_t loc)
   return false;
 }
 
+/* Given an initializer INIT for a TYPE, return true if INIT is zero
+   so that it can be replaced by value initialization.  This function
+   distinguishes betwen empty strings as initializers for arrays and
+   for pointers (which make it return false).  */
+
+bool
+type_initializer_zero_p (tree type, tree init)
+{
+  if (type == error_mark_node || init == error_mark_node)
+    return false;
+
+  STRIP_NOPS (init);
+
+  if (POINTER_TYPE_P (type))
+    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);
+
+  if (TREE_CODE (init) != CONSTRUCTOR)
+    {
+      /* A class can only be initialized by a non-class type if it has
+	 a ctor that converts from that type.  Such classes are excluded
+	 since their semantics are unknown.  */
+      if (RECORD_OR_UNION_TYPE_P (type)
+	  && !RECORD_OR_UNION_TYPE_P (TREE_TYPE (init)))
+	return false;
+      return initializer_zerop (init);
+    }
+
+  if (TREE_CODE (type) == ARRAY_TYPE)
+    {
+      tree elt_type = TREE_TYPE (type);
+      elt_type = TYPE_MAIN_VARIANT (elt_type);
+      if (elt_type == char_type_node)
+	return initializer_zerop (init);
+
+      tree elt_init;
+      unsigned HOST_WIDE_INT i;
+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)
+	if (!type_initializer_zero_p (elt_type, elt_init))
+	  return false;
+      return true;
+    }
+
+  if (TREE_CODE (type) != RECORD_TYPE)
+    return initializer_zerop (init);
+
+  if (TYPE_NON_AGGREGATE_CLASS (type))
+    return false;
+
+  tree fld = TYPE_FIELDS (type);
+
+  tree fld_init;
+  unsigned HOST_WIDE_INT i;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)
+    {
+      fld = next_initializable_field (fld);
+      if (!fld)
+	return true;
+
+      tree fldtype = TREE_TYPE (fld);
+      if (!type_initializer_zero_p (fldtype, fld_init))
+	return false;
+
+      fld = DECL_CHAIN (fld);
+      if (!fld)
+	break;
+    }
+
+  return true;
+}
+
 #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
 /* Complain that some language-specific thing hanging off a tree
    node has been accessed improperly.  */
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 3255af58a25..2169f8c4efd 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -4309,7 +4309,7 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)
       || TREE_NO_WARNING (op))
     return;
 
-  tree cop = fold_non_dependent_expr (op, complain);
+  tree cop = fold_for_warn (op);
 
   if (TREE_CODE (cop) == ADDR_EXPR
       && decl_with_nonnull_addr_p (TREE_OPERAND (cop, 0))
@@ -4632,9 +4632,8 @@ cp_build_binary_op (const op_location_t &location,
 	      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))
 	{
 	  enum tree_code tcode0 = code0, tcode1 = code1;
-	  tree cop1 = fold_non_dependent_expr (op1, complain);
 	  doing_div_or_mod = true;
-	  warn_for_div_by_zero (location, cop1);
+	  warn_for_div_by_zero (location, fold_for_warn (op1));
 
 	  if (tcode0 == COMPLEX_TYPE || tcode0 == VECTOR_TYPE)
 	    tcode0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));
@@ -4673,11 +4672,8 @@ cp_build_binary_op (const op_location_t &location,
 
     case TRUNC_MOD_EXPR:
     case FLOOR_MOD_EXPR:
-      {
-	tree cop1 = fold_non_dependent_expr (op1, complain);
-	doing_div_or_mod = true;
-	warn_for_div_by_zero (location, cop1);
-      }
+      doing_div_or_mod = true;
+      warn_for_div_by_zero (location, fold_for_warn (op1));
 
       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE
 	  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE
@@ -4770,7 +4766,7 @@ cp_build_binary_op (const op_location_t &location,
 	}
       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
-	  tree const_op1 = fold_non_dependent_expr (op1, complain);
+	  tree const_op1 = fold_for_warn (op1);
 	  if (TREE_CODE (const_op1) != INTEGER_CST)
 	    const_op1 = op1;
 	  result_type = type0;
@@ -4816,10 +4812,10 @@ cp_build_binary_op (const op_location_t &location,
 	}
       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
-	  tree const_op0 = fold_non_dependent_expr (op0, complain);
+	  tree const_op0 = fold_for_warn (op0);
 	  if (TREE_CODE (const_op0) != INTEGER_CST)
 	    const_op0 = op0;
-	  tree const_op1 = fold_non_dependent_expr (op1, complain);
+	  tree const_op1 = fold_for_warn (op1);
 	  if (TREE_CODE (const_op1) != INTEGER_CST)
 	    const_op1 = op1;
 	  result_type = type0;
@@ -5516,9 +5512,9 @@ cp_build_binary_op (const op_location_t &location,
   if (! converted)
     {
       warning_sentinel w (warn_sign_conversion, short_compare);
-      if (TREE_TYPE (op0) != result_type)
+      if (!same_type_p (TREE_TYPE (op0), result_type))
 	op0 = cp_convert_and_check (result_type, op0, complain);
-      if (TREE_TYPE (op1) != result_type)
+      if (!same_type_p (TREE_TYPE (op1), result_type))
 	op1 = cp_convert_and_check (result_type, op1, complain);
 
       if (op0 == error_mark_node || op1 == error_mark_node)
@@ -9296,8 +9292,10 @@ maybe_warn_about_returning_address_of_local (tree retval)
 	  tree base = DECL_DECOMP_BASE (whats_returned);
 	  if (TYPE_REF_P (TREE_TYPE (base)))
 	    {
-	      tree init = DECL_INITIAL (base);
-	      return maybe_warn_about_returning_address_of_local (init);
+	      if (tree init = DECL_INITIAL (base))
+		return maybe_warn_about_returning_address_of_local (init);
+	      else
+		return false;
 	    }
 	}
       bool w = false;
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index bdb98f84435..b406368a5d6 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -1291,6 +1291,8 @@ digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)
   gcc_assert (TREE_CODE (decl) == FIELD_DECL);
 
   tree type = TREE_TYPE (decl);
+  if (DECL_BIT_FIELD_TYPE (decl))
+    type = DECL_BIT_FIELD_TYPE (decl);
   int flags = LOOKUP_IMPLICIT;
   if (DIRECT_LIST_INIT_P (init))
     {
diff --git a/gcc/doc/avr-mmcu.texi b/gcc/doc/avr-mmcu.texi
index ea0161ecccb..8c8d4dad663 100644
--- a/gcc/doc/avr-mmcu.texi
+++ b/gcc/doc/avr-mmcu.texi
@@ -4,9 +4,9 @@
 
 @c This file is generated automatically using
 @c gcc/config/avr/gen-avr-mmcu-texi.c from:
-@c    gcc/config/avr/avr-arch.h
-@c    gcc/config/avr/avr-devices.c
-@c    gcc/config/avr/avr-mcus.def
+@c	 gcc/config/avr/avr-arch.h
+@c	 gcc/config/avr/avr-devices.c
+@c	 gcc/config/avr/avr-mcus.def
 
 @c Please do not edit manually.
 
@@ -14,15 +14,15 @@
 
 @item avr2
 ``Classic'' devices with up to 8@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{attiny22}, @code{attiny26}, @code{at90c8534}, @code{at90s2313}, @code{at90s2323}, @code{at90s2333}, @code{at90s2343}, @code{at90s4414}, @code{at90s4433}, @code{at90s4434}, @code{at90s8515}, @code{at90s8535}.
+@*@var{mcu}@tie{}= @code{attiny22}, @code{attiny26}, @code{at90s2313}, @code{at90s2323}, @code{at90s2333}, @code{at90s2343}, @code{at90s4414}, @code{at90s4433}, @code{at90s4434}, @code{at90c8534}, @code{at90s8515}, @code{at90s8535}.
 
 @item avr25
 ``Classic'' devices with up to 8@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5272}, @code{ata6616c}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny441}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny828}, @code{attiny84}, @code{attiny84a}, @code{attiny841}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
+@*@var{mcu}@tie{}= @code{attiny13}, @code{attiny13a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny43u}, @code{attiny44}, @code{attiny44a}, @code{attiny45}, @code{attiny48}, @code{attiny441}, @code{attiny461}, @code{attiny461a}, @code{attiny4313}, @code{attiny84}, @code{attiny84a}, @code{attiny85}, @code{attiny87}, @code{attiny88}, @code{attiny828}, @code{attiny841}, @code{attiny861}, @code{attiny861a}, @code{ata5272}, @code{ata6616c}, @code{at86rf401}.
 
 @item avr3
-``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of  program memory.
-@*@var{mcu}@tie{}= @code{at43usb355}, @code{at76c711}.
+``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.
+@*@var{mcu}@tie{}= @code{at76c711}, @code{at43usb355}.
 
 @item avr31
 ``Classic'' devices with 128@tie{}KiB of program memory.
@@ -30,15 +30,15 @@
 
 @item avr35
 ``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5505}, @code{ata6617c}, @code{ata664251}, @code{atmega16u2}, @code{atmega32u2}, @code{atmega8u2}, @code{attiny1634}, @code{attiny167}, @code{at90usb162}, @code{at90usb82}.
+@*@var{mcu}@tie{}= @code{attiny167}, @code{attiny1634}, @code{atmega8u2}, @code{atmega16u2}, @code{atmega32u2}, @code{ata5505}, @code{ata6617c}, @code{ata664251}, @code{at90usb82}, @code{at90usb162}.
 
 @item avr4
 ``Enhanced'' devices with up to 8@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata6285}, @code{ata6286}, @code{ata6289}, @code{ata6612c}, @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega48pb}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega8515}, @code{atmega8535}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{atmega88pb}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
+@*@var{mcu}@tie{}= @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega48pb}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{atmega88pb}, @code{atmega8515}, @code{atmega8535}, @code{ata6285}, @code{ata6286}, @code{ata6289}, @code{ata6612c}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
 
 @item avr5
 ``Enhanced'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata5702m322}, @code{ata5782}, @code{ata5790}, @code{ata5790n}, @code{ata5791}, @code{ata5795}, @code{ata5831}, @code{ata6613c}, @code{ata6614q}, @code{ata8210}, @code{ata8510}, @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega168pb}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega32}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega325pa}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega328}, @code{atmega328p}, @code{atmega328pb}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64hve2}, @code{atmega64m1}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega644rfr2}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{at90can32}, @code{at90can64}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
+@*@var{mcu}@tie{}= @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega168pb}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega32}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega325pa}, @code{atmega328}, @code{atmega328p}, @code{atmega328pb}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64hve2}, @code{atmega64m1}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega644rfr2}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{ata5795}, @code{ata5790}, @code{ata5790n}, @code{ata5791}, @code{ata6613c}, @code{ata6614q}, @code{ata5782}, @code{ata5831}, @code{ata8210}, @code{ata8510}, @code{ata5702m322}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90can32}, @code{at90can64}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
 
 @item avr51
 ``Enhanced'' devices with 128@tie{}KiB of program memory.
@@ -50,11 +50,11 @@
 
 @item avrxmega2
 ``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16e5}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c3}, @code{atxmega32c4}, @code{atxmega32d3}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega8e5}.
+@*@var{mcu}@tie{}= @code{atxmega8e5}, @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16e5}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c3}, @code{atxmega32c4}, @code{atxmega32d3}, @code{atxmega32d4}, @code{atxmega32e5}.
 
 @item avrxmega3
 ``XMEGA'' devices with up to 64@tie{}KiB of combined program memory and RAM, and with program memory visible in the RAM address space.
-@*@var{mcu}@tie{}= @code{attiny1614}, @code{attiny1616}, @code{attiny1617}, @code{attiny212}, @code{attiny214}, @code{attiny3214}, @code{attiny3216}, @code{attiny3217}, @code{attiny412}, @code{attiny414}, @code{attiny416}, @code{attiny417}, @code{attiny814}, @code{attiny816}, @code{attiny817}.
+@*@var{mcu}@tie{}= @code{attiny202}, @code{attiny204}, @code{attiny212}, @code{attiny214}, @code{attiny402}, @code{attiny404}, @code{attiny406}, @code{attiny412}, @code{attiny414}, @code{attiny416}, @code{attiny417}, @code{attiny804}, @code{attiny806}, @code{attiny807}, @code{attiny814}, @code{attiny816}, @code{attiny817}, @code{attiny1604}, @code{attiny1606}, @code{attiny1607}, @code{attiny1614}, @code{attiny1616}, @code{attiny1617}, @code{attiny3214}, @code{attiny3216}, @code{attiny3217}, @code{atmega808}, @code{atmega809}, @code{atmega1608}, @code{atmega1609}, @code{atmega3208}, @code{atmega3209}, @code{atmega4808}, @code{atmega4809}.
 
 @item avrxmega4
 ``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB of program memory.
@@ -74,7 +74,7 @@
 
 @item avrtiny
 ``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{attiny10}, @code{attiny20}, @code{attiny4}, @code{attiny40}, @code{attiny5}, @code{attiny9}.
+@*@var{mcu}@tie{}= @code{attiny4}, @code{attiny5}, @code{attiny9}, @code{attiny10}, @code{attiny20}, @code{attiny40}.
 
 @item avr1
 This ISA is implemented by the minimal AVR core and supported for assembler only.
diff --git a/gcc/doc/contribute.texi b/gcc/doc/contribute.texi
index bc3d209630d..039cc6eed9c 100644
--- a/gcc/doc/contribute.texi
+++ b/gcc/doc/contribute.texi
@@ -6,8 +6,8 @@
 @chapter Contributing to GCC Development
 
 If you would like to help pretest GCC releases to assure they work well,
-current development sources are available by SVN (see
-@uref{http://gcc.gnu.org/svn.html}).  Source and binary snapshots are
+current development sources are available via Git (see
+@uref{http://gcc.gnu.org/git.html}).  Source and binary snapshots are
 also available for FTP; see @uref{http://gcc.gnu.org/snapshots.html}.
 
 If you would like to work on improvements to GCC, please read the
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 91679e8b9ba..f5becf988d2 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -6713,6 +6713,33 @@ attributes.
 The following attributes are supported on most targets.
 
 @table @code
+
+@item alias ("@var{target}")
+@cindex @code{alias} variable attribute
+The @code{alias} variable attribute causes the declaration to be emitted
+as an alias for another symbol known as an @dfn{alias target}.  Except
+for top-level qualifiers the alias target must have the same type as
+the alias.  For instance, the following
+
+@smallexample
+int var_target;
+extern int __attribute__ ((alias ("var_target"))) var_alias;
+@end smallexample
+
+@noindent
+defines @code{var_alias} to be an alias for the @code{var_target} variable.
+
+It is an error if the alias target is not defined in the same translation
+unit as the alias.
+
+Note that in the absence of the attribute GCC assumes that distinct
+declarations with external linkage denote distinct objects.  Using both
+the alias and the alias target to access the same object is undefined
+in a translation unit without a declaration of the alias with the attribute.
+
+This attribute requires assembler and object file support, and may not be
+available on all targets.
+
 @cindex @code{aligned} variable attribute
 @item aligned
 @itemx aligned (@var{alignment})
@@ -20297,13 +20324,13 @@ vector unsigned long long __builtin_crypto_vpermxor (vector unsigned long long,
 vector unsigned char __builtin_crypto_vpmsumb (vector unsigned char,
                                                vector unsigned char);
 
-vector unsigned short __builtin_crypto_vpmsumb (vector unsigned short,
+vector unsigned short __builtin_crypto_vpmsumh (vector unsigned short,
                                                 vector unsigned short);
 
-vector unsigned int __builtin_crypto_vpmsumb (vector unsigned int,
+vector unsigned int __builtin_crypto_vpmsumw (vector unsigned int,
                                               vector unsigned int);
 
-vector unsigned long long __builtin_crypto_vpmsumb (vector unsigned long long,
+vector unsigned long long __builtin_crypto_vpmsumd (vector unsigned long long,
                                                     vector unsigned long long);
 
 vector unsigned long long __builtin_crypto_vshasigmad (vector unsigned long long,
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 911875f9578..0d08696c207 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -335,8 +335,9 @@ and up works.
 Necessary when regenerating @file{Makefile} dependencies in libiberty.
 Necessary when regenerating @file{libiberty/functions.texi}.
 Necessary when generating manpages from Texinfo manuals.
-Used by various scripts to generate some files included in SVN (mainly
-Unicode-related and rarely changing) from source tables.
+Used by various scripts to generate some files included in the source
+repository (mainly Unicode-related and rarely changing) from source
+tables.
 
 Used by @command{automake}.
 
@@ -458,8 +459,8 @@ Necessary to regenerate the top level @file{Makefile.in} file from
 Necessary when modifying @file{*.l} files.
 
 Necessary to build GCC during development because the generated output
-files are not included in the SVN repository.  They are included in
-releases.
+files are not included in the version-controlled source repository.
+They are included in releases.
 
 @item Texinfo version 4.7 (or later)
 
@@ -471,7 +472,7 @@ create printable documentation in DVI or PDF format.  Texinfo version
 4.8 or later is required for @command{make pdf}.
 
 Necessary to build GCC documentation during development because the
-generated output files are not included in the SVN repository.  They are
+generated output files are not included in the repository.  They are
 included in releases.
 
 @item @TeX{} (any working version)
@@ -485,11 +486,11 @@ DVI or PDF files, respectively.
 Necessary to regenerate @file{jit/docs/_build/texinfo} from the @file{.rst}
 files in the directories below @file{jit/docs}.
 
-@item SVN (any version)
+@item git (any version)
 @itemx SSH (any version)
 
-Necessary to access the SVN repository.  Public releases and weekly
-snapshots of the development sources are also available via FTP@.
+Necessary to access the source repository.  Public releases and weekly
+snapshots of the development sources are also available via HTTPS@.
 
 @item GNU diffutils version 2.7 (or later)
 
@@ -523,9 +524,8 @@ own sources.
 @cindex Downloading GCC
 @cindex Downloading the Source
 
-GCC is distributed via @uref{http://gcc.gnu.org/svn.html,,SVN} and FTP
-tarballs compressed with @command{gzip} or
-@command{bzip2}.
+GCC is distributed via @uref{http://gcc.gnu.org/git.html,,git} and via
+HTTPS as tarballs compressed with @command{gzip} or @command{bzip2}.
 
 Please refer to the @uref{http://gcc.gnu.org/releases.html,,releases web page}
 for information on how to obtain GCC@.
@@ -583,9 +583,10 @@ for both native and cross targets.
 We use @var{srcdir} to refer to the toplevel source directory for
 GCC; we use @var{objdir} to refer to the toplevel build/object directory.
 
-If you obtained the sources via SVN, @var{srcdir} must refer to the top
-@file{gcc} directory, the one where the @file{MAINTAINERS} file can be
-found, and not its @file{gcc} subdirectory, otherwise the build will fail.
+If you obtained the sources by cloning the repository, @var{srcdir}
+must refer to the top @file{gcc} directory, the one where the
+@file{MAINTAINERS} file can be found, and not its @file{gcc}
+subdirectory, otherwise the build will fail.
 
 If either @var{srcdir} or @var{objdir} is located on an automounted NFS
 file system, the shell's built-in @command{pwd} command will return
@@ -1512,7 +1513,7 @@ with @option{--enable-bootstrap}.
 @item --enable-generated-files-in-srcdir
 Neither the .c and .h files that are generated from Bison and flex nor the
 info manuals and man pages that are built from the .texi files are present
-in the SVN development tree.  When building GCC from that development tree,
+in the repository development tree.  When building GCC from that development tree,
 or from one of our snapshots, those generated files are placed in your
 build directory, which allows for the source to be in a readonly
 directory.
@@ -1806,41 +1807,50 @@ final releases.  The specific files which get @option{-Werror} are
 controlled by the Makefiles.
 
 @item --enable-checking
+@itemx --disable-checking
 @itemx --enable-checking=@var{list}
-When you specify this option, the compiler is built to perform internal
-consistency checks of the requested complexity.  This does not change the
-generated code, but adds error checking within the compiler.  This will
-slow down the compiler and may only work properly if you are building
-the compiler with GCC@.  This is @samp{yes,extra} by default when building
-from SVN or snapshots, but @samp{release} for releases.  The default
-for building the stage1 compiler is @samp{yes}.  More control
-over the checks may be had by specifying @var{list}.  The categories of
-checks available are @samp{yes} (most common checks
-@samp{assert,misc,tree,gc,rtlflag,runtime}), @samp{no} (no checks at
-all), @samp{all} (all but @samp{valgrind}), @samp{release} (cheapest
-checks @samp{assert,runtime}) or @samp{none} (same as @samp{no}).
-Individual checks can be enabled with these flags @samp{assert},
-@samp{df}, @samp{fold}, @samp{gc}, @samp{gcac}, @samp{misc}, @samp{rtl},
-@samp{rtlflag}, @samp{runtime}, @samp{tree}, @samp{extra} and @samp{valgrind}.
-@samp{extra} adds for @samp{misc} checking extra checks that might affect
-code generation and should therefore not differ between stage1 and later
-stages.
-
-The @samp{valgrind} check requires the external @command{valgrind}
-simulator, available from @uref{http://valgrind.org/}.  The
-@samp{df}, @samp{rtl}, @samp{gcac} and @samp{valgrind} checks are very expensive.
-To disable all checking, @samp{--disable-checking} or
-@samp{--enable-checking=none} must be explicitly requested.  Disabling
-assertions will make the compiler and runtime slightly faster but
-increase the risk of undetected internal errors causing wrong code to be
-generated.
+This option controls performing internal consistency checks in the compiler.
+It does not change the generated code, but adds error checking of the
+requested complexity.  This slows down the compiler and may only work
+properly if you are building the compiler with GCC@.
+
+When the option is not specified, the active set of checks depends on context.
+Namely, bootstrap stage 1 defaults to @samp{--enable-checking=yes}, builds
+from release branches or release archives default to
+@samp{--enable-checking=release}, and otherwise
+@samp{--enable-checking=yes,extra} is used.  When the option is
+specified without a @var{list}, the result is the same as
+@samp{--enable-checking=yes}.  Likewise, @samp{--disable-checking} is
+equivalent to @samp{--enable-checking=no}.
+
+The categories of checks available in @var{list} are @samp{yes} (most common
+checks @samp{assert,misc,gc,gimple,rtlflag,runtime,tree,types}), @samp{no}
+(no checks at all), @samp{all} (all but @samp{valgrind}), @samp{release}
+(cheapest checks @samp{assert,runtime}) or @samp{none} (same as @samp{no}).
+@samp{release} checks are always on and to disable them
+@samp{--disable-checking} or @samp{--enable-checking=no[,<other checks>]}
+must be explicitly requested.  Disabling assertions makes the compiler and
+runtime slightly faster but increases the risk of undetected internal errors
+causing wrong code to be generated.
+
+Individual checks can be enabled with these flags: @samp{assert}, @samp{df},
+@samp{extra}, @samp{fold}, @samp{gc}, @samp{gcac}, @samp{gimple},
+@samp{misc}, @samp{rtl}, @samp{rtlflag}, @samp{runtime}, @samp{tree},
+@samp{types} and @samp{valgrind}.  @samp{extra} extends @samp{misc}
+checking with extra checks that might affect code generation and should
+therefore not differ between stage1 and later stages in bootstrap.
+
+The @samp{valgrind} check requires the external @command{valgrind} simulator,
+available from @uref{http://valgrind.org/}.  The @samp{rtl} checks are
+expensive and the @samp{df}, @samp{gcac} and @samp{valgrind} checks are very
+expensive.
 
 @item --disable-stage1-checking
 @itemx --enable-stage1-checking
 @itemx --enable-stage1-checking=@var{list}
-If no @option{--enable-checking} option is specified the stage1
-compiler will be built with @samp{yes} checking enabled, otherwise
-the stage1 checking flags are the same as specified by
+This option affects only bootstrap build.  If no @option{--enable-checking}
+option is specified the stage1 compiler is built with @samp{yes} checking
+enabled, otherwise the stage1 checking flags are the same as specified by
 @option{--enable-checking}.  To build the stage1 compiler with
 different checking options use @option{--enable-stage1-checking}.
 The list of checking options is the same as for @option{--enable-checking}.
@@ -2129,7 +2139,7 @@ specifying paths @var{path1}, @dots{}, @var{pathN}.
 
 @smallexample
 % @var{srcdir}/configure \
-    --enable-offload-target=i686-unknown-linux-gnu=/path/to/i686/compiler,x86_64-pc-linux-gnu
+    --enable-offload-targets=x86_64-intelmicemul-linux-gnu=/path/to/x86_64/compiler,nvptx-none,hsa
 @end smallexample
 
 If @samp{hsa} is specified as one of the targets, the compiler will be
@@ -2408,7 +2418,7 @@ that type mismatches occur, this could be the cause.
 
 The solution is not to use such a directory for building GCC@.
 
-Similarly, when building from SVN or snapshots, or if you modify
+Similarly, when building from the source repository or snapshots, or if you modify
 @file{*.l} files, you need the Flex lexical analyzer generator
 installed.  If you do not modify @file{*.l} files, releases contain
 the Flex-generated files and you do not need Flex installed to build
@@ -2416,7 +2426,7 @@ them.  There is still one Flex-based lexical analyzer (part of the
 build machinery, not of GCC itself) that is used even if you only
 build the C front end.
 
-When building from SVN or snapshots, or if you modify Texinfo
+When building from the source repository or snapshots, or if you modify Texinfo
 documentation, you need version 4.7 or later of Texinfo installed if you
 want Info documentation to be regenerated.  Releases contain Info
 documentation pre-built for the unmodified documentation in the release.
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 6ef36ce02aa..0ab6c9c6449 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -292,6 +292,7 @@ Objective-C and Objective-C++ Dialects}.
 -Wbool-compare  -Wbool-operation @gol
 -Wno-builtin-declaration-mismatch @gol
 -Wno-builtin-macro-redefined  -Wc90-c99-compat  -Wc99-c11-compat @gol
+-Wc11-c2x-compat @gol
 -Wc++-compat  -Wc++11-compat  -Wc++14-compat  -Wc++17-compat  @gol
 -Wcast-align  -Wcast-align=strict  -Wcast-function-type  -Wcast-qual  @gol
 -Wchar-subscripts  -Wcatch-value  -Wcatch-value=@var{n} @gol
@@ -712,7 +713,7 @@ Objective-C and Objective-C++ Dialects}.
 -mn_flash=@var{size}  -mno-interrupts @gol
 -mmain-is-OS_task  -mrelax  -mrmw  -mstrict-X  -mtiny-stack @gol
 -mfract-convert-truncate @gol
--mshort-calls  -nodevicelib @gol
+-mshort-calls -nodevicelib  -nodevicespecs @gol
 -Waddr-space-convert  -Wmisspelled-isr}
 
 @emph{Blackfin Options}
@@ -6698,6 +6699,14 @@ For instance, warn about use of anonymous structures and unions,
 and so on.  This option is independent of the standards mode.  Warnings are
 disabled in the expression that follows @code{__extension__}.
 
+@item -Wc11-c2x-compat @r{(C and Objective-C only)}
+@opindex Wc11-c2x-compat
+@opindex Wno-c11-c2x-compat
+Warn about features not present in ISO C11, but present in ISO C2X.
+For instance, warn about omitting the string in @code{_Static_assert}.
+This option is independent of the standards mode.  Warnings are
+disabled in the expression that follows @code{__extension__}.
+
 @item -Wc++-compat @r{(C and Objective-C only)}
 @opindex Wc++-compat
 @opindex Wno-c++-compat
@@ -8027,7 +8036,7 @@ consumers are not expected to support this extended format, and they
 would be rendered unable to decode location lists using it.
 
 @item -ginternal-reset-location-views
-@itemx -gnointernal-reset-location-views
+@itemx -gno-internal-reset-location-views
 @opindex ginternal-reset-location-views
 @opindex gno-internal-reset-location-views
 Attempt to determine location views that can be omitted from location
@@ -17911,8 +17920,7 @@ provided for use in debugging the compiler.
 Do not allow constant data to be placed in code sections.
 Additionally, when compiling for ELF object format give all text sections the
 ELF processor-specific section attribute @code{SHF_ARM_PURECODE}.  This option
-is only available when generating non-pic code for M-profile targets with the
-MOVT instruction.
+is only available when generating non-pic code for M-profile targets.
 
 @item -mcmse
 @opindex mcmse
@@ -18083,6 +18091,13 @@ Allow to use truncation instead of rounding towards zero for fractional fixed-po
 @opindex nodevicelib
 Don't link against AVR-LibC's device specific library @code{lib<mcu>.a}.
 
+@item -nodevicespecs
+@opindex nodevicespecs
+Don't add @option{-specs=device-specs/specs-<mcu>} to the compiler driver's
+command line.  The user takes responsibility for supplying the sub-processes
+like compiler proper, assembler and linker with appropriate command line
+options.
+
 @item -Waddr-space-convert
 @opindex Waddr-space-convert
 @opindex Wno-addr-space-convert
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index 30612a6aecb..50e13124bc3 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -3566,7 +3566,7 @@ The @code{X} register.
 @table @code
 
 @item f
-A floating-point register (if availiable).
+A floating-point register (if available).
 
 @item I
 An I-type 12-bit signed immediate.
diff --git a/gcc/dse.c b/gcc/dse.c
index 6f6f768f371..4becdcf1cbb 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -2535,10 +2535,13 @@ scan_insn (bb_info_t bb_info, rtx_insn *insn)
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 1cec00f2b85..30c4c7007ee 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -15461,7 +15461,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,
   if (mode != GET_MODE (rtl) && GET_MODE (rtl) != VOIDmode)
     return NULL;
 
-  scalar_int_mode int_mode, inner_mode, op1_mode;
+  scalar_int_mode int_mode = BImode, inner_mode, op1_mode;
   switch (GET_CODE (rtl))
     {
     case POST_INC:
@@ -22284,19 +22284,18 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,
       /* If the contexts differ, we may not be talking about the same
 	 thing.
 	 ???  When in LTO the DIE parent is the "abstract" copy and the
-	 context_die is the specification "copy".  But this whole block
-	 should eventually be no longer needed.  */
-      if (parm_die && parm_die->die_parent != context_die && !in_lto_p)
+	 context_die is the specification "copy".  */
+      if (parm_die
+	  && parm_die->die_parent != context_die
+	  && (parm_die->die_parent->die_tag != DW_TAG_GNU_formal_parameter_pack
+	      || parm_die->die_parent->die_parent != context_die)
+	  && !in_lto_p)
 	{
-	  if (!DECL_ABSTRACT_P (node))
-	    {
-	      /* This can happen when creating an inlined instance, in
-		 which case we need to create a new DIE that will get
-		 annotated with DW_AT_abstract_origin.  */
-	      parm_die = NULL;
-	    }
-	  else
-	    gcc_unreachable ();
+	  gcc_assert (!DECL_ABSTRACT_P (node));
+	  /* This can happen when creating a concrete instance, in
+	     which case we need to create a new DIE that will get
+	     annotated with DW_AT_abstract_origin.  */
+	  parm_die = NULL;
 	}
 
       if (parm_die && parm_die->die_parent == NULL)
@@ -26647,16 +26646,12 @@ dwarf2out_late_global_decl (tree decl)
     {
       dw_die_ref die = lookup_decl_die (decl);
 
-      /* We may have to generate early debug late for LTO in case debug
+      /* We may have to generate full debug late for LTO in case debug
          was not enabled at compile-time or the target doesn't support
 	 the LTO early debug scheme.  */
       if (! die && in_lto_p)
-	{
-	  dwarf2out_decl (decl);
-	  die = lookup_decl_die (decl);
-	}
-
-      if (die)
+	dwarf2out_decl (decl);
+      else if (die)
 	{
 	  /* We get called via the symtab code invoking late_global_decl
 	     for symbols that are optimized out.
@@ -27062,6 +27057,9 @@ lookup_filename (const char *file_name)
   if (!file_name)
     return NULL;
 
+  if (!file_name[0])
+    file_name = "<stdin>";
+
   dwarf_file_data **slot
     = file_table->find_slot_with_hash (file_name, htab_hash_string (file_name),
 				       INSERT);
@@ -27687,6 +27685,7 @@ dwarf2out_inline_entry (tree block)
 static void
 dwarf2out_size_function (tree decl)
 {
+  set_early_dwarf s;
   function_to_dwarf_procedure (decl);
 }
 
@@ -29582,9 +29581,9 @@ prune_unused_types (void)
   for (i = 0; base_types.iterate (i, &base_type); i++)
     prune_unused_types_mark (base_type, 1);
 
-  /* For -fvar-tracking-assignments, also set the mark on nodes that could be
-     referenced by DW_TAG_call_site DW_AT_call_origin (i.e. direct call
-     callees).  */
+  /* Also set the mark on nodes that could be referenced by
+     DW_TAG_call_site DW_AT_call_origin (i.e. direct call callees) or
+     by DW_TAG_inlined_subroutine origins.  */
   cgraph_node *cnode;
   FOR_EACH_FUNCTION (cnode)
     if (cnode->referred_to_p (false))
@@ -29593,8 +29592,7 @@ prune_unused_types (void)
 	if (die == NULL || die->die_mark)
 	  continue;
 	for (cgraph_edge *e = cnode->callers; e; e = e->next_caller)
-	  if (e->caller != cnode
-	      && opt_for_fn (e->caller->decl, flag_var_tracking_assignments))
+	  if (e->caller != cnode)
 	    {
 	      prune_unused_types_mark (die, 1);
 	      break;
diff --git a/gcc/explow.c b/gcc/explow.c
index aea7118af1e..ea22ecf0939 100644
--- a/gcc/explow.c
+++ b/gcc/explow.c
@@ -128,6 +128,9 @@ plus_constant (machine_mode mode, rtx x, poly_int64 c, bool inplace)
 	      cst = gen_lowpart (mode, cst);
 	      gcc_assert (cst);
 	    }
+	  else if (GET_MODE (cst) == VOIDmode
+		   && get_pool_mode (XEXP (x, 0)) != mode)
+	    break;
 	  if (GET_MODE (cst) == VOIDmode || GET_MODE (cst) == mode)
 	    {
 	      tem = plus_constant (mode, cst, c);
diff --git a/gcc/expmed.c b/gcc/expmed.c
index d7f8e9a5d76..c5f5499c013 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -838,6 +838,27 @@ store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,
       if (MEM_P (op0))
 	op0 = adjust_bitfield_address_size (op0, op0_mode.else_blk (),
 					    0, MEM_SIZE (op0));
+      else if (!op0_mode.exists ())
+	{
+	  if (ibitnum == 0
+	      && known_eq (ibitsize, GET_MODE_BITSIZE (GET_MODE (op0)))
+	      && MEM_P (value)
+	      && !reverse)
+	    {
+	      value = adjust_address (value, GET_MODE (op0), 0);
+	      emit_move_insn (op0, value);
+	      return true;
+	    }
+	  if (!fallback_p)
+	    return false;
+	  rtx temp = assign_stack_temp (GET_MODE (op0),
+					GET_MODE_SIZE (GET_MODE (op0)));
+	  emit_move_insn (temp, op0);
+	  store_bit_field_1 (temp, bitsize, bitnum, 0, 0, fieldmode, value,
+			     reverse, fallback_p);
+	  emit_move_insn (op0, temp);
+	  return true;
+	}
       else
 	op0 = gen_lowpart (op0_mode.require (), op0);
     }
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index f0e43b5fda2..c717f24501e 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2932,6 +2932,11 @@ combine_comparisons (location_t loc,
    If OEP_LEXICOGRAPHIC is set, then also handle expressions with side-effects
    such as MODIFY_EXPR, RETURN_EXPR, as well as STATEMENT_LISTs.
 
+   If OEP_BITWISE is set, then require the values to be bitwise identical
+   rather than simply numerically equal.  Do not take advantage of things
+   like math-related flags or undefined behavior; only return true for
+   values that are provably bitwise identical in all circumstances.
+
    Unless OEP_MATCH_SIDE_EFFECTS is set, the function returns false on
    any operand with side effect.  This is unnecesarily conservative in the
    case we know that arg0 and arg1 are in disjoint code paths (such as in
@@ -2978,6 +2983,11 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
   if (!TREE_TYPE (arg0) || !TREE_TYPE (arg1))
     return 0;
 
+  /* Bitwise identity makes no sense if the values have different layouts.  */
+  if ((flags & OEP_BITWISE)
+      && !tree_nop_conversion_p (TREE_TYPE (arg0), TREE_TYPE (arg1)))
+    return 0;
+
   /* We cannot consider pointers to different address space equal.  */
   if (POINTER_TYPE_P (TREE_TYPE (arg0))
       && POINTER_TYPE_P (TREE_TYPE (arg1))
@@ -3110,8 +3120,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
 	if (real_identical (&TREE_REAL_CST (arg0), &TREE_REAL_CST (arg1)))
 	  return 1;
 
-
-	if (!HONOR_SIGNED_ZEROS (arg0))
+	if (!(flags & OEP_BITWISE) && !HONOR_SIGNED_ZEROS (arg0))
 	  {
 	    /* If we do not distinguish between signed and unsigned zero,
 	       consider them equal.  */
@@ -3163,7 +3172,9 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
 	break;
       }
 
-  if (flags & OEP_ONLY_CONST)
+  /* Don't handle more cases for OEP_BITWISE, since we can't guarantee that
+     two instances of undefined behavior will give identical results.  */
+  if (flags & (OEP_ONLY_CONST | OEP_BITWISE))
     return 0;
 
 /* Define macros to test an operand from arg0 and arg1 for equality and a
@@ -4935,10 +4946,9 @@ range_check_type (tree etype)
   /* First make sure that arithmetics in this type is valid, then make sure
      that it wraps around.  */
   if (TREE_CODE (etype) == ENUMERAL_TYPE || TREE_CODE (etype) == BOOLEAN_TYPE)
-    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
-					    TYPE_UNSIGNED (etype));
+    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype), 1);
 
-  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_OVERFLOW_WRAPS (etype))
+  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_UNSIGNED (etype))
     {
       tree utype, minv, maxv;
 
@@ -4956,6 +4966,8 @@ range_check_type (tree etype)
       else
 	return NULL_TREE;
     }
+  else if (POINTER_TYPE_P (etype))
+    etype = unsigned_type_for (etype);
   return etype;
 }
 
@@ -5046,9 +5058,6 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,
   if (etype == NULL_TREE)
     return NULL_TREE;
 
-  if (POINTER_TYPE_P (etype))
-    etype = unsigned_type_for (etype);
-
   high = fold_convert_loc (loc, etype, high);
   low = fold_convert_loc (loc, etype, low);
   exp = fold_convert_loc (loc, etype, exp);
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index e3073787ea9..b3ccda4cf46 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,601 @@
+2020-03-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92976
+	* match.c (select_type_set_tmp): Variable 'selector' to replace
+	select_type_stack->selector. If the selector array spec has
+	explicit bounds, make the temporary's bounds deferred.
+
+2020-02-19  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from mainline
+	2020-02-18  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/93714
+	* expr.c (gfc_check_pointer_assign): Move check for
+	matching character length to after checking the lvalue
+	attributes for target or pointer.
+
+2020-02-18  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from mainline
+	2020-02-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+	            Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/93580
+	* primary.c (gfc_match_varspec): If the symbol following %
+	is re or im and the primary expression type is not BT_COMPLEX
+	issue an error. If the symbol is len and the primary
+	expression type is not BT_CHARACTER is an error.
+
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/93463
+	* openmp.c (oacc_code_to_statement): Handle
+	EXEC_OACC_{ROUTINE,UPDATE,WAIT,CACHE,{ENTER,EXIT}_DATA,DECLARE}.
+
+2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93541
+	* intrinisic.texi (OpenMP Modules OMP_LIB and OMP_LIB_KINDS):
+	Add undocumented parameters from omp_lib.f90.in.
+
+2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93462
+	* frontend-passes.c (gfc_code_walker): For EXEC_OACC_ATOMIC, set
+	in_omp_atomic to true prevent front-end optimization.
+
+2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-21  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93309
+	* interface.c (gfc_procedure_use): Also check parent namespace for
+	'implict none (external)'.
+	* symbol.c (gfc_get_namespace): Don't set has_implicit_none_export
+	to parent namespace's setting.
+
+2020-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* parse.c (parse_omp_structured_block): Handle ST_OMP_TARGET_PARALLEL.
+	* trans-openmp.c (gfc_trans_omp_target)
+	<case EXEC_OMP_TARGET_PARALLEL>: Call pushlevel first.
+
+	PR fortran/93329
+	* openmp.c (omp_code_to_statement): Handle remaining EXEC_OMP_*
+	cases.
+
+2020-01-17  Mark Eggleston  <mark.eggleston@codethink.com>
+
+	Backport from mainline
+	Mark Eggleston  <mark.eggleston@codethink.com>
+
+	PR fortran/93236
+	* resolve.c (resolve_types): Declare boolean recursive and set with the
+	value of the recursive attribute of namespace proc_name symbol
+	structure if it exists.  Call gfc_save_all if both flag_automatic and
+	recursive are false or ns->save_all is true.
+
+2020-01-10  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/84135
+	* array.c (gfc_set_array_spec): Fix shifting of codimensions
+	when adding a dimension.
+	* decl.c (merge_array_spec): Ditto. Fix using correct codimensions.
+
+2019-12-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92961
+	* gfortran.h (gfc_seen_div0): Add declaration.
+	* arith.h (gfc_seen_div0): Add definition.
+	(eval_intrinsic): For integer division by zero, set gfc_seen_div0.
+	* decl.c (variable_decl):  If resolution resp. simplification
+	fails for array spec and a division of zero error has been
+	seen, return MATCH_ERROR.
+
+2019-12-21  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/92753
+	* expr.c (find_inquiry_ref): Catch INQUIRY_LEN case, where the
+	temporary expression has been converted to a constant and make
+	the new expression accordingly. Correct the error in INQUIRY_RE
+	and INQUIRY_IM cases. The original rather than the resolved
+	expression was being used as the source in mpfr_set.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-12-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92977
+	* frontend-passes.c (call_external_blas): Use || instead of |.
+
+	PR fortran/92977
+	* frontend-passes.c (in_omp_atomic): New variable.
+	(cfe_expr_0, matmul_to_var_expr, matmul_temp_args,
+	inline_matmul_assign, call_external_blas): Don't optimize in
+	EXEC_OMP_ATOMIC.
+	(optimize_namespace): Clear in_omp_atomic.
+	(gfc_code_walker): Set in_omp_atomic for EXEC_OMP_ATOMIC, save/restore
+	it around.
+
+	2019-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92899
+	* trans-openmp.c (gfc_trans_omp_atomic): For GFC_OMP_ATOMIC_SWAP,
+	do look through conversion on expr2 if any.
+
+	2019-12-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92775
+	* trans.h (struct lang_type, struct lang_decl): Remove span member.
+	(GFC_DECL_SPAN, GFC_TYPE_ARRAY_SPAN): Remove macros.
+	* trans-array.h (gfc_get_descriptor_offsets_for_info): Add another
+	argument.
+	* trans-array.c (gfc_get_descriptor_offsets_for_info): Add SPAN_OFF
+	argument and initialize *SPAN_OFF to the offset of span field.
+	* trans-types.c (gfc_get_array_descr_info): Adjust
+	gfc_get_descriptor_offsets_for_info caller.  Compute elem_size
+	as base->span instead of TYPE_SIZE_UNIT (etype) constant.
+
+	2019-12-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92781
+	* trans-decl.c (gfc_get_symbol_decl): If sym->backend_decl is
+	current_function_decl, add length to current rather than parent
+	function and expect DECL_CONTEXT (length) to be current_function_decl.
+
+	2019-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/91944
+	* simplify.c (gfc_simplify_spread): Check gfc_init_expr_flag instead
+	of gfc_current_ns->sym_root->n.sym->attr.flavor == FL_PARAMETER.
+
+2019-12-12  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/92898
+	* check.c (gfc_check_is_contiguous): Simplify check to handle
+	arbitrary NULL() argument.
+
+2019-12-11 Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/92897
+	* array.c (gfc_set_array_spec):  Remove invalid assert() triggered
+	by invalid Fortran code.
+
+2019-11-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/92629
+	* simplify.c (convert_mpz_to_unsigned): Skip assert for argument
+	range when -fno-range-check is specified.
+
+2019-11-25  Tobias Burnus  <tobias@codesourcery.com
+
+	Backport from mainline
+	2019-10-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92050
+	* trans-expr.c (gfc_conv_procedure_call): Handle code generated
+	by -fcheck=all.
+
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92113
+	* trans-decl.c (gfc_get_symbol_decl): If __def_init actually
+	contains a value, put it into  the read-only section.
+
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92321
+	* frontend-passes.c (call_external_blas): Commit symbol for
+	external BLAS routine.
+
+2019-11-08  Tobias Burnus  <tobias@codesourcery.com
+
+	Backport from mainline
+	2019-11-08  Tobias Burnus  <tobias@codesourcery.com
+
+	PR fortran/91253
+	* scanner.c (skip_fixed_comments): Move comment
+	lines to next if block.
+	(gfc_next_char_literal): Fix continue_line setting.
+	(get_file): Remove bogus ATTRIBUTE_UNUSED.
+
+2019-11-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92208
+	Backport from mainline
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92277
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Fix DECL_ARTIFICIAL
+	checking.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92208
+	* trans-array.c (gfc_conv_array_parameter): Only copy
+	string-length backend_decl if expression is not a function.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92284.
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Free CFI descriptor
+	at the end; partial revised revert of Rev. 277502.
+
+2019-10-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91926
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Correct the
+	assignment of the attribute field to account correctly for an
+	assumed shape dummy. Assign separately to the gfc and cfi
+	descriptors since the atribute can be different. Add branch to
+	correctly handle missing optional dummies.
+
+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91863
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Don't free data
+	memory as that's done on the Fortran side.
+	(gfc_conv_procedure_call): Handle void* pointers from
+	gfc_conv_gfc_desc_to_cfi_desc.
+
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* resolve.c (flag_fn_result_spec): Correct a typo before the
+	function declaration.
+	* trans-decl.c (gfc_sym_identifier): Boost the length of 'name'
+	to allow for all variants. Simplify the code by using a pointer
+	to the symbol's proc_name and taking the return out of each of
+	the conditional branches. Allow symbols with fn_result_spec set
+	that do not come from a procedure namespace and have a module
+	name to go through the non-fn_result_spec branch.
+
+2019-10-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/92174
+	* decl.c (attr_decl1): Move check for F2018:C822 from here ...
+	* array.c (gfc_set_array_spec): ... to here.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* trans-decl.c (generate_local_decl): Avoid misconstructed
+	intrinsic modules in a BLOCK construct.
+
+2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91586
+	* class.c (gfc_find_derived_vtab): Return NULL
+	instead of deref'ing NULL pointer.
+
+2019-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83113
+	PR fortran/89943
+	decl.c (gfc_match_function_decl): Ignore duplicate BIND(C) for function
+	declaration in submodule.  Implement at check for F2018 C1550.
+	(gfc_match_entry): Use temporary for locus, which allows removal of
+	one gfc_error_now().
+	(gfc_match_subroutine): Ignore duplicate BIND(C) for subroutine
+	declaration in submodule.  Implement at check for F2018 C1550.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91715
+	* decl.c (gfc_match_prefix): If matching a type-spec returns an error,
+	it's an error so re-act correctly.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91649
+	check.c (gfc_check_findloc): Additional checking for valid arguments
+
+2019-10-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91801
+	* simplify.c (gfc_simplify_reshape): Convert a gcc_assert into a
+	gfc_error as a user can easily hit the condition.
+
+2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84487
+	* trans-decl.c (gfc_get_symbol_decl): For __def_init, set
+	DECL_ARTIFICAL and do not set TREE_READONLY.
+
+2019-10-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/47054
+	* decl.c (variable_decl): Do not search parent namespace for symbol.
+
+2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91942
+	* io.c (match_vtag): Check for non-NULL result->symtree.
+	(match_out_tag): Check for invalid constant due to inquiry parameter.
+	(match_filepos): Instead of a syntax error, go to cleanup to get better
+	error messages.
+
+2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91785
+	* primary.c (gfc_match_varspec): Ensure an inquiry parameter has
+	it locus set.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91864
+	* gcc/fortran/io.c (match_io_element): An inquiry parameter cannot be
+	read into.
+	* gcc/fortran/match.c (gfc_match_allocate): An inquiry parameter
+	can be neither an allocate-object nor stat variable.
+	(gfc_match_deallocate): An inquiry parameter cannot be deallocated.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.ngu.org>
+
+	Backport of r276254+276265
+	PR fortran/91802
+	* decl.c (attr_decl1): Check if rank+corank > 15.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91714
+	* decl.c (gfc_match_decl_type_spec):  Issue errors for a few
+	mangled types.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91641
+	* check.c (gfc_check_is_contiguous): null() cannot be an actual
+	argument to is_contiguous().
+
+2019-09-21  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91588
+	* expr.c (check_inquiry): Remove extended component refs by
+	using symbol pointers. If a function argument is an associate
+	variable with a constant target, copy the target expression in
+	place of the argument expression. Check that the charlen is not
+	NULL before using the string length.
+
+2019-09-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91727
+	* resolve.c (conformable_arrays):  If array-spec is NULL, then
+	allocate-object is a scalar.  a conformability check only occurs
+	for an array source-expr.
+
+2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91550
+	* frontend-passes.c (do_subscript): If step equals
+	zero, a previuos error has been reported; do nothing
+	in this case.
+	* resolve.c (gfc_resolve_iterator): Move error checking
+	after type conversion.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* trans-decl.c (generate_local_decl): Do not warn if the symbol
+	is artificial.
+	* trans-types.c (get_formal_from_actual_arglist): Set artificial
+	attribute on dummy arguments.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91553
+	* simplify.c (gfc_convert_constant):  During conversion check if the
+	constant is enclosed in parenthesis, and simplify expression.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91566
+	* simplify.c (gfc_simplify_merge): Need to simplify expression
+	after insertation of parenthesis.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91642
+	* io.c (gfc_match_inquire): null() cannot be in an iolength inquire
+	list.
+
+2019-09-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91589
+	* primary.c (gfc_match_varspec): Return MATCH_NO on an apparent
+	component ref, when the primary type is intrinsic.
+
+2019-09-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/91496
+	* gfortran.h: Extend struct gfc_iterator for loop annotations.
+	* array.c (gfc_copy_iterator): Copy loop annotations by IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* decl.c (gfc_match_gcc_ivdep, gfc_match_gcc_vector)
+	(gfc_match_gcc_novector): New matcher functions handling IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* match.h: Declare prototypes of matcher functions handling IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* parse.c (decode_gcc_attribute, parse_do_block)
+	(parse_executable): Decode IVDEP, VECTOR, and NOVECTOR pragmas;
+	emit warning for unrecognized pragmas instead of error.
+	* trans-stmt.c (gfc_trans_simple_do, gfc_trans_do): Add code to
+	emit annotations for IVDEP, VECTOR, and NOVECTOR pragmas.
+	* gfortran.texi: Document IVDEP, VECTOR, and NOVECTOR pragmas.
+
+	PR fortran/91496
+	* parse.c (parse_executable): Improve error messages for
+	improperly placed pragmas not preceeding a loop.
+
+2019-09-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91660
+	* decl.c (gfc_match_decl_type_spec): Improve and restore error
+	message for malformed types-spec.
+
+2019-09-02  Steven G. Kargl  <kargl@gc.gnu.org>
+
+	PR fortran/91552
+	* array.c (walk_array_constructor): New function.
+	(gfc_match_array_constructor): Use it.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91587
+	* io.c (match_filepos): MATCH_ERROR should branch to a syntax error.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91565
+	* simplify.c (gfc_simplify_reshape): Add additional checks of the
+	ORDER dummy argument.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91564
+	* check.c (gfc_check_kill_sub): Additional checks on status dummy
+	argument.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91551
+	* intrinsic.c (sort_actual): ALLOCATED has one argument. Check for
+	no argument case.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91485
+	module.c (gfc_match_use): User defined operator cannot conflict with
+	a rename symbol.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91471
+	* primary.c (gfc_variable_attr): Remove a gfc_internal_error(),
+	which cannot be reached by conforming Fortran code, but seems to
+	be reachable from nonconforming Fortran code.  Treat the AR_UNKNOWN
+	case as a no-op.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78739
+	* match.c (gfc_match_st_function):  When matching a statement function,
+	need to check if the statement function name shadows the function
+	name.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78719
+	* decl.c (get_proc_name): Check for a CLASS entity when trying to
+	add attributes to an entity that already has an explicit interface.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82992
+	* module.c (gfc_match_use):  When renaming a module entity, search
+	current namespace for conflicting symbol.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* resolve.c (check_data_variable): data-stmt-object with pointer
+	attribute requires a data-stmt-value with the target attribute.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* misc.c (gfc_typename): Do not point to something that ought not to
+	be pointed at.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* trans.h (gfc_evaluate_now_function_scope): New function.
+	* trans.c (gfc_evaluate_now_function_scope): New function.
+	* trans-expr.c (gfc_trans_assignment): Use it.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	resolve.c (resolve_typebound_procedure): Allow host associated
+	procedure to be a binding target.  While here, wrap long line.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* expr.c (gfc_simplify_expr): Simplifcation of an array with a kind
+	type inquiry suffix yields a constant expression.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* frontend-passes.c (do_subscript): Do not warn for an
+	expression a second time.  Do not warn about a zero-trip loop.
+	(doloop_warn): Also look at contained namespaces.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* trans-decl.c (gfc_generate_return): Ensure something is returned
+	from a function.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* check.c(gfc_check_allocated): Add comment pointing to ...
+	* intrinsic.c(sort_actual): ... the checking done here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
index a4f879531d9..8c025045b93 100644
--- a/gcc/fortran/arith.c
+++ b/gcc/fortran/arith.c
@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "target-memory.h"
 #include "constructor.h"
 
+bool gfc_seen_div0;
+
 /* MPFR does not have a direct replacement for mpz_set_f() from GMP.
    It's easily implemented with a few calls though.  */
 
@@ -1620,6 +1622,10 @@ eval_intrinsic (gfc_intrinsic_op op,
       gfc_error (gfc_arith_error (rc), &op1->where);
       if (rc == ARITH_OVERFLOW)
 	goto done;
+
+      if (rc == ARITH_DIV0 && op2->ts.type == BT_INTEGER)
+	gfc_seen_div0 = true;
+
       return NULL;
     }
 
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 0aee220e68d..4a7f44f3e8b 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -837,12 +837,12 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
 
   if (as->corank)
     {
-      /* The "sym" has no corank (checked via gfc_add_codimension). Thus
-	 the codimension is simply added.  */
-      gcc_assert (as->rank == 0 && sym->as->corank == 0);
-
       sym->as->cotype = as->cotype;
       sym->as->corank = as->corank;
+      /* Check F2018:C822.  */
+      if (sym->as->rank + sym->as->corank > GFC_MAX_DIMENSIONS)
+	goto too_many;
+
       for (i = 0; i < as->corank; i++)
 	{
 	  sym->as->lower[sym->as->rank + i] = as->lower[i];
@@ -861,7 +861,11 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
       sym->as->cray_pointee = as->cray_pointee;
       sym->as->cp_was_assumed = as->cp_was_assumed;
 
-      for (i = 0; i < sym->as->corank; i++)
+      /* Check F2018:C822.  */
+      if (sym->as->rank + sym->as->corank > GFC_MAX_DIMENSIONS)
+	goto too_many;
+
+      for (i = sym->as->corank - 1; i >= 0; i--)
 	{
 	  sym->as->lower[as->rank + i] = sym->as->lower[i];
 	  sym->as->upper[as->rank + i] = sym->as->upper[i];
@@ -875,6 +879,12 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
 
   free (as);
   return true;
+
+too_many:
+
+  gfc_error ("rank + corank of %qs exceeds %d at %C", sym->name,
+	     GFC_MAX_DIMENSIONS);
+  return false;
 }
 
 
@@ -1124,6 +1134,31 @@ match_array_cons_element (gfc_constructor_base *result)
 }
 
 
+/* Convert components of an array constructor to the type in ts.  */
+
+static match
+walk_array_constructor (gfc_typespec *ts, gfc_constructor_base head)
+{
+  gfc_constructor *c;
+  gfc_expr *e;
+  match m;
+
+  for (c = gfc_constructor_first (head); c; c = gfc_constructor_next (c))
+    {
+      e = c->expr;
+      if (e->expr_type == EXPR_ARRAY && e->ts.type == BT_UNKNOWN
+	  && !e->ref && e->value.constructor)
+	{
+	  m = walk_array_constructor (ts, e->value.constructor);
+	  if (m == MATCH_ERROR)
+	    return m;
+	}
+      else if (!gfc_convert_type (e, ts, 1) && e->ts.type != BT_UNKNOWN)
+	return MATCH_ERROR;
+  }
+  return MATCH_YES;
+}
+
 /* Match an array constructor.  */
 
 match
@@ -1253,14 +1288,13 @@ done:
 	    }
 	}
 
-      /* Walk the constructor and ensure type conversion for numeric types.  */
+      /* Walk the constructor, and if possible, do type conversion for
+	 numeric types.  */
       if (gfc_numeric_ts (&ts))
 	{
-	  c = gfc_constructor_first (head);
-	  for (; c; c = gfc_constructor_next (c))
-	    if (!gfc_convert_type (c->expr, &ts, 1)
-		&& c->expr->ts.type != BT_UNKNOWN)
-	      return MATCH_ERROR;
+	  m = walk_array_constructor (&ts, head);
+	  if (m == MATCH_ERROR)
+	    return m;
 	}
     }
   else
@@ -2175,6 +2209,9 @@ gfc_copy_iterator (gfc_iterator *src)
   dest->end = gfc_copy_expr (src->end);
   dest->step = gfc_copy_expr (src->step);
   dest->unroll = src->unroll;
+  dest->ivdep = src->ivdep;
+  dest->vector = src->vector;
+  dest->novector = src->novector;
 
   return dest;
 }
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index a04f0d66655..6d37bbb8fd2 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -924,6 +924,10 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)
 }
 
 
+/* Limited checking for ALLOCATED intrinsic.  Additional checking
+   is performed in intrinsic.c(sort_actual), because ALLOCATED
+   has two mutually exclusive non-optional arguments.  */
+
 bool
 gfc_check_allocated (gfc_expr *array)
 {
@@ -2781,6 +2785,22 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)
 
       if (!scalar_check (status, 2))
 	return false;
+
+      if (status->expr_type != EXPR_VARIABLE)
+	{
+	  gfc_error ("STATUS at %L shall be an INTENT(OUT) variable",
+		     &status->where);
+	  return false;
+	}
+
+      if (status->expr_type == EXPR_VARIABLE
+	  && status->symtree && status->symtree->n.sym
+	  && status->symtree->n.sym->attr.intent == INTENT_IN)
+	{
+	  gfc_error ("%qs at %L shall be an INTENT(OUT) variable",
+		     status->symtree->name, &status->where);
+	  return false;
+	}
     }
 
   return true;
@@ -3343,26 +3363,27 @@ bool
 gfc_check_findloc (gfc_actual_arglist *ap)
 {
   gfc_expr *a, *v, *m, *d, *k, *b;
+  bool a1, v1;
 
   a = ap->expr;
   if (!intrinsic_type_check (a, 0) || !array_check (a, 0))
     return false;
 
   v = ap->next->expr;
-  if (!scalar_check (v,1))
+  if (!intrinsic_type_check (v, 1) || !scalar_check (v,1))
     return false;
 
-  /* Check if the type is compatible.  */
+  /* Check if the type are both logical.  */
+  a1 = a->ts.type == BT_LOGICAL;
+  v1 = v->ts.type == BT_LOGICAL;
+  if ((a1 && !v1) || (!a1 && v1))
+    goto incompat;
 
-  if ((a->ts.type == BT_LOGICAL && v->ts.type != BT_LOGICAL)
-      || (a->ts.type != BT_LOGICAL && v->ts.type == BT_LOGICAL))
-    {
-      gfc_error ("Argument %qs of %qs intrinsic at %L must be in type "
-		 "conformance to argument %qs at %L",
-		 gfc_current_intrinsic_arg[0]->name,
-		 gfc_current_intrinsic, &a->where,
-		 gfc_current_intrinsic_arg[1]->name, &v->where);
-    }
+  /* Check if the type are both character.  */
+  a1 = a->ts.type == BT_CHARACTER;
+  v1 = v->ts.type == BT_CHARACTER;
+  if ((a1 && !v1) || (!a1 && v1))
+    goto incompat;
 	 
   d = ap->next->next->expr;
   m = ap->next->next->next->expr;
@@ -3410,6 +3431,14 @@ gfc_check_findloc (gfc_actual_arglist *ap)
     return false;
 
   return true;
+
+incompat:
+  gfc_error ("Argument %qs of %qs intrinsic at %L must be in type "
+	     "conformance to argument %qs at %L",
+	     gfc_current_intrinsic_arg[0]->name,
+	     gfc_current_intrinsic, &a->where,
+	     gfc_current_intrinsic_arg[1]->name, &v->where);
+  return false;
 }
 
 
@@ -6549,6 +6578,13 @@ gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)
 bool
 gfc_check_is_contiguous (gfc_expr *array)
 {
+  if (array->expr_type == EXPR_NULL)
+    {
+      gfc_error ("Actual argument at %L of %qs intrinsic shall be an "
+		 "associated pointer", &array->where, gfc_current_intrinsic);
+      return false;
+    }
+
   if (!array_check (array, 0))
     return false;
 
@@ -6556,7 +6592,6 @@ gfc_check_is_contiguous (gfc_expr *array)
 }
 
 
-
 bool
 gfc_check_isatty (gfc_expr *unit)
 {
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 8a1f43f116c..9117121e5fe 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -2241,6 +2241,9 @@ gfc_find_derived_vtab (gfc_symbol *derived)
   if (!derived->attr.unlimited_polymorphic && derived->attr.is_class)
     derived = gfc_get_derived_super_type (derived);
 
+  if (!derived)
+    return NULL;
+
   /* Find the gsymbol for the module of use associated derived types.  */
   if ((derived->attr.use_assoc || derived->attr.used_in_submodule)
        && !derived->attr.vtype && !derived->attr.is_class)
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index cf09420cfbe..abff4af9f67 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -99,6 +99,11 @@ bool gfc_matching_function;
 /* Set upon parsing a !GCC$ unroll n directive for use in the next loop.  */
 int directive_unroll = -1;
 
+/* Set upon parsing supported !GCC$ pragmas for use in the next loop.  */
+bool directive_ivdep = false;
+bool directive_vector = false;
+bool directive_novector = false;
+
 /* Map of middle-end built-ins that should be vectorized.  */
 hash_map<nofree_string_hash, int> *gfc_vectorized_builtins;
 
@@ -895,8 +900,6 @@ done:
 static bool
 merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)
 {
-  int i, j;
-
   if ((from->type == AS_ASSUMED_RANK && to->corank)
       || (to->type == AS_ASSUMED_RANK && from->corank))
     {
@@ -911,18 +914,18 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)
       to->cray_pointee = from->cray_pointee;
       to->cp_was_assumed = from->cp_was_assumed;
 
-      for (i = 0; i < to->corank; i++)
+      for (int i = to->corank - 1; i >= 0; i--)
 	{
 	  /* Do not exceed the limits on lower[] and upper[].  gfortran
 	     cleans up elsewhere.  */
-	  j = from->rank + i;
+	  int j = from->rank + i;
 	  if (j >= GFC_MAX_DIMENSIONS)
 	    break;
 
 	  to->lower[j] = to->lower[i];
 	  to->upper[j] = to->upper[i];
 	}
-      for (i = 0; i < from->rank; i++)
+      for (int i = 0; i < from->rank; i++)
 	{
 	  if (copy)
 	    {
@@ -941,23 +944,24 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)
       to->corank = from->corank;
       to->cotype = from->cotype;
 
-      for (i = 0; i < from->corank; i++)
+      for (int i = 0; i < from->corank; i++)
 	{
 	  /* Do not exceed the limits on lower[] and upper[].  gfortran
 	     cleans up elsewhere.  */
-	  j = to->rank + i;
+	  int k = from->rank + i;
+	  int j = to->rank + i;
 	  if (j >= GFC_MAX_DIMENSIONS)
 	    break;
 
 	  if (copy)
 	    {
-	      to->lower[j] = gfc_copy_expr (from->lower[i]);
-	      to->upper[j] = gfc_copy_expr (from->upper[i]);
+	      to->lower[j] = gfc_copy_expr (from->lower[k]);
+	      to->upper[j] = gfc_copy_expr (from->upper[k]);
 	    }
 	  else
 	    {
-	      to->lower[j] = from->lower[i];
-	      to->upper[j] = from->upper[i];
+	      to->lower[j] = from->lower[k];
+	      to->upper[j] = from->upper[k];
 	    }
 	}
     }
@@ -1335,9 +1339,9 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
 	}
 
       /* Trap declarations of attributes in encompassing scope.  The
-	 signature for this is that ts.kind is set.  Legitimate
-	 references only set ts.type.  */
-      if (sym->ts.kind != 0
+	 signature for this is that ts.kind is nonzero for no-CLASS
+	 entity.  For a CLASS entity, ts.kind is zero.  */
+      if ((sym->ts.kind != 0 || sym->ts.type == BT_CLASS)
 	  && !sym->attr.implicit_type
 	  && sym->attr.proc == 0
 	  && gfc_current_ns->parent != NULL
@@ -2506,6 +2510,8 @@ variable_decl (int elem)
 	  goto cleanup;
 	}
 
+      gfc_seen_div0 = false;
+      
       /* F2018:C830 (R816) An explicit-shape-spec whose bounds are not
 	 constant expressions shall appear only in a subprogram, derived
 	 type definition, BLOCK construct, or interface body.  */
@@ -2522,7 +2528,12 @@ variable_decl (int elem)
 	  for (int i = 0; i < as->rank; i++)
 	    {
 	      e = gfc_copy_expr (as->lower[i]);
-	      gfc_resolve_expr (e);
+	      if (!gfc_resolve_expr (e) && gfc_seen_div0)
+		{
+		  m = MATCH_ERROR;
+		  goto cleanup;
+		}
+
 	      gfc_simplify_expr (e, 0);
 	      if (e && (e->expr_type != EXPR_CONSTANT))
 		{
@@ -2532,7 +2543,12 @@ variable_decl (int elem)
 	      gfc_free_expr (e);
 
 	      e = gfc_copy_expr (as->upper[i]);
-	      gfc_resolve_expr (e);
+	      if (!gfc_resolve_expr (e)  && gfc_seen_div0)
+		{
+		  m = MATCH_ERROR;
+		  goto cleanup;
+		}
+
 	      gfc_simplify_expr (e, 0);
 	      if (e && (e->expr_type != EXPR_CONSTANT))
 		{
@@ -2558,7 +2574,12 @@ variable_decl (int elem)
 	      if (e->expr_type != EXPR_CONSTANT)
 		{
 		  n = gfc_copy_expr (e);
-		  gfc_simplify_expr (n, 1);
+		  if (!gfc_simplify_expr (n, 1)  && gfc_seen_div0) 
+		    {
+		      m = MATCH_ERROR;
+		      goto cleanup;
+		    }
+
 		  if (n->expr_type == EXPR_CONSTANT)
 		    gfc_replace_expr (e, n);
 		  else
@@ -2568,7 +2589,12 @@ variable_decl (int elem)
 	      if (e->expr_type != EXPR_CONSTANT)
 		{
 		  n = gfc_copy_expr (e);
-		  gfc_simplify_expr (n, 1);
+		  if (!gfc_simplify_expr (n, 1)  && gfc_seen_div0) 
+		    {
+		      m = MATCH_ERROR;
+		      goto cleanup;
+		    }
+		  
 		  if (n->expr_type == EXPR_CONSTANT)
 		    gfc_replace_expr (e, n);
 		  else
@@ -2644,7 +2670,7 @@ variable_decl (int elem)
       then we want to set the type & bail out.  */
   if (flag_cray_pointer && !gfc_comp_struct (gfc_current_state ()))
     {
-      gfc_find_symbol (name, gfc_current_ns, 1, &sym);
+      gfc_find_symbol (name, gfc_current_ns, 0, &sym);
       if (sym != NULL && sym->attr.cray_pointee)
 	{
 	  m = MATCH_YES;
@@ -2905,6 +2931,7 @@ variable_decl (int elem)
 
 cleanup:
   /* Free stuff up and return.  */
+  gfc_seen_div0 = false;
   gfc_free_expr (initializer);
   gfc_free_array_spec (as);
 
@@ -3991,7 +4018,6 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       return MATCH_YES;
     }
 
-
   m = gfc_match (" type (");
   matched_type = (m == MATCH_YES);
   if (matched_type)
@@ -4039,7 +4065,10 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	m = MATCH_YES;
 
       if (matched_type && m == MATCH_YES && gfc_match_char (')') != MATCH_YES)
-	m = MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       return m;
     }
@@ -4062,8 +4091,12 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	  && !gfc_notify_std (GFC_STD_F2008, "TYPE with "
 			      "intrinsic-type-spec at %C"))
 	return MATCH_ERROR;
+
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_REAL;
       ts->kind = gfc_default_double_kind;
@@ -4093,7 +4126,10 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_ERROR;
 
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_COMPLEX;
       ts->kind = gfc_default_double_kind;
@@ -4114,7 +4150,13 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       if (m == MATCH_ERROR)
 	return m;
 
-    m = gfc_match_char (')');
+      gfc_gobble_whitespace ();
+      if (gfc_peek_ascii_char () != ')')
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
+      m = gfc_match_char (')'); /* Burn closing ')'.  */
     }
 
   if (m != MATCH_YES)
@@ -4397,6 +4439,7 @@ get_kind:
 	      gfc_next_ascii_char ();
 	      return MATCH_YES;
 	    }
+	  gfc_error ("Malformed type-spec at %C");
 	  return MATCH_NO;
 	}
     }
@@ -4410,7 +4453,10 @@ get_kind:
     }
 
   if (matched_type && gfc_match_char (')') != MATCH_YES)
-    return MATCH_ERROR;
+    {
+      gfc_error ("Malformed type-spec at %C");
+      return MATCH_ERROR;
+    }
 
   /* Defer association of the KIND expression of function results
      until after USE and IMPORT statements.  */
@@ -6145,13 +6191,17 @@ gfc_match_prefix (gfc_typespec *ts)
 	  found_prefix = true;
 	}
 
-      if (!seen_type && ts != NULL
-	  && gfc_match_decl_type_spec (ts, 0) == MATCH_YES
-	  && gfc_match_space () == MATCH_YES)
+      if (!seen_type && ts != NULL)
 	{
-
-	  seen_type = true;
-	  found_prefix = true;
+	  match m;
+	  m = gfc_match_decl_type_spec (ts, 0);
+	  if (m == MATCH_ERROR)
+	    goto error;
+	  if (m == MATCH_YES && gfc_match_space () == MATCH_YES)
+	    {
+	      seen_type = true;
+	      found_prefix = true;
+	    }
 	}
 
       if (gfc_match ("elemental% ") == MATCH_YES)
@@ -7202,13 +7252,16 @@ gfc_match_function_decl (void)
   if (sym->attr.is_bind_c == 1)
     {
       sym->attr.is_bind_c = 0;
-      if (sym->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(sym->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
+
+      if (gfc_state_stack->previous
+	  && gfc_state_stack->previous->state != COMP_SUBMODULE)
+	{
+	  locus loc;
+	  loc = sym->old_symbol != NULL
+	    ? sym->old_symbol->declared_at : gfc_current_locus;
+	  gfc_error_now ("BIND(C) attribute at %L can only be used for "
+			 "variables or common blocks", &loc);
+	}
     }
 
   if (found_match != MATCH_YES)
@@ -7222,6 +7275,24 @@ gfc_match_function_decl (void)
 	found_match = suffix_match;
     }
 
+  /* F2018 C1550 (R1526) If MODULE appears in the prefix of a module
+     subprogram and a binding label is specified, it shall be the
+     same as the binding label specified in the corresponding module
+     procedure interface body.  */
+    if (sym->attr.is_bind_c && sym->attr.module_procedure && sym->old_symbol
+  	&& strcmp (sym->name, sym->old_symbol->name) == 0
+	&& strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
+      {
+	  const char *null = "NULL", *s1, *s2;
+	  s1 = sym->binding_label;
+	  if (!s1) s1 = null;
+	  s2 = sym->old_symbol->binding_label;
+	  if (!s2) s2 = null;
+          gfc_error ("Mismatch in BIND(C) names (%qs/%qs) at %C", s1, s2);
+	  sym->refs++;	/* Needed to avoid an ICE in gfc_release_symbol */
+	  return MATCH_ERROR;
+      }
+
   if(found_match != MATCH_YES)
     m = MATCH_ERROR;
   else
@@ -7460,15 +7531,15 @@ gfc_match_entry (void)
      not allowed for procedures.  */
   if (entry->attr.is_bind_c == 1)
     {
+      locus loc;
+
       entry->attr.is_bind_c = 0;
-      if (entry->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(entry->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
-    }
+
+      loc = entry->old_symbol != NULL
+	? entry->old_symbol->declared_at : gfc_current_locus; 
+      gfc_error_now ("BIND(C) attribute at %L can only be used for "
+		     "variables or common blocks", &loc);
+     }
 
   /* Check what next non-whitespace character is so we can tell if there
      is the required parens if we have a BIND(C).  */
@@ -7668,13 +7739,16 @@ gfc_match_subroutine (void)
   if (sym->attr.is_bind_c == 1)
     {
       sym->attr.is_bind_c = 0;
-      if (sym->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(sym->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
+
+      if (gfc_state_stack->previous
+	  && gfc_state_stack->previous->state != COMP_SUBMODULE)
+	{
+	  locus loc;
+	  loc = sym->old_symbol != NULL
+	    ? sym->old_symbol->declared_at : gfc_current_locus;
+	  gfc_error_now ("BIND(C) attribute at %L can only be used for "
+			 "variables or common blocks", &loc);
+	}
     }
 
   /* C binding names are not allowed for internal procedures.  */
@@ -7716,6 +7790,24 @@ gfc_match_subroutine (void)
           return MATCH_ERROR;
         }
 
+      /* F2018 C1550 (R1526) If MODULE appears in the prefix of a module
+	 subprogram and a binding label is specified, it shall be the
+	 same as the binding label specified in the corresponding module
+	 procedure interface body.  */
+      if (sym->attr.module_procedure && sym->old_symbol
+  	  && strcmp (sym->name, sym->old_symbol->name) == 0
+	  && strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
+	{
+	  const char *null = "NULL", *s1, *s2;
+	  s1 = sym->binding_label;
+	  if (!s1) s1 = null;
+	  s2 = sym->old_symbol->binding_label;
+	  if (!s2) s2 = null;
+          gfc_error ("Mismatch in BIND(C) names (%qs/%qs) at %C", s1, s2);
+	  sym->refs++;	/* Needed to avoid an ICE in gfc_release_symbol */
+	  return MATCH_ERROR;
+	}
+
       /* Scan the dummy arguments for an alternate return.  */
       for (arg = sym->formal; arg; arg = arg->next)
 	if (!arg->sym)
@@ -10161,6 +10253,20 @@ gfc_match_derived_decl (void)
       return MATCH_ERROR;
     }
 
+  /*  In free source form, need to check for TYPE XXX as oppose to TYPEXXX.
+      But, we need to simply return for TYPE(.  */ 
+  if (m == MATCH_NO && gfc_current_form == FORM_FREE)
+    {
+      char c = gfc_peek_ascii_char ();
+      if (c == '(')
+	return m;
+      if (!gfc_is_whitespace (c))
+	{
+	  gfc_error ("Mangled derived type definition at %C");
+	  return MATCH_NO;
+	}
+    }
+
   m = gfc_match (" %n ", name);
   if (m != MATCH_YES)
     return m;
@@ -10168,7 +10274,7 @@ gfc_match_derived_decl (void)
   /* Make sure that we don't identify TYPE IS (...) as a parameterized
      derived type named 'is'.
      TODO Expand the check, when 'name' = "is" by matching " (tname) "
-     and checking if this is a(n intrinsic) typename. his picks up
+     and checking if this is a(n intrinsic) typename.  This picks up
      misplaced TYPE IS statements such as in select_type_1.f03.  */
   if (gfc_peek_ascii_char () == '(')
     {
@@ -11472,3 +11578,53 @@ gfc_match_gcc_builtin (void)
 
   return MATCH_YES;
 }
+
+/* Match an !GCC$ IVDEP statement.
+   When we come here, we have already matched the !GCC$ IVDEP string.  */
+
+match
+gfc_match_gcc_ivdep (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_ivdep = true;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ IVDEP directive at %C");
+  return MATCH_ERROR;
+}
+
+/* Match an !GCC$ VECTOR statement.
+   When we come here, we have already matched the !GCC$ VECTOR string.  */
+
+match
+gfc_match_gcc_vector (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_vector = true;
+      directive_novector = false;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ VECTOR directive at %C");
+  return MATCH_ERROR;
+}
+
+/* Match an !GCC$ NOVECTOR statement.
+   When we come here, we have already matched the !GCC$ NOVECTOR string.  */
+
+match
+gfc_match_gcc_novector (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_novector = true;
+      directive_vector = false;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ NOVECTOR directive at %C");
+  return MATCH_ERROR;
+}
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 2aeea92b8fb..94f9eb00f71 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1780,11 +1780,15 @@ find_inquiry_ref (gfc_expr *p, gfc_expr **newp)
 	  if (!gfc_notify_std (GFC_STD_F2003, "LEN part_ref at %C"))
 	    goto cleanup;
 
-	  if (!tmp->ts.u.cl->length
-	      || tmp->ts.u.cl->length->expr_type != EXPR_CONSTANT)
+	  if (tmp->ts.u.cl->length
+	      && tmp->ts.u.cl->length->expr_type == EXPR_CONSTANT)
+	    *newp = gfc_copy_expr (tmp->ts.u.cl->length);
+	  else if (tmp->expr_type == EXPR_CONSTANT)
+	    *newp = gfc_get_int_expr (gfc_default_integer_kind,
+				      NULL, tmp->value.character.length);
+	  else
 	    goto cleanup;
 
-	  *newp = gfc_copy_expr (tmp->ts.u.cl->length);
 	  break;
 
 	case INQUIRY_KIND:
@@ -1807,7 +1811,7 @@ find_inquiry_ref (gfc_expr *p, gfc_expr **newp)
 
 	  *newp = gfc_get_constant_expr (BT_REAL, tmp->ts.kind, &tmp->where);
 	  mpfr_set ((*newp)->value.real,
-		    mpc_realref (p->value.complex), GFC_RND_MODE);
+		    mpc_realref (tmp->value.complex), GFC_RND_MODE);
 	  break;
 
 	case INQUIRY_IM:
@@ -1819,7 +1823,7 @@ find_inquiry_ref (gfc_expr *p, gfc_expr **newp)
 
 	  *newp = gfc_get_constant_expr (BT_REAL, tmp->ts.kind, &tmp->where);
 	  mpfr_set ((*newp)->value.real,
-		    mpc_imagref (p->value.complex), GFC_RND_MODE);
+		    mpc_imagref (tmp->value.complex), GFC_RND_MODE);
 	  break;
 	}
       tmp = gfc_copy_expr (*newp);
@@ -2220,6 +2224,11 @@ gfc_simplify_expr (gfc_expr *p, int type)
       if (!simplify_ref_chain (p->ref, type, &p))
 	return false;
 
+      /* If the following conditions hold, we found something like kind type
+	 inquiry of the form a(2)%kind while simplify the ref chain.  */
+      if (p->expr_type == EXPR_CONSTANT && !p->ref && !p->rank && !p->shape)
+	return true;
+
       if (!simplify_constructor (p->value.constructor, type))
 	return false;
 
@@ -2598,6 +2607,8 @@ check_inquiry (gfc_expr *e, int not_restricted)
 
   int i = 0;
   gfc_actual_arglist *ap;
+  gfc_symbol *sym;
+  gfc_symbol *asym;
 
   if (!e->value.function.isym
       || !e->value.function.isym->inquiry)
@@ -2607,20 +2618,22 @@ check_inquiry (gfc_expr *e, int not_restricted)
   if (e->symtree == NULL)
     return MATCH_NO;
 
-  if (e->symtree->n.sym->from_intmod)
+  sym = e->symtree->n.sym;
+
+  if (sym->from_intmod)
     {
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
+      if (sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
 	return MATCH_NO;
 
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_C_BINDING
-	  && e->symtree->n.sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
+      if (sym->from_intmod == INTMOD_ISO_C_BINDING
+	  && sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
 	return MATCH_NO;
     }
   else
     {
-      name = e->symtree->n.sym->name;
+      name = sym->name;
 
       functions = inquiry_func_gnu;
       if (gfc_option.warn_std & GFC_STD_F2003)
@@ -2645,41 +2658,48 @@ check_inquiry (gfc_expr *e, int not_restricted)
       if (!ap->expr)
 	continue;
 
+      asym = ap->expr->symtree ? ap->expr->symtree->n.sym : NULL;
+
       if (ap->expr->ts.type == BT_UNKNOWN)
 	{
-	  if (ap->expr->symtree->n.sym->ts.type == BT_UNKNOWN
-	      && !gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns))
+	  if (asym && asym->ts.type == BT_UNKNOWN
+	      && !gfc_set_default_type (asym, 0, gfc_current_ns))
 	    return MATCH_NO;
 
-	  ap->expr->ts = ap->expr->symtree->n.sym->ts;
+	  ap->expr->ts = asym->ts;
 	}
 
-	/* Assumed character length will not reduce to a constant expression
-	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted && ap->expr->symtree
-	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
-	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
-		|| ap->expr->symtree->n.sym->ts.deferred))
-	  {
-	    gfc_error ("Assumed or deferred character length variable %qs "
-			"in constant expression at %L",
-			ap->expr->symtree->n.sym->name,
-			&ap->expr->where);
-	      return MATCH_ERROR;
-	  }
-	else if (not_restricted && !gfc_check_init_expr (ap->expr))
-	  return MATCH_ERROR;
+      if (asym && asym->assoc && asym->assoc->target
+	  && asym->assoc->target->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_free_expr (ap->expr);
+	  ap->expr = gfc_copy_expr (asym->assoc->target);
+	}
 
-	if (not_restricted == 0
-	      && ap->expr->expr_type != EXPR_VARIABLE
-	      && !check_restricted (ap->expr))
+      /* Assumed character length will not reduce to a constant expression
+	 with LEN, as required by the standard.  */
+      if (i == 5 && not_restricted && asym
+	  && asym->ts.type == BT_CHARACTER
+	  && ((asym->ts.u.cl && asym->ts.u.cl->length == NULL)
+	      || asym->ts.deferred))
+	{
+	  gfc_error ("Assumed or deferred character length variable %qs "
+		     "in constant expression at %L",
+		      asym->name, &ap->expr->where);
 	  return MATCH_ERROR;
+	}
+      else if (not_restricted && !gfc_check_init_expr (ap->expr))
+	return MATCH_ERROR;
+
+      if (not_restricted == 0
+	  && ap->expr->expr_type != EXPR_VARIABLE
+	  && !check_restricted (ap->expr))
+	return MATCH_ERROR;
 
-	if (not_restricted == 0
-	    && ap->expr->expr_type == EXPR_VARIABLE
-	    && ap->expr->symtree->n.sym->attr.dummy
-	    && ap->expr->symtree->n.sym->attr.optional)
-	  return MATCH_NO;
+      if (not_restricted == 0
+	  && ap->expr->expr_type == EXPR_VARIABLE
+	  && asym->attr.dummy && asym->attr.optional)
+	return MATCH_NO;
     }
 
   return MATCH_YES;
@@ -4176,13 +4196,6 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,
   if (rvalue->expr_type == EXPR_NULL)
     return true;
 
-  if (lvalue->ts.type == BT_CHARACTER)
-    {
-      bool t = gfc_check_same_strlen (lvalue, rvalue, "pointer assignment");
-      if (!t)
-	return false;
-    }
-
   if (rvalue->expr_type == EXPR_VARIABLE && is_subref_array (rvalue))
     lvalue->symtree->n.sym->attr.subref_array_pointer = 1;
 
@@ -4238,6 +4251,13 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,
 	}
     }
 
+  if (lvalue->ts.type == BT_CHARACTER)
+    {
+      bool t = gfc_check_same_strlen (lvalue, rvalue, "pointer assignment");
+      if (!t)
+	return false;
+    }
+
   if (is_pure && gfc_impure_variable (rvalue->symtree->n.sym))
     {
       gfc_error ("Bad target in pointer assignment in PURE "
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index d4264dafa6f..a6e710beb33 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -94,6 +94,10 @@ static int forall_level;
 
 static bool in_omp_workshare;
 
+/* Keep track of whether we are within an OMP atomic.  */
+
+static bool in_omp_atomic;
+
 /* Keep track of whether we are within a WHERE statement.  */
 
 static bool in_where;
@@ -915,9 +919,9 @@ cfe_expr_0 (gfc_expr **e, int *walk_subtrees,
   gfc_expr *newvar;
   gfc_expr **ei, **ej;
 
-  /* Don't do this optimization within OMP workshare or ASSOC lists.  */
+  /* Don't do this optimization within OMP workshare/atomic or ASSOC lists.  */
 
-  if (in_omp_workshare || in_assoc_list)
+  if (in_omp_workshare || in_omp_atomic || in_assoc_list)
     {
       *walk_subtrees = 0;
       return 0;
@@ -1466,6 +1470,7 @@ optimize_namespace (gfc_namespace *ns)
   iterator_level = 0;
   in_assoc_list = false;
   in_omp_workshare = false;
+  in_omp_atomic = false;
 
   if (flag_frontend_optimize)
     {
@@ -2519,7 +2524,12 @@ insert_index (gfc_expr *e, gfc_symbol *sym, mpz_t val, mpz_t ret)
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
@@ -2557,6 +2567,12 @@ do_subscript (gfc_expr **e)
   if (in_assoc_list)
     return 0;
 
+  /* We already warned about this.  */
+  if (v->do_not_warn)
+    return 0;
+
+  v->do_not_warn = 1;
+
   for (ref = v->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)
@@ -2569,6 +2585,7 @@ do_subscript (gfc_expr **e)
 	      bool have_do_start, have_do_end;
 	      bool error_not_proven;
 	      int warn;
+	      int sgn;
 
 	      dl = lp->c;
 	      if (dl == NULL)
@@ -2597,7 +2614,16 @@ do_subscript (gfc_expr **e)
 		 Do not warn in this case.  */
 
 	      if (dl->ext.iterator->step->expr_type == EXPR_CONSTANT)
-		mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		{
+		  sgn = mpz_cmp_ui (dl->ext.iterator->step->value.integer, 0);
+		  /* This can happen, but then the error has been
+		     reported previusly.  */
+		  if (sgn == 0)
+		    continue;
+
+		  mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		}
+
 	      else
 		continue;
 
@@ -2609,7 +2635,6 @@ do_subscript (gfc_expr **e)
 	      else
 		have_do_start = false;
 
-
 	      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)
 		{
 		  have_do_end = true;
@@ -2621,6 +2646,16 @@ do_subscript (gfc_expr **e)
 	      if (!have_do_start && !have_do_end)
 		return 0;
 
+	      /* No warning inside a zero-trip loop.  */
+	      if (have_do_start && have_do_end)
+		{
+		  int cmp;
+
+		  cmp = mpz_cmp (do_end, do_start);
+		  if ((sgn > 0 && cmp < 0) || (sgn < 0 && cmp > 0))
+		    break;
+		}
+
 	      /* May have to correct the end value if the step does not equal
 		 one.  */
 	      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)
@@ -2762,6 +2797,12 @@ static void
 doloop_warn (gfc_namespace *ns)
 {
   gfc_code_walker (&ns->code, doloop_code, do_function, NULL);
+
+  for (ns = ns->contained; ns; ns = ns->sibling)
+    {
+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)
+	doloop_warn (ns);
+    }
 }
 
 /* This selction deals with inlining calls to MATMUL.  */
@@ -2784,7 +2825,7 @@ matmul_to_var_expr (gfc_expr **ep, int *walk_subtrees ATTRIBUTE_UNUSED,
     return 0;
 
   if (forall_level > 0 || iterator_level > 0 || in_omp_workshare
-      || in_where || in_assoc_list)
+      || in_omp_atomic || in_where || in_assoc_list)
     return 0;
 
   /* Check if this is already in the form c = matmul(a,b).  */
@@ -2846,7 +2887,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
     return 0;
 
   if (forall_level > 0 || iterator_level > 0 || in_omp_workshare
-      || in_where)
+      || in_omp_atomic || in_where)
     return 0;
 
   /* This has some duplication with inline_matmul_assign.  This
@@ -3814,7 +3855,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,
   /* For now don't do anything in OpenMP workshare, it confuses
      its translation, which expects only the allowed statements in there.
      We should figure out how to parallelize this eventually.  */
-  if (in_omp_workshare)
+  if (in_omp_workshare || in_omp_atomic)
     return 0;
 
   expr1 = co->expr1;
@@ -4351,7 +4392,7 @@ call_external_blas (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
   /* For now don't do anything in OpenMP workshare, it confuses
      its translation, which expects only the allowed statements in there. */
 
-  if (in_omp_workshare)
+  if (in_omp_workshare || in_omp_atomic)
     return 0;
 
   expr1 = co->expr1;
@@ -4601,6 +4642,7 @@ call_external_blas (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
   call->symtree->n.sym->attr.procedure = 1;
   call->symtree->n.sym->attr.flavor = FL_PROCEDURE;
   call->resolved_sym = call->symtree->n.sym;
+  gfc_commit_symbol (call->resolved_sym);
 
   /* Argument TRANSA.  */
   next = gfc_get_actual_arglist ();
@@ -5012,6 +5054,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 	  gfc_code *co;
 	  gfc_association_list *alist;
 	  bool saved_in_omp_workshare;
+	  bool saved_in_omp_atomic;
 	  bool saved_in_where;
 
 	  /* There might be statement insertions before the current code,
@@ -5019,6 +5062,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 
 	  co = *c;
 	  saved_in_omp_workshare = in_omp_workshare;
+	  saved_in_omp_atomic = in_omp_atomic;
 	  saved_in_where = in_where;
 
 	  switch (co->op)
@@ -5216,6 +5260,11 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 	      WALK_SUBEXPR (co->ext.dt->extra_comma);
 	      break;
 
+	    case EXEC_OACC_ATOMIC:
+	    case EXEC_OMP_ATOMIC:
+	      in_omp_atomic = true;
+	      break;
+
 	    case EXEC_OMP_PARALLEL:
 	    case EXEC_OMP_PARALLEL_DO:
 	    case EXEC_OMP_PARALLEL_DO_SIMD:
@@ -5333,6 +5382,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 	    select_level --;
 
 	  in_omp_workshare = saved_in_omp_workshare;
+	  in_omp_atomic = saved_in_omp_atomic;
 	  in_where = saved_in_where;
 	}
     }
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 2bb82980e8e..d7071ae5fcf 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -2407,6 +2407,9 @@ typedef struct
 {
   gfc_expr *var, *start, *end, *step;
   unsigned short unroll;
+  bool ivdep;
+  bool vector;
+  bool novector;
 }
 gfc_iterator;
 
@@ -2783,6 +2786,9 @@ gfc_finalizer;
 bool gfc_in_match_data (void);
 match gfc_match_char_spec (gfc_typespec *);
 extern int directive_unroll;
+extern bool directive_ivdep;
+extern bool directive_vector;
+extern bool directive_novector;
 
 /* SIMD clause enum.  */
 enum gfc_simd_clause
@@ -2961,6 +2967,8 @@ void gfc_arith_done_1 (void);
 arith gfc_check_integer_range (mpz_t p, int kind);
 bool gfc_check_character_range (gfc_char_t, int);
 
+extern bool gfc_seen_div0;
+
 /* trans-types.c */
 bool gfc_check_any_c_kind (gfc_typespec *);
 int gfc_validate_kind (bt, int, bool);
diff --git a/gcc/fortran/gfortran.texi b/gcc/fortran/gfortran.texi
index 6a8337a4bbf..733403a129d 100644
--- a/gcc/fortran/gfortran.texi
+++ b/gcc/fortran/gfortran.texi
@@ -3542,6 +3542,9 @@ as this requires the new array descriptor.
 * ATTRIBUTES directive::
 * UNROLL directive::
 * BUILTIN directive::
+* IVDEP directive::
+* VECTOR directive::
+* NOVECTOR directive::
 @end menu
 
 @node ATTRIBUTES directive
@@ -3653,6 +3656,52 @@ for the built-in that should be vectorized.  Example usage:
 The purpose of the directive is to provide an API among the GCC compiler and
 the GNU C Library which would define vector implementations of math routines.
 
+
+@node IVDEP directive
+@subsection IVDEP directive
+
+The syntax of the directive is
+
+@code{!GCC$ ivdep}
+
+This directive tells the compiler to ignore vector dependencies in the
+following loop.  It must be placed immediately before a @code{DO} loop
+and applies only to the loop that follows.
+
+Sometimes the compiler may not have sufficient information to decide
+whether a particular loop is vectorizable due to potential
+dependencies between iterations.  The purpose of the directive is to
+tell the compiler that vectorization is safe.
+
+This directive is intended for annotation of existing code.  For new
+code it is recommended to consider OpenMP SIMD directives as potential
+alternative.
+
+
+@node VECTOR directive
+@subsection VECTOR directive
+
+The syntax of the directive is
+
+@code{!GCC$ vector}
+
+This directive tells the compiler to vectorize the following loop.  It
+must be placed immediately before a @code{DO} loop and applies only to
+the loop that follows.
+
+
+@node NOVECTOR directive
+@subsection NOVECTOR directive
+
+The syntax of the directive is
+
+@code{!GCC$ novector}
+
+This directive tells the compiler to not vectorize the following loop.
+It must be placed immediately before a @code{DO} loop and applies only
+to the loop that follows.
+
+
 @node Non-Fortran Main Program
 @section Non-Fortran Main Program
 
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index bee98129bc1..b5701b1a59a 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -3671,7 +3671,12 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
      explicitly declared at all if requested.  */
   if (sym->attr.if_source == IFSRC_UNKNOWN && !sym->attr.is_iso_c)
     {
-      if (sym->ns->has_implicit_none_export && sym->attr.proc == PROC_UNKNOWN)
+      bool has_implicit_none_export = false;
+      if (sym->attr.proc == PROC_UNKNOWN)
+	for (gfc_namespace *ns = sym->ns; ns; ns = ns->parent)
+	   if (ns->has_implicit_none_export)
+	     has_implicit_none_export = true;
+      if (has_implicit_none_export)
 	{
 	  const char *guessed
 	    = gfc_lookup_function_fuzzy (sym->name, sym->ns->sym_root);
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index c21fbddd5fb..357a35052eb 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -4180,6 +4180,50 @@ sort_actual (const char *name, gfc_actual_arglist **ap,
   if (f == NULL && a == NULL)	/* No arguments */
     return true;
 
+  /* ALLOCATED has two mutually exclusive keywords, but only one
+     can be present at time and neither is optional. */
+  if (strcmp (name, "allocated") == 0)
+    {
+      if (!a)
+	{
+	  gfc_error ("ALLOCATED intrinsic at %L requires an array or scalar "
+		     "allocatable entity", where);
+	  return false;
+	}
+
+      if (a->name)
+	{
+	  if (strcmp (a->name, "scalar") == 0)
+	    {
+	      if (a->next)
+		goto whoops;
+	      if (a->expr->rank != 0)
+		{
+		  gfc_error ("Scalar entity required at %L", &a->expr->where);
+		  return false;
+		}
+	      return true;
+	    }
+	  else if (strcmp (a->name, "array") == 0)
+	    {
+	      if (a->next)
+		goto whoops;
+	      if (a->expr->rank == 0)
+		{
+		  gfc_error ("Array entity required at %L", &a->expr->where);
+		  return false;
+		}
+	      return true;
+	    }
+	  else
+	    {
+	      gfc_error ("Invalid keyword %qs in %qs intrinsic function at %L",
+			 a->name, name, &a->expr->where);
+	      return false;
+	    }
+	}
+    }
+
   for (;;)
     {		/* Put the nonkeyword arguments in a 1:1 correspondence */
       if (f == NULL)
@@ -4199,6 +4243,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,
   if (a == NULL)
     goto do_sort;
 
+whoops:
   gfc_error ("Too many arguments in call to %qs at %L", name, where);
   return false;
 
diff --git a/gcc/fortran/intrinsic.texi b/gcc/fortran/intrinsic.texi
index f390761dc3d..b39c576a8f6 100644
--- a/gcc/fortran/intrinsic.texi
+++ b/gcc/fortran/intrinsic.texi
@@ -15017,13 +15017,16 @@ below.
 For details refer to the actual
 @uref{http://www.openmp.org/wp-content/uploads/openmp-4.5.pdf,
 OpenMP Application Program Interface v4.5}.
+And for the @code{pause}-related constants to the OpenMP 5.0 specification.
 
 @code{OMP_LIB_KINDS} provides the following scalar default-integer
 named constants:
 
 @table @asis
 @item @code{omp_lock_kind}
+@item @code{omp_lock_hint_kind}
 @item @code{omp_nest_lock_kind}
+@item @code{omp_pause_resource_kind}
 @item @code{omp_proc_bind_kind}
 @item @code{omp_sched_kind}
 @end table
@@ -15054,6 +15057,24 @@ kind @code{omp_proc_bind_kind}:
 @item @code{omp_proc_bind_spread}
 @end table
 
+The following scalar integer named constants are of the
+kind @code{omp_lock_hint_kind}:
+
+@table @asis
+@item @code{omp_lock_hint_none}
+@item @code{omp_lock_hint_uncontended}
+@item @code{omp_lock_hint_contended}
+@item @code{omp_lock_hint_nonspeculative}
+@item @code{omp_lock_hint_speculative}
+@end table
+
+And the following two scalar integer named constants are of the
+kind @code{omp_pause_resource_kind}:
+
+@table @asis
+@item @code{omp_pause_soft}
+@item @code{omp_pause_hard}
+@end table
 
 
 @node OpenACC Module OPENACC
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 9828897852a..b9a29a0f932 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -1441,24 +1441,29 @@ match_vtag (const io_tag *tag, gfc_expr **v)
       return MATCH_ERROR;
     }
 
-  if (result->symtree->n.sym->attr.intent == INTENT_IN)
+  if (result->symtree)
     {
-      gfc_error ("Variable %s cannot be INTENT(IN) at %C", tag->name);
-      gfc_free_expr (result);
-      return MATCH_ERROR;
-    }
+      bool impure;
 
-  bool impure = gfc_impure_variable (result->symtree->n.sym);
-  if (impure && gfc_pure (NULL))
-    {
-      gfc_error ("Variable %s cannot be assigned in PURE procedure at %C",
-		 tag->name);
-      gfc_free_expr (result);
-      return MATCH_ERROR;
-    }
+      if (result->symtree->n.sym->attr.intent == INTENT_IN)
+	{
+	  gfc_error ("Variable %s cannot be INTENT(IN) at %C", tag->name);
+	  gfc_free_expr (result);
+	  return MATCH_ERROR;
+	}
 
-  if (impure)
-    gfc_unset_implicit_pure (NULL);
+      impure = gfc_impure_variable (result->symtree->n.sym);
+      if (impure && gfc_pure (NULL))
+	{
+	  gfc_error ("Variable %s cannot be assigned in PURE procedure at %C",
+		     tag->name);
+	  gfc_free_expr (result);
+	  return MATCH_ERROR;
+	}
+
+      if (impure)
+	gfc_unset_implicit_pure (NULL);
+    }
 
   *v = result;
   return MATCH_YES;
@@ -1474,7 +1479,16 @@ match_out_tag (const io_tag *tag, gfc_expr **result)
 
   m = match_vtag (tag, result);
   if (m == MATCH_YES)
-    gfc_check_do_variable ((*result)->symtree);
+    {
+      if ((*result)->symtree)
+	gfc_check_do_variable ((*result)->symtree);
+
+      if ((*result)->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Expecting a variable at %L", &(*result)->where);
+	  return MATCH_ERROR;
+	}
+    }
 
   return m;
 }
@@ -2804,7 +2818,7 @@ match_filepos (gfc_statement st, gfc_exec_op op)
 
   m = match_file_element (fp);
   if (m == MATCH_ERROR)
-    goto done;
+    goto cleanup;
   if (m == MATCH_NO)
     {
       m = gfc_match_expr (&fp->unit);
@@ -3608,7 +3622,17 @@ match_io_element (io_kind k, gfc_code **cpp)
     {
       m = gfc_match_variable (&expr, 0);
       if (m == MATCH_NO)
-	gfc_error ("Expected variable in READ statement at %C");
+	{
+	  gfc_error ("Expecting variable in READ statement at %C");
+	  m = MATCH_ERROR;
+	}
+
+      if (m == MATCH_YES && expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Expecting variable or io-implied-do in READ statement "
+		   "at %L", &expr->where);
+	  m = MATCH_ERROR;
+	}
 
       if (m == MATCH_YES
 	  && expr->expr_type == EXPR_VARIABLE
@@ -3618,7 +3642,6 @@ match_io_element (io_kind k, gfc_code **cpp)
 		     &expr->where);
 	  m = MATCH_ERROR;
 	}
-
     }
   else
     {
@@ -4583,6 +4606,17 @@ gfc_match_inquire (void)
       if (m == MATCH_NO)
 	goto syntax;
 
+      for (gfc_code *c = code; c; c = c->next)
+	if (c->expr1 && c->expr1->expr_type == EXPR_FUNCTION
+	    && c->expr1->symtree && c->expr1->symtree->n.sym->attr.function
+	    && !c->expr1->symtree->n.sym->attr.external
+	    && strcmp (c->expr1->symtree->name, "null") == 0)
+	  {
+	    gfc_error ("NULL() near %L cannot appear in INQUIRE statement",
+		       &c->expr1->where);
+	    goto cleanup;
+	  }
+
       new_st.op = EXEC_IOLENGTH;
       new_st.expr1 = inquire->iolength;
       new_st.ext.inquire = inquire;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 156d7a05f6b..088b69f8ec9 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -4219,6 +4219,12 @@ gfc_match_allocate (void)
       if (m == MATCH_ERROR)
 	goto cleanup;
 
+      if (tail->expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Unexpected constant at %C");
+	  goto cleanup;
+	}
+
       if (gfc_check_do_variable (tail->expr->symtree))
 	goto cleanup;
 
@@ -4351,6 +4357,12 @@ alloc_opt_list:
 	  tmp = NULL;
 	  saw_stat = true;
 
+	  if (stat->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("STAT tag at %L cannot be a constant", &stat->where);
+	      goto cleanup;
+	    }
+
 	  if (gfc_check_do_variable (stat->symtree))
 	    goto cleanup;
 
@@ -4627,6 +4639,12 @@ gfc_match_deallocate (void)
       if (m == MATCH_NO)
 	goto syntax;
 
+      if (tail->expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Unexpected constant at %C");
+	  goto cleanup;
+	}
+
       if (gfc_check_do_variable (tail->expr->symtree))
 	goto cleanup;
 
@@ -5698,7 +5716,29 @@ gfc_match_st_function (void)
   gfc_symbol *sym;
   gfc_expr *expr;
   match m;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  locus old_locus;
+  bool fcn;
+  gfc_formal_arglist *ptr;
+
+  /* Read the possible statement function name, and then check to see if
+     a symbol is already present in the namespace.  Record if it is a
+     function and whether it has been referenced.  */
+  fcn = false;
+  ptr = NULL;
+  old_locus = gfc_current_locus;
+  m = gfc_match_name (name);
+  if (m == MATCH_YES)
+    {
+      gfc_find_symbol (name, NULL, 1, &sym);
+      if (sym && sym->attr.function && !sym->attr.referenced)
+	{
+	  fcn = true;
+	  ptr = sym->formal;
+	}
+    }
 
+  gfc_current_locus = old_locus;
   m = gfc_match_symbol (&sym, 0);
   if (m != MATCH_YES)
     return m;
@@ -5726,6 +5766,13 @@ gfc_match_st_function (void)
       return MATCH_ERROR;
     }
 
+  if (fcn && ptr != sym->formal)
+    {
+      gfc_error ("Statement function %qs at %L conflicts with function name",
+		 sym->name, &expr->where);
+      return MATCH_ERROR;
+    }
+
   sym->value = expr;
 
   if ((gfc_current_state () == COMP_FUNCTION
@@ -6118,6 +6165,7 @@ select_type_set_tmp (gfc_typespec *ts)
 {
   char name[GFC_MAX_SYMBOL_LEN];
   gfc_symtree *tmp = NULL;
+  gfc_symbol *selector = select_type_stack->selector;
 
   if (!ts)
     {
@@ -6139,22 +6187,27 @@ select_type_set_tmp (gfc_typespec *ts)
       gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);
       gfc_add_type (tmp->n.sym, ts, NULL);
 
-      if (select_type_stack->selector->ts.type == BT_CLASS
-	&& select_type_stack->selector->attr.class_ok)
+      if (selector->ts.type == BT_CLASS && selector->attr.class_ok)
 	{
-	  tmp->n.sym->attr.pointer
-		= CLASS_DATA (select_type_stack->selector)->attr.class_pointer;
+	  tmp->n.sym->attr.pointer = CLASS_DATA (selector)->attr.class_pointer;
 
 	  /* Copy across the array spec to the selector.  */
-	  if (CLASS_DATA (select_type_stack->selector)->attr.dimension
-	      || CLASS_DATA (select_type_stack->selector)->attr.codimension)
+	  if (CLASS_DATA (selector)->attr.dimension
+	      || CLASS_DATA (selector)->attr.codimension)
 	    {
 	      tmp->n.sym->attr.dimension
-		    = CLASS_DATA (select_type_stack->selector)->attr.dimension;
+		    = CLASS_DATA (selector)->attr.dimension;
 	      tmp->n.sym->attr.codimension
-		    = CLASS_DATA (select_type_stack->selector)->attr.codimension;
-	      tmp->n.sym->as
-	    = gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);
+		    = CLASS_DATA (selector)->attr.codimension;
+	      if (CLASS_DATA (selector)->as->type != AS_EXPLICIT)
+		tmp->n.sym->as
+			= gfc_copy_array_spec (CLASS_DATA (selector)->as);
+	      else
+		{
+		  tmp->n.sym->as = gfc_get_array_spec();
+		  tmp->n.sym->as->rank = CLASS_DATA (selector)->as->rank;
+		  tmp->n.sym->as->type = AS_DEFERRED;
+		}
 	    }
     }
 
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index ac47d992f4a..29854ee9000 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -246,8 +246,11 @@ match gfc_match_contiguous (void);
 match gfc_match_dimension (void);
 match gfc_match_external (void);
 match gfc_match_gcc_attributes (void);
-match gfc_match_gcc_unroll (void);
 match gfc_match_gcc_builtin (void);
+match gfc_match_gcc_ivdep (void);
+match gfc_match_gcc_novector (void);
+match gfc_match_gcc_unroll (void);
+match gfc_match_gcc_vector (void);
 match gfc_match_import (void);
 match gfc_match_intent (void);
 match gfc_match_intrinsic (void);
diff --git a/gcc/fortran/misc.c b/gcc/fortran/misc.c
index ec31fb93cd2..809f2e07674 100644
--- a/gcc/fortran/misc.c
+++ b/gcc/fortran/misc.c
@@ -125,6 +125,7 @@ gfc_typename (gfc_typespec *ts)
   static char buffer2[GFC_MAX_SYMBOL_LEN + 7];
   static int flag = 0;
   char *buffer;
+  gfc_typespec *ts1;
 
   buffer = flag ? buffer1 : buffer2;
   flag = !flag;
@@ -156,9 +157,8 @@ gfc_typename (gfc_typespec *ts)
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
     case BT_CLASS:
-      if (ts->u.derived->components)
-	ts = &ts->u.derived->components->ts;
-      if (ts->u.derived->attr.unlimited_polymorphic)
+      ts1 = ts->u.derived->components ? &ts->u.derived->components->ts : NULL;
+      if (ts1 && ts1->u.derived && ts1->u.derived->attr.unlimited_polymorphic)
 	sprintf (buffer, "CLASS(*)");
       else
 	sprintf (buffer, "CLASS(%s)", ts->u.derived->name);
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 3e1ffedd8ee..dccce4fe0a4 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -525,6 +525,8 @@ gfc_match_use (void)
   gfc_intrinsic_op op;
   match m;
   gfc_use_list *use_list;
+  gfc_symtree *st;
+  locus loc;
 
   use_list = gfc_get_use_list ();
 
@@ -632,6 +634,8 @@ gfc_match_use (void)
 	case INTERFACE_USER_OP:
 	case INTERFACE_GENERIC:
 	case INTERFACE_DTIO:
+	  loc = gfc_current_locus;
+
 	  m = gfc_match (" =>");
 
 	  if (type == INTERFACE_USER_OP && m == MATCH_YES
@@ -642,6 +646,18 @@ gfc_match_use (void)
 	  if (type == INTERFACE_USER_OP)
 	    new_use->op = INTRINSIC_USER;
 
+	  st = gfc_find_symtree (gfc_current_ns->sym_root, name);
+	  if (st && type != INTERFACE_USER_OP)
+	    {
+	      if (m == MATCH_YES)
+		gfc_error ("Symbol %qs at %L conflicts with the rename symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      else
+		gfc_error ("Symbol %qs at %L conflicts with the symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      goto cleanup;
+	    }
+
 	  if (use_list->only_flag)
 	    {
 	      if (m != MATCH_YES)
diff --git a/gcc/fortran/openmp.c b/gcc/fortran/openmp.c
index 1c7bce6c300..83b1c4487de 100644
--- a/gcc/fortran/openmp.c
+++ b/gcc/fortran/openmp.c
@@ -5757,6 +5757,81 @@ omp_code_to_statement (gfc_code *code)
       return ST_OMP_PARALLEL_WORKSHARE;
     case EXEC_OMP_DO:
       return ST_OMP_DO;
+    case EXEC_OMP_ATOMIC:
+      return ST_OMP_ATOMIC;
+    case EXEC_OMP_BARRIER:
+      return ST_OMP_BARRIER;
+    case EXEC_OMP_CANCEL:
+      return ST_OMP_CANCEL;
+    case EXEC_OMP_CANCELLATION_POINT:
+      return ST_OMP_CANCELLATION_POINT;
+    case EXEC_OMP_FLUSH:
+      return ST_OMP_FLUSH;
+    case EXEC_OMP_DISTRIBUTE:
+      return ST_OMP_DISTRIBUTE;
+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:
+      return ST_OMP_DISTRIBUTE_PARALLEL_DO;
+    case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:
+      return ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD;
+    case EXEC_OMP_DISTRIBUTE_SIMD:
+      return ST_OMP_DISTRIBUTE_SIMD;
+    case EXEC_OMP_DO_SIMD:
+      return ST_OMP_DO_SIMD;
+    case EXEC_OMP_SIMD:
+      return ST_OMP_SIMD;
+    case EXEC_OMP_TARGET:
+      return ST_OMP_TARGET;
+    case EXEC_OMP_TARGET_DATA:
+      return ST_OMP_TARGET_DATA;
+    case EXEC_OMP_TARGET_ENTER_DATA:
+      return ST_OMP_TARGET_ENTER_DATA;
+    case EXEC_OMP_TARGET_EXIT_DATA:
+      return ST_OMP_TARGET_EXIT_DATA;
+    case EXEC_OMP_TARGET_PARALLEL:
+      return ST_OMP_TARGET_PARALLEL;
+    case EXEC_OMP_TARGET_PARALLEL_DO:
+      return ST_OMP_TARGET_PARALLEL_DO;
+    case EXEC_OMP_TARGET_PARALLEL_DO_SIMD:
+      return ST_OMP_TARGET_PARALLEL_DO_SIMD;
+    case EXEC_OMP_TARGET_SIMD:
+      return ST_OMP_TARGET_SIMD;
+    case EXEC_OMP_TARGET_TEAMS:
+      return ST_OMP_TARGET_TEAMS;
+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:
+      return ST_OMP_TARGET_TEAMS_DISTRIBUTE;
+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:
+      return ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO;
+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:
+      return ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;
+    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD:
+      return ST_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD;
+    case EXEC_OMP_TARGET_UPDATE:
+      return ST_OMP_TARGET_UPDATE;
+    case EXEC_OMP_TASKGROUP:
+      return ST_OMP_TASKGROUP;
+    case EXEC_OMP_TASKLOOP:
+      return ST_OMP_TASKLOOP;
+    case EXEC_OMP_TASKLOOP_SIMD:
+      return ST_OMP_TASKLOOP_SIMD;
+    case EXEC_OMP_TASKWAIT:
+      return ST_OMP_TASKWAIT;
+    case EXEC_OMP_TASKYIELD:
+      return ST_OMP_TASKYIELD;
+    case EXEC_OMP_TEAMS:
+      return ST_OMP_TEAMS;
+    case EXEC_OMP_TEAMS_DISTRIBUTE:
+      return ST_OMP_TEAMS_DISTRIBUTE;
+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO:
+      return ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO;
+    case EXEC_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD:
+      return ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD;
+    case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:
+      return ST_OMP_TEAMS_DISTRIBUTE_SIMD;
+    case EXEC_OMP_PARALLEL_DO:
+      return ST_OMP_PARALLEL_DO;
+    case EXEC_OMP_PARALLEL_DO_SIMD:
+      return ST_OMP_PARALLEL_DO_SIMD;
+
     default:
       gcc_unreachable ();
     }
@@ -5783,6 +5858,20 @@ oacc_code_to_statement (gfc_code *code)
       return ST_OACC_LOOP;
     case EXEC_OACC_ATOMIC:
       return ST_OACC_ATOMIC;
+    case EXEC_OACC_ROUTINE:
+      return ST_OACC_ROUTINE;
+    case EXEC_OACC_UPDATE:
+      return ST_OACC_UPDATE;
+    case EXEC_OACC_WAIT:
+      return ST_OACC_WAIT;
+    case EXEC_OACC_CACHE:
+      return ST_OACC_CACHE;
+    case EXEC_OACC_ENTER_DATA:
+      return ST_OACC_ENTER_DATA;
+    case EXEC_OACC_EXIT_DATA:
+      return ST_OACC_EXIT_DATA;
+    case EXEC_OACC_DECLARE:
+      return ST_OACC_DECLARE;
     default:
       gcc_unreachable ();
     }
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 66d84b4118f..9e662a66126 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -1079,12 +1079,20 @@ decode_gcc_attribute (void)
   match ("attributes", gfc_match_gcc_attributes, ST_ATTR_DECL);
   match ("unroll", gfc_match_gcc_unroll, ST_NONE);
   match ("builtin", gfc_match_gcc_builtin, ST_NONE);
+  match ("ivdep", gfc_match_gcc_ivdep, ST_NONE);
+  match ("vector", gfc_match_gcc_vector, ST_NONE);
+  match ("novector", gfc_match_gcc_novector, ST_NONE);
 
   /* All else has failed, so give up.  See if any of the matchers has
      stored an error message of some sort.  */
 
   if (!gfc_error_check ())
-    gfc_error_now ("Unclassifiable GCC directive at %C");
+    {
+      if (pedantic)
+	gfc_error_now ("Unclassifiable GCC directive at %C");
+      else
+	gfc_warning_now (0, "Unclassifiable GCC directive at %C, ignored");
+    }
 
   reject_statement ();
 
@@ -4672,6 +4680,21 @@ parse_do_block (void)
 	  new_st.ext.iterator->unroll = directive_unroll;
 	  directive_unroll = -1;
 	}
+      if (directive_ivdep)
+	{
+	  new_st.ext.iterator->ivdep = directive_ivdep;
+	  directive_ivdep = false;
+	}
+      if (directive_vector)
+	{
+	  new_st.ext.iterator->vector = directive_vector;
+	  directive_vector = false;
+	}
+      if (directive_novector)
+	{
+	  new_st.ext.iterator->novector = directive_novector;
+	  directive_novector = false;
+	}
     }
   else
     stree = NULL;
@@ -5080,6 +5103,9 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)
     case ST_OMP_TARGET_DATA:
       omp_end_st = ST_OMP_END_TARGET_DATA;
       break;
+    case ST_OMP_TARGET_PARALLEL:
+      omp_end_st = ST_OMP_END_TARGET_PARALLEL;
+      break;
     case ST_OMP_TARGET_TEAMS:
       omp_end_st = ST_OMP_END_TARGET_TEAMS;
       break;
@@ -5431,7 +5457,17 @@ parse_executable (gfc_statement st)
 	}
 
       if (directive_unroll != -1)
-	gfc_error ("%<GCC unroll%> directive does not commence a loop at %C");
+	gfc_error ("%<GCC unroll%> directive not at the start of a loop at %C");
+
+      if (directive_ivdep)
+	gfc_error ("%<GCC ivdep%> directive not at the start of a loop at %C");
+
+      if (directive_vector)
+	gfc_error ("%<GCC vector%> directive not at the start of a loop at %C");
+
+      if (directive_novector)
+	gfc_error ("%<GCC novector%> "
+		   "directive not at the start of a loop at %C");
 
       st = next_statement ();
     }
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index e918372ef85..ff93698f478 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -1990,6 +1990,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
   match m;
   bool unknown;
   bool inquiry;
+  bool intrinsic;
   locus old_loc;
   char sep;
 
@@ -2194,11 +2195,35 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
       if (m != MATCH_YES)
 	return MATCH_ERROR;
 
+      intrinsic = false;
       if (primary->ts.type != BT_CLASS && primary->ts.type != BT_DERIVED)
 	{
 	  inquiry = is_inquiry_ref (name, &tmp);
 	  if (inquiry)
 	    sym = NULL;
+
+	  if (sep == '%')
+	    {
+	      if (tmp)
+		{
+		  if ((tmp->u.i == INQUIRY_RE || tmp->u.i == INQUIRY_IM)
+		      && primary->ts.type != BT_COMPLEX)
+		    {
+			gfc_error ("The RE or IM part_ref at %C must be "
+				   "applied to a COMPLEX expression");
+			return MATCH_ERROR;
+		    }
+		  else if (tmp->u.i == INQUIRY_LEN
+			   && primary->ts.type != BT_CHARACTER)
+		    {
+			gfc_error ("The LEN part_ref at %C must be applied "
+				   "to a CHARACTER expression");
+			return MATCH_ERROR;
+		    }
+		}
+	      if (primary->ts.type != BT_UNKNOWN)
+		intrinsic = true;
+	    }
 	}
       else
 	inquiry = false;
@@ -2258,12 +2283,16 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	  break;
 	}
 
-      if (!inquiry)
+      if (!inquiry && !intrinsic)
 	component = gfc_find_component (sym, name, false, false, &tmp);
       else
 	component = NULL;
 
-      if (component == NULL && !inquiry)
+      /* In some cases, returning MATCH_NO gives a better error message. Most
+	 cases return "Unclassifiable statement at..."  */
+      if (intrinsic && !inquiry)
+	return MATCH_NO;
+      else if (component == NULL && !inquiry)
 	return MATCH_ERROR;
 
       /* Extend the reference chain determined by gfc_find_component or
@@ -2284,6 +2313,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 
       if (tmp && tmp->type == REF_INQUIRY)
 	{
+	  if (!primary->where.lb || !primary->where.nextc)
+	    primary->where = gfc_current_locus;
 	  gfc_simplify_expr (primary, 0);
 
 	  if (primary->expr_type == EXPR_CONSTANT)
@@ -2559,12 +2590,10 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)
 	    break;
 
 	  case AR_UNKNOWN:
-	    /* If any of start, end or stride is not integer, there will
-	       already have been an error issued.  */
-	    int errors;
-	    gfc_get_errors (NULL, &errors);
-	    if (errors == 0)
-	      gfc_internal_error ("gfc_variable_attr(): Bad array reference");
+	    /* For standard conforming code, AR_UNKNOWN should not happen.
+	       For nonconforming code, gfortran can end up here.  Treat it 
+	       as a no-op.  */
+	    break;
 	  }
 
 	break;
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index afa4e5c2ccf..a4ad26efffc 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1866,7 +1866,7 @@ resolve_procedure_expression (gfc_expr* expr)
 
 
 /* Check that name is not a derived type.  */
- 
+
 static bool
 is_dt_name (const char *name)
 {
@@ -7059,19 +7059,6 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)
 				  "Step expression in DO loop"))
     return false;
 
-  if (iter->step->expr_type == EXPR_CONSTANT)
-    {
-      if ((iter->step->ts.type == BT_INTEGER
-	   && mpz_cmp_ui (iter->step->value.integer, 0) == 0)
-	  || (iter->step->ts.type == BT_REAL
-	      && mpfr_sgn (iter->step->value.real) == 0))
-	{
-	  gfc_error ("Step expression in DO loop at %L cannot be zero",
-		     &iter->step->where);
-	  return false;
-	}
-    }
-
   /* Convert start, end, and step to the same type as var.  */
   if (iter->start->ts.kind != iter->var->ts.kind
       || iter->start->ts.type != iter->var->ts.type)
@@ -7085,6 +7072,19 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)
       || iter->step->ts.type != iter->var->ts.type)
     gfc_convert_type (iter->step, &iter->var->ts, 1);
 
+  if (iter->step->expr_type == EXPR_CONSTANT)
+    {
+      if ((iter->step->ts.type == BT_INTEGER
+	   && mpz_cmp_ui (iter->step->value.integer, 0) == 0)
+	  || (iter->step->ts.type == BT_REAL
+	      && mpfr_sgn (iter->step->value.real) == 0))
+	{
+	  gfc_error ("Step expression in DO loop at %L cannot be zero",
+		     &iter->step->where);
+	  return false;
+	}
+    }
+
   if (iter->start->expr_type == EXPR_CONSTANT
       && iter->end->expr_type == EXPR_CONSTANT
       && iter->step->expr_type == EXPR_CONSTANT)
@@ -7439,7 +7439,7 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)
   for (tail = e2->ref; tail && tail->next; tail = tail->next);
 
   /* First compare rank.  */
-  if ((tail && e1->rank != tail->u.ar.as->rank)
+  if ((tail && (!tail->u.ar.as || e1->rank != tail->u.ar.as->rank))
       || (!tail && e1->rank != e2->rank))
     {
       gfc_error ("Source-expr at %L must be scalar or have the "
@@ -13539,14 +13539,34 @@ resolve_typebound_procedure (gfc_symtree* stree)
     }
   else
     {
+      /* If proc has not been resolved at this point, proc->name may
+	 actually be a USE associated entity. See PR fortran/89647. */
+      if (!proc->resolved
+	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
+	{
+	  gfc_symbol *tmp;
+	  gfc_find_symbol (proc->name, gfc_current_ns->parent, 1, &tmp);
+	  if (tmp && tmp->attr.use_assoc)
+	    {
+	      proc->module = tmp->module;
+	      proc->attr.proc = tmp->attr.proc;
+	      proc->attr.function = tmp->attr.function;
+	      proc->attr.subroutine = tmp->attr.subroutine;
+	      proc->attr.use_assoc = tmp->attr.use_assoc;
+	      proc->ts = tmp->ts;
+	      proc->result = tmp->result;
+	    }
+	}
+
       /* Check for F08:C465.  */
       if ((!proc->attr.subroutine && !proc->attr.function)
 	  || (proc->attr.proc != PROC_MODULE
 	      && proc->attr.if_source != IFSRC_IFBODY)
 	  || proc->attr.abstract)
 	{
-	  gfc_error ("%qs must be a module procedure or an external procedure with"
-		    " an explicit interface at %L", proc->name, &where);
+	  gfc_error ("%qs must be a module procedure or an external "
+		     "procedure with an explicit interface at %L",
+		     proc->name, &where);
 	  goto error;
 	}
     }
@@ -15662,8 +15682,6 @@ check_data_variable (gfc_data_variable *var, locus *where)
       return false;
     }
 
-  has_pointer = sym->attr.pointer;
-
   if (gfc_is_coindexed (e))
     {
       gfc_error ("DATA element %qs at %L cannot have a coindex", sym->name,
@@ -15671,19 +15689,30 @@ check_data_variable (gfc_data_variable *var, locus *where)
       return false;
     }
 
+  has_pointer = sym->attr.pointer;
+
   for (ref = e->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
 	has_pointer = 1;
 
-      if (has_pointer
-	    && ref->type == REF_ARRAY
-	    && ref->u.ar.type != AR_FULL)
-	  {
-	    gfc_error ("DATA element %qs at %L is a pointer and so must "
-			"be a full array", sym->name, where);
-	    return false;
-	  }
+      if (has_pointer)
+	{
+	  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_FULL)
+	    {
+	      gfc_error ("DATA element %qs at %L is a pointer and so must "
+			 "be a full array", sym->name, where);
+	      return false;
+	    }
+
+	  if (values.vnode->expr->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("DATA object near %L has the pointer attribute "
+			 "and the corresponding DATA value is not a valid "
+			 "initial-data-target", where);
+	      return false;
+	    }
+	}
     }
 
   if (e->rank == 0 || has_pointer)
@@ -16525,8 +16554,8 @@ resolve_equivalence (gfc_equiv *eq)
 }
 
 
-/* Function called by resolve_fntype to flag other symbol used in the
-   length type parameter specification of function resuls.  */
+/* Function called by resolve_fntype to flag other symbols used in the
+   length type parameter specification of function results.  */
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
@@ -16740,6 +16769,7 @@ resolve_types (gfc_namespace *ns)
   gfc_data *d;
   gfc_equiv *eq;
   gfc_namespace* old_ns = gfc_current_ns;
+  bool recursive = ns->proc_name && ns->proc_name->attr.recursive;
 
   if (ns->types_resolved)
     return;
@@ -16793,7 +16823,7 @@ resolve_types (gfc_namespace *ns)
 
   gfc_traverse_ns (ns, resolve_values);
 
-  if (ns->save_all || !flag_automatic)
+  if (ns->save_all || (!flag_automatic && !recursive))
     gfc_save_all (ns);
 
   iter_stack = NULL;
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index e54d483baff..40c06b6b674 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -1050,6 +1050,10 @@ skip_fixed_comments (void)
 	      return;
 	    }
 
+	  if (gfc_current_locus.lb != NULL
+	      && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
+	    continue_line = gfc_linebuf_linenum (gfc_current_locus.lb);
+
 	  /* If -fopenmp/-fopenacc, we need to handle here 2 things:
 	     1) don't treat !$omp/!$acc|c$omp/c$acc|*$omp / *$acc as comments, 
 		but directives
@@ -1057,10 +1061,6 @@ skip_fixed_comments (void)
 		!$|c$|*$ should be treated as 2 spaces if the characters
 		in columns 3 to 6 are valid fixed form label columns
 		characters.  */
-	  if (gfc_current_locus.lb != NULL
-	      && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
-	    continue_line = gfc_linebuf_linenum (gfc_current_locus.lb);
-
 	  if ((flag_openmp || flag_openmp_simd) && !flag_openacc)
 	    {
 	      if (next_char () == '$')
@@ -1313,6 +1313,14 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* This can happen if the input file changed or via cpp's #line
+	 without getting reset (e.g. via input_stmt). It also happens
+	 when pre-including files via -fpre-include=.  */
+      if (continue_count == 0
+	  && gfc_current_locus.lb
+	  && continue_line > gfc_linebuf_linenum (gfc_current_locus.lb) + 1)
+	continue_line = gfc_linebuf_linenum (gfc_current_locus.lb) + 1;
+
       continue_flag = 1;
       if (c == '!')
 	skip_comment_line ();
@@ -1475,6 +1483,14 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* This can happen if the input file changed or via cpp's #line
+	 without getting reset (e.g. via input_stmt). It also happens
+	 when pre-including files via -fpre-include=.  */
+      if (continue_count == 0
+	  && gfc_current_locus.lb
+	  && continue_line > gfc_linebuf_linenum (gfc_current_locus.lb) + 1)
+	continue_line = gfc_linebuf_linenum (gfc_current_locus.lb) + 1;
+
       continue_flag = 1;
       old_loc = gfc_current_locus;
 
@@ -1943,7 +1959,7 @@ next_char:
    the file stack.  */
 
 static gfc_file *
-get_file (const char *name, enum lc_reason reason ATTRIBUTE_UNUSED)
+get_file (const char *name, enum lc_reason reason)
 {
   gfc_file *f;
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 6c1f4bd4fce..2b4581e1236 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -169,8 +169,10 @@ convert_mpz_to_unsigned (mpz_t x, int bitsize)
     }
   else
     {
-      /* Confirm that no bits above the signed range are set.  */
-      gcc_assert (mpz_scan1 (x, bitsize-1) == ULONG_MAX);
+      /* Confirm that no bits above the signed range are set if we
+	 are doing range checking.  */
+      if (flag_range_check != 0)
+	gcc_assert (mpz_scan1 (x, bitsize-1) == ULONG_MAX);
     }
 }
 
@@ -4808,8 +4810,12 @@ gfc_simplify_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)
   gfc_constructor *tsource_ctor, *fsource_ctor, *mask_ctor;
 
   if (mask->expr_type == EXPR_CONSTANT)
-    return gfc_get_parentheses (gfc_copy_expr (mask->value.logical
-					       ? tsource : fsource));
+    {
+      result = gfc_copy_expr (mask->value.logical ? tsource : fsource);
+      result = gfc_get_parentheses (result);
+      gfc_simplify_expr (result, 1);
+      return result;
+    }
 
   if (!mask->rank || !is_constant_array_expr (mask)
       || !is_constant_array_expr (tsource) || !is_constant_array_expr (fsource))
@@ -5533,7 +5539,7 @@ simplify_findloc_nodim (gfc_expr *result, gfc_expr *value, gfc_expr *array,
   bool continue_loop;
   bool ma;
 
-  for (i = 0; i<array->rank; i++)
+  for (i = 0; i < array->rank; i++)
     res[i] = -1;
 
   /* Shortcut for constant .FALSE. MASK.  */
@@ -5576,7 +5582,7 @@ simplify_findloc_nodim (gfc_expr *result, gfc_expr *value, gfc_expr *array,
 
 	  if (ma && gfc_compare_expr (a, value, INTRINSIC_EQ) == 0)
 	    {
-	      for (i = 0; i<array->rank; i++)
+	      for (i = 0; i < array->rank; i++)
 		res[i] = count[i];
 	      if (!back_val)
 		goto finish;
@@ -5601,9 +5607,9 @@ simplify_findloc_nodim (gfc_expr *result, gfc_expr *value, gfc_expr *array,
 	} while (count[n] == extent[n]);
     }
 
- finish:
+finish:
   result_ctor = gfc_constructor_first (result->value.constructor);
-  for (i = 0; i<array->rank; i++)
+  for (i = 0; i < array->rank; i++)
     {
       gfc_expr *r_expr;
       r_expr = result_ctor->expr;
@@ -6684,6 +6690,9 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
   mpz_init (index);
   rank = 0;
 
+  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)
+    x[i] = 0;
+
   for (;;)
     {
       e = gfc_constructor_lookup_expr (shape_exp->value.constructor, rank);
@@ -6708,8 +6717,28 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
     }
   else
     {
-      for (i = 0; i < rank; i++)
-	x[i] = 0;
+      mpz_t size;
+      int order_size, shape_size;
+
+      if (order_exp->rank != shape_exp->rank)
+	{
+	  gfc_error ("Shapes of ORDER at %L and SHAPE at %L are different",
+		     &order_exp->where, &shape_exp->where);
+	  return &gfc_bad_expr;
+	}
+
+      gfc_array_size (shape_exp, &size);
+      shape_size = mpz_get_ui (size);
+      mpz_clear (size);
+      gfc_array_size (order_exp, &size);
+      order_size = mpz_get_ui (size);
+      mpz_clear (size);
+      if (order_size != shape_size)
+	{
+	  gfc_error ("Sizes of ORDER at %L and SHAPE at %L are different",
+		     &order_exp->where, &shape_exp->where);
+	  return &gfc_bad_expr;
+	}
 
       for (i = 0; i < rank; i++)
 	{
@@ -6718,9 +6747,22 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
 
 	  gfc_extract_int (e, &order[i]);
 
-	  gcc_assert (order[i] >= 1 && order[i] <= rank);
+	  if (order[i] < 1 || order[i] > rank)
+	    {
+	      gfc_error ("Element with a value of %d in ORDER at %L must be "
+			 "in the range [1, ..., %d] for the RESHAPE intrinsic "
+			 "near %L", order[i], &order_exp->where, rank,
+			 &shape_exp->where);
+	      return &gfc_bad_expr;
+	    }
+
 	  order[i]--;
-	  gcc_assert (x[order[i]] == 0);
+	  if (x[order[i]] != 0)
+	    {
+	      gfc_error ("ORDER at %L is not a permutation of the size of "
+			 "SHAPE at %L", &order_exp->where, &shape_exp->where);
+	      return &gfc_bad_expr;
+	    }
 	  x[order[i]] = 1;
 	}
     }
@@ -7213,6 +7255,8 @@ gfc_simplify_shape (gfc_expr *source, gfc_expr *kind)
     return NULL;
 
   result = gfc_get_array_expr (BT_INTEGER, k, &source->where);
+  result->shape = gfc_get_shape (1);
+  mpz_init (result->shape[0]);
 
   if (source->rank == 0)
     return result;
@@ -7269,6 +7313,8 @@ gfc_simplify_shape (gfc_expr *source, gfc_expr *kind)
   if (t)
     gfc_clear_shape (shape, source->rank);
 
+  mpz_set_si (result->shape[0], source->rank);
+
   return result;
 }
 
@@ -7630,7 +7676,7 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp
   nelem = mpz_get_si (size) * ncopies;
   if (nelem > flag_max_array_constructor)
     {
-      if (gfc_current_ns->sym_root->n.sym->attr.flavor == FL_PARAMETER)
+      if (gfc_init_expr_flag)
 	{
 	  gfc_error ("The number of elements (%d) in the array constructor "
 		     "at %L requires an increase of the allowed %d upper "
@@ -8494,6 +8540,12 @@ gfc_convert_constant (gfc_expr *e, bt type, int kind)
 	    {
 	      if (c->expr->expr_type == EXPR_ARRAY)
 		tmp = gfc_convert_constant (c->expr, type, kind);
+	      else if (c->expr->expr_type == EXPR_OP
+			&& c->expr->value.op.op == INTRINSIC_PARENTHESES)
+		{
+		  gfc_simplify_expr (c->expr, 1);
+		  tmp = f (c->expr, kind);
+		}
 	      else
 		tmp = f (c->expr, kind);
 	    }
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 2b8f86e0881..faaeebf2c09 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -2899,9 +2899,6 @@ gfc_get_namespace (gfc_namespace *parent, int parent_types)
 	}
     }
 
-  if (parent_types && ns->parent != NULL)
-    ns->has_implicit_none_export = ns->parent->has_implicit_none_export;
-
   ns->refs = 1;
 
   return ns;
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 583425c516d..2e5eb4f468f 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -537,9 +537,10 @@ gfc_conv_shift_descriptor_lbound (stmtblock_t* block, tree desc,
 
 void
 gfc_get_descriptor_offsets_for_info (const_tree desc_type, tree *data_off,
-				     tree *dtype_off, tree *dim_off,
-				     tree *dim_size, tree *stride_suboff,
-				     tree *lower_suboff, tree *upper_suboff)
+				     tree *dtype_off, tree *span_off,
+				     tree *dim_off, tree *dim_size,
+				     tree *stride_suboff, tree *lower_suboff,
+				     tree *upper_suboff)
 {
   tree field;
   tree type;
@@ -549,6 +550,8 @@ gfc_get_descriptor_offsets_for_info (const_tree desc_type, tree *data_off,
   *data_off = byte_position (field);
   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);
   *dtype_off = byte_position (field);
+  field = gfc_advance_chain (TYPE_FIELDS (type), SPAN_FIELD);
+  *span_off = byte_position (field);
   field = gfc_advance_chain (TYPE_FIELDS (type), DIMENSION_FIELD);
   *dim_off = byte_position (field);
   type = TREE_TYPE (TREE_TYPE (field));
@@ -6110,17 +6113,20 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)
 		  tree atype = type;
 		  while (TREE_CODE (TREE_TYPE (atype)) == ARRAY_TYPE)
 		    atype = TREE_TYPE (atype);
-		  if (TREE_CODE (TREE_TYPE (atype)) == INTEGER_TYPE
-		      && tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (se.expr)))
-			 > tree_to_uhwi (TYPE_SIZE_UNIT (atype)))
+		  gcc_checking_assert (TREE_CODE (TREE_TYPE (atype))
+				       == INTEGER_TYPE);
+		  gcc_checking_assert (TREE_TYPE (TREE_TYPE (se.expr))
+				       == TREE_TYPE (atype));
+		  if (tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (se.expr)))
+		      > tree_to_uhwi (TYPE_SIZE_UNIT (atype)))
 		    {
 		      unsigned HOST_WIDE_INT size
 			= tree_to_uhwi (TYPE_SIZE_UNIT (atype));
 		      const char *p = TREE_STRING_POINTER (se.expr);
 
 		      se.expr = build_string (size, p);
-		      TREE_TYPE (se.expr) = atype;
 		    }
+		  TREE_TYPE (se.expr) = atype;
 		}
 	      break;
 
@@ -8024,7 +8030,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,
 	  /* The components shall be deallocated before their containing entity.  */
 	  gfc_prepend_expr_to_block (&se->post, tmp);
 	}
-      if (expr->ts.type == BT_CHARACTER)
+      if (expr->ts.type == BT_CHARACTER && expr->expr_type != EXPR_FUNCTION)
 	se->string_length = expr->ts.u.cl->backend_decl;
       if (size)
 	array_parameter_size (se->expr, expr, size);
diff --git a/gcc/fortran/trans-array.h b/gcc/fortran/trans-array.h
index 8c2d51838d4..aadb685b8b1 100644
--- a/gcc/fortran/trans-array.h
+++ b/gcc/fortran/trans-array.h
@@ -161,7 +161,7 @@ void gfc_trans_array_cobounds (tree, stmtblock_t *, const gfc_symbol *);
 
 /* Build expressions for accessing components of an array descriptor.  */
 void gfc_get_descriptor_offsets_for_info (const_tree, tree *, tree *, tree *, tree *,
-					  tree *, tree *, tree *);
+					  tree *, tree *, tree *, tree *);
 
 tree gfc_conv_descriptor_data_get (tree);
 tree gfc_conv_descriptor_data_addr (tree);
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 9538dee5733..71f751de76f 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -369,44 +369,37 @@ gfc_sym_identifier (gfc_symbol * sym)
 static const char *
 mangled_identifier (gfc_symbol *sym)
 {
-  static char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
+  gfc_symbol *proc = sym->ns->proc_name;
+  static char name[3*GFC_MAX_MANGLED_SYMBOL_LEN + 14];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
 
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
     return sym->binding_label;
 
-  if (!sym->fn_result_spec)
+  if (!sym->fn_result_spec
+      || (sym->module && !(proc && proc->attr.flavor == FL_PROCEDURE)))
     {
       if (sym->module == NULL)
 	return sym_identifier (sym);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return name;
-	}
+	snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
     }
   else
     {
       /* This is an entity that is actually local to a module procedure
 	 that appears in the result specification expression.  Since
 	 sym->module will be a zero length string, we use ns->proc_name
-	 instead. */
-      if (sym->ns->proc_name && sym->ns->proc_name->module)
-	{
-	  snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
-		    sym->ns->proc_name->module,
-		    sym->ns->proc_name->name,
-		    sym->name);
-	  return name;
-	}
+	 to provide the module name instead. */
+      if (proc && proc->module)
+	snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
+		  proc->module, proc->name, sym->name);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_PROC_%s",
-		    sym->ns->proc_name->name, sym->name);
-	  return name;
-	}
+	snprintf (name, sizeof name, "__%s_PROC_%s",
+		  proc->name, sym->name);
     }
+
+  return name;
 }
 
 /* Get mangled identifier, adding the symbol to the global table if
@@ -1618,15 +1611,18 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 	      /* Add the string length to the same context as the symbol.  */
 	      if (DECL_CONTEXT (length) == NULL_TREE)
 		{
-		  if (DECL_CONTEXT (sym->backend_decl)
-		      == current_function_decl)
+		  if (sym->backend_decl == current_function_decl
+		      || (DECL_CONTEXT (sym->backend_decl)
+			  == current_function_decl))
 		    gfc_add_decl_to_function (length);
 		  else
 		    gfc_add_decl_to_parent_function (length);
 		}
 
-	      gcc_assert (DECL_CONTEXT (sym->backend_decl)
-			  == DECL_CONTEXT (length));
+	      gcc_assert (sym->backend_decl == current_function_decl
+			  ? DECL_CONTEXT (length) == current_function_decl
+			  : (DECL_CONTEXT (sym->backend_decl)
+			     == DECL_CONTEXT (length)));
 
 	      gfc_defer_symbol_init (sym);
 	    }
@@ -1892,9 +1888,18 @@ gfc_get_symbol_decl (gfc_symbol * sym)
   if (sym->attr.associate_var)
     GFC_DECL_ASSOCIATE_VAR_P (decl) = 1;
 
-  if (sym->attr.vtab
-      || (sym->name[0] == '_' && gfc_str_startswith (sym->name, "__def_init")))
-    TREE_READONLY (decl) = 1;
+  /* We only mark __def_init as read-only if it actually has an
+     initializer so it does not needlessly take up space in the
+     read-only section and can go into the BSS instead, see PR 84487.
+     Marking this as artificial means that OpenMP will treat this as
+     predetermined shared.  */
+
+  if (sym->attr.vtab || gfc_str_startswith (sym->name, "__def_init"))
+    {
+      DECL_ARTIFICIAL (decl) = 1;
+      if (sym->attr.vtab || sym->value)
+	TREE_READONLY (decl) = 1;
+    }
 
   return decl;
 }
@@ -5862,9 +5867,11 @@ generate_local_decl (gfc_symbol * sym)
 	    }
 	  else if (warn_unused_dummy_argument)
 	    {
-	      gfc_warning (OPT_Wunused_dummy_argument,
-			   "Unused dummy argument %qs at %L", sym->name,
-			   &sym->declared_at);
+	      if (!sym->attr.artificial)
+		gfc_warning (OPT_Wunused_dummy_argument,
+			     "Unused dummy argument %qs at %L", sym->name,
+			     &sym->declared_at);
+
 	      if (sym->backend_decl != NULL_TREE)
 		TREE_NO_WARNING(sym->backend_decl) = 1;
 	    }
@@ -5956,7 +5963,14 @@ generate_local_decl (gfc_symbol * sym)
 
       if (sym->ns && sym->ns->construct_entities)
 	{
-	  if (sym->attr.referenced)
+	  /* Construction of the intrinsic modules within a BLOCK
+	     construct, where ONLY and RENAMED entities are included,
+	     seems to be bogus.  This is a workaround that can be removed
+	     if someone ever takes on the task to creating full-fledge
+	     modules.  See PR 69455.  */
+	  if (sym->attr.referenced
+	      && sym->from_intmod != INTMOD_ISO_C_BINDING
+	      && sym->from_intmod != INTMOD_ISO_FORTRAN_ENV)
 	    gfc_get_symbol_decl (sym);
 	  sym->mark = 1;
 	}
@@ -6440,6 +6454,20 @@ gfc_generate_return (void)
 				    TREE_TYPE (result), DECL_RESULT (fndecl),
 				    result);
 	}
+      else
+	{
+	  /* If the function does not have a result variable, result is
+	     NULL_TREE, and a 'return' is generated without a variable.
+	     The following generates a 'return __result_XXX' where XXX is
+	     the function name.  */
+	  if (sym == sym->result && sym->attr.function)
+	    {
+	      result = gfc_get_fake_result_decl (sym, 0);
+	      result = fold_build2_loc (input_location, MODIFY_EXPR,
+					TREE_TYPE (result),
+					DECL_RESULT (fndecl), result);
+	    }
+	}
     }
 
   return build1_v (RETURN_EXPR, result);
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index afe08fc2668..fe10d52dd16 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -4989,21 +4989,30 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
   tree gfc_desc_ptr;
   tree type;
   tree cond;
+  tree desc_attr;
   int attribute;
+  int cfi_attribute;
   symbol_attribute attr = gfc_expr_attr (e);
-  stmtblock_t block;
 
   /* If this is a full array or a scalar, the allocatable and pointer
      attributes can be passed. Otherwise it is 'CFI_attribute_other'*/
   attribute = 2;
   if (!e->rank || gfc_get_full_arrayspec_from_expr (e))
     {
-      if (fsym->attr.pointer)
+      if (attr.pointer)
 	attribute = 0;
-      else if (fsym->attr.allocatable)
+      else if (attr.allocatable)
 	attribute = 1;
     }
 
+  /* If the formal argument is assumed shape and neither a pointer nor
+     allocatable, it is unconditionally CFI_attribute_other.  */
+  if (fsym->as->type == AS_ASSUMED_SHAPE
+      && !fsym->attr.pointer && !fsym->attr.allocatable)
+   cfi_attribute = 2;
+  else
+   cfi_attribute = attribute;
+
   if (e->rank != 0)
     {
       parmse->force_no_tmp = 1;
@@ -5018,6 +5027,10 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 	parmse->expr = build_fold_indirect_ref_loc (input_location,
 						    parmse->expr);
 
+      bool is_artificial = (INDIRECT_REF_P (parmse->expr)
+			    ? DECL_ARTIFICIAL (TREE_OPERAND (parmse->expr, 0))
+			    : DECL_ARTIFICIAL (parmse->expr));
+
       /* Unallocated allocatable arrays and unassociated pointer arrays
 	 need their dtype setting if they are argument associated with
 	 assumed rank dummies.  */
@@ -5036,7 +5049,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
       type = e->ts.type != BT_ASSUMED ? gfc_typenode_for_spec (&e->ts) :
 					NULL_TREE;
 
-      if (type && DECL_ARTIFICIAL (parmse->expr)
+      if (type && is_artificial
 	  && type != gfc_get_element_type (TREE_TYPE (parmse->expr)))
 	{
 	  /* Obtain the offset to the data.  */
@@ -5048,8 +5061,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 			  gfc_conv_descriptor_dtype (parmse->expr),
 			  gfc_get_dtype_rank_type (e->rank, type));
 	}
-      else if (type == NULL_TREE
-	       || (!is_subref_array (e) && !DECL_ARTIFICIAL (parmse->expr)))
+      else if (type == NULL_TREE || (!is_subref_array (e) && !is_artificial))
 	{
 	  /* Make sure that the span is set for expressions where it
 	     might not have been done already.  */
@@ -5070,41 +5082,40 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 						    parmse->expr, attr);
     }
 
-  /* Set the CFI attribute field.  */
-  tmp = gfc_conv_descriptor_attribute (parmse->expr);
+  /* Set the CFI attribute field through a temporary value for the
+     gfc attribute.  */
+  desc_attr = gfc_conv_descriptor_attribute (parmse->expr);
   tmp = fold_build2_loc (input_location, MODIFY_EXPR,
-			 void_type_node, tmp,
-			 build_int_cst (TREE_TYPE (tmp), attribute));
+			 void_type_node, desc_attr,
+			 build_int_cst (TREE_TYPE (desc_attr), cfi_attribute));
   gfc_add_expr_to_block (&parmse->pre, tmp);
 
   /* Now pass the gfc_descriptor by reference.  */
   parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);
 
-  /* Variables to point to the gfc and CFI descriptors.  */
+  /* Variables to point to the gfc and CFI descriptors; cfi = NULL implies
+     that the CFI descriptor is allocated by the gfor_fndecl_gfc_to_cfi call.  */
   gfc_desc_ptr = parmse->expr;
   cfi_desc_ptr = gfc_create_var (pvoid_type_node, "cfi");
-  gfc_add_modify (&parmse->pre, cfi_desc_ptr,
-		  build_int_cst (pvoid_type_node, 0));
+  gfc_add_modify (&parmse->pre, cfi_desc_ptr, null_pointer_node);
 
-  /* Allocate the CFI descriptor and fill the fields.  */
+  /* Allocate the CFI descriptor itself and fill the fields.  */
   tmp = gfc_build_addr_expr (NULL_TREE, cfi_desc_ptr);
   tmp = build_call_expr_loc (input_location,
 			     gfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);
   gfc_add_expr_to_block (&parmse->pre, tmp);
 
+  /* Now set the gfc descriptor attribute.  */
+  tmp = fold_build2_loc (input_location, MODIFY_EXPR,
+			 void_type_node, desc_attr,
+			 build_int_cst (TREE_TYPE (desc_attr), attribute));
+  gfc_add_expr_to_block (&parmse->pre, tmp);
+
   /* The CFI descriptor is passed to the bind_C procedure.  */
   parmse->expr = cfi_desc_ptr;
 
   /* Free the CFI descriptor.  */
-  gfc_init_block (&block);
-  cond = fold_build2_loc (input_location, NE_EXPR,
-			  logical_type_node, cfi_desc_ptr,
-			  build_int_cst (TREE_TYPE (cfi_desc_ptr), 0));
   tmp = gfc_call_free (cfi_desc_ptr);
-  gfc_add_expr_to_block (&block, tmp);
-  tmp = build3_v (COND_EXPR, cond,
-		  gfc_finish_block (&block),
-		  build_empty_stmt (input_location));
   gfc_prepend_expr_to_block (&parmse->post, tmp);
 
   /* Transfer values back to gfc descriptor.  */
@@ -5112,6 +5123,25 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
   tmp = build_call_expr_loc (input_location,
 			     gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);
   gfc_prepend_expr_to_block (&parmse->post, tmp);
+
+  /* Deal with an optional dummy being passed to an optional formal arg
+     by finishing the pre and post blocks and making their execution
+     conditional on the dummy being present.  */
+  if (fsym->attr.optional && e->expr_type == EXPR_VARIABLE
+      && e->symtree->n.sym->attr.optional)
+    {
+      cond = gfc_conv_expr_present (e->symtree->n.sym);
+      tmp = fold_build2 (MODIFY_EXPR, void_type_node,
+			 cfi_desc_ptr,
+			 build_int_cst (pvoid_type_node, 0));
+      tmp = build3_v (COND_EXPR, cond,
+		      gfc_finish_block (&parmse->pre), tmp);
+      gfc_add_expr_to_block (&parmse->pre, tmp);
+      tmp = build3_v (COND_EXPR, cond,
+		      gfc_finish_block (&parmse->post),
+		      build_empty_stmt (input_location));
+      gfc_add_expr_to_block (&parmse->post, tmp);
+    }
 }
 
 
@@ -6001,8 +6031,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		  }
 
-		  tmp = build_fold_indirect_ref_loc (input_location,
-						     parmse.expr);
+		  tmp = parmse.expr;
+		  /* With bind(C), the actual argument is replaced by a bind-C
+		     descriptor; in this case, the data component arrives here,
+		     which shall not be dereferenced, but still freed and
+		     nullified.  */
+		  if  (TREE_TYPE(tmp) != pvoid_type_node)
+		    tmp = build_fold_indirect_ref_loc (input_location,
+						       parmse.expr);
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
 		    tmp = gfc_conv_descriptor_data_get (tmp);
 		  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,
@@ -6782,8 +6818,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	gfc_allocate_lang_decl (result);
       GFC_DECL_SAVED_DESCRIPTOR (result) = parmse.expr;
       gfc_free_expr (class_expr);
-      gcc_assert (parmse.pre.head == NULL_TREE
-		  && parmse.post.head == NULL_TREE);
+      /* -fcheck= can add diagnostic code, which has to be placed before
+	 the call. */
+      if (parmse.pre.head != NULL)
+	  gfc_add_expr_to_block (&se->pre, parmse.pre.head);
+      gcc_assert (parmse.post.head == NULL_TREE);
     }
 
   /* Follow the function call with the argument post block.  */
@@ -10603,7 +10642,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
       if (expr1->ts.deferred
 	  && gfc_expr_attr (expr1).allocatable
 	  && gfc_check_dependency (expr1, expr2, true))
-	rse.string_length = gfc_evaluate_now (rse.string_length, &rse.pre);
+	rse.string_length =
+	  gfc_evaluate_now_function_scope (rse.string_length, &rse.pre);
       string_length = rse.string_length;
     }
   else
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
index 0eb5956cc53..52a2cc8a4da 100644
--- a/gcc/fortran/trans-openmp.c
+++ b/gcc/fortran/trans-openmp.c
@@ -3215,7 +3215,6 @@ gfc_trans_omp_atomic (gfc_code *code)
   expr2 = code->expr2;
   if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)
        != GFC_OMP_ATOMIC_WRITE)
-      && (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SWAP) == 0
       && expr2->expr_type == EXPR_FUNCTION
       && expr2->value.function.isym
       && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)
@@ -4784,6 +4783,7 @@ gfc_trans_omp_target (gfc_code *code)
       {
 	stmtblock_t iblock;
 
+	pushlevel ();
 	gfc_start_block (&iblock);
 	tree inner_clauses
 	  = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 5fa182bf05a..b839d6c73e1 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -2171,6 +2171,19 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,
 		build_int_cst (integer_type_node, annot_expr_unroll_kind),
 		build_int_cst (integer_type_node, code->ext.iterator->unroll));
 
+  if (code->ext.iterator->ivdep && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_ivdep_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->vector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_vector_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->novector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_no_vector_kind),
+		   integer_zero_node);
+
   /* The loop exit.  */
   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);
   TREE_USED (exit_label) = 1;
@@ -2501,6 +2514,20 @@ gfc_trans_do (gfc_code * code, tree exit_cond)
       = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
 		build_int_cst (integer_type_node, annot_expr_unroll_kind),
 		build_int_cst (integer_type_node, code->ext.iterator->unroll));
+
+  if (code->ext.iterator->ivdep && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_ivdep_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->vector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_vector_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->novector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_no_vector_kind),
+		   integer_zero_node);
+
   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);
   tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,
 			 cond, tmp, build_empty_stmt (loc));
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d3b61e78887..d0f1095edd5 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -3021,6 +3021,7 @@ get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args
 		}
 	    }
 	  s->attr.dummy = 1;
+	  s->attr.artificial = 1;
 	  s->attr.intent = INTENT_UNKNOWN;
 	  (*f)->sym = s;
 	}
@@ -3322,7 +3323,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)
   int rank, dim;
   bool indirect = false;
   tree etype, ptype, t, base_decl;
-  tree data_off, dim_off, dtype_off, dim_size, elem_size;
+  tree data_off, span_off, dim_off, dtype_off, dim_size, elem_size;
   tree lower_suboff, upper_suboff, stride_suboff;
   tree dtype, field, rank_off;
 
@@ -3379,12 +3380,13 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)
   if (indirect)
     base_decl = build1 (INDIRECT_REF, ptype, base_decl);
 
-  elem_size = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (etype));
-
-  gfc_get_descriptor_offsets_for_info (type, &data_off, &dtype_off, &dim_off,
-				       &dim_size, &stride_suboff,
+  gfc_get_descriptor_offsets_for_info (type, &data_off, &dtype_off, &span_off,
+				       &dim_off, &dim_size, &stride_suboff,
 				       &lower_suboff, &upper_suboff);
 
+  t = fold_build_pointer_plus (base_decl, span_off);
+  elem_size = build1 (INDIRECT_REF, gfc_array_index_type, t);
+
   t = base_decl;
   if (!integer_zerop (data_off))
     t = fold_build_pointer_plus (t, data_off);
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index e7844c9bf1f..167fcb2158c 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -118,6 +118,19 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)
   return gfc_evaluate_now_loc (input_location, expr, pblock);
 }
 
+/* Like gfc_evaluate_now, but add the created variable to the
+   function scope.  */
+
+tree
+gfc_evaluate_now_function_scope (tree expr, stmtblock_t * pblock)
+{
+  tree var;
+  var = gfc_create_var_np (TREE_TYPE (expr), NULL);
+  gfc_add_decl_to_function (var);
+  gfc_add_modify (pblock, var, expr);
+
+  return var;
+}
 
 /* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.
    A MODIFY_EXPR is an assignment:
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 273c75a422c..f6af09fedf7 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -507,6 +507,7 @@ void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);
 /* If the value is not constant, Create a temporary and copy the value.  */
 tree gfc_evaluate_now_loc (location_t, tree, stmtblock_t *);
 tree gfc_evaluate_now (tree, stmtblock_t *);
+tree gfc_evaluate_now_function_scope (tree, stmtblock_t *);
 
 /* Find the appropriate variant of a math intrinsic.  */
 tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);
@@ -962,7 +963,6 @@ struct GTY(())	lang_type	 {
   tree offset;
   tree dtype;
   tree dataptr_type;
-  tree span;
   tree base_decl[2];
   tree nonrestricted_type;
   tree caf_token;
@@ -978,7 +978,6 @@ struct GTY(()) lang_decl {
      address of target label.  */
   tree stringlen;
   tree addr;
-  tree span;
   /* For assumed-shape coarrays.  */
   tree token, caf_offset;
   unsigned int scalar_allocatable : 1;
@@ -988,7 +987,6 @@ struct GTY(()) lang_decl {
 
 #define GFC_DECL_ASSIGN_ADDR(node) DECL_LANG_SPECIFIC(node)->addr
 #define GFC_DECL_STRING_LEN(node) DECL_LANG_SPECIFIC(node)->stringlen
-#define GFC_DECL_SPAN(node) DECL_LANG_SPECIFIC(node)->span
 #define GFC_DECL_TOKEN(node) DECL_LANG_SPECIFIC(node)->token
 #define GFC_DECL_CAF_OFFSET(node) DECL_LANG_SPECIFIC(node)->caf_offset
 #define GFC_DECL_SAVED_DESCRIPTOR(node) \
@@ -1037,7 +1035,6 @@ struct GTY(()) lang_decl {
 #define GFC_TYPE_ARRAY_DTYPE(node) (TYPE_LANG_SPECIFIC(node)->dtype)
 #define GFC_TYPE_ARRAY_DATAPTR_TYPE(node) \
   (TYPE_LANG_SPECIFIC(node)->dataptr_type)
-#define GFC_TYPE_ARRAY_SPAN(node) (TYPE_LANG_SPECIFIC(node)->span)
 #define GFC_TYPE_ARRAY_BASE_DECL(node, internal) \
   (TYPE_LANG_SPECIFIC(node)->base_decl[(internal)])
 
diff --git a/gcc/function.c b/gcc/function.c
index c6e862b3369..acf9f9e60c7 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -2449,8 +2449,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,
   /* If the parm is to be passed as a transparent union or record, use the
      type of the first field for the tests below.  We have already verified
      that the modes are the same.  */
-  if ((TREE_CODE (passed_type) == UNION_TYPE
-       || TREE_CODE (passed_type) == RECORD_TYPE)
+  if (RECORD_OR_UNION_TYPE_P (passed_type)
       && TYPE_TRANSPARENT_AGGR (passed_type))
     passed_type = TREE_TYPE (first_field (passed_type));
 
@@ -3079,7 +3078,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,
 	move_block_from_reg (REGNO (entry_parm), mem,
 			     size_stored / UNITS_PER_WORD);
     }
-  else if (data->stack_parm == 0)
+  else if (data->stack_parm == 0 && !TYPE_EMPTY_P (data->passed_type))
     {
       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);
       emit_block_move (stack_parm, data->entry_parm, GEN_INT (size),
@@ -3455,7 +3454,9 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,
       dest = validize_mem (copy_rtx (data->stack_parm));
       src = validize_mem (copy_rtx (data->entry_parm));
 
-      if (MEM_P (src))
+      if (TYPE_EMPTY_P (data->passed_type))
+	/* Empty types don't really need to be copied.  */;
+      else if (MEM_P (src))
 	{
 	  /* Use a block move to handle potentially misaligned entry_parm.  */
 	  if (!to_conversion)
@@ -3611,6 +3612,16 @@ assign_parms (tree fndecl)
 	{
 	  assign_parm_find_stack_rtl (parm, &data);
 	  assign_parm_adjust_entry_rtl (&data);
+	  /* For arguments that occupy no space in the parameter
+	     passing area, have non-zero size and have address taken,
+	     force creation of a stack slot so that they have distinct
+	     address from other parameters.  */
+	  if (TYPE_EMPTY_P (data.passed_type)
+	      && TREE_ADDRESSABLE (parm)
+	      && data.entry_parm == data.stack_parm
+	      && MEM_P (data.entry_parm)
+	      && int_size_in_bytes (data.passed_type))
+	    data.stack_parm = NULL_RTX;
 	}
       /* Record permanently how this parm was passed.  */
       if (data.passed_pointer)
diff --git a/gcc/gcov.c b/gcc/gcov.c
index b06a6714c2e..7e51c2efb30 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -725,10 +725,10 @@ unblock (const block_info *u, block_vector_t &blocked,
 /* Return true when PATH contains a zero cycle arc count.  */
 
 static bool
-path_contains_zero_cycle_arc (arc_vector_t &path)
+path_contains_zero_or_negative_cycle_arc (arc_vector_t &path)
 {
   for (unsigned i = 0; i < path.size (); i++)
-    if (path[i]->cs_count == 0)
+    if (path[i]->cs_count <= 0)
       return true;
   return false;
 }
@@ -754,7 +754,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
     {
       block_info *w = arc->dst;
       if (w < start
-	  || arc->cs_count == 0
+	  || arc->cs_count <= 0
 	  || !linfo.has_block (w))
 	continue;
 
@@ -765,7 +765,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
 	  handle_cycle (path, count);
 	  loop_found = true;
 	}
-      else if (!path_contains_zero_cycle_arc (path)
+      else if (!path_contains_zero_or_negative_cycle_arc (path)
 	       &&  find (blocked.begin (), blocked.end (), w) == blocked.end ())
 	loop_found |= circuit (w, path, start, blocked, block_lists, linfo,
 			       count);
@@ -780,7 +780,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
       {
 	block_info *w = arc->dst;
 	if (w < start
-	    || arc->cs_count == 0
+	    || arc->cs_count <= 0
 	    || !linfo.has_block (w))
 	  continue;
 
diff --git a/gcc/generic-match-head.c b/gcc/generic-match-head.c
index a46f375017b..3478cf59f91 100644
--- a/gcc/generic-match-head.c
+++ b/gcc/generic-match-head.c
@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "ssa.h"
 #include "cgraph.h"
 #include "fold-const.h"
+#include "fold-const-call.h"
 #include "stor-layout.h"
 #include "tree-dfa.h"
 #include "builtins.h"
diff --git a/gcc/genmatch.c b/gcc/genmatch.c
index 7b9b09c7d8b..345e21dac40 100644
--- a/gcc/genmatch.c
+++ b/gcc/genmatch.c
@@ -3035,10 +3035,15 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,
 	    {
 	      expr *e = as_a <expr *>(fns[i]->op);
 	      fprintf_indent (f, indent, "case %s:\n", e->operation->id);
-	      fprintf_indent (f, indent, "  {\n");
-	      fns[i]->gen (f, indent + 4, true);
-	      fprintf_indent (f, indent, "    break;\n");
-	      fprintf_indent (f, indent, "  }\n");
+	      /* We need to be defensive against bogus prototypes allowing
+		 calls with not enough arguments.  */
+	      fprintf_indent (f, indent,
+			      "  if (gimple_call_num_args (def) == %d)\n"
+			      "    {\n", e->ops.length ());
+	      fns[i]->gen (f, indent + 6, true);
+	      fprintf_indent (f, indent,
+			      "    }\n"
+			      "  break;\n");
 	    }
 
 	  fprintf_indent (f, indent, "default:;\n");
@@ -3099,10 +3104,11 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,
 	  gcc_assert (e->operation->kind == id_base::FN);
 
 	  fprintf_indent (f, indent, "case %s:\n", e->operation->id);
-	  fprintf_indent (f, indent, "  {\n");
-	  generic_fns[j]->gen (f, indent + 4, false);
-	  fprintf_indent (f, indent, "    break;\n");
-	  fprintf_indent (f, indent, "  }\n");
+	  fprintf_indent (f, indent, "  if (call_expr_nargs (%s) == %d)\n"
+				     "    {\n", kid_opname, e->ops.length ());
+	  generic_fns[j]->gen (f, indent + 6, false);
+	  fprintf_indent (f, indent, "    }\n"
+				     "  break;\n");
 	}
       fprintf_indent (f, indent, "default:;\n");
 
diff --git a/gcc/ggc-none.c b/gcc/ggc-none.c
index 6edec27868c..737429f9e49 100644
--- a/gcc/ggc-none.c
+++ b/gcc/ggc-none.c
@@ -72,3 +72,8 @@ void
 ggc_grow (void)
 {
 }
+
+void
+ggc_trim (void)
+{
+}
diff --git a/gcc/ggc-page.c b/gcc/ggc-page.c
index 143986be58f..3c9636d0fe7 100644
--- a/gcc/ggc-page.c
+++ b/gcc/ggc-page.c
@@ -1016,6 +1016,8 @@ free_page (page_entry *entry)
 static void
 release_pages (void)
 {
+  size_t n1 = 0;
+  size_t n2 = 0;
 #ifdef USING_MADVISE
   page_entry *p, *start_p;
   char *start;
@@ -1061,6 +1063,7 @@ release_pages (void)
           else
             G.free_pages = p;
           G.bytes_mapped -= mapped_len;
+	  n1 += len;
 	  continue;
         }
       prev = newprev;
@@ -1092,6 +1095,7 @@ release_pages (void)
       /* Don't count those pages as mapped to not touch the garbage collector
          unnecessarily. */
       G.bytes_mapped -= len;
+      n2 += len;
       while (start_p != p)
         {
           start_p->discarded = true;
@@ -1124,6 +1128,7 @@ release_pages (void)
 	}
 
       munmap (start, len);
+      n1 += len;
       G.bytes_mapped -= len;
     }
 
@@ -1151,11 +1156,21 @@ release_pages (void)
       {
 	*gp = g->next;
 	G.bytes_mapped -= g->alloc_size;
+	n1 += g->alloc_size;
 	free (g->allocation);
       }
     else
       gp = &g->next;
 #endif
+  if (!quiet_flag && (n1 || n2))
+    {
+      fprintf (stderr, " {GC");
+      if (n1)
+	fprintf (stderr, " released %luk", (unsigned long)(n1 / 1024));
+      if (n2)
+	fprintf (stderr, " madv_dontneed %luk", (unsigned long)(n2 / 1024));
+      fprintf (stderr, "}");
+    }
 }
 
 /* This table provides a fast way to determine ceil(log_2(size)) for
@@ -2178,19 +2193,22 @@ ggc_collect (void)
     return;
 
   timevar_push (TV_GC);
-  if (!quiet_flag)
-    fprintf (stderr, " {GC %luk -> ", (unsigned long) G.allocated / 1024);
   if (GGC_DEBUG_LEVEL >= 2)
     fprintf (G.debug_file, "BEGIN COLLECTING\n");
 
   /* Zero the total allocated bytes.  This will be recalculated in the
      sweep phase.  */
+  size_t allocated = G.allocated;
   G.allocated = 0;
 
   /* Release the pages we freed the last time we collected, but didn't
      reuse in the interim.  */
   release_pages ();
 
+  /* Output this later so we do not interfere with release_pages.  */
+  if (!quiet_flag)
+    fprintf (stderr, " {GC %luk -> ", (unsigned long) allocated / 1024);
+
   /* Indicate that we've seen collections at this context depth.  */
   G.context_depth_collections = ((unsigned long)1 << (G.context_depth + 1)) - 1;
 
@@ -2221,9 +2239,25 @@ ggc_collect (void)
     fprintf (G.debug_file, "END COLLECTING\n");
 }
 
-/* Assume that all GGC memory is reachable and grow the limits for next collection.
-   With checking, trigger GGC so -Q compilation outputs how much of memory really is
-   reachable.  */
+/* Return free pages to the system.  */
+
+void
+ggc_trim ()
+{
+  timevar_push (TV_GC);
+  G.allocated = 0;
+  sweep_pages ();
+  release_pages ();
+  if (!quiet_flag)
+    fprintf (stderr, " {GC trimmed to %luk, %luk mapped}",
+	     (unsigned long) G.allocated / 1024,
+	     (unsigned long) G.bytes_mapped / 1024);
+  timevar_pop (TV_GC);
+}
+
+/* Assume that all GGC memory is reachable and grow the limits for next
+   collection.  With checking, trigger GGC so -Q compilation outputs how much
+   of memory really is reachable.  */
 
 void
 ggc_grow (void)
@@ -2556,6 +2590,9 @@ ggc_pch_read (FILE *f, void *addr)
 
   count_old_page_tables = G.by_depth_in_use;
 
+  if (fread (&d, sizeof (d), 1, f) != 1)
+    fatal_error (input_location, "cannot read PCH file: %m");
+
   /* We've just read in a PCH file.  So, every object that used to be
      allocated is now free.  */
   clear_marks ();
@@ -2584,8 +2621,6 @@ ggc_pch_read (FILE *f, void *addr)
 
   /* Allocate the appropriate page-table entries for the pages read from
      the PCH file.  */
-  if (fread (&d, sizeof (d), 1, f) != 1)
-    fatal_error (input_location, "can%'t read PCH file: %m");
 
   for (i = 0; i < NUM_ORDERS; i++)
     {
diff --git a/gcc/ggc.h b/gcc/ggc.h
index 60273f2e57d..31606dc843f 100644
--- a/gcc/ggc.h
+++ b/gcc/ggc.h
@@ -243,6 +243,9 @@ extern const char *ggc_alloc_string (const char *contents, int length
    function is called, not during allocations.  */
 extern void ggc_collect	(void);
 
+/* Return unused memory pages to the system.  */
+extern void ggc_trim (void);
+
 /* Assume that all GGC memory is reachable and grow the limits for next collection. */
 extern void ggc_grow (void);
 
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index f30818042ee..d00f1e2b035 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -6557,6 +6557,7 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),
 
 	fn = (*valueize) (gimple_call_fn (stmt));
 	if (TREE_CODE (fn) == ADDR_EXPR
+	    && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL
 	    && fndecl_built_in_p (TREE_OPERAND (fn, 0))
 	    && gimple_builtin_call_types_compatible_p (stmt,
 						       TREE_OPERAND (fn, 0)))
diff --git a/gcc/gimple-loop-jam.c b/gcc/gimple-loop-jam.c
index 90ddbf37b07..236349e36ba 100644
--- a/gcc/gimple-loop-jam.c
+++ b/gcc/gimple-loop-jam.c
@@ -360,16 +360,33 @@ fuse_loops (struct loop *loop)
   rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_USE, loop);
 }
 
+/* Return true if any of the access functions for dataref A
+   isn't invariant with respect to loop LOOP_NEST.  */
+static bool
+any_access_function_variant_p (const struct data_reference *a,
+			       const class loop *loop_nest)
+{
+  unsigned int i;
+  vec<tree> fns = DR_ACCESS_FNS (a);
+  tree t;
+
+  FOR_EACH_VEC_ELT (fns, i, t)
+    if (!evolution_function_is_invariant_p (t, loop_nest->num))
+      return true;
+
+  return false;
+}
+
 /* Returns true if the distance in DDR can be determined and adjusts
    the unroll factor in *UNROLL to make unrolling valid for that distance.
-   Otherwise return false.
+   Otherwise return false.  DDR is with respect to the outer loop of INNER.
 
    If this data dep can lead to a removed memory reference, increment
    *REMOVED and adjust *PROFIT_UNROLL to be the necessary unroll factor
    for this to happen.  */
 
 static bool
-adjust_unroll_factor (struct data_dependence_relation *ddr,
+adjust_unroll_factor (class loop *inner, struct data_dependence_relation *ddr,
 		      unsigned *unroll, unsigned *profit_unroll,
 		      unsigned *removed)
 {
@@ -392,9 +409,59 @@ adjust_unroll_factor (struct data_dependence_relation *ddr,
 	    gcc_unreachable ();
 	  else if ((unsigned)dist >= *unroll)
 	    ;
-	  else if (lambda_vector_lexico_pos (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)
-		   || (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)
-		       && dist > 0))
+	  else if (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))
+	    {
+	      /* We have (a,0) with a < N, so this will be transformed into
+	         (0,0) after unrolling by N.  This might potentially be a
+		 problem, if it's not a read-read dependency.  */
+	      if (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr)))
+		;
+	      else
+		{
+		  /* So, at least one is a write, and we might reduce the
+		     distance vector to (0,0).  This is still no problem
+		     if both data-refs are affine with respect to the inner
+		     loops.  But if one of them is invariant with respect
+		     to an inner loop our reordering implicit in loop fusion
+		     corrupts the program, as our data dependences don't
+		     capture this.  E.g. for:
+		       for (0 <= i < n)
+		         for (0 <= j < m)
+		           a[i][0] = a[i+1][0] + 2;    // (1)
+		           b[i][j] = b[i+1][j] + 2;    // (2)
+		     the distance vector for both statements is (-1,0),
+		     but exchanging the order for (2) is okay, while
+		     for (1) it is not.  To see this, write out the original
+		     accesses (assume m is 2):
+		       a i j original
+		       0 0 0 r a[1][0] b[1][0]
+		       1 0 0 w a[0][0] b[0][0]
+		       2 0 1 r a[1][0] b[1][1]
+		       3 0 1 w a[0][0] b[0][1]
+		       4 1 0 r a[2][0] b[2][0]
+		       5 1 0 w a[1][0] b[1][0]
+		     after unroll-by-2 and fusion the accesses are done in
+		     this order (from column a): 0,1, 4,5, 2,3, i.e. this:
+		       a i j transformed
+		       0 0 0 r a[1][0] b[1][0]
+		       1 0 0 w a[0][0] b[0][0]
+		       4 1 0 r a[2][0] b[2][0]
+		       5 1 0 w a[1][0] b[1][0]
+		       2 0 1 r a[1][0] b[1][1]  
+		       3 0 1 w a[0][0] b[0][1]
+		     Note how access 2 accesses the same element as access 5
+		     for array 'a' but not for array 'b'.  */
+		  if (any_access_function_variant_p (DDR_A (ddr), inner)
+		      && any_access_function_variant_p (DDR_B (ddr), inner))
+		    ;
+		  else
+		    /* And if any dataref of this pair is invariant with
+		       respect to the inner loop, we have no chance than
+		       to reduce the unroll factor.  */
+		    *unroll = dist;
+		}
+	    }
+	  else if (lambda_vector_lexico_pos (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))
 	    ;
 	  else
 	    *unroll = dist;
@@ -486,7 +553,7 @@ tree_loop_unroll_and_jam (void)
 	  /* Now check the distance vector, for determining a sensible
 	     outer unroll factor, and for validity of merging the inner
 	     loop copies.  */
-	  if (!adjust_unroll_factor (ddr, &unroll_factor, &profit_unroll,
+	  if (!adjust_unroll_factor (loop, ddr, &unroll_factor, &profit_unroll,
 				     &removed))
 	    {
 	      /* Couldn't get the distance vector.  For two reads that's
@@ -506,7 +573,7 @@ tree_loop_unroll_and_jam (void)
 	 to ignore all profitability concerns and apply the transformation
 	 always.  */
       if (!PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))
-	profit_unroll = 2;
+	profit_unroll = MAX(2, profit_unroll);
       else if (removed * 100 / datarefs.length ()
 	  < (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))
 	profit_unroll = 1;
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index 4a8cf6f847f..550f782813b 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -2375,8 +2375,9 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)
 /* Check if there are any stores in M_STORE_INFO after index I
    (where M_STORE_INFO must be sorted by sort_by_bitpos) that overlap
    a potential group ending with END that have their order
-   smaller than LAST_ORDER.  RHS_CODE is the kind of store in the
-   group.  Return true if there are no such stores.
+   smaller than LAST_ORDER.  ALL_INTEGER_CST_P is true if
+   all the stores already merged and the one under consideration
+   have rhs_code of INTEGER_CST.  Return true if there are no such stores.
    Consider:
      MEM[(long long int *)p_28] = 0;
      MEM[(long long int *)p_28 + 8B] = 0;
@@ -2399,13 +2400,13 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)
    the MEM[(long long int *)p_28 + 8B] = 0; would now be before it,
    so we need to refuse merging MEM[(long long int *)p_28 + 8B] = 0;
    into the group.  That way it will be its own store group and will
-   not be touched.  If RHS_CODE is INTEGER_CST and there are overlapping
+   not be touched.  If ALL_INTEGER_CST_P and there are overlapping
    INTEGER_CST stores, those are mergeable using merge_overlapping,
    so don't return false for those.  */
 
 static bool
 check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,
-		  enum tree_code rhs_code, unsigned int last_order,
+		  bool all_integer_cst_p, unsigned int last_order,
 		  unsigned HOST_WIDE_INT end)
 {
   unsigned int len = m_store_info.length ();
@@ -2415,7 +2416,7 @@ check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,
       if (info->bitpos >= end)
 	break;
       if (info->order < last_order
-	  && (rhs_code != INTEGER_CST || info->rhs_code != INTEGER_CST))
+	  && (!all_integer_cst_p || info->rhs_code != INTEGER_CST))
 	return false;
     }
   return true;
@@ -2568,7 +2569,7 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,
   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))
     return false;
 
-  if (!check_no_overlap (m_store_info, last, LROTATE_EXPR, last_order, end))
+  if (!check_no_overlap (m_store_info, last, false, last_order, end))
     return false;
 
   /* Don't handle memory copy this way if normal non-bswap processing
@@ -2709,7 +2710,14 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	       |---store 2---|
 	 Overlapping stores.  */
       else if (IN_RANGE (info->bitpos, merged_store->start,
-			 merged_store->start + merged_store->width - 1))
+			 merged_store->start + merged_store->width - 1)
+	       /* |---store 1---||---store 2---|
+		  Handle also the consecutive INTEGER_CST stores case here,
+		  as we have here the code to deal with overlaps.  */
+	       || (info->bitregion_start <= merged_store->bitregion_end
+		   && info->rhs_code == INTEGER_CST
+		   && merged_store->only_constants
+		   && merged_store->can_be_merged_into (info)))
 	{
 	  /* Only allow overlapping stores of constants.  */
 	  if (info->rhs_code == INTEGER_CST && merged_store->only_constants)
@@ -2719,8 +2727,7 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	      unsigned HOST_WIDE_INT end
 		= MAX (merged_store->start + merged_store->width,
 		       info->bitpos + info->bitsize);
-	      if (check_no_overlap (m_store_info, i, INTEGER_CST,
-				    last_order, end))
+	      if (check_no_overlap (m_store_info, i, true, last_order, end))
 		{
 		  /* check_no_overlap call above made sure there are no
 		     overlapping stores with non-INTEGER_CST rhs_code
@@ -2873,7 +2880,7 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	      std::swap (info->ops[0], info->ops[1]);
 	      info->ops_swapped_p = true;
 	    }
-	  if (check_no_overlap (m_store_info, i, info->rhs_code,
+	  if (check_no_overlap (m_store_info, i, false,
 				MAX (merged_store->last_order, info->order),
 				MAX (merged_store->start + merged_store->width,
 				     info->bitpos + info->bitsize)))
diff --git a/gcc/gimple-streamer-out.c b/gcc/gimple-streamer-out.c
index 34b8d6fda7d..7185c07f36b 100644
--- a/gcc/gimple-streamer-out.c
+++ b/gcc/gimple-streamer-out.c
@@ -57,7 +57,7 @@ output_phi (struct output_block *ob, gphi *phi)
 /* Emit statement STMT on the main stream of output block OB.  */
 
 static void
-output_gimple_stmt (struct output_block *ob, gimple *stmt)
+output_gimple_stmt (struct output_block *ob, struct function *fn, gimple *stmt)
 {
   unsigned i;
   enum gimple_code code;
@@ -80,7 +80,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 		     as_a <gassign *> (stmt)),
 		   1);
   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);
-  hist = gimple_histogram_value (cfun, stmt);
+  hist = gimple_histogram_value (fn, stmt);
   bp_pack_value (&bp, hist != NULL, 1);
   bp_pack_var_len_unsigned (&bp, stmt->subcode);
 
@@ -139,7 +139,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 	     so that we do not have to deal with type mismatches on
 	     merged symbols during IL read in.  The first operand
 	     of GIMPLE_DEBUG must be a decl, not MEM_REF, though.  */
-	  if (op && (i || !is_gimple_debug (stmt)))
+	  if (!flag_wpa && op && (i || !is_gimple_debug (stmt)))
 	    {
 	      basep = &op;
 	      if (TREE_CODE (*basep) == ADDR_EXPR)
@@ -147,7 +147,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 	      while (handled_component_p (*basep))
 		basep = &TREE_OPERAND (*basep, 0);
 	      if (VAR_P (*basep)
-		  && !auto_var_in_fn_p (*basep, current_function_decl)
+		  && !auto_var_in_fn_p (*basep, fn->decl)
 		  && !DECL_REGISTER (*basep))
 		{
 		  bool volatilep = TREE_THIS_VOLATILE (*basep);
@@ -228,7 +228,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)
 	      print_gimple_stmt (streamer_dump_file, stmt, 0, TDF_SLIM);
 	    }
 
-	  output_gimple_stmt (ob, stmt);
+	  output_gimple_stmt (ob, fn, stmt);
 
 	  /* Emit the EH region holding STMT.  */
 	  region = lookup_stmt_eh_lp_fn (fn, stmt);
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 98408b981dc..bd8bd6d7e06 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -4831,6 +4831,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	    && num_nonzero_elements > 1
 	    && TREE_READONLY (object)
 	    && VAR_P (object)
+	    && !DECL_REGISTER (object)
 	    && (flag_merge_constants >= 2 || !TREE_ADDRESSABLE (object))
 	    /* For ctors that have many repeated nonzero elements
 	       represented through RANGE_EXPRs, prefer initializing
@@ -7058,6 +7059,8 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,
   kind = lang_hooks.decls.omp_predetermined_sharing (decl);
   if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)
     default_kind = kind;
+  else if (VAR_P (decl) && TREE_STATIC (decl) && DECL_IN_CONSTANT_POOL (decl))
+    default_kind = OMP_CLAUSE_DEFAULT_SHARED;
 
   switch (default_kind)
     {
@@ -8716,8 +8719,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,
 			      break;
 			    if (scp)
 			      continue;
-			    gcc_assert (offset == NULL_TREE
-					|| poly_int_tree_p (offset));
+			    gcc_assert (offset2 == NULL_TREE
+					|| poly_int_tree_p (offset2));
 			    tree d1 = OMP_CLAUSE_DECL (*sc);
 			    tree d2 = OMP_CLAUSE_DECL (c);
 			    while (TREE_CODE (d1) == ARRAY_REF)
@@ -9079,9 +9082,13 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,
 				  == POINTER_TYPE))))
 		    omp_firstprivatize_variable (outer_ctx, decl);
 		  else
-		    omp_add_variable (outer_ctx, decl,
-				      GOVD_SEEN | GOVD_SHARED);
-		  omp_notice_variable (outer_ctx, decl, true);
+		    {
+		      omp_add_variable (outer_ctx, decl,
+					GOVD_SEEN | GOVD_SHARED);
+		      if (outer_ctx->outer_context)
+			omp_notice_variable (outer_ctx->outer_context, decl,
+					     true);
+		    }
 		}
 	    }
 	  if (outer_ctx)
@@ -13519,7 +13526,8 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	{
 	  /* Avoid the extra copy if possible.  */
 	  *expr_p = create_tmp_reg (TREE_TYPE (name));
-	  gimple_set_lhs (SSA_NAME_DEF_STMT (name), *expr_p);
+	  if (!gimple_nop_p (SSA_NAME_DEF_STMT (name)))
+	    gimple_set_lhs (SSA_NAME_DEF_STMT (name), *expr_p);
 	  release_ssa_name (name);
 	}
     }
diff --git a/gcc/go/gofrontend/escape.cc b/gcc/go/gofrontend/escape.cc
index e1c98094831..23fa7552f4c 100644
--- a/gcc/go/gofrontend/escape.cc
+++ b/gcc/go/gofrontend/escape.cc
@@ -1879,7 +1879,8 @@ Escape_analysis_assign::expression(Expression** pexpr)
             this->context_->track(addr_node);
 
             Node::Escape_state* addr_state = addr_node->state(this->context_, NULL);
-            addr_state->loop_depth = array_state->loop_depth;
+            if (array_state->loop_depth != 0)
+              addr_state->loop_depth = array_state->loop_depth;
           }
       }
       break;
diff --git a/gcc/go/gofrontend/expressions.cc b/gcc/go/gofrontend/expressions.cc
index 6f9775dd5a2..859c1ece5da 100644
--- a/gcc/go/gofrontend/expressions.cc
+++ b/gcc/go/gofrontend/expressions.cc
@@ -2036,7 +2036,11 @@ class Integer_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 1; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 1; 
+  }
 
   void
   do_export(Export_function_body*) const;
@@ -2451,7 +2455,11 @@ class Float_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 1; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 1;
+  }
 
   void
   do_export(Export_function_body*) const;
@@ -2664,7 +2672,11 @@ class Complex_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 2; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 2;
+  }
 
   void
   do_export(Export_function_body*) const;
diff --git a/gcc/internal-fn.c b/gcc/internal-fn.c
index 04081f36c4d..95788dfee7d 100644
--- a/gcc/internal-fn.c
+++ b/gcc/internal-fn.c
@@ -1407,7 +1407,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,
   /* s1 * s2 -> ur  */
   if (!uns0_p && !uns1_p && unsr_p)
     {
-      rtx tem, tem2;
+      rtx tem;
       switch (pos_neg0 | pos_neg1)
 	{
 	case 1: /* Both operands known to be non-negative.  */
@@ -1437,10 +1437,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,
 	      ops.op2 = NULL_TREE;
 	      ops.location = loc;
 	      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);
-	      tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,
-				  OPTAB_LIB_WIDEN);
-	      do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode,
-				       NULL_RTX, NULL, done_label,
+	      do_compare_rtx_and_jump (pos_neg0 == 1 ? op0 : op1, const0_rtx, EQ,
+				       true, mode, NULL_RTX, NULL, done_label,
 				       profile_probability::very_likely ());
 	      goto do_error_label;
 	    }
@@ -1471,16 +1469,23 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,
 	  arg1 = error_mark_node;
 	  emit_jump (do_main_label);
 	  emit_label (after_negate_label);
-	  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,
-			       OPTAB_LIB_WIDEN);
-	  do_compare_rtx_and_jump (tem2, const0_rtx, GE, false, mode, NULL_RTX,
-				   NULL, do_main_label, profile_probability::very_likely ());
+	  tem = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,
+			      OPTAB_LIB_WIDEN);
+	  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,
+				   NULL, do_main_label,
+				   profile_probability::very_likely ());
 	  /* One argument is negative here, the other positive.  This
 	     overflows always, unless one of the arguments is 0.  But
 	     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1
 	     is, thus we can keep do_main code oring in overflow as is.  */
-	  do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode, NULL_RTX,
-				   NULL, do_main_label, profile_probability::very_likely ());
+	  if (pos_neg0 != 2)
+	    do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,
+				     NULL, do_main_label,
+				     profile_probability::very_unlikely ());
+	  if (pos_neg1 != 2)
+	    do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,
+				     NULL, do_main_label,
+				     profile_probability::very_unlikely ());
 	  expand_arith_set_overflow (lhs, target);
 	  emit_label (do_main_label);
 	  goto do_main;
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 32b352328a9..98403940100 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -2567,7 +2567,7 @@ devirtualization_time_bonus (struct cgraph_node *node,
       if (avail < AVAIL_AVAILABLE)
 	continue;
       isummary = ipa_fn_summaries->get (callee);
-      if (!isummary->inlinable)
+      if (!isummary || !isummary->inlinable)
 	continue;
 
       /* FIXME: The values below need re-considering and perhaps also
@@ -4452,7 +4452,6 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,
 
   for (i = 0; i < count; i++)
     {
-      static vec<ipa_agg_jf_item> values = vec<ipa_agg_jf_item>();
       struct ipcp_param_lattices *plats;
       bool interesting = false;
       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)
@@ -4468,7 +4467,8 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,
       if (plats->aggs_bottom)
 	return false;
 
-      values = intersect_aggregates_with_edge (cs, i, values);
+      vec<ipa_agg_jf_item> values
+	= intersect_aggregates_with_edge (cs, i, vNULL);
       if (!values.exists ())
 	return false;
 
@@ -4492,6 +4492,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,
 		return false;
 	      }
 	  }
+      values.release ();
     }
   return true;
 }
@@ -5190,4 +5191,5 @@ ipa_cp_c_finalize (void)
   max_count = profile_count::uninitialized ();
   overall_size = 0;
   max_new_size = 0;
+  ipcp_free_transformation_sum ();
 }
diff --git a/gcc/ipa-fnsummary.c b/gcc/ipa-fnsummary.c
index 160261d34c9..7c5562ad801 100644
--- a/gcc/ipa-fnsummary.c
+++ b/gcc/ipa-fnsummary.c
@@ -3452,24 +3452,24 @@ static void
 ipa_fn_summary_write (void)
 {
   struct output_block *ob = create_output_block (LTO_section_ipa_fn_summary);
+  lto_symtab_encoder_iterator lsei;
   lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;
   unsigned int count = 0;
-  int i;
 
-  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)
+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);
+       lsei_next_function_in_partition (&lsei))
     {
-      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);
-      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);
-      if (cnode && cnode->definition && !cnode->alias)
+      cgraph_node *cnode = lsei_cgraph_node (lsei);
+      if (cnode->definition && !cnode->alias)
 	count++;
     }
   streamer_write_uhwi (ob, count);
 
-  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)
+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);
+       lsei_next_function_in_partition (&lsei))
     {
-      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);
-      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);
-      if (cnode && cnode->definition && !cnode->alias)
+      cgraph_node *cnode = lsei_cgraph_node (lsei);
+      if (cnode->definition && !cnode->alias)
 	{
 	  struct ipa_fn_summary *info = ipa_fn_summaries->get (cnode);
 	  struct bitpack_d bp;
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index d86c2f3db55..40edee7951c 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -3725,6 +3725,18 @@ ipcp_transformation_initialize (void)
     ipcp_transformation_sum = ipcp_transformation_t::create_ggc (symtab);
 }
 
+/* Release the IPA CP transformation summary.  */
+
+void
+ipcp_free_transformation_sum (void)
+{
+  if (!ipcp_transformation_sum)
+    return;
+
+  ipcp_transformation_sum->release ();
+  ipcp_transformation_sum = NULL;
+}
+
 /* Set the aggregate replacements of NODE to be AGGVALS.  */
 
 void
@@ -4703,9 +4715,10 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,
 	  bool known = bp_unpack_value (&bp, 1);
 	  if (known)
 	    {
+	      const widest_int value = streamer_read_widest_int (ib);
+	      const widest_int mask = streamer_read_widest_int (ib);
 	      ipa_bits *bits
-		= ipa_get_ipa_bits_for_value (streamer_read_widest_int (ib),
-					      streamer_read_widest_int (ib));
+		= ipa_get_ipa_bits_for_value (value, mask);
 	      (*ts->bits)[i] = bits;
 	    }
 	}
diff --git a/gcc/ipa-prop.h b/gcc/ipa-prop.h
index 7257a6d04f1..5ab3d07a6de 100644
--- a/gcc/ipa-prop.h
+++ b/gcc/ipa-prop.h
@@ -558,6 +558,7 @@ struct GTY(()) ipcp_transformation
 void ipa_set_node_agg_value_chain (struct cgraph_node *node,
 				   struct ipa_agg_replacement_value *aggvals);
 void ipcp_transformation_initialize (void);
+void ipcp_free_transformation_sum (void);
 
 /* ipa_edge_args stores information related to a callsite and particularly its
    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index bb561d00853..0c6f84ff72d 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -527,7 +527,6 @@ special_builtin_state (enum pure_const_state_e *state, bool *looping,
 	case BUILT_IN_CXA_END_CLEANUP:
 	case BUILT_IN_EH_COPY_VALUES:
 	case BUILT_IN_FRAME_ADDRESS:
-	case BUILT_IN_APPLY:
 	case BUILT_IN_APPLY_ARGS:
 	case BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT:
 	case BUILT_IN_ASAN_AFTER_DYNAMIC_INIT:
diff --git a/gcc/ira.c b/gcc/ira.c
index fd481d6e0e2..b330f2a287b 100644
--- a/gcc/ira.c
+++ b/gcc/ira.c
@@ -5198,6 +5198,8 @@ ira (FILE *f)
   int ira_max_point_before_emit;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
+  unsigned int i;
+  int num_used_regs = 0;
 
   clear_bb_flags ();
 
@@ -5213,12 +5215,17 @@ ira (FILE *f)
 
   ira_conflicts_p = optimize > 0;
 
+  /* Determine the number of pseudos actually requiring coloring.  */
+  for (i = FIRST_PSEUDO_REGISTER; i < DF_REG_SIZE (df); i++)
+    num_used_regs += !!(DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i));
+
   /* If there are too many pseudos and/or basic blocks (e.g. 10K
      pseudos and 10K blocks or 100K pseudos and 1K blocks), we will
      use simplified and faster algorithms in LRA.  */
   lra_simple_p
     = (ira_use_lra_p
-       && max_reg_num () >= (1 << 26) / last_basic_block_for_fn (cfun));
+       && num_used_regs >= (1 << 26) / last_basic_block_for_fn (cfun));
+
   if (lra_simple_p)
     {
       /* It permits to skip live range splitting in LRA.  */
diff --git a/gcc/loop-iv.c b/gcc/loop-iv.c
index 82b4bdb1523..340045ce8b2 100644
--- a/gcc/loop-iv.c
+++ b/gcc/loop-iv.c
@@ -1380,24 +1380,23 @@ simple_rhs_p (rtx rhs)
 static rtx
 find_single_def_src (unsigned int regno)
 {
-  df_ref adef;
-  rtx set, src;
+  rtx src = NULL_RTX;
 
-  for (;;)
+  /* Don't look through unbounded number of single definition REG copies,
+     there might be loops for sources with uninitialized variables.  */
+  for (int cnt = 0; cnt < 128; cnt++)
     {
-      rtx note;
-      adef = DF_REG_DEF_CHAIN (regno);
+      df_ref adef = DF_REG_DEF_CHAIN (regno);
       if (adef == NULL || DF_REF_NEXT_REG (adef) != NULL
 	  || DF_REF_IS_ARTIFICIAL (adef))
 	return NULL_RTX;
 
-      set = single_set (DF_REF_INSN (adef));
+      rtx set = single_set (DF_REF_INSN (adef));
       if (set == NULL || !REG_P (SET_DEST (set))
 	  || REGNO (SET_DEST (set)) != regno)
 	return NULL_RTX;
 
-      note = find_reg_equal_equiv_note (DF_REF_INSN (adef));
-
+      rtx note = find_reg_equal_equiv_note (DF_REF_INSN (adef));
       if (note && function_invariant_p (XEXP (note, 0)))
 	{
 	  src = XEXP (note, 0);
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index d0a8facc50e..253ae1e6cb0 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -401,6 +401,7 @@ extern bool lra_coalesce (void);
 
 /* lra-spills.c:  */
 
+extern bool lra_need_for_scratch_reg_p (void);
 extern bool lra_need_for_spills_p (void);
 extern void lra_spill (void);
 extern void lra_final_code_change (void);
diff --git a/gcc/lra-remat.c b/gcc/lra-remat.c
index 10838116143..69209b2a18d 100644
--- a/gcc/lra-remat.c
+++ b/gcc/lra-remat.c
@@ -1020,7 +1020,6 @@ get_hard_regs (struct lra_insn_reg *reg, int &nregs)
 static void
 update_scratch_ops (rtx_insn *remat_insn)
 {
-  int hard_regno;
   lra_insn_recog_data_t id = lra_get_insn_recog_data (remat_insn);
   struct lra_static_insn_data *static_id = id->insn_static_data;
   for (int i = 0; i < static_id->n_operands; i++)
@@ -1031,17 +1030,9 @@ update_scratch_ops (rtx_insn *remat_insn)
       int regno = REGNO (*loc);
       if (! lra_former_scratch_p (regno))
 	continue;
-      hard_regno = reg_renumber[regno];
       *loc = lra_create_new_reg (GET_MODE (*loc), *loc,
 				 lra_get_allocno_class (regno),
 				 "scratch pseudo copy");
-      if (hard_regno >= 0)
-	{
-	  reg_renumber[REGNO (*loc)] = hard_regno;
-	  if (lra_dump_file)
-	    fprintf (lra_dump_file, "	 Assigning the same %d to r%d\n",
-		     REGNO (*loc), hard_regno);
-	}
       lra_register_new_scratch_op (remat_insn, i, id->icode);
     }
   
diff --git a/gcc/lra-spills.c b/gcc/lra-spills.c
index c19b76a579c..7a49c0779b8 100644
--- a/gcc/lra-spills.c
+++ b/gcc/lra-spills.c
@@ -548,6 +548,19 @@ spill_pseudos (void)
     }
 }
 
+/* Return true if we need scratch reg assignments.  */
+bool
+lra_need_for_scratch_reg_p (void)
+{
+  int i; max_regno = max_reg_num ();
+
+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)
+    if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0
+	&& lra_former_scratch_p (i))
+      return true;
+  return false;
+}
+
 /* Return true if we need to change some pseudos into memory.  */
 bool
 lra_need_for_spills_p (void)
diff --git a/gcc/lra.c b/gcc/lra.c
index bef2f676a78..1d2578f8c12 100644
--- a/gcc/lra.c
+++ b/gcc/lra.c
@@ -2587,7 +2587,11 @@ lra (FILE *f)
 	  lra_create_live_ranges (lra_reg_spill_p, true);
 	  live_p = true;
 	  if (! lra_need_for_spills_p ())
-	    break;
+	    {
+	      if (lra_need_for_scratch_reg_p ())
+		continue;
+	      break;
+	    }
 	}
       lra_spill ();
       /* Assignment of stack slots changes elimination offsets for
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
index b6e395b53fd..42f382ecf21 100644
--- a/gcc/lto-streamer-out.c
+++ b/gcc/lto-streamer-out.c
@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "debug.h"
 #include "omp-offload.h"
 #include "print-tree.h"
+#include "tree-dfa.h"
 
 
 static void lto_write_tree (struct output_block*, tree, bool);
@@ -1891,7 +1892,7 @@ output_cfg (struct output_block *ob, struct function *fn)
 
   streamer_write_hwi (ob, -1);
 
-  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);
+  bb = ENTRY_BLOCK_PTR_FOR_FN (fn);
   while (bb->next_bb)
     {
       streamer_write_hwi (ob, bb->next_bb->index);
@@ -1900,9 +1901,6 @@ output_cfg (struct output_block *ob, struct function *fn)
 
   streamer_write_hwi (ob, -1);
 
-  /* ???  The cfgloop interface is tied to cfun.  */
-  gcc_assert (cfun == fn);
-
   /* Output the number of loops.  */
   streamer_write_uhwi (ob, number_of_loops (fn));
 
@@ -2063,6 +2061,62 @@ collect_block_tree_leafs (tree root, vec<tree> &leafs)
       collect_block_tree_leafs (BLOCK_SUBBLOCKS (root), leafs);
 }
 
+/* This performs function body modifications that are needed for streaming
+   to work.  */
+
+void
+lto_prepare_function_for_streaming (struct cgraph_node *node)
+{
+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);
+  basic_block bb;
+
+  if (number_of_loops (fn))
+    {
+      push_cfun (fn);
+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);
+      loop_optimizer_finalize ();
+      pop_cfun ();
+    }
+  /* We will renumber the statements.  The code that does this uses
+     the same ordering that we use for serializing them so we can use
+     the same code on the other end and not have to write out the
+     statement numbers.  We do not assign UIDs to PHIs here because
+     virtual PHIs get re-computed on-the-fly which would make numbers
+     inconsistent.  */
+  set_gimple_stmt_max_uid (fn, 0);
+  FOR_ALL_BB_FN (bb, fn)
+    {
+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *stmt = gsi.phi ();
+
+	  /* Virtual PHIs are not going to be streamed.  */
+	  if (!virtual_operand_p (gimple_phi_result (stmt)))
+	    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gimple *stmt = gsi_stmt (gsi);
+	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+    }
+  /* To avoid keeping duplicate gimple IDs in the statements, renumber
+     virtual phis now.  */
+  FOR_ALL_BB_FN (bb, fn)
+    {
+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *stmt = gsi.phi ();
+	  if (virtual_operand_p (gimple_phi_result (stmt)))
+	    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+    }
+
+}
+
 /* Output the body of function NODE->DECL.  */
 
 static void
@@ -2086,9 +2140,6 @@ output_function (struct cgraph_node *node)
 
   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);
 
-  /* Set current_function_decl and cfun.  */
-  push_cfun (fn);
-
   /* Make string 0 be a NULL string.  */
   streamer_write_char_stream (ob->string_stream, 0);
 
@@ -2125,9 +2176,6 @@ output_function (struct cgraph_node *node)
      debug info.  */
   if (gimple_has_body_p (function))
     {
-      /* Fixup loops if required to match discovery done in the reader.  */
-      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);
-
       streamer_write_uhwi (ob, 1);
       output_struct_function_base (ob, fn);
 
@@ -2137,45 +2185,6 @@ output_function (struct cgraph_node *node)
       /* Output any exception handling regions.  */
       output_eh_regions (ob, fn);
 
-
-      /* We will renumber the statements.  The code that does this uses
-	 the same ordering that we use for serializing them so we can use
-	 the same code on the other end and not have to write out the
-	 statement numbers.  We do not assign UIDs to PHIs here because
-	 virtual PHIs get re-computed on-the-fly which would make numbers
-	 inconsistent.  */
-      set_gimple_stmt_max_uid (cfun, 0);
-      FOR_ALL_BB_FN (bb, cfun)
-	{
-	  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gphi *stmt = gsi.phi ();
-
-	      /* Virtual PHIs are not going to be streamed.  */
-	      if (!virtual_operand_p (gimple_phi_result (stmt)))
-	        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gimple *stmt = gsi_stmt (gsi);
-	      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	}
-      /* To avoid keeping duplicate gimple IDs in the statements, renumber
-	 virtual phis now.  */
-      FOR_ALL_BB_FN (bb, cfun)
-	{
-	  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gphi *stmt = gsi.phi ();
-	      if (virtual_operand_p (gimple_phi_result (stmt)))
-	        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	}
-
       /* Output the code for the function.  */
       FOR_ALL_BB_FN (bb, fn)
 	output_bb (ob, bb, fn);
@@ -2184,9 +2193,6 @@ output_function (struct cgraph_node *node)
       streamer_write_record_start (ob, LTO_null);
 
       output_cfg (ob, fn);
-
-      loop_optimizer_finalize ();
-      pop_cfun ();
    }
   else
     streamer_write_uhwi (ob, 0);
@@ -2617,12 +2623,6 @@ write_symbol (struct streamer_tree_cache_d *cache,
   const char *comdat;
   unsigned char c;
 
-  gcc_checking_assert (TREE_PUBLIC (t)
-		       && (TREE_CODE (t) != FUNCTION_DECL
-			   || !fndecl_built_in_p (t))
-		       && !DECL_ABSTRACT_P (t)
-		       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));
-
   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));
 
   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
index 04b79dbce3b..ac3ecc9e5ed 100644
--- a/gcc/lto-streamer.h
+++ b/gcc/lto-streamer.h
@@ -879,6 +879,7 @@ void lto_output_decl_state_refs (struct output_block *,
 			         struct lto_out_decl_state *);
 void lto_output_location (struct output_block *, struct bitpack_d *, location_t);
 void lto_output_init_mode_table (void);
+void lto_prepare_function_for_streaming (cgraph_node *);
 
 
 /* In lto-cgraph.c  */
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index ac971494054..10bd7c9becb 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -128,12 +128,11 @@ maybe_unlink (const char *file)
 #define DUMPBASE_SUFFIX ".ltrans18446744073709551615"
 
 /* Create decoded options from the COLLECT_GCC and COLLECT_GCC_OPTIONS
-   environment according to LANG_MASK.  */
+   environment.  */
 
 static void
 get_options_from_collect_gcc_options (const char *collect_gcc,
 				      const char *collect_gcc_options,
-				      unsigned int lang_mask,
 				      struct cl_decoded_option **decoded_options,
 				      unsigned int *decoded_options_count)
 {
@@ -175,8 +174,7 @@ get_options_from_collect_gcc_options (const char *collect_gcc,
   argc = obstack_object_size (&argv_obstack) / sizeof (void *) - 1;
   argv = XOBFINISH (&argv_obstack, const char **);
 
-  decode_cmdline_options_to_array (argc, (const char **)argv,
-				   lang_mask,
+  decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,
 				   decoded_options, decoded_options_count);
   obstack_free (&argv_obstack, NULL);
 }
@@ -1008,8 +1006,7 @@ find_and_merge_options (int fd, off_t file_offset, const char *prefix,
     {
       struct cl_decoded_option *f2decoded_options;
       unsigned int f2decoded_options_count;
-      get_options_from_collect_gcc_options (collect_gcc,
-					    fopts, CL_LANG_ALL,
+      get_options_from_collect_gcc_options (collect_gcc, fopts,
 					    &f2decoded_options,
 					    &f2decoded_options_count);
       if (!fdecoded_options)
@@ -1150,7 +1147,6 @@ run_gcc (unsigned argc, char *argv[])
     fatal_error (input_location,
 		 "environment variable COLLECT_GCC_OPTIONS must be set");
   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,
-					CL_LANG_ALL,
 					&decoded_options,
 					&decoded_options_count);
 
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
index eb2653be616..8c715129c11 100644
--- a/gcc/lto/ChangeLog
+++ b/gcc/lto/ChangeLog
@@ -1,3 +1,37 @@
+2020-01-20  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-01-16  Martin Liska  <mliska@suse.cz>
+
+	* lto-partition.c (lto_balanced_map): Remember
+	best_noreorder_pos and then restore to it
+	when we revert.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/92231
+	* lto-lang.c (handle_const_attribute): Don't call fndecl_built_in_p
+	on *node that is not FUNCTION_DECL.
+
+2019-10-26  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+
+	2019-10-12  Jan Hubicka  <hubicka@ucw.cz>
+	* lto.c (lto_wpa_write_files): Do not update bodies of clones.
+
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* lto.c (lto_wpa_write_files): Prepare all bodies for streaming.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	* lto-partition.c (add_symbol_to_partition_1): Update.
+	(undo_parittion): Update.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/lto/lto-lang.c b/gcc/lto/lto-lang.c
index 5a35d4794c2..4ef228fcb45 100644
--- a/gcc/lto/lto-lang.c
+++ b/gcc/lto/lto-lang.c
@@ -303,7 +303,8 @@ handle_const_attribute (tree *node, tree ARG_UNUSED (name),
 			tree ARG_UNUSED (args), int ARG_UNUSED (flags),
 			bool * ARG_UNUSED (no_add_attrs))
 {
-  if (!fndecl_built_in_p (*node))
+  if (TREE_CODE (*node) != FUNCTION_DECL
+      || !fndecl_built_in_p (*node))
     inform (UNKNOWN_LOCATION, "%s:%s: %E: %E", __FILE__, __func__, *node, name);
 
   tree type = TREE_TYPE (*node);
diff --git a/gcc/lto/lto-partition.c b/gcc/lto/lto-partition.c
index 6972e6e9ef3..e4860c74624 100644
--- a/gcc/lto/lto-partition.c
+++ b/gcc/lto/lto-partition.c
@@ -501,6 +501,7 @@ void
 lto_balanced_map (int n_lto_partitions, int max_partition_size)
 {
   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;
+  int best_noreorder_pos = 0;
   auto_vec <cgraph_node *> order (symtab->cgraph_count);
   auto_vec<cgraph_node *> noreorder;
   auto_vec<varpool_node *> varpool_order;
@@ -762,6 +763,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)
 	  best_i = i;
 	  best_n_nodes = lto_symtab_encoder_size (partition->encoder);
 	  best_varpool_pos = varpool_pos;
+	  best_noreorder_pos = noreorder_pos;
 	}
       if (dump_file)
 	fprintf (dump_file, "Step %i: added %s/%i, size %i, "
@@ -782,6 +784,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)
 			 i - best_i, best_i);
 	      undo_partition (partition, best_n_nodes);
 	      varpool_pos = best_varpool_pos;
+	      noreorder_pos = best_noreorder_pos;
 	    }
 	  gcc_assert (best_size == partition->insns);
 	  i = best_i;
diff --git a/gcc/lto/lto.c b/gcc/lto/lto.c
index 4367928a515..4dde8c001e1 100644
--- a/gcc/lto/lto.c
+++ b/gcc/lto/lto.c
@@ -2446,6 +2446,15 @@ lto_wpa_write_files (void)
 
   timevar_push (TV_WHOPR_WPA_IO);
 
+  ggc_trim ();
+
+  cgraph_node *node;
+  /* Do body modifications needed for streaming before we fork out
+     worker processes.  */
+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)
+    if (!node->clone_of && gimple_has_body_p (node->decl))
+      lto_prepare_function_for_streaming (node);
+
   /* Generate a prefix for the LTRANS unit files.  */
   blen = strlen (ltrans_output_list);
   temp_filename = (char *) xmalloc (blen + sizeof ("2147483648.o"));
diff --git a/gcc/match.pd b/gcc/match.pd
index 039ddacfed1..f7e192d9b73 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -1419,7 +1419,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 (for cmp (gt lt ge le)
 (simplify
  (mult (convert (cmp @0 @1)) @2)
-  (cond (cmp @0 @1) @2 { build_zero_cst (type); })))
+  (if (GIMPLE || !TREE_SIDE_EFFECTS (@2))
+   (cond (cmp @0 @1) @2 { build_zero_cst (type); }))))
 
 /* For integral types with undefined overflow and C != 0 fold
    x * C EQ/NE y * C into x EQ/NE y.  */
@@ -1519,8 +1520,6 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 	tree etype = range_check_type (TREE_TYPE (@0));
 	if (etype)
 	  {
-	    if (! TYPE_UNSIGNED (etype))
-	      etype = unsigned_type_for (etype);
 	    hi = fold_convert (etype, hi);
 	    lo = fold_convert (etype, lo);
 	    hi = const_binop (MINUS_EXPR, etype, hi, lo);
@@ -3381,8 +3380,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
      (cmp { tem; } @1)))))
 
  /* Fold comparisons against built-in math functions.  */
- (if (flag_unsafe_math_optimizations
-      && ! flag_errno_math)
+ (if (flag_unsafe_math_optimizations && ! flag_errno_math)
   (for sq (SQRT)
    (simplify
     (cmp (sq @0) REAL_CST@1)
@@ -3417,56 +3415,108 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 	  if x is negative or NaN.  Due to -funsafe-math-optimizations,
 	  the results for other x follow from natural arithmetic.  */
        (cmp @0 @1)))
-     (if (cmp == GT_EXPR || cmp == GE_EXPR)
+     (if ((cmp == LT_EXPR
+	   || cmp == LE_EXPR
+	   || cmp == GT_EXPR
+	   || cmp == GE_EXPR)
+	  && !REAL_VALUE_ISNAN (TREE_REAL_CST (@1))
+	  /* Give up for -frounding-math.  */
+	  && !HONOR_SIGN_DEPENDENT_ROUNDING (TREE_TYPE (@0)))
       (with
        {
-         REAL_VALUE_TYPE c2;
+	 REAL_VALUE_TYPE c2;
+	 enum tree_code ncmp = cmp;
+	 const real_format *fmt
+	   = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (@0)));
 	 real_arithmetic (&c2, MULT_EXPR,
 			  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));
-	 real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);
-       }
-       (if (REAL_VALUE_ISINF (c2))
-	/* sqrt(x) > y is x == +Inf, when y is very large.  */
-	(if (HONOR_INFINITIES (@0))
-	 (eq @0 { build_real (TREE_TYPE (@0), c2); })
-	 { constant_boolean_node (false, type); })
-	/* sqrt(x) > c is the same as x > c*c.  */
-	(cmp @0 { build_real (TREE_TYPE (@0), c2); }))))
-     (if (cmp == LT_EXPR || cmp == LE_EXPR)
-      (with
-       {
-       	 REAL_VALUE_TYPE c2;
-	 real_arithmetic (&c2, MULT_EXPR,
-			  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));
-	 real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);
+	 real_convert (&c2, fmt, &c2);
+	 /* See PR91734: if c2 is inexact and sqrt(c2) < c (or sqrt(c2) >= c),
+	    then change LT_EXPR into LE_EXPR or GE_EXPR into GT_EXPR.  */
+	 if (!REAL_VALUE_ISINF (c2))
+	   {
+	     tree c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),
+					build_real (TREE_TYPE (@0), c2));
+	     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)
+	       ncmp = ERROR_MARK;
+	     else if ((cmp == LT_EXPR || cmp == GE_EXPR)
+		      && real_less (&TREE_REAL_CST (c3), &TREE_REAL_CST (@1)))
+	       ncmp = cmp == LT_EXPR ? LE_EXPR : GT_EXPR;
+	     else if ((cmp == LE_EXPR || cmp == GT_EXPR)
+		      && real_less (&TREE_REAL_CST (@1), &TREE_REAL_CST (c3)))
+	       ncmp = cmp == LE_EXPR ? LT_EXPR : GE_EXPR;
+	     else
+	       {
+		 /* With rounding to even, sqrt of up to 3 different values
+		    gives the same normal result, so in some cases c2 needs
+		    to be adjusted.  */
+		 REAL_VALUE_TYPE c2alt, tow;
+		 if (cmp == LT_EXPR || cmp == GE_EXPR)
+		   tow = dconst0;
+		 else
+		   real_inf (&tow);
+		 real_nextafter (&c2alt, fmt, &c2, &tow);
+		 real_convert (&c2alt, fmt, &c2alt);
+		 if (REAL_VALUE_ISINF (c2alt))
+		   ncmp = ERROR_MARK;
+		 else
+		   {
+		     c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),
+					   build_real (TREE_TYPE (@0), c2alt));
+		     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)
+		       ncmp = ERROR_MARK;
+		     else if (real_equal (&TREE_REAL_CST (c3),
+					  &TREE_REAL_CST (@1)))
+		       c2 = c2alt;
+		   }
+	       }
+	   }
        }
-       (if (REAL_VALUE_ISINF (c2))
-        (switch
-	 /* sqrt(x) < y is always true, when y is a very large
-	    value and we don't care about NaNs or Infinities.  */
-	 (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))
-	  { constant_boolean_node (true, type); })
-	 /* sqrt(x) < y is x != +Inf when y is very large and we
-	    don't care about NaNs.  */
-	 (if (! HONOR_NANS (@0))
-	  (ne @0 { build_real (TREE_TYPE (@0), c2); }))
-	 /* sqrt(x) < y is x >= 0 when y is very large and we
-	    don't care about Infinities.  */
-	 (if (! HONOR_INFINITIES (@0))
-	  (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))
-	 /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */
-	 (if (GENERIC)
-	  (truth_andif
-	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
-	   (ne @0 { build_real (TREE_TYPE (@0), c2); }))))
-	/* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */
-	(if (! HONOR_NANS (@0))
-	 (cmp @0 { build_real (TREE_TYPE (@0), c2); })
-	 /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */
-	 (if (GENERIC)
-	  (truth_andif
-	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
-	   (cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))
+       (if (cmp == GT_EXPR || cmp == GE_EXPR)
+	(if (REAL_VALUE_ISINF (c2))
+	 /* sqrt(x) > y is x == +Inf, when y is very large.  */
+	 (if (HONOR_INFINITIES (@0))
+	  (eq @0 { build_real (TREE_TYPE (@0), c2); })
+	  { constant_boolean_node (false, type); })
+	 /* sqrt(x) > c is the same as x > c*c.  */
+	 (if (ncmp != ERROR_MARK)
+	  (if (ncmp == GE_EXPR)
+	   (ge @0 { build_real (TREE_TYPE (@0), c2); })
+	   (gt @0 { build_real (TREE_TYPE (@0), c2); }))))
+	/* else if (cmp == LT_EXPR || cmp == LE_EXPR)  */
+	(if (REAL_VALUE_ISINF (c2))
+	 (switch
+	  /* sqrt(x) < y is always true, when y is a very large
+	     value and we don't care about NaNs or Infinities.  */
+	  (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))
+	   { constant_boolean_node (true, type); })
+	  /* sqrt(x) < y is x != +Inf when y is very large and we
+	     don't care about NaNs.  */
+	  (if (! HONOR_NANS (@0))
+	   (ne @0 { build_real (TREE_TYPE (@0), c2); }))
+	  /* sqrt(x) < y is x >= 0 when y is very large and we
+	     don't care about Infinities.  */
+	  (if (! HONOR_INFINITIES (@0))
+	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))
+	  /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */
+	  (if (GENERIC)
+	   (truth_andif
+	    (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	    (ne @0 { build_real (TREE_TYPE (@0), c2); }))))
+	 /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */
+	 (if (ncmp != ERROR_MARK && ! HONOR_NANS (@0))
+	  (if (ncmp == LT_EXPR)
+	   (lt @0 { build_real (TREE_TYPE (@0), c2); })
+	   (le @0 { build_real (TREE_TYPE (@0), c2); }))
+	  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */
+	  (if (ncmp != ERROR_MARK && GENERIC)
+	   (if (ncmp == LT_EXPR)
+	    (truth_andif
+	     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	     (lt @0 { build_real (TREE_TYPE (@0), c2); }))
+	    (truth_andif
+	     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	     (le @0 { build_real (TREE_TYPE (@0), c2); })))))))))))
    /* Transform sqrt(x) cmp sqrt(y) -> x cmp y.  */
    (simplify
     (cmp (sq @0) (sq @1))
diff --git a/gcc/modulo-sched.c b/gcc/modulo-sched.c
index 9954ea5cfa1..059b5440123 100644
--- a/gcc/modulo-sched.c
+++ b/gcc/modulo-sched.c
@@ -3201,7 +3201,7 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, int n,
    			     int c, sbitmap must_precede,
 			     sbitmap must_follow)
 {
-  int has_conflicts = 0;
+  int i, first, amount, has_conflicts = 0;
   ps_insn_ptr ps_i;
 
   /* First add the node to the PS, if this succeeds check for
@@ -3209,23 +3209,32 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, int n,
   if (! (ps_i = add_node_to_ps (ps, n, c, must_precede, must_follow)))
     return NULL; /* Failed to insert the node at the given cycle.  */
 
-  has_conflicts = ps_has_conflicts (ps, c, c)
-		  || (ps->history > 0
-		      && ps_has_conflicts (ps,
-					   c - ps->history,
-					   c + ps->history));
-
-  /* Try different issue slots to find one that the given node can be
-     scheduled in without conflicts.  */
-  while (has_conflicts)
+  while (1)
     {
+      has_conflicts = ps_has_conflicts (ps, c, c);
+      if (ps->history > 0 && !has_conflicts)
+	{
+	  /* Check all 2h+1 intervals, starting from c-2h..c up to c..2h,
+	     but not more than ii intervals.  */
+	  first = c - ps->history;
+	  amount = 2 * ps->history + 1;
+	  if (amount > ps->ii)
+	    amount = ps->ii;
+	  for (i = first; i < first + amount; i++)
+	    {
+	      has_conflicts = ps_has_conflicts (ps,
+						i - ps->history,
+						i + ps->history);
+	      if (has_conflicts)
+		break;
+	    }
+	}
+      if (!has_conflicts)
+	break;
+      /* Try different issue slots to find one that the given node can be
+	 scheduled in without conflicts.  */
       if (! ps_insn_advance_column (ps, ps_i, must_follow))
 	break;
-      has_conflicts = ps_has_conflicts (ps, c, c)
-		      || (ps->history > 0
-			  && ps_has_conflicts (ps,
-					       c - ps->history,
-					       c + ps->history));
     }
 
   if (has_conflicts)
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index f9ab91aafaa..813cefd69b9 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -444,18 +444,30 @@ use_pointer_for_field (tree decl, omp_context *shared_ctx)
 	  omp_context *up;
 
 	  for (up = shared_ctx->outer; up; up = up->outer)
-	    if (is_taskreg_ctx (up) && maybe_lookup_decl (decl, up))
+	    if ((is_taskreg_ctx (up)
+		 || (gimple_code (up->stmt) == GIMPLE_OMP_TARGET
+		     && is_gimple_omp_offloaded (up->stmt)))
+		&& maybe_lookup_decl (decl, up))
 	      break;
 
 	  if (up)
 	    {
 	      tree c;
 
-	      for (c = gimple_omp_taskreg_clauses (up->stmt);
-		   c; c = OMP_CLAUSE_CHAIN (c))
-		if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
-		    && OMP_CLAUSE_DECL (c) == decl)
-		  break;
+	      if (gimple_code (up->stmt) == GIMPLE_OMP_TARGET)
+		{
+		  for (c = gimple_omp_target_clauses (up->stmt);
+		       c; c = OMP_CLAUSE_CHAIN (c))
+		    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP
+			&& OMP_CLAUSE_DECL (c) == decl)
+		      break;
+		}
+	      else
+		for (c = gimple_omp_taskreg_clauses (up->stmt);
+		     c; c = OMP_CLAUSE_CHAIN (c))
+		  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
+		      && OMP_CLAUSE_DECL (c) == decl)
+		    break;
 
 	      if (c)
 		goto maybe_mark_addressable_and_ret;
@@ -3041,6 +3053,16 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)
       }
       break;
     case GIMPLE_OMP_TEAMS:
+      if ((ctx == NULL
+           || gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET
+           || gimple_omp_target_kind (ctx->stmt) != GF_OMP_TARGET_KIND_REGION)
+	  && lang_GNU_Fortran ())
+	{
+	  error_at (gimple_location (stmt),
+		    "%<teams%> construct not closely nested inside of "
+		    "%<target%> construct");
+	  return false;
+	}
       if (ctx == NULL)
 	break;
       else if (gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET
@@ -3338,7 +3360,14 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,
       break;
 
     case GIMPLE_OMP_TARGET:
-      scan_omp_target (as_a <gomp_target *> (stmt), ctx);
+      if (is_gimple_omp_offloaded (stmt))
+	{
+	  taskreg_nesting_level++;
+	  scan_omp_target (as_a <gomp_target *> (stmt), ctx);
+	  taskreg_nesting_level--;
+	}
+      else
+	scan_omp_target (as_a <gomp_target *> (stmt), ctx);
       break;
 
     case GIMPLE_OMP_TEAMS:
diff --git a/gcc/omp-simd-clone.c b/gcc/omp-simd-clone.c
index 472e2025e19..e865828f569 100644
--- a/gcc/omp-simd-clone.c
+++ b/gcc/omp-simd-clone.c
@@ -498,7 +498,6 @@ simd_clone_adjust_return_type (struct cgraph_node *node)
   /* Adjust the function return type.  */
   if (orig_rettype == void_type_node)
     return NULL_TREE;
-  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));
   t = TREE_TYPE (TREE_TYPE (fndecl));
   if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))
     veclen = node->simdclone->vecsize_int;
@@ -724,11 +723,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)
 	  else
 	    new_reversed = void_list_node;
 	}
-
-      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));
-      TYPE_ARG_TYPES (new_type) = new_reversed;
-      TREE_TYPE (node->decl) = new_type;
-
+      TYPE_ARG_TYPES (TREE_TYPE (node->decl)) = new_reversed;
       adjustments.release ();
     }
   args.release ();
@@ -1164,6 +1159,7 @@ simd_clone_adjust (struct cgraph_node *node)
 {
   push_cfun (DECL_STRUCT_FUNCTION (node->decl));
 
+  TREE_TYPE (node->decl) = build_distinct_type_copy (TREE_TYPE (node->decl));
   targetm.simd_clone.adjust (node);
 
   tree retval = simd_clone_adjust_return_type (node);
@@ -1707,14 +1703,22 @@ expand_simd_clones (struct cgraph_node *node)
 	     already.  */
 	  tree id = simd_clone_mangle (node, clone);
 	  if (id == NULL_TREE)
-	    continue;
+	    {
+	      if (i == 0)
+		clone->nargs += clone->inbranch;
+	      continue;
+	    }
 
 	  /* Only when we are sure we want to create the clone actually
 	     clone the function (or definitions) or create another
 	     extern FUNCTION_DECL (for prototypes without definitions).  */
 	  struct cgraph_node *n = simd_clone_create (node);
 	  if (n == NULL)
-	    continue;
+	    {
+	      if (i == 0)
+		clone->nargs += clone->inbranch;
+	      continue;
+	    }
 
 	  n->simdclone = clone;
 	  clone->origin = node;
@@ -1737,6 +1741,8 @@ expand_simd_clones (struct cgraph_node *node)
 	    simd_clone_adjust (n);
 	  else
 	    {
+	      TREE_TYPE (n->decl)
+		= build_distinct_type_copy (TREE_TYPE (n->decl));
 	      targetm.simd_clone.adjust (n);
 	      simd_clone_adjust_return_type (n);
 	      simd_clone_adjust_argument_types (n);
diff --git a/gcc/optabs.c b/gcc/optabs.c
index a0e361b8bfe..7d7efe0a4a2 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -5819,6 +5819,25 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
   if (icode == CODE_FOR_nothing)
     {
+      if (tcode == LT_EXPR
+	  && op0a == op0
+	  && TREE_CODE (op0) == VECTOR_CST)
+	{
+	  /* A VEC_COND_EXPR condition could be folded from EQ_EXPR/NE_EXPR
+	     into a constant when only get_vcond_eq_icode is supported.
+	     Verify < 0 and != 0 behave the same and change it to NE_EXPR.  */
+	  unsigned HOST_WIDE_INT nelts;
+	  if (!VECTOR_CST_NELTS (op0).is_constant (&nelts))
+	    {
+	      if (VECTOR_CST_STEPPED_P (op0))
+		return 0;
+	      nelts = vector_cst_encoded_nelts (op0);
+	    }
+	  for (unsigned int i = 0; i < nelts; ++i)
+	    if (tree_int_cst_sgn (vector_cst_elt (op0, i)) == 1)
+	      return 0;
+	  tcode = NE_EXPR;
+	}
       if (tcode == EQ_EXPR || tcode == NE_EXPR)
 	icode = get_vcond_eq_icode (mode, cmp_op_mode);
       if (icode == CODE_FOR_nothing)
diff --git a/gcc/optc-save-gen.awk b/gcc/optc-save-gen.awk
index 74096bc5462..cf1c3689eff 100644
--- a/gcc/optc-save-gen.awk
+++ b/gcc/optc-save-gen.awk
@@ -332,7 +332,7 @@ for (i = 0; i < n_opt_string; i++) {
 	print "             indent_to, \"\",";
 	print "             \"" name "\",";
 	print "             ptr1->x_" name " ? ptr1->x_" name " : \"(null)\",";
-	print "             ptr2->x_" name " ? ptr1->x_" name " : \"(null)\");";
+	print "             ptr2->x_" name " ? ptr2->x_" name " : \"(null)\");";
 	print "";
 }
 
diff --git a/gcc/output.h b/gcc/output.h
index 835d63556e6..e4017bb6b8e 100644
--- a/gcc/output.h
+++ b/gcc/output.h
@@ -236,6 +236,12 @@ extern void assemble_label (FILE *, const char *);
    addition of an underscore).  */
 extern void assemble_name_raw (FILE *, const char *);
 
+/* Return NAME that should actually be emitted, looking through
+   transparent aliases.  If NAME refers to an entity that is also
+   represented as a tree (like a function or variable), mark the entity
+   as referenced.  */
+extern const char *assemble_name_resolve (const char *);
+
 /* Like assemble_name_raw, but should be used when NAME might refer to
    an entity that is also represented as a tree (like a function or
    variable).  If NAME does refer to such an entity, that entity will
diff --git a/gcc/params.def b/gcc/params.def
index 813dc55d94c..8e4887e50a2 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -419,7 +419,7 @@ DEFPARAM(PARAM_SMS_MIN_SC,
 DEFPARAM(PARAM_SMS_DFA_HISTORY,
 	 "sms-dfa-history",
 	 "The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.",
-	 0, 0, 0)
+	 0, 0, 16)
 DEFPARAM(PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD,
 	 "sms-loop-average-count-threshold",
 	 "A threshold on the average loop count considered by the swing modulo scheduler.",
diff --git a/gcc/passes.c b/gcc/passes.c
index d8d479a1c17..e071a878301 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -1646,24 +1646,39 @@ do_per_function (void (*callback) (function *, void *data), void *data)
     }
 }
 
-/* Because inlining might remove no-longer reachable nodes, we need to
-   keep the array visible to garbage collector to avoid reading collected
-   out nodes.  */
-static int nnodes;
-static GTY ((length ("nnodes"))) cgraph_node **order;
-
-#define uid_hash_t hash_set<int_hash <int, 0, -1> >
-
 /* Hook called when NODE is removed and therefore should be
    excluded from order vector.  DATA is a hash set with removed nodes.  */
 
 static void
 remove_cgraph_node_from_order (cgraph_node *node, void *data)
 {
-  uid_hash_t *removed_nodes = (uid_hash_t *)data;
-  removed_nodes->add (node->get_uid ());
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  removed_nodes->add (node);
+}
+
+/* Hook called when NODE is insert and therefore should be
+   excluded from removed_nodes.  DATA is a hash set with removed nodes.  */
+
+static void
+insert_cgraph_node_to_order (cgraph_node *node, void *data)
+{
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  removed_nodes->remove (node);
+}
+
+/* Hook called when NODE is duplicated and therefore should be
+   excluded from removed_nodes.  DATA is a hash set with removed nodes.  */
+
+static void
+duplicate_cgraph_node_to_order (cgraph_node *node, cgraph_node *node2,
+				void *data)
+{
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  gcc_checking_assert (!removed_nodes->contains (node));
+  removed_nodes->remove (node2);
 }
 
+
 /* If we are in IPA mode (i.e., current_function_decl is NULL), call
    function CALLBACK for every function in the call graph.  Otherwise,
    call CALLBACK on the current function.
@@ -1677,26 +1692,30 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)
     callback (cfun, data);
   else
     {
-      cgraph_node_hook_list *hook;
-      uid_hash_t removed_nodes;
-      gcc_assert (!order);
-      order = ggc_vec_alloc<cgraph_node *> (symtab->cgraph_count);
+      hash_set<cgraph_node *> removed_nodes;
+      unsigned nnodes = symtab->cgraph_count;
+      cgraph_node **order = XNEWVEC (cgraph_node *, nnodes);
 
       nnodes = ipa_reverse_postorder (order);
       for (i = nnodes - 1; i >= 0; i--)
 	order[i]->process = 1;
-      hook = symtab->add_cgraph_removal_hook (remove_cgraph_node_from_order,
-					      &removed_nodes);
+      cgraph_node_hook_list *removal_hook
+	= symtab->add_cgraph_removal_hook (remove_cgraph_node_from_order,
+					   &removed_nodes);
+      cgraph_node_hook_list *insertion_hook
+	= symtab->add_cgraph_insertion_hook (insert_cgraph_node_to_order,
+					     &removed_nodes);
+      cgraph_2node_hook_list *duplication_hook
+	= symtab->add_cgraph_duplication_hook (duplicate_cgraph_node_to_order,
+					       &removed_nodes);
       for (i = nnodes - 1; i >= 0; i--)
 	{
 	  cgraph_node *node = order[i];
 
 	  /* Function could be inlined and removed as unreachable.  */
-	  if (node == NULL || removed_nodes.contains (node->get_uid ()))
+	  if (node == NULL || removed_nodes.contains (node))
 	    continue;
 
-	  /* Allow possibly removed nodes to be garbage collected.  */
-	  order[i] = NULL;
 	  node->process = 0;
 	  if (node->has_gimple_body_p ())
 	    {
@@ -1706,11 +1725,12 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)
 	      pop_cfun ();
 	    }
 	}
-      symtab->remove_cgraph_removal_hook (hook);
+      symtab->remove_cgraph_removal_hook (removal_hook);
+      symtab->remove_cgraph_insertion_hook (insertion_hook);
+      symtab->remove_cgraph_duplication_hook (duplication_hook);
+
+      free (order);
     }
-  ggc_free (order);
-  order = NULL;
-  nnodes = 0;
 }
 
 /* Helper function to perform function body dump.  */
@@ -2699,20 +2719,12 @@ ipa_write_summaries (void)
     {
       struct cgraph_node *node = order[i];
 
-      if (gimple_has_body_p (node->decl))
+      if (node->definition && node->need_lto_streaming)
 	{
-	  /* When streaming out references to statements as part of some IPA
-	     pass summary, the statements need to have uids assigned and the
-	     following does that for all the IPA passes here. Naturally, this
-	     ordering then matches the one IPA-passes get in their stmt_fixup
-	     hooks.  */
-
-	  push_cfun (DECL_STRUCT_FUNCTION (node->decl));
-	  renumber_gimple_stmt_uids ();
-	  pop_cfun ();
+	  if (gimple_has_body_p (node->decl))
+	    lto_prepare_function_for_streaming (node);
+	  lto_set_symtab_encoder_in_partition (encoder, node);
 	}
-      if (node->definition && node->need_lto_streaming)
-        lto_set_symtab_encoder_in_partition (encoder, node);
     }
 
   FOR_EACH_DEFINED_FUNCTION (node)
@@ -2780,28 +2792,13 @@ void
 ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)
 {
   struct lto_out_decl_state *state = lto_new_out_decl_state ();
-  lto_symtab_encoder_iterator lsei;
   state->symtab_node_encoder = encoder;
 
   lto_output_init_mode_table ();
   lto_push_out_decl_state (state);
-  for (lsei = lsei_start_function_in_partition (encoder);
-       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))
-    {
-      struct cgraph_node *node = lsei_cgraph_node (lsei);
-      /* When streaming out references to statements as part of some IPA
-	 pass summary, the statements need to have uids assigned.
-
-	 For functions newly born at WPA stage we need to initialize
-	 the uids here.  */
-      if (node->definition
-	  && gimple_has_body_p (node->decl))
-	{
-	  push_cfun (DECL_STRUCT_FUNCTION (node->decl));
-	  renumber_gimple_stmt_uids ();
-	  pop_cfun ();
-	}
-    }
+
+  /* Be sure that we did not forget to renumber stmt uids.  */
+  gcc_checking_assert (flag_wpa);
 
   gcc_assert (flag_wpa);
   pass_manager *passes = g->get_passes ();
@@ -3060,5 +3057,3 @@ function_called_by_processed_nodes_p (void)
     }
   return e != NULL;
 }
-
-#include "gt-passes.h"
diff --git a/gcc/passes.def b/gcc/passes.def
index bc147c4444d..9a859070b26 100644
--- a/gcc/passes.def
+++ b/gcc/passes.def
@@ -434,6 +434,7 @@ along with GCC; see the file COPYING3.  If not see
       NEXT_PASS (pass_ud_rtl_dce);
       NEXT_PASS (pass_combine);
       NEXT_PASS (pass_if_after_combine);
+      NEXT_PASS (pass_jump_after_combine);
       NEXT_PASS (pass_partition_blocks);
       NEXT_PASS (pass_outof_cfg_layout_mode);
       NEXT_PASS (pass_split_all_insns);
@@ -450,7 +451,6 @@ along with GCC; see the file COPYING3.  If not see
       NEXT_PASS (pass_reload);
       NEXT_PASS (pass_postreload);
       PUSH_INSERT_PASSES_WITHIN (pass_postreload)
-	  NEXT_PASS (pass_postreload_jump);
 	  NEXT_PASS (pass_postreload_cse);
 	  NEXT_PASS (pass_gcse2);
 	  NEXT_PASS (pass_split_after_reload);
diff --git a/gcc/po/ChangeLog b/gcc/po/ChangeLog
index e0186084236..624685bfb5e 100644
--- a/gcc/po/ChangeLog
+++ b/gcc/po/ChangeLog
@@ -1,3 +1,31 @@
+2020-01-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* zh_TW.po: Update.
+
+2019-12-30  Joseph Myers  <joseph@codesourcery.com>
+
+	* fi.po: Update.
+
+2019-10-11  Joseph Myers  <joseph@codesourcery.com>
+
+	* fi.po: Update.
+
+2019-09-30  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-31  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-23  Joseph Myers  <joseph@codesourcery.com>
+
+	* zh_CN.po: Update.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/po/es.po b/gcc/po/es.po
index 2f3a21984ac..c6eed017b3f 100644
--- a/gcc/po/es.po
+++ b/gcc/po/es.po
@@ -43,7 +43,7 @@ msgstr ""
 "Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2019-05-17 05:23+0200\n"
+"PO-Revision-Date: 2019-09-30 17:16+0200\n"
 "Last-Translator: Antonio Ceballos Roa <aceballos@gmail.com>\n"
 "Language-Team: Spanish <es@tp.org.es>\n"
 "Language: es\n"
@@ -174,17 +174,11 @@ msgstr "compilación terminada.\n"
 
 #: diagnostic.c:618
 msgid "In file included from"
-msgstr ""
+msgstr "En el fichero incluido desde"
 
 #: diagnostic.c:619
-#, fuzzy
-#| msgid ""
-#| ",\n"
-#| "                 from %s:%u"
 msgid "                 from"
-msgstr ""
-",\n"
-"                 de %s:%u"
+msgstr "                 desde"
 
 #: diagnostic.c:991
 #, c-format
@@ -796,10 +790,9 @@ msgstr ""
 "%s.\n"
 
 #: gcov-tool.c:528
-#, fuzzy, c-format
-#| msgid "Copyright %s 2018 Free Software Foundation, Inc.\n"
+#, c-format
 msgid "Copyright %s 2019 Free Software Foundation, Inc.\n"
-msgstr "Copyright %s 2018 Free Software Foundation, Inc.\n"
+msgstr "Copyright %s 2019 Free Software Foundation, Inc.\n"
 
 #: gcov-tool.c:531 gcov.c:925
 #, c-format
@@ -867,10 +860,9 @@ msgid "  -h, --help                      Print this help, then exit\n"
 msgstr "  -h, --help                      Muestra esta información, y finaliza\n"
 
 #: gcov.c:894
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -i, --json-format               Output JSON intermediate format into .gcov.json.gz file\n"
-msgstr "  -n, --no-output                 No crea un fichero de salida\n"
+msgstr "  -i, --json-format               Salida con formato JSON intermedia en el fichero .gcov.json.gz\n"
 
 #: gcov.c:895
 #, c-format
@@ -912,10 +904,9 @@ msgid "  -p, --preserve-paths            Preserve all pathname components\n"
 msgstr "  -p, --preserve-paths            Preserva todos los nombres de ruta de los componentes\n"
 
 #: gcov.c:903
-#, fuzzy, c-format
-#| msgid "  -k, --use-colors                Emit colored output\n"
+#, c-format
 msgid "  -q, --use-hotness-colors        Emit perf-like colored output for hot lines\n"
-msgstr "  -k, --use-colors                Emite salida con colores\n"
+msgstr "  -q, --use-hotness-colors        Emite salida con colores de tipo perf para las líneas calientes\n"
 
 #: gcov.c:904
 #, c-format
@@ -928,10 +919,9 @@ msgid "  -s, --source-prefix DIR         Source prefix to elide\n"
 msgstr "  -s, --source-prefix DIR         Prefijo de fuente a omitir\n"
 
 #: gcov.c:906
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -t, --stdout                    Output to stdout instead of a file\n"
-msgstr "  -n, --no-output                 No crea un fichero de salida\n"
+msgstr "  -t, --stdout                    Salida en stdout en lugar de un fichero\n"
 
 #: gcov.c:907
 #, c-format
@@ -959,10 +949,9 @@ msgid "gcov %s%s\n"
 msgstr "gcov %s%s\n"
 
 #: gcov.c:1250
-#, fuzzy, c-format
-#| msgid "Treat the input file as already preprocessed."
+#, c-format
 msgid "'%s' file is already processed\n"
-msgstr "Trata al fichero de entrada como previamente preprocesado."
+msgstr "El fichero '%s' ya está procesado\n"
 
 #: gcov.c:1364
 #, c-format
@@ -990,16 +979,14 @@ msgid "\n"
 msgstr "\n"
 
 #: gcov.c:1489
-#, fuzzy, c-format
-#| msgid "%s: Cannot open output file: %s\n"
+#, c-format
 msgid "Cannot open JSON output file %s\n"
-msgstr "%s: No se puede abrir el fichero de salida: %s\n"
+msgstr "No se puede abrir el fichero de salida JSON %s\n"
 
 #: gcov.c:1497
-#, fuzzy, c-format
-#| msgid "Error writing output file '%s'\n"
+#, c-format
 msgid "Error writing JSON output file %s\n"
-msgstr "Error al escribir el fichero de salida '%s'\n"
+msgstr "Error al escribir el fichero de salida JSON %s\n"
 
 #: gcov.c:1664
 #, c-format
@@ -1266,10 +1253,8 @@ msgid "this is the insn:"
 msgstr "este es la insn:"
 
 #: lra-constraints.c:2971
-#, fuzzy
-#| msgid "unable to generate reloads for:"
 msgid "unable to generate reloads for impossible constraints:"
-msgstr "no se pueden generar recargas para:"
+msgstr "no se pueden generar recargas para restricciones imposibles:"
 
 #: lra-constraints.c:3962 reload.c:3814
 msgid "unable to generate reloads for:"
@@ -1327,12 +1312,13 @@ msgid " All options with the desired characteristics have already been displayed
 msgstr "Ya se mostraron todas las opciones con las características deseadas\n"
 
 #: opts.c:1581
-#, fuzzy, c-format
-#| msgid "invalid argument %qs to %qs"
+#, c-format
 msgid ""
 "  Known valid arguments for %s option:\n"
 "   "
-msgstr "argumento %qs no válido para %qs"
+msgstr ""
+"  Argumentos válidos conocidos para la opción %s:\n"
+"   "
 
 #: opts.c:1631
 msgid "The following options are target specific"
@@ -1430,16 +1416,12 @@ msgid "created and used with differing settings of '%s'"
 msgstr "creado y usado con diferentes opciones de '%s'"
 
 #: targhooks.c:2038
-#, fuzzy
-#| msgid "created and used with different settings of -fpic"
 msgid "created and used with different settings of %<-fpic%>"
-msgstr "creado y usado con diferentes opciones de -fpic"
+msgstr "creado y usado con diferentes opciones de %<-fpic%>"
 
 #: targhooks.c:2040
-#, fuzzy
-#| msgid "created and used with different settings of -fpie"
 msgid "created and used with different settings of %<-fpie%>"
-msgstr "creado y usado con diferentes opciones de -fpie"
+msgstr "creado y usado con diferentes opciones de %<-fpie%>"
 
 #: tlink.c:387
 #, c-format
@@ -1703,16 +1685,14 @@ msgid "The maximum number of instructions when inlining for size."
 msgstr "El número máximo de instrucciones cuando se hace inclusión en línea por tamaño."
 
 #: params.def:97
-#, fuzzy, no-c-format
-#| msgid "Use subroutines for function prologues and epilogues."
+#, no-c-format
 msgid "Instruction accounted for function prologue, epilogue and other overhead."
-msgstr "Usa subrutinas para los prólogos y epílogos de función."
+msgstr "Instrucción contabilizada para el prólogo y epílogo de la función y otras sobrecargas."
 
 #: params.def:103
-#, fuzzy, no-c-format
-#| msgid "Use subroutines for function prologues and epilogues."
+#, no-c-format
 msgid "Time accounted for function prologue, epilogue and other overhead."
-msgstr "Usa subrutinas para los prólogos y epílogos de función."
+msgstr "Tiempo contabilizado para el prólogo y epílogo de la función y otras sobrecargas."
 
 #: params.def:109
 #, no-c-format
@@ -1946,10 +1926,9 @@ msgstr "El número máximo de eliminación de opciones en un solo bucle."
 
 # 'desfactorizar' no me gusta. ¿Alguna sugerencia? - cfuga
 #: params.def:393
-#, fuzzy, no-c-format
-#| msgid "The maximum number of insns to duplicate when unfactoring computed gotos."
+#, no-c-format
 msgid "The maximum number of insns in loop header duplicated by the copy loop headers pass."
-msgstr "El número máximo de insns a duplicar al desfactorizar gotos calculados."
+msgstr "El número máximo de instrucciones en encabezamiento de bucle a duplicar en el paso de encabezamientos de bucles."
 
 #: params.def:400
 #, no-c-format
@@ -1982,16 +1961,14 @@ msgid "A threshold on the average loop count considered by the swing modulo sche
 msgstr "Umbral en el número promedio de bucles considerado por el planificador de cambio de módulo."
 
 #: params.def:430
-#, fuzzy, no-c-format
-#| msgid "Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot"
+#, no-c-format
 msgid "Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot (used in non-LTO mode)."
-msgstr "La selección de fracción de la cuenta maximal de repeticiones del bloque básico en el bloque básico dado de programa que necesita para ser considerado caliente"
+msgstr "La selección de fracción de la cuenta maximal de repeticiones del bloque básico en el bloque básico dado de programa que necesita para ser considerado caliente (utilizado en modo no LTO)."
 
 #: params.def:435
-#, fuzzy, no-c-format
-#| msgid "A basic block profile count is considered hot if it contributes to the given permillage of the entire profiled execution."
+#, no-c-format
 msgid "A basic block profile count is considered hot if it contributes to the given permillage of the entire profiled execution (used in LTO mode)."
-msgstr "El número de perfiles de bloque básicos se considera caliente si contribuye al pormillaje dado de la ejecución perfilada completa."
+msgstr "El número de perfiles de bloque básicos se considera caliente si contribuye al pormillaje dado de la ejecución perfilada completa (utilizado en modo LTO)."
 
 #: params.def:440
 #, no-c-format
@@ -2009,8 +1986,7 @@ msgid "Select fraction of the maximal frequency of executions of basic block in
 msgstr "Selección de fracción de la frecuencia máxima de ejecuciones de bloque básico en la función dada para la que el bloque básico consigue alinear."
 
 #: params.def:455
-#, fuzzy, no-c-format
-#| msgid "Loops iterating at least selected number of iterations will get loop alignment.."
+#, no-c-format
 msgid "Loops iterating at least selected number of iterations will get loop alignment."
 msgstr "Iterar ciclos por lo menos el número seleccionado de iteraciones que logrará alineación de bucles."
 
@@ -2121,10 +2097,9 @@ msgid "Maximum size (in bytes) of objects tracked bytewise by dead store elimina
 msgstr "Número máximo (en bytes) de objetos rastreados en btyes por la eliminación de almacenamiento muerto."
 
 #: params.def:593
-#, fuzzy, no-c-format
-#| msgid "Maximum number of times that an insn could be scheduled."
+#, no-c-format
 msgid "Maximum number of queries into the alias oracle per store."
-msgstr "El número máximo de veces que se puede planificar una insns."
+msgstr "El número máximo de consultas al oráculo de alias por almacenamiento."
 
 #: params.def:598
 #, no-c-format
@@ -2495,22 +2470,19 @@ msgid "Maximum size of a list of values associated with each parameter for inter
 msgstr "Tamaño máximo de una lista de valores asociada con cada parámetro para propagación constante entre procedimientos."
 
 #: params.def:1092
-#, fuzzy, no-c-format
-#| msgid "Threshold ipa-cp opportunity evaluation that is still considered beneficial to clone.."
+#, no-c-format
 msgid "Threshold ipa-cp opportunity evaluation that is still considered beneficial to clone."
-msgstr "Rango de evaluación de oportunidad ipa-cp que aún se considera beneficioso para clonar.."
+msgstr "Rango de evaluación de oportunidad ipa-cp que aún se considera beneficioso para clonar."
 
 #: params.def:1098
-#, fuzzy, no-c-format
-#| msgid "Percentage penalty the recursive functions will receive when they are evaluated for cloning.."
+#, no-c-format
 msgid "Percentage penalty the recursive functions will receive when they are evaluated for cloning."
-msgstr "Penalización porcentual que recibirán las funciones recursivas cuando se evalúen para clonación.."
+msgstr "Penalización porcentual que recibirán las funciones recursivas cuando se evalúen para clonación."
 
 #: params.def:1104
-#, fuzzy, no-c-format
-#| msgid "Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning.."
+#, no-c-format
 msgid "Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning."
-msgstr "Penalización porcentual que recibirán las funciones que contien una sola llamada a otra función cuando se evalúen para clonación.."
+msgstr "Penalización porcentual que recibirán las funciones que contien una sola llamada a otra función cuando se evalúen para clonación."
 
 #: params.def:1110
 #, no-c-format
@@ -2518,16 +2490,14 @@ msgid "Maximum number of aggregate content items for a parameter in jump functio
 msgstr "Número máximo de elementos de contenido agregado de un parámetro en funciones de salto y celosías."
 
 #: params.def:1116
-#, fuzzy, no-c-format
-#| msgid "Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known.."
+#, no-c-format
 msgid "Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known."
-msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan a conocer los límites o los pasos de los bucles.."
+msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan a conocer los límites o los pasos de los bucles."
 
 #: params.def:1122
-#, fuzzy, no-c-format
-#| msgid "Compile-time bonus IPA-CP assigns to candidates which make an array index known.."
+#, no-c-format
 msgid "Compile-time bonus IPA-CP assigns to candidates which make an array index known."
-msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan conocer el índice de un array.."
+msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan conocer el índice de un array."
 
 #: params.def:1128
 #, no-c-format
@@ -2576,10 +2546,9 @@ msgid "Allow new data races on stores to be introduced."
 msgstr "Permite que se introduzcan carreras de datos nuevos en stores."
 
 #: params.def:1187
-#, fuzzy, no-c-format
-#| msgid "Set the maximum number of instructions executed in parallel in reassociated tree. If 0, use the target dependent heuristic.."
+#, no-c-format
 msgid "Set the maximum number of instructions executed in parallel in reassociated tree.  If 0, use the target dependent heuristic."
-msgstr "Establece el número máximo de instrucciones ejecutadas en paralelo en el árbol de reasociación. Si es 0, usa la heurística dependiente del objetivo.."
+msgstr "Establece el número máximo de instrucciones ejecutadas en paralelo en el árbol de reasociación. Si es 0, usa la heurística dependiente del objetivo."
 
 #: params.def:1193
 #, no-c-format
@@ -2748,10 +2717,9 @@ msgid "Maximum number of may-defs visited when devirtualizing speculatively."
 msgstr "Número máximo de definiciones posibles visitadas cuando se desvirtualiza especulativamente."
 
 #: params.def:1375
-#, fuzzy, no-c-format
-#| msgid "Maximum number of constant stores to merge in the store merging pass."
+#, no-c-format
 msgid "Maximum number of assertions to add along the default edge of a switch statement during VRP."
-msgstr "Número máximo de almacenamientos constantes que hay que mezclar en el paso de mezcla de almacenamientos."
+msgstr "Número máximo de aserciones que hay que añadir a lo largo del borde predefinido de una sentencia switch durante VRP."
 
 #: params.def:1381
 #, no-c-format
@@ -2766,7 +2734,7 @@ msgstr ""
 #: params.def:1391
 #, no-c-format
 msgid "Maximum unroll factor for the unroll-and-jam transformation."
-msgstr ""
+msgstr "Máximo factor de desenrrollado para la transformación unroll-and-jam."
 
 #: params.def:1396
 #, no-c-format
@@ -2776,19 +2744,17 @@ msgstr "Número máximo de bits para el cual evitamos crear FMAs."
 #: params.def:1401
 #, no-c-format
 msgid "True if a non-short-circuit operation is optimal."
-msgstr ""
+msgstr "Verdadero si una operación de non-short-circuit es óptima."
 
 #: params.def:1406
-#, fuzzy, no-c-format
-#| msgid "Maximum number of instructions in basic block to be considered for SLP vectorization."
+#, no-c-format
 msgid "The maximum number of instructions in an inner loop that is being considered for versioning."
-msgstr "El número máximo de instrucciones en bloque básico que se consideran para vectorización SLP."
+msgstr "El número máximo de instrucciones en un bucle interior que se consideran para versionar."
 
 #: params.def:1412
-#, fuzzy, no-c-format
-#| msgid "The maximum number of instructions to consider to unroll in a loop."
+#, no-c-format
 msgid "The maximum number of instructions in an outer loop that is being considered for versioning, on top of the instructions in inner loops."
-msgstr "El número máximo de instrucciones para considerar el desenrollo en un bucle."
+msgstr "El número máximo de instrucciones ien un bucle exterior que se consideran para versionar, por encima de las instrucciones en los bucles interiores."
 
 #: c-family/c-format.c:404
 msgid "format"
@@ -3655,15 +3621,14 @@ msgstr "operando output_condmove_single erróneo"
 #: config/gcn/gcn.c:5637 config/gcn/gcn.c:5648 config/gcn/gcn.c:5651
 #, c-format
 msgid "bad ADDR_SPACE_GLOBAL address"
-msgstr ""
+msgstr "dirección ADDR_SPACE_GLOBAL errónea"
 
 #: config/gcn/gcn.c:5423 config/gcn/gcn.c:5446 config/gcn/gcn.c:5475
 #: config/gcn/gcn.c:5491 config/gcn/gcn.c:5510 config/gcn/gcn.c:5586
 #: config/gcn/gcn.c:5782 config/gcn/gcn.c:5879
-#, fuzzy, c-format
-#| msgid "invalid operand to %%Z code"
+#, c-format
 msgid "invalid operand %%xn code"
-msgstr "operando no válido para el código %%Z"
+msgstr "operando no válido para el código %%xn"
 
 #: config/gcn/gcn.c:5949
 #, c-format
@@ -3962,22 +3927,19 @@ msgid "invalid zero extract"
 msgstr "extracto de cero no válido"
 
 #: config/or1k/or1k.c:1124 config/or1k/or1k.c:1132
-#, fuzzy, c-format
-#| msgid "invalid operation"
+#, c-format
 msgid "invalid relocation"
-msgstr "operación no válida"
+msgstr "reubicación no válida"
 
 #: config/or1k/or1k.c:1226
-#, fuzzy, c-format
-#| msgid "invalid %H value"
+#, c-format
 msgid "invalid %%H value"
-msgstr "valor %H no válido"
+msgstr "valor %%H no válido"
 
 #: config/or1k/or1k.c:1274
-#, fuzzy, c-format
-#| msgid "unknown punctuation '%c'"
+#, c-format
 msgid "unknown operand letter: '%c'"
-msgstr "puntuación '%c' desconocida"
+msgstr "letra de operando desconocida: '%c'"
 
 #: config/rl78/rl78.c:2009 config/rl78/rl78.c:2095
 #, c-format
@@ -3995,46 +3957,32 @@ msgid "Try running '%s' in the shell to raise its limit.\n"
 msgstr "Pruebe ejecutar '%s' en el intérprete de órdenes para elevar su límite.\n"
 
 #: config/rs6000/rs6000.c:3995
-#, fuzzy
-#| msgid "-mvsx requires hardware floating point"
 msgid "%<-mvsx%> requires hardware floating point"
-msgstr "-mvsx requiere coma flotante de hardware"
+msgstr "%<-mvsx%> requiere coma flotante de hardware"
 
 #: config/rs6000/rs6000.c:4003
-#, fuzzy
-#| msgid "-mvsx needs indexed addressing"
 msgid "%<-mvsx%> needs indexed addressing"
-msgstr "-mvsx necesita direccionamiento indizado"
+msgstr "%<-mvsx%> necesita direccionamiento indexado"
 
 #: config/rs6000/rs6000.c:4008
-#, fuzzy
-#| msgid "-mvsx and -mno-altivec are incompatible"
 msgid "%<-mvsx%> and %<-mno-altivec%> are incompatible"
-msgstr "-mvsx y -mno-altivec son incompatibles"
+msgstr "%<-mvsx%> y -%<mno-altivec%> son incompatibles"
 
 #: config/rs6000/rs6000.c:4010
-#, fuzzy
-#| msgid "-mno-altivec disables vsx"
 msgid "%<-mno-altivec%> disables vsx"
-msgstr "-mno-altivec desactiva vsx"
+msgstr "%<-mno-altivec%> desactiva vsx"
 
 #: config/rs6000/rs6000.c:4136
-#, fuzzy
-#| msgid "-mquad-memory requires 64-bit mode"
 msgid "%<-mquad-memory%> requires 64-bit mode"
-msgstr "-mquad-memory requiere modo de 64 bits"
+msgstr "%<-mquad-memory%> requiere modo de 64 bits"
 
 #: config/rs6000/rs6000.c:4139
-#, fuzzy
-#| msgid "-mquad-memory-atomic requires 64-bit mode"
 msgid "%<-mquad-memory-atomic%> requires 64-bit mode"
-msgstr "-mquad-memory-atomic requiere modo de 64 bits"
+msgstr "%<-mquad-memory-atomic%> requiere modo de 64 bits"
 
 #: config/rs6000/rs6000.c:4151
-#, fuzzy
-#| msgid "-mquad-memory is not available in little endian mode"
 msgid "%<-mquad-memory%> is not available in little endian mode"
-msgstr "-mquad-memory no está disponible en modo little endian"
+msgstr "%<-mquad-memory%> no está disponible en modo little endian"
 
 #: config/rs6000/rs6000.c:10374
 msgid "bad move"
@@ -4100,10 +4048,9 @@ msgid "invalid %%q value"
 msgstr "valor %%q no válido"
 
 #: config/rs6000/rs6000.c:21141
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%t value"
-msgstr "valor %%J no válido"
+msgstr "valor %%t no válido"
 
 #: config/rs6000/rs6000.c:21158
 #, c-format
@@ -4121,10 +4068,9 @@ msgid "invalid %%v value"
 msgstr "valor %%v no válido"
 
 #: config/rs6000/rs6000.c:21234
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%V value"
-msgstr "valor %%J no válido"
+msgstr "valor %%V no válido"
 
 #: config/rs6000/rs6000.c:21251 config/xtensa/xtensa.c:2439
 #, c-format
@@ -4696,10 +4642,8 @@ msgid "enters synchronized or atomic statement"
 msgstr "entra en la sentencia sincronizada o atómica"
 
 #: cp/decl.c:3254
-#, fuzzy
-#| msgid "expected statement"
 msgid "enters constexpr if statement"
-msgstr "se esperaba una declaración"
+msgstr "entre en la sentencia if de expresión constante"
 
 #: cp/error.c:375
 msgid "<missing>"
@@ -5032,10 +4976,8 @@ msgid "Integer outside symmetric range implied by Standard Fortran at %L"
 msgstr "Rango simétrico fuera de entero implicado por Standard Fortran en %L"
 
 #: fortran/arith.c:118
-#, fuzzy
-#| msgid "Illegal character in BOZ constant at %C"
 msgid "Illegal type in character concatenation at %L"
-msgstr "Carácter ilegal en la constante BOZ en %C"
+msgstr "Typo ilegal en concatenación de caracteres en %L"
 
 #: fortran/arith.c:1384
 msgid "elemental binary operation"
@@ -5397,10 +5339,9 @@ msgid "Operand of unary numeric operator %%<%s%%> at %%L is %s"
 msgstr "El operando del operador numérico unitario %%<%s%%> en %%L es %s"
 
 #: fortran/resolve.c:3949
-#, fuzzy, c-format
-#| msgid "Operands of binary numeric operator %%<%s%%> at %%L are %s/%s"
+#, c-format
 msgid "Unexpected derived-type entities in binary intrinsic numeric operator %%<%s%%> at %%L"
-msgstr "Los operandos del operador numérico binario %%<%s%%> en %%L son %s/%s"
+msgstr "Entidades de tipos derivados no esperadas en el operador numérico intrínseco binario %%<%s%%> en %%L"
 
 #: fortran/resolve.c:3954
 #, c-format
@@ -5517,7 +5458,7 @@ msgstr "Desborde entero al calcular la cantidad de memoria a reservar"
 #: fortran/trans-array.c:9544
 #, c-format
 msgid "The value of the PDT LEN parameter '%s' does not agree with that in the dummy declaration"
-msgstr ""
+msgstr "El valor del parámetro PDT LEN '%s' no concuerda con el de la declaración «dummy»"
 
 #: fortran/trans-decl.c:6025
 #, c-format
@@ -5719,10 +5660,8 @@ msgid "-E or -x required when input is from standard input"
 msgstr "se requiere -E ó -x cuando la entrada es de entrada estándar"
 
 #: config/darwin.h:126 config/darwin.h:427
-#, fuzzy
-#| msgid "-pg not supported on this platform"
 msgid "gsplit-dwarf is not supported on this platform"
-msgstr "-pg no se admite en esta plataforma"
+msgstr "gsplit-dwarf no se admite en esta plataforma"
 
 #: config/darwin.h:170
 msgid "rdynamic is not supported"
@@ -5788,8 +5727,6 @@ msgstr "-Xbind-now y -Xbind-lazy son incompatibles"
 
 #: config/aarch64/aarch64-freebsd.h:37 config/arm/freebsd.h:49
 #: config/riscv/freebsd.h:44
-#, fuzzy
-#| msgid "consider using `-pg' instead of `-p' with gprof (1) "
 msgid "consider using `-pg' instead of `-p' with gprof (1)"
 msgstr "considere usar `-pg' en lugar de `-p' con gprof (1)"
 
@@ -5868,7 +5805,7 @@ msgstr "considere usar `-pg' en lugar de `-p' con gprof(1)"
 
 #: config/rs6000/rs6000.h:139
 msgid "Missing -mcpu option in ASM_CPU_SPEC?"
-msgstr ""
+msgstr "¿Falta la opción -mcpu en ASM_CPU_SPEC?"
 
 #: config/rx/rx.h:80
 msgid "-mas100-syntax is incompatible with -gdwarf"
@@ -5891,10 +5828,8 @@ msgid "SH2a does not support little-endian"
 msgstr "SH2a no se admite para little-endian"
 
 #: config/sparc/linux64.h:148
-#, fuzzy
-#| msgid "-pie is not supported in this configuration"
 msgid "-fsanitize=address is not supported in this configuration"
-msgstr "-pie no se admite en esta configuración"
+msgstr "-fsanitize=dirección no se admite en esta configuración"
 
 #: config/sparc/linux64.h:162 config/sparc/linux64.h:168
 #: config/sparc/netbsd-elf.h:108 config/sparc/netbsd-elf.h:117
@@ -5960,7 +5895,7 @@ msgstr "Avisa sobre la creación de matrices temporales."
 
 #: fortran/lang.opt:214
 msgid "Warn about type and rank mismatches between arguments and parameters."
-msgstr ""
+msgstr "Avisa sobre discordancias de tipo y rango entre argumentos y parámetros."
 
 #: fortran/lang.opt:218
 msgid "Warn if the type of a variable might be not interoperable with C."
@@ -6243,7 +6178,7 @@ msgstr "-ffree-line-length-<n>\tUsa n como ancho de línea de carácter en modo
 
 #: fortran/lang.opt:565
 msgid "Try to interchange loops if profitable."
-msgstr ""
+msgstr "Intenta intercambiar bucles si es provechoso."
 
 #: fortran/lang.opt:569
 msgid "Enable front end optimization."
@@ -6259,7 +6194,7 @@ msgstr "-finit-character=<n>\tInicializa las variables de carácter locales al v
 
 #: fortran/lang.opt:581
 msgid "Initialize components of derived type variables according to other init flags."
-msgstr ""
+msgstr "Inicializa componentes de variables de tipo derivado en conformidad con otros indicadores de inicialización."
 
 #: fortran/lang.opt:585
 msgid "-finit-integer=<n>\tInitialize local integer variables to n."
@@ -6315,7 +6250,7 @@ msgstr "Protege paréntesis en las expresiones."
 
 #: fortran/lang.opt:675
 msgid "Path to header file that should be pre-included before each compilation unit."
-msgstr ""
+msgstr "Ruta de fichero de cabecera que debería preincluirse antes de cada unidad de compilación."
 
 #: fortran/lang.opt:679
 msgid "Enable range checking during compilation."
@@ -6517,7 +6452,7 @@ msgstr "Avisa si un subojeto tiene un atributo abi_tag que el objeto completo no
 
 #: c-family/c.opt:276
 msgid "Warn on suspicious calls of standard functions computing absolute values."
-msgstr ""
+msgstr "Advierte de llamadas sospechosas de funciones estándar que calculan valores absolutos."
 
 #: c-family/c.opt:280
 msgid "Warn about suspicious uses of memory addresses."
@@ -6545,7 +6480,7 @@ msgstr "-Walloc-size-larger-than=<bytes> Avierte de llamadas a funciones de rese
 
 #: c-family/c.opt:317
 msgid "-Wno-alloc-size-larger-than Disable Walloc-size-larger-than= warning.  Equivalent to Walloc-size-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-alloc-size-larger-than Desactiva el aviso Walloc-size-larger-than=.  Equivalente a Walloc-size-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:321
 msgid "-Walloc-zero Warn for calls to allocation functions that specify zero bytes."
@@ -6557,7 +6492,7 @@ msgstr "-Walloca-larger-than=<número>\tAdvierte de usos no acotados de alloca y
 
 #: c-family/c.opt:331
 msgid "-Wno-alloca-larger-than Disable Walloca-larger-than= warning.  Equivalent to Walloca-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-alloca-larger-than Desactiva el aviso Walloca-larger-than=.  Equivalente a Walloca-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:343
 msgid "Warn whenever an Objective-C assignment is being intercepted by the garbage collector."
@@ -6588,10 +6523,8 @@ msgid "Warn when a built-in preprocessor macro is undefined or redefined."
 msgstr "Avisa cuando una macro de preprocesador interna está sin definir o redefinida."
 
 #: c-family/c.opt:371
-#, fuzzy
-#| msgid "Warn about features not present in ISO C99, but present in ISO C11."
 msgid "Warn about features not present in ISO C11, but present in ISO C2X."
-msgstr "Avisa sobre características no presentes en ISO C99, pero presentes en ISO C11."
+msgstr "Avisa sobre características no presentes en ISO C11, pero presentes en ISO C2X."
 
 #: c-family/c.opt:375
 msgid "Warn about features not present in ISO C90, but present in ISO C99."
@@ -6641,10 +6574,8 @@ msgstr "Avisa sobre subíndices cuyo tipo es \"char\"."
 #: c-family/c.opt:1369 c-family/c.opt:1373 c-family/c.opt:1377
 #: c-family/c.opt:1381 c-family/c.opt:1385 c-family/c.opt:1389
 #: config/i386/i386.opt:967
-#, fuzzy
-#| msgid "Deprecated in GCC 8.  This switch has no effect."
 msgid "Deprecated in GCC 9.  This switch has no effect."
-msgstr "Obsoleto en GCC 8.  Esta opción no tiene efecto."
+msgstr "Obsoleto en GCC 9.  Esta opción no tiene efecto."
 
 #: c-family/c.opt:429
 msgid "Warn about variables that might be changed by \"longjmp\" or \"vfork\"."
@@ -6676,7 +6607,7 @@ msgstr "Avisa cuando todos los constructores y destructores son privados."
 
 #: c-family/c.opt:461
 msgid "Warn about dangling else."
-msgstr "Avisa sobre else colgados."
+msgstr "Avisa sobre else congante."
 
 #: c-family/c.opt:465
 msgid "Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."
@@ -6696,11 +6627,11 @@ msgstr "Avisa al borrar objetos polimórficos con destructores que no son virtua
 
 #: c-family/c.opt:485
 msgid "Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation."
-msgstr ""
+msgstr "Marca las operaciones de copia declaradas implícitamente como obsoletas si la clase tiene una operación de copia definida por el usuario."
 
 #: c-family/c.opt:490
 msgid "Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation or destructor."
-msgstr ""
+msgstr "Marca las operaciones de copia declaradas implícitamente como obsoletas si la clase tiene una operación de copia o un destructor definidos por el usuario."
 
 #: c-family/c.opt:495
 msgid "Warn about positional initialization of structs requiring designated initializers."
@@ -6776,7 +6707,7 @@ msgstr "Avisa sobre el uso de cadenas de formato que no son literales."
 
 #: c-family/c.opt:575
 msgid "Warn about function calls with format strings that write past the end of the destination region.  Same as -Wformat-overflow=1."
-msgstr ""
+msgstr "Advierte de llamadas a función con cadenas de formato que escriben más allá del final de la región de destino.  Igual que -Wformat-overflow=1."
 
 #: c-family/c.opt:580
 msgid "Warn about possible security problems with format functions."
@@ -6788,7 +6719,7 @@ msgstr "Advierte de diferencias de signo en funciones de formato."
 
 #: c-family/c.opt:588
 msgid "Warn about calls to snprintf and similar functions that truncate output. Same as -Wformat-truncation=1."
-msgstr ""
+msgstr "Advierte de llamadas a snprintf y funciones similares que truncan la salida. Igual que -Wformat-truncation=1."
 
 #: c-family/c.opt:593
 msgid "Warn about strftime formats yielding 2-digit years."
@@ -6824,7 +6755,7 @@ msgstr "Avisa cuando hay conversión entre punteros de tipos incompatibles."
 
 #: c-family/c.opt:630
 msgid "Warn when the address of packed member of struct or union is taken."
-msgstr ""
+msgstr "Avisa cuando se toma la dirección del miembro empaquetado de una estructura o unión."
 
 #: c-family/c.opt:634
 msgid "Warn about variables which are initialized to themselves."
@@ -6832,7 +6763,7 @@ msgstr "Avisa sobre variables que se inicialicen ellas mismas."
 
 #: c-family/c.opt:638
 msgid "Warn about uses of std::initializer_list that can result in dangling pointers."
-msgstr ""
+msgstr "Avisa sobre usos de std::initializer_list que pueden resultar en punteros "
 
 #: c-family/c.opt:642
 msgid "Warn about implicit declarations."
@@ -6864,7 +6795,7 @@ msgstr "Advierte de conversiones de entero a puntero y viceversa incompatibles."
 
 #: c-family/c.opt:677
 msgid "Warn for suspicious integer expressions in boolean context."
-msgstr ""
+msgstr "Advierte de expresiones enteras sospechosas en contexto booleano."
 
 #: c-family/c.opt:681
 msgid "Warn when there is a cast to a pointer from an integer of a different size."
@@ -6928,7 +6859,7 @@ msgstr "Avisa sobre campos faltantes en los inicializadores de struct."
 
 #: c-family/c.opt:745
 msgid "Warn about unsafe macros expanding to multiple statements used as a body of a clause such as if, else, while, switch, or for."
-msgstr ""
+msgstr "Advierte de expansiones de macros no seguras a sentencias múltiples utilizadas como cuerpo de una cláusula como if, while, switch o for."
 
 #: c-family/c.opt:749
 msgid "Warn on direct multiple inheritance."
@@ -6940,7 +6871,7 @@ msgstr "Advierta de la definición de espacios de nombres."
 
 #: c-family/c.opt:757
 msgid "Warn when fields in a struct with the packed attribute are misaligned."
-msgstr ""
+msgstr "Avisa cuando un struct con el atributo «packed» tiene campos desalineados."
 
 #: c-family/c.opt:761
 msgid "Warn about missing sized deallocation functions."
@@ -6948,7 +6879,7 @@ msgstr "Advierte de funciones de desasignación con tamaño ausentes."
 
 #: c-family/c.opt:765
 msgid "Warn about suspicious divisions of two sizeof expressions that don't work correctly with pointers."
-msgstr ""
+msgstr "Advierte de divisiones sospechosas de dos expresiones sizeof que no funcionan correctamente con punteros."
 
 #: c-family/c.opt:769
 msgid "Warn about suspicious length parameters to certain string functions if the argument uses sizeof."
@@ -6960,7 +6891,7 @@ msgstr "Avisa cuando se aplica sizeof a parámetros declarados como array."
 
 #: c-family/c.opt:777
 msgid "Warn about buffer overflow in string manipulation functions like memcpy and strcpy."
-msgstr ""
+msgstr "Advierte de desbordamiento de búfer en funciones que manipulan cadenas, como memcpy y strcpy."
 
 #: c-family/c.opt:782
 msgid "Under the control of Object Size type, warn about buffer overflow in string manipulation functions like memcpy and strcpy."
@@ -7039,14 +6970,12 @@ msgid "Warn when non-templatized friend functions are declared within a template
 msgstr "Avisa cuando las funciones friend sin plantillas se declaran dentro de una plantilla."
 
 #: c-family/c.opt:868
-#, fuzzy
-#| msgid "conversion to void will never use a type conversion operator"
 msgid "Warn when a conversion function will never be called due to the type it converts to."
-msgstr "la conversión a void nunca usará un operador de conversión de tipo"
+msgstr "Avisa cuando una función de conversión nunca será llamada debido al tipo al que convierte."
 
 #: c-family/c.opt:872
 msgid "Warn for unsafe raw memory writes to objects of class types."
-msgstr ""
+msgstr "Avisa en caso de escrituras de memoria en bruto no seguras a objetivos de tipos de clase."
 
 #: c-family/c.opt:876
 msgid "Warn about non-virtual destructors."
@@ -7130,7 +7059,7 @@ msgstr "Avisa sobre malos usos de pragmas."
 
 #: c-family/c.opt:991
 msgid "Warn if constructor or destructors with priorities from 0 to 100 are used."
-msgstr ""
+msgstr "Avisa si se usan constructores o destructores con prioridades entre 0 y 100."
 
 #: c-family/c.opt:995
 msgid "Warn if a property for an Objective-C object has no assign semantics specified."
@@ -7150,7 +7079,7 @@ msgstr "Avisa sobre declaraciones múltiples del mismo objeto."
 
 #: c-family/c.opt:1015
 msgid "Warn about redundant calls to std::move."
-msgstr ""
+msgstr "Advierte de llamadas redundantes a std::move."
 
 #: c-family/c.opt:1019
 msgid "Warn about uses of register storage specifier."
@@ -7293,14 +7222,12 @@ msgid "Warn if a variable length array is used."
 msgstr "Avisa si se usa una matriz de longitud variable."
 
 #: c-family/c.opt:1199
-#, fuzzy
-#| msgid "-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than <number> bytes."
 msgid "-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than <number> bytes. <number> bytes."
-msgstr "-Wvla-larger-than=<número>\tAdvierte de usos no acotados de arrays de longitud variable y de usos acotados de arrays de longitud variable cuyo límite pueda ser más grande que <número> bytes."
+msgstr "-Wvla-larger-than=<número>\tAdvierte de usos no acotados de arrays de longitud variable y de usos acotados de arrays de longitud variable cuyo límite pueda ser más grande que <número> bytes. <número> bytes"
 
 #: c-family/c.opt:1206
 msgid "-Wno-vla-larger-than Disable Wvla-larger-than= warning.  Equivalent to Wvla-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-vla-larger-than Desactiva el aviso Wvla-larger-than=.  Equivalente a Wvla-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:1210
 msgid "Warn when a register variable is declared volatile."
@@ -7356,11 +7283,11 @@ msgstr "-fada-spec-parent=unidad  Vuelca specs de Ada como unidades hijas del pa
 
 #: c-family/c.opt:1267
 msgid "Support C++17 allocation of over-aligned types."
-msgstr ""
+msgstr "Admite alojamiento C++17 de tipos sobrealineados."
 
 #: c-family/c.opt:1271
 msgid "-faligned-new=<N> Use C++17 over-aligned type allocation for alignments greater than N."
-msgstr ""
+msgstr "-faligned-new=<N> Usa alojamiento de tipo sobrealineado de C++17 para alineamientos mayores que N."
 
 #: c-family/c.opt:1278
 msgid "Allow variadic functions without named parameter."
@@ -7385,7 +7312,7 @@ msgstr "Donde acorte, usar rutas canonicalizadas para cabeceras de sistemas."
 
 #: c-family/c.opt:1305
 msgid "Enable the char8_t fundamental type and use it as the type for UTF-8 string and character literals."
-msgstr ""
+msgstr "Habilita el tipo fundamental char8_t y lo usa como el tipo para los literales de cadenas UTF-8 y de caracteres."
 
 #: c-family/c.opt:1393
 msgid "Deprecated in GCC 8.  This switch has no effect."
@@ -7412,10 +7339,8 @@ msgid "-fconstexpr-loop-limit=<number>\tSpecify maximum constexpr loop iteration
 msgstr "-fconstexpr-loop-limit=<número>\tEspecifica el número de iteraciones de bucle constexpr máximo."
 
 #: c-family/c.opt:1421
-#, fuzzy
-#| msgid "-fconstexpr-loop-limit=<number>\tSpecify maximum constexpr loop iteration count."
 msgid "-fconstexpr-ops-limit=<number>\tSpecify maximum number of constexpr operations during a single constexpr evaluation."
-msgstr "-fconstexpr-loop-limit=<número>\tEspecifica el número de iteraciones de bucle constexpr máximo."
+msgstr "-fconstexpr-ops-limit=<número>\tEspecifica el número máximo de operaciones constexpr durante una evaluación de constexpr."
 
 #: c-family/c.opt:1425
 msgid "Emit debug annotations during preprocessing."
@@ -7431,7 +7356,7 @@ msgstr "Factoriza constructores y destructores complejos para favorecer el espac
 
 #: c-family/c.opt:1441
 msgid "Print hierarchical comparisons when template types are mismatched."
-msgstr ""
+msgstr "Imprime comparaciones jerárquicas cuando los tipos de plantilla no coinciden."
 
 #: c-family/c.opt:1445
 msgid "Preprocess directives only."
@@ -7443,7 +7368,7 @@ msgstr "Permite '$' como un identificador de carácter."
 
 #: c-family/c.opt:1453
 msgid "-fmacro-prefix-map=<old>=<new> Map one directory name to another in __FILE__, __BASE_FILE__, and __builtin_FILE()."
-msgstr ""
+msgstr "-fmacro-prefix-map=<viejo>=<nuevo> Asocia un nombre de directorio a otro en __FILE__, __BASE_FILE__, y __builtin_FILE()."
 
 #: c-family/c.opt:1457
 msgid "Write all declarations as Ada code transitively."
@@ -7851,16 +7776,12 @@ msgstr "Obsoleto en favor de -std=c11."
 
 #: c-family/c.opt:2017 c-family/c.opt:2021 c-family/c.opt:2139
 #: c-family/c.opt:2143
-#, fuzzy
-#| msgid "Conform to the ISO 2017 C standard (expected to be published in 2018)."
 msgid "Conform to the ISO 2017 C standard (published in 2018)."
-msgstr "Conforma al estándar ISO 2017 C (publicación prevista en 2018)."
+msgstr "Conforma al estándar ISO 2017 C (publicado en 2018)."
 
 #: c-family/c.opt:2025
-#, fuzzy
-#| msgid "Conform to the ISO 2011 C standard (experimental and incomplete support)"
 msgid "Conform to the ISO 202X C standard draft (experimental and incomplete support)."
-msgstr "Conforma al estándar ISO 2011 C (soporte experimental e incompleto)"
+msgstr "Conforma al borrador del estándar ISO 202X C (soporte experimental e incompleto)"
 
 #: c-family/c.opt:2029 c-family/c.opt:2033 c-family/c.opt:2119
 msgid "Conform to the ISO 1990 C standard."
@@ -7915,16 +7836,12 @@ msgid "Deprecated in favor of -std=gnu11."
 msgstr "Obsoleto en favor de -std=gnu11."
 
 #: c-family/c.opt:2091 c-family/c.opt:2095
-#, fuzzy
-#| msgid "Conform to the ISO 2017 C standard (expected to be published in 2018) with GNU extensions."
 msgid "Conform to the ISO 2017 C standard (published in 2018) with GNU extensions."
-msgstr "Conforma al estándar ISO 2017 C (publicación prevista en 2018) con extensiones GNU."
+msgstr "Conforma al estándar ISO 2017 C (publicado en 2018) con extensiones GNU."
 
 #: c-family/c.opt:2099
-#, fuzzy
-#| msgid "Conform to the ISO 2011 C standard with GNU extensions (experimental and incomplete support)"
 msgid "Conform to the ISO 202X C standard draft with GNU extensions (experimental and incomplete support)."
-msgstr "Conforma al estándar ISO 2011 C con extensiones GNU (soporte experimental e incompleto)"
+msgstr "Conforma al borrador del estándar ISO 202X C con extensiones GNU (soporte experimental e incompleto)."
 
 #: c-family/c.opt:2103 c-family/c.opt:2107
 msgid "Conform to the ISO 1990 C standard with GNU extensions."
@@ -7992,99 +7909,79 @@ msgstr "No considerada."
 
 #: d/lang.opt:51
 msgid "-Hd <dir>\tWrite D interface files to directory <dir>."
-msgstr ""
+msgstr "-Hd <dir>\tEscribe los ficheros de interfaz de D en el directorio <dir>."
 
 #: d/lang.opt:55
-#, fuzzy
-#| msgid "-o <file>\tPlace output into <file>."
 msgid "-Hf <file>\tWrite D interface to <file>."
-msgstr "-o <fichero>\tColoca la salida en el <fichero>."
+msgstr "-Hf <fichero>\tEscribe el interfaz de D en el <fichero>."
 
 #: d/lang.opt:123
-#, fuzzy
-#| msgid "Warn about casts which discard qualifiers."
 msgid "Warn about casts that will produce a null result."
-msgstr "Avisa sobre conversiones que descartan calificadores."
+msgstr "Avisa sobre conversiones que darán resultado nulo."
 
 #: d/lang.opt:139
 msgid "Warn from speculative compiles such as __traits(compiles)."
 msgstr ""
 
 #: d/lang.opt:151
-#, fuzzy
-#| msgid "Generate H8S code."
 msgid "Generate JSON file."
-msgstr "Genera código H8S."
+msgstr "Genera fichero JSON."
 
 #: d/lang.opt:155
-#, fuzzy
-#| msgid "-MF <file>\tWrite dependency output to the given file."
 msgid "-Xf <file>\tWrite JSON output to the given <file>."
-msgstr "-MF <fichero>\tEscribe la salida de dependencias al fichero dado."
+msgstr "-Xf <fichero>\tEscribe salida JSON al <fichero> dado."
 
 #: d/lang.opt:159
 msgid "Debug library to use instead of phobos."
-msgstr ""
+msgstr "Biblioteca de depuración que se utilizará en lugar de phobos."
 
 #: d/lang.opt:163
 msgid "Default library to use instead of phobos."
-msgstr ""
+msgstr "Biblioteca predefinida que se utilizará en lugar de phobos."
 
 #: d/lang.opt:167
 msgid "Do link the standard D startup files in the compilation."
 msgstr ""
 
 #: d/lang.opt:174
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for all template instantiations."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para todas las instanciaciones de plantillas."
 
 #: d/lang.opt:178
-#, fuzzy
-#| msgid "Generate code for GNU assembler (gas)."
 msgid "Generate code for assert contracts."
-msgstr "Genera código para el ensamblador de GNU (gas)."
+msgstr "Genera código para contratos de assert."
 
 #: d/lang.opt:186
 msgid "-fbounds-check=[on|safeonly|off]\tTurn array bounds checks on, in @safe code only, or off."
-msgstr ""
+msgstr "-fbounds-check=[on|safeonly|off]\tActiva o desactiva las comprobaciones de límites de matrices, solo en código @safe."
 
 #: d/lang.opt:210
-#, fuzzy
-#| msgid "incompatible index mode"
 msgid "Compile in debug code."
-msgstr "modo de índices incompatibles"
+msgstr "Compila en código de depuración."
 
 #: d/lang.opt:214
 msgid "-fdebug=<level|ident>\tCompile in debug code, code <= <level>, or code identified by <ident>."
-msgstr ""
+msgstr "-fdebug=<level|ident>\tCompila en código de depuración, código <= <nivel>, o código identificado por <ident>."
 
 #: d/lang.opt:218
-#, fuzzy
-#| msgid "Generate norm instruction."
 msgid "Generate documentation."
-msgstr "Genera instrucciones norm."
+msgstr "Genera documentación."
 
 #: d/lang.opt:222
 msgid "-fdoc-dir=<dir>\tWrite documentation file to directory <dir>."
-msgstr ""
+msgstr "-fdoc-dir=<dir>\tEscribe el fichero de documentación en el directorio <dir>."
 
 #: d/lang.opt:226
-#, fuzzy
-#| msgid "-o <file>\tPlace output into <file>."
 msgid "-fdoc-file=<file>\tWrite documentation to <file>."
-msgstr "-o <fichero>\tColoca la salida en el <fichero>."
+msgstr "-fdoc-file=<fichero>\tEscribe la documentación en <fichero>."
 
 #: d/lang.opt:230
 msgid "-fdoc-inc=<file>\tInclude a Ddoc macro <file>."
-msgstr ""
+msgstr "-fdoc-inc=<fichero>\tIncluye un <fichero> de macros Ddoc."
 
 #: d/lang.opt:234
-#, fuzzy
-#| msgid "Do not assume that standard C libraries and \"main\" exist."
 msgid "Assume that standard D runtime libraries and \"D main\" exist."
-msgstr "No asume que existen las bibliotecas C estándar y \"main\"."
+msgstr "Asume que existen bibliotecas D estándar de tiempo de ejecución y \"D main\"."
 
 #: d/lang.opt:238
 #, fuzzy
@@ -8094,7 +7991,7 @@ msgstr "Muestra el árbol del código después de analizar; opción obsoleta."
 
 #: d/lang.opt:242
 msgid "Ignore unsupported pragmas."
-msgstr ""
+msgstr "Hace caso omiso de pragmas no admitidas."
 
 #: d/lang.opt:246
 #, fuzzy
@@ -8104,11 +8001,11 @@ msgstr "Genera código para operaciones atómicas internas."
 
 #: d/lang.opt:250
 msgid "Generate a default D main() function when compiling."
-msgstr ""
+msgstr "Genera una función main() de D predefinida al compilar."
 
 #: d/lang.opt:254
 msgid "-fmodule-file=<package.module>=<filespec>\tuse <filespec> as source file for <package.module>."
-msgstr ""
+msgstr "-fmodule-file=<paquete.módulo>=<especfich>\tutiliza <especfich> como fichero fuente para <paquete.módulo>."
 
 #: d/lang.opt:258
 #, fuzzy
@@ -8118,19 +8015,15 @@ msgstr "Genera código para el modo de usuario."
 
 #: d/lang.opt:262
 msgid "Process all modules specified on the command line, but only generate code for the module specified by the argument."
-msgstr ""
+msgstr "Procesa todos los módulos especificados en la línea de órdenes, pero solo genera código para el módulo especificado por el argumento."
 
 #: d/lang.opt:266
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for postcondition contracts."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para contratos de postcondiciones."
 
 #: d/lang.opt:270
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for precondition contracts."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para contratos de precondiciones."
 
 #: d/lang.opt:274
 #, fuzzy
@@ -8139,14 +8032,12 @@ msgid "Compile release version."
 msgstr "Muestra la versión del compilador."
 
 #: d/lang.opt:282
-#, fuzzy
-#| msgid "Generate code for the supervisor mode (default)."
 msgid "Generate code for switches without a default case."
-msgstr "Genera código para el modo supervisor (predeterminado)."
+msgstr "Genera código para las opciones sin caso predefinido."
 
 #: d/lang.opt:286
 msgid "List information on all language changes."
-msgstr ""
+msgstr "Muestra información sobre todos los cambios del lenguaje."
 
 #: d/lang.opt:290
 msgid "Give deprecation messages about -ftransition=import anomalies."
@@ -8154,7 +8045,7 @@ msgstr ""
 
 #: d/lang.opt:294
 msgid "List all usages of complex or imaginary types."
-msgstr ""
+msgstr "Enumera todos los usos de los tipos complejo o imaginario."
 
 #: d/lang.opt:298
 msgid "Implement DIP1000: Scoped pointers (experimental)."
@@ -8166,21 +8057,19 @@ msgstr ""
 
 #: d/lang.opt:306
 msgid "List all non-mutable fields which occupy an object instance."
-msgstr ""
+msgstr "Enumera todos los campos no mutables que ocupan la instancia de un objeto."
 
 #: d/lang.opt:310
 msgid "Revert to single phase name lookup."
-msgstr ""
+msgstr "Revierta a búsqueda de nombres de una sola fase."
 
 #: d/lang.opt:314
 msgid "List all hidden GC allocations."
 msgstr ""
 
 #: d/lang.opt:318
-#, fuzzy
-#| msgid "Use given thread-local storage dialect."
 msgid "List all variables going into thread local storage."
-msgstr "Usa el dialecto de almacenamiento thread-local dado."
+msgstr "Enumera todas las variables que van al almacenamiento local del hilo."
 
 #: d/lang.opt:322
 #, fuzzy
@@ -8193,18 +8082,16 @@ msgid "-fversion=<level|ident>\tCompile in version code >= <level> or identified
 msgstr ""
 
 #: d/lang.opt:350
-#, fuzzy
-#| msgid "Do not assume that standard C libraries and \"main\" exist."
 msgid "Do not link the standard D library in the compilation."
-msgstr "No asume que existen las bibliotecas C estándar y \"main\"."
+msgstr "No enlaza la biblioteca D estándar en la compilación."
 
 #: d/lang.opt:358
 msgid "Link the standard D library statically in the compilation."
-msgstr ""
+msgstr "Enlaza la biblioteca D estándar estáticamente en la compilación."
 
 #: d/lang.opt:362
 msgid "Link the standard D library dynamically in the compilation."
-msgstr ""
+msgstr "Enlaza la biblioteca D estándar dinámicamente en la compilación."
 
 #: go/lang.opt:42
 msgid "-fgo-c-header=<file>\tWrite Go struct definitions to file as C code."
@@ -8271,16 +8158,12 @@ msgid "-mpointer-size=[no,32,short,64,long]\tSet the default pointer size."
 msgstr "-mpointer-size=[no,32,short,64,long]\tEstablece el tamaña predeterminado de los punteros."
 
 #: config/mcore/mcore.opt:23
-#, fuzzy
-#| msgid "Generate code for the M*Core M210"
 msgid "Generate code for the M*Core M210."
-msgstr "Genera código para el M*Core M210"
+msgstr "Genera código para el M*Core M210."
 
 #: config/mcore/mcore.opt:27
-#, fuzzy
-#| msgid "Generate code for the M*Core M340"
 msgid "Generate code for the M*Core M340."
-msgstr "Genera código para el M*Core M340"
+msgstr "Genera código para el M*Core M340."
 
 #: config/mcore/mcore.opt:31
 msgid "Force functions to be aligned to a 4 byte boundary."
@@ -8650,7 +8533,7 @@ msgstr "Activa la biblioteca compartida basada en ID."
 
 #: config/m68k/m68k.opt:147
 msgid "Use 32-bit offsets in jump tables rather than 16-bit offsets."
-msgstr ""
+msgstr "Usa desplazamientos de 32 bits en las tablas de saltos en lugar de desplazamientos de 16 bits."
 
 #: config/m68k/m68k.opt:151
 msgid "Do not use the bit-field instructions."
@@ -8761,11 +8644,11 @@ msgstr "Utiliza operadores %reloc() en vez de macros de ensamblador para cargar
 
 #: config/riscv/riscv.opt:114
 msgid "Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses."
-msgstr ""
+msgstr "Aprovecha los descansos del enlazador para reducir el número de instrucciones requeridas para materializar direcciones de símbolos."
 
 #: config/riscv/riscv.opt:133
 msgid "Emit RISC-V ELF attribute."
-msgstr ""
+msgstr "Emite el atributo ELF de RISC-V."
 
 #: config/m32c/m32c.opt:23
 msgid "-msim\tUse simulator runtime."
diff --git a/gcc/po/fi.po b/gcc/po/fi.po
index c66de8afab4..40b86635286 100644
--- a/gcc/po/fi.po
+++ b/gcc/po/fi.po
@@ -33,7 +33,7 @@ msgstr ""
 "Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2019-05-29 18:58+0300\n"
+"PO-Revision-Date: 2019-12-26 00:56+0200\n"
 "Last-Translator: Lauri Nurmi <lanurmi@iki.fi>\n"
 "Language-Team: Finnish <translation-team-fi@lists.sourceforge.net>\n"
 "Language: fi\n"
@@ -42,15 +42,17 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "X-Bugs: Report translation errors to the Language-Team address.\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Poedit 2.2.3\n"
+"X-Generator: Poedit 2.2.4\n"
+"X-Poedit-Bookmarks: -1,4379,4571,5891,-1,9667,-1,-1,-1,-1\n"
 
 #: cfgrtl.c:2705
 msgid "flow control insn inside a basic block"
 msgstr "vuonohjauskäsky peruslohkon sisällä"
 
 #: cfgrtl.c:2937
+#, fuzzy
 msgid "wrong insn in the fallthru edge"
-msgstr ""
+msgstr "nimettömällä kentällä on vaillinainen tyyppi"
 
 #: cfgrtl.c:2994
 msgid "insn outside basic block"
@@ -67,9 +69,9 @@ msgid "[cannot find %s]"
 msgstr "lähdetiedostoa %s ei löydy"
 
 #: collect2.c:1632
-#, fuzzy, c-format
+#, c-format
 msgid "collect2 version %s\n"
-msgstr "gcc-versio %s %s\n"
+msgstr "collect2-versio %s\n"
 
 #: collect2.c:1737
 #, c-format
@@ -103,6 +105,8 @@ msgid ""
 "\n"
 "write_c_file - output name is %s, prefix is %s\n"
 msgstr ""
+"\n"
+"write_c_file - tuotoksen nimi on %s, etuliite on %s\n"
 
 #: collect2.c:2645
 #, c-format
@@ -118,9 +122,9 @@ msgid "const/copy propagation disabled"
 msgstr "const-/kopioinnin-eteneminen poistettu käytöstä"
 
 #: diagnostic.c:145
-#, fuzzy, c-format
+#, c-format
 msgid "%s: all warnings being treated as errors"
-msgstr "Käsittele kaikki varoitukset virheinä"
+msgstr "%s: kaikki varoitukset käsitellään virheinä"
 
 #: diagnostic.c:150
 #, c-format
@@ -179,7 +183,7 @@ msgstr "%s:%d: hämmentynyt aikaisemmista virheistä, poistutaan\n"
 #: diagnostic.c:1589
 #, c-format
 msgid "Internal compiler error: Error reporting routines re-entered.\n"
-msgstr ""
+msgstr "Sisäinen kääntäjän virhe: virheraportoinnin rutiineihin palattiin uudelleen.\n"
 
 #: final.c:1127
 msgid "negative insn length"
@@ -772,7 +776,7 @@ msgstr ""
 #: gcov-tool.c:528
 #, c-format
 msgid "Copyright %s 2019 Free Software Foundation, Inc.\n"
-msgstr ""
+msgstr "Tekijänoikeus %s 2019 Free Software Foundation, Inc.\n"
 
 #: gcov-tool.c:531 gcov.c:925
 #, c-format
@@ -955,7 +959,6 @@ msgstr "Tulostiedoston ”%s” avaaminen epäonnistui\n"
 msgid "Removing '%s'\n"
 msgstr "Poistetaan ”%s”\n"
 
-# Hmm...
 #: gcov.c:1399 gcov.c:1467 gcov.c:2804
 #, c-format
 msgid "\n"
@@ -1267,7 +1270,7 @@ msgstr "Virheellinen vähimmäisargumenttimäärä (%d) funktiolle %s"
 #: opts.c:1396
 #, c-format
 msgid "Same as %s.  Use the latter option instead."
-msgstr ""
+msgstr "Sama kuin %s. Käytä tätä valitsinta ensimmäisen sijaan."
 
 #: opts.c:1404
 #, fuzzy, c-format
@@ -1657,9 +1660,8 @@ msgid "note: "
 msgstr "huom: "
 
 #: diagnostic.def:40
-#, fuzzy
 msgid "debug: "
-msgstr "aseta vianjäljityksen tulostetiedoston nimi"
+msgstr "vianjäljitys: "
 
 #. These two would be re-classified as DK_WARNING or DK_ERROR, so the
 #. prefix does not matter.
@@ -1814,9 +1816,9 @@ msgid "How much can given compilation unit grow because of the inlining (in perc
 msgstr ""
 
 #: params.def:232
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "How much can given compilation unit grow because of the interprocedural constant propagation (in percent)."
-msgstr ""
+msgstr "Sähkökatko"
 
 #: params.def:236
 #, no-c-format
@@ -1844,9 +1846,9 @@ msgid "Interval in which to probe the stack expressed as a power of two in bytes
 msgstr ""
 
 #: params.def:262
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "The maximum amount of memory to be allocated by GCSE."
-msgstr ""
+msgstr "Kumoamistoimintojen enimmäismäärä"
 
 #: params.def:269
 #, fuzzy, no-c-format
@@ -2074,9 +2076,9 @@ msgid "The maximum number of insns to duplicate when unfactoring computed gotos.
 msgstr "parametrin %qs maksimiarvo on %u"
 
 #: params.def:542
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "The maximum length of path considered in cse."
-msgstr ""
+msgstr "Kumoamistoimintojen enimmäismäärä"
 
 #: params.def:546
 #, fuzzy, no-c-format
@@ -2099,9 +2101,9 @@ msgid "Bound on number of iv uses in loop optimized in iv optimizations."
 msgstr "moduulienvälisiä optimointeja ei ole toteutettu C++:lle"
 
 #: params.def:578
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "If number of candidates in the set is smaller, we always try to remove unused ivs during its optimization."
-msgstr ""
+msgstr "moduulienvälisiä optimointeja ei ole toteutettu C++:lle"
 
 #: params.def:583
 #, fuzzy, no-c-format
@@ -2199,9 +2201,9 @@ msgid "The maximum conflict delay for an insn to be considered for speculative m
 msgstr "parametrin %qs maksimiarvo on %u"
 
 #: params.def:700
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "The minimal probability of speculation success (in percents), so that speculative insn will be scheduled."
-msgstr ""
+msgstr "parametrin %qs maksimiarvo on %u"
 
 #: params.def:705
 #, no-c-format
@@ -2249,9 +2251,9 @@ msgid "The upper bound for sharing integer constants."
 msgstr "luetellun tyypin jäsenen %qE arvo ei ole kokonaislukuvakio"
 
 #: params.def:754
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "The lower bound for a buffer to be considered for stack smashing protection."
-msgstr ""
+msgstr "parametrin %qs maksimiarvo on %u"
 
 #: params.def:759
 #, no-c-format
@@ -2334,9 +2336,9 @@ msgid "Maximum length of partial antic set when performing tree pre optimization
 msgstr ""
 
 #: params.def:894
-#, no-c-format
+#, fuzzy, no-c-format
 msgid "Maximum depth of a loop nest to fully value-number optimistically."
-msgstr ""
+msgstr "parametrin %qs maksimiarvo on %u"
 
 #: params.def:905
 #, fuzzy, no-c-format
@@ -6142,9 +6144,8 @@ msgid "gfortran does not support -E without -cpp"
 msgstr "gfortran ei tue valitsinta -E ilman valitsinta -cpp"
 
 #: objc/lang-specs.h:30 objc/lang-specs.h:41
-#, fuzzy
 msgid "GNU Objective C no longer supports traditional compilation"
-msgstr "GCC ei enää tue valitsinta -traditional ilman valitsinta -E"
+msgstr "GNU Objective C ei enää tue perinteistä kääntämistä"
 
 #: objc/lang-specs.h:55
 msgid "objc-cpp-output is deprecated; please use objective-c-cpp-output instead"
@@ -6308,8 +6309,9 @@ msgid "Disable preprocessing."
 msgstr "%s esikääntäjän direktiivissä"
 
 #: fortran/lang.opt:370
+#, fuzzy
 msgid "Eliminate multiple function invocations also for impure functions."
-msgstr ""
+msgstr "indeksoitu arvo on osoitin funktioon"
 
 #: fortran/lang.opt:374
 #, fuzzy
@@ -6424,7 +6426,7 @@ msgstr ""
 #: common.opt:1010 common.opt:1574 common.opt:1630 common.opt:1762
 #: common.opt:1766 common.opt:2000 common.opt:2178 common.opt:2879
 msgid "Does nothing. Preserved for backward compatibility."
-msgstr ""
+msgstr "Ei tee mitään. Säilytetty yhteensopivuuden vuoksi."
 
 #: fortran/lang.opt:493
 #, fuzzy
@@ -6499,8 +6501,9 @@ msgid "-ffree-line-length-<n>\tUse n as character line width in free mode."
 msgstr ""
 
 #: fortran/lang.opt:565
+#, fuzzy
 msgid "Try to interchange loops if profitable."
-msgstr ""
+msgstr "Kumoamistoimintojen enimmäismäärä"
 
 #: fortran/lang.opt:569
 #, fuzzy
@@ -6656,7 +6659,7 @@ msgstr ""
 #: common.opt:2602 common.opt:2703 common.opt:2755 common.opt:2843
 #: common.opt:2980 common.opt:2984 common.opt:2988 common.opt:2992
 msgid "Does nothing.  Preserved for backward compatibility."
-msgstr ""
+msgstr "Ei tee mitään. Säilytetty yhteensopivuuden vuoksi."
 
 #: fortran/lang.opt:803
 msgid "Statically link the GNU Fortran helper library (libgfortran)."
@@ -6688,9 +6691,8 @@ msgid "Conform to the ISO Fortran 95 standard."
 msgstr "Noudata ISO Fortran 95 -standardia"
 
 #: fortran/lang.opt:827
-#, fuzzy
 msgid "Conform to nothing in particular."
-msgstr "Älä noudata mitään erityisesti"
+msgstr "Älä noudata mitään erityisesti."
 
 #: fortran/lang.opt:831
 msgid "Accept extensions to support legacy code."
@@ -6732,24 +6734,20 @@ msgid "-I <dir>\tAdd <dir> to the end of the main include path."
 msgstr "-isystem <hakemisto>\tLisää <hakemisto> järjestelmän include-polun alkuun"
 
 #: c-family/c.opt:217
-#, fuzzy
 msgid "Generate make dependencies."
-msgstr "Luo make-riippuvuudet"
+msgstr "Luo make-riippuvuudet."
 
 #: c-family/c.opt:221
-#, fuzzy
 msgid "Generate make dependencies and compile."
-msgstr "Luo make-riippuvuudet ja käännä"
+msgstr "Luo make-riippuvuudet ja käännä."
 
 #: c-family/c.opt:225
-#, fuzzy
 msgid "-MF <file>\tWrite dependency output to the given file."
-msgstr "Kirjoita riippuvuustuloste annettuun tiedostoon"
+msgstr "-MF <tiedosto>\tKirjoita riippuvuustuloste annettuun tiedostoon."
 
 #: c-family/c.opt:229
-#, fuzzy
 msgid "Treat missing header files as generated files."
-msgstr "Käsittele puuttuvia otsikkotiedostoja luotavina tiedostoina"
+msgstr "Käsittele puuttuvia otsikkotiedostoja luotavina tiedostoina."
 
 #: c-family/c.opt:233
 msgid "Like -M but ignore system header files."
@@ -6773,9 +6771,8 @@ msgid "-MT <target>\tAdd an unquoted target."
 msgstr ""
 
 #: c-family/c.opt:253
-#, fuzzy
 msgid "Do not generate #line directives."
-msgstr "Älä luo #line-direktiivejä"
+msgstr "Älä luo #line-direktiivejä."
 
 #: c-family/c.opt:257
 #, fuzzy
@@ -6817,11 +6814,9 @@ msgstr ""
 msgid "Enable most warning messages."
 msgstr "Subject: Fetchmailin varoitus liian suuresta viestistä"
 
-# vähän fuzzy
 #: c-family/c.opt:308
-#, fuzzy
 msgid "Warn on any use of alloca."
-msgstr "Varoita pragmain väärästä käytöstä."
+msgstr "Varoita kaikesta allocan käytöstä."
 
 #: c-family/c.opt:312
 #, fuzzy
@@ -6931,9 +6926,8 @@ msgstr "Varoita ”char”-tyypillä indeksoinnista."
 #: c-family/c.opt:1369 c-family/c.opt:1373 c-family/c.opt:1377
 #: c-family/c.opt:1381 c-family/c.opt:1385 c-family/c.opt:1389
 #: config/i386/i386.opt:967
-#, fuzzy
 msgid "Deprecated in GCC 9.  This switch has no effect."
-msgstr "Vanhentunut. Tämä valitsin ei vaikuta mihinkään."
+msgstr "Vanhentunut GCC 9:ssä. Tämä valitsin ei vaikuta mihinkään."
 
 #: c-family/c.opt:429
 msgid "Warn about variables that might be changed by \"longjmp\" or \"vfork\"."
@@ -6964,9 +6958,8 @@ msgid "Warn when all constructors and destructors are private."
 msgstr "Varoita kun kaikki muodostimet ja hajottimet ovat yksityisiä."
 
 #: c-family/c.opt:461
-#, fuzzy
 msgid "Warn about dangling else."
-msgstr "Varoita implisiittisistä funktioesittelyistä."
+msgstr "Varoita orvosta elsestä."
 
 #: c-family/c.opt:465
 msgid "Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."
@@ -7074,8 +7067,9 @@ msgid "Warn about format strings that are not literals."
 msgstr "Varoita muotoilumerkkijonoista, jotka eivät ole literaaleja."
 
 #: c-family/c.opt:575
+#, fuzzy
 msgid "Warn about function calls with format strings that write past the end of the destination region.  Same as -Wformat-overflow=1."
-msgstr ""
+msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: c-family/c.opt:580
 msgid "Warn about possible security problems with format functions."
@@ -7119,9 +7113,8 @@ msgid "Warn whenever type qualifiers are ignored."
 msgstr "Varoita tyyppimääreiden huomiotta jättämisestä."
 
 #: c-family/c.opt:622
-#, fuzzy
 msgid "Warn whenever attributes are ignored."
-msgstr "Varoita tyyppimääreiden huomiotta jättämisestä."
+msgstr "Varoita attribuuttien huomiotta jättämisestä."
 
 #: c-family/c.opt:626
 #, fuzzy
@@ -7196,9 +7189,8 @@ msgid "Warn when a string or character literal is followed by a ud-suffix which
 msgstr ""
 
 #: c-family/c.opt:701
-#, fuzzy
 msgid "Warn when a logical operator is suspiciously always evaluating to true or false."
-msgstr "Varoita vertailusta, joka on aina tosi tai aina epätosi."
+msgstr "Varoita, kun looginen operaattori on aina tosi tai aina epätosi."
 
 #: c-family/c.opt:705
 msgid "Warn when logical not is used on the left hand side operand of a comparison."
@@ -7429,9 +7421,8 @@ msgid "Warn about packed bit-fields whose offset changed in GCC 4.4."
 msgstr "Varoita pakatuista bittikentistä, joiden siirrososoite vaihtui GCC 4.4:ssä"
 
 #: c-family/c.opt:955
-#, fuzzy
 msgid "Warn about possibly missing parentheses."
-msgstr "Varoita mahdollisesti puuttuvista sulkeista"
+msgstr "Varoita mahdollisesti puuttuvista sulkeista."
 
 #: c-family/c.opt:963
 msgid "Warn about calling std::move on a local object in a return statement preventing copy elision."
@@ -7646,8 +7637,9 @@ msgid "Warn if a variable length array is used."
 msgstr "käytetään muuttuvapituista taulukkoa"
 
 #: c-family/c.opt:1199
+#, fuzzy
 msgid "-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than <number> bytes. <number> bytes."
-msgstr ""
+msgstr "muuttuja %qD esitelty %<inline%>:ksi"
 
 #: c-family/c.opt:1206
 msgid "-Wno-vla-larger-than Disable Wvla-larger-than= warning.  Equivalent to Wvla-larger-than=<SIZE_MAX> or larger."
@@ -7747,9 +7739,8 @@ msgid "Enable the char8_t fundamental type and use it as the type for UTF-8 stri
 msgstr ""
 
 #: c-family/c.opt:1393
-#, fuzzy
 msgid "Deprecated in GCC 8.  This switch has no effect."
-msgstr "Vanhentunut. Tämä valitsin ei vaikuta mihinkään."
+msgstr "Vanhentunut GCC 8:ssa. Tämä valitsin ei vaikuta mihinkään."
 
 #: c-family/c.opt:1397
 #, fuzzy
@@ -7975,9 +7966,8 @@ msgid "Enable OpenMP's SIMD directives."
 msgstr "Luokittelematon lause IF-lauseessa kohdassa %C"
 
 #: c-family/c.opt:1681
-#, fuzzy
 msgid "Recognize C++ keywords like \"compl\" and \"xor\"."
-msgstr "Tunnista C++:n avainsanat kuten ”compl” ja ”xor”"
+msgstr "Tunnista C++:n avainsanat kuten ”compl” ja ”xor”."
 
 #: c-family/c.opt:1692
 msgid "Look for and use PCH files even when preprocessing."
@@ -8459,9 +8449,8 @@ msgid "Generate code for all template instantiations."
 msgstr "Käytä AltiVec-käskyjä"
 
 #: d/lang.opt:178
-#, fuzzy
 msgid "Generate code for assert contracts."
-msgstr "Tuota koodia GNU-assemblerille (gas)"
+msgstr "Tuota koodia väitesopimuksille."
 
 #: d/lang.opt:186
 msgid "-fbounds-check=[on|safeonly|off]\tTurn array bounds checks on, in @safe code only, or off."
@@ -8732,9 +8721,8 @@ msgid "Set the maximum amount for a single stack increment operation."
 msgstr ""
 
 #: config/mcore/mcore.opt:75
-#, fuzzy
 msgid "Always treat bitfields as int-sized."
-msgstr "Käsittele bittikenttiä aina int-kokoisina"
+msgstr "Käsittele bittikenttiä aina int-kokoisina."
 
 #: config/linux-android.opt:23
 msgid "Generate code for the Android platform."
@@ -9653,8 +9641,9 @@ msgid "Count speculative dependencies while calculating priority of instructions
 msgstr "Tuota koodia, joka käyttää 68881-liukulukukäskyjä"
 
 #: config/ia64/ia64.opt:178
+#, fuzzy
 msgid "Place a stop bit after every cycle when scheduling."
-msgstr ""
+msgstr "Ota käyttöön RX FPU-käskyjen käyttö."
 
 #: config/ia64/ia64.opt:182
 msgid "Assume that floating-point stores and loads are not likely to cause conflict when placed into one instruction group."
@@ -13439,8 +13428,9 @@ msgstr ""
 "\n"
 
 #: config/rx/rx.opt:105
+#, fuzzy
 msgid "Maximum size in bytes of constant values allowed as operands."
-msgstr ""
+msgstr "parametrin %qs maksimiarvo on %u"
 
 #: config/rx/rx.opt:111
 #, fuzzy
@@ -13512,7 +13502,7 @@ msgstr "Tuota koodia big-endian-tilassa"
 
 #: config/visium/visium.opt:73
 msgid "Only retained for backward compatibility."
-msgstr ""
+msgstr "Säilytetty vain yhteensopivuuden vuoksi."
 
 #: config/sol2.opt:32
 msgid "Clear hardware capabilities when linking."
@@ -17148,8 +17138,9 @@ msgid "Optimize amount of stdarg registers saved to stack at start of function."
 msgstr ""
 
 #: common.opt:2439
+#, fuzzy
 msgid "Apply variable expansion when loops are unrolled."
-msgstr ""
+msgstr "Tuota bittikäskyjä"
 
 #: common.opt:2443
 msgid "-fstack-check=[no|generic|specific]\tInsert stack checking code into the program."
@@ -17398,8 +17389,9 @@ msgid "Perform straight-line strength reduction."
 msgstr ""
 
 #: common.opt:2715
+#, fuzzy
 msgid "Perform scalar replacement of aggregates."
-msgstr ""
+msgstr "Sähkökatko"
 
 #: common.opt:2719
 msgid "Replace temporary expressions in the SSA->normal pass."
@@ -18102,9 +18094,8 @@ msgid "return with value in function with no return type"
 msgstr "funktion paluuarvon tyyppi ei voi olla funktio"
 
 #: go/gofrontend/statements.cc:2797
-#, fuzzy
 msgid "too many values in return statement"
-msgstr "%s: liian monta arvoa"
+msgstr "liikaa arvoja return-lauseessa"
 
 #: go/gofrontend/statements.cc:3214
 #, fuzzy
@@ -19207,9 +19198,9 @@ msgid "size of loop %d should be %d, not %d"
 msgstr "sektorimäärä: %d, sektorikoko: %d\n"
 
 #: cfgloop.c:1458
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "bb %d does not belong to loop %d"
-msgstr ""
+msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1470
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -19237,9 +19228,9 @@ msgid "loop %d%'s latch is not dominated by its header"
 msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1512
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "loop %d%'s latch does not have exactly 1 successor"
-msgstr ""
+msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1517
 #, fuzzy, gcc-internal-format
@@ -19247,9 +19238,9 @@ msgid "loop %d%'s latch does not have header as successor"
 msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1522
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "loop %d%'s latch does not belong directly to it"
-msgstr ""
+msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1528
 #, fuzzy, gcc-internal-format
@@ -19257,9 +19248,9 @@ msgid "loop %d%'s header does not belong directly to it"
 msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1534
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "loop %d%'s latch is marked as part of irreducible region"
-msgstr ""
+msgstr "säiekohtaista muistia ei tueta tälle kohteelle"
 
 #: cfgloop.c:1568
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -19342,9 +19333,9 @@ msgid "verify_flow_info: REG_BR_PROB does not match cfg %i %i"
 msgstr "verify_flow_info: Väärä lohkolukumäärä %i %i"
 
 #: cfgrtl.c:2507
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "EDGE_CROSSING incorrectly set across same section"
-msgstr ""
+msgstr "väärä määrä argumentteja funktiolle %<va_start%>"
 
 #: cfgrtl.c:2512
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -19537,9 +19528,9 @@ msgid "inline clone with address taken"
 msgstr ""
 
 #: cgraph.c:3148
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "inline clone is forced to output"
-msgstr ""
+msgstr "virheellinen sisäinen makro ”%s”"
 
 #: cgraph.c:3155
 #, gcc-internal-format, gfc-internal-format
@@ -19637,9 +19628,9 @@ msgid "Analyzed alias has no reference"
 msgstr ""
 
 #: cgraph.c:3336
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "No edge out of thunk node"
-msgstr ""
+msgstr "bittikentän %qs leveys on negatiivinen"
 
 #: cgraph.c:3341
 #, gcc-internal-format
@@ -19730,7 +19721,7 @@ msgstr "%qs-attribuuttia ei huomioida %qs:lle"
 #: cgraphunit.c:976 c/c-decl.c:11507
 #, fuzzy, gcc-internal-format
 msgid "%q+F used but never defined"
-msgstr "nimike %q+D määritelty mutta käytettämättä"
+msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #: cgraphunit.c:978 c/c-decl.c:11517
 #, fuzzy, gcc-internal-format
@@ -19818,9 +19809,9 @@ msgid "can%'t get program status: %m"
 msgstr "ei voi lukea tiedostoa %s: %m"
 
 #: collect-utils.c:82
-#, fuzzy, gcc-internal-format, gfc-internal-format
+#, gcc-internal-format, gfc-internal-format
 msgid "%s terminated with signal %d [%s]%s"
-msgstr "%s%sTuntematon signaali %d\n"
+msgstr "%s päätettiin signaalilla %d [%s]%s"
 
 #: collect-utils.c:98
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -20056,9 +20047,9 @@ msgid "profile for function %qD not found in profile data"
 msgstr "”%s” ei ole oikea profiilidatatiedosto ”%s”:lle"
 
 #: coverage.c:358
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "number of counters in profile data for function %qD does not match its profile data (counter %qs, expected %i and have %i)"
-msgstr ""
+msgstr "”%s” ei ole oikea profiilidatatiedosto ”%s”:lle"
 
 #: coverage.c:367
 #, fuzzy, gcc-internal-format
@@ -20126,7 +20117,7 @@ msgid "%<-fdbg-cnt=%s%>"
 msgstr "%s[%s] %s%s%s"
 
 #: dbgcnt.c:188
-#, fuzzy, gcc-internal-format, gfc-internal-format
+#, gcc-internal-format, gfc-internal-format
 msgid "           %s"
 msgstr "          %s"
 
@@ -20503,9 +20494,9 @@ msgstr "nykyisen prosessin ryhmien noutaminen epäonnistui"
 
 #. The inferior failed to catch the signal.
 #: gcc.c:3270 gcc.c:3294
-#, fuzzy, gcc-internal-format, gfc-internal-format
+#, gcc-internal-format, gfc-internal-format
 msgid "%s signal terminated program %s"
-msgstr "käytä aina numeroita käyttäjän/ryhmän nimissä"
+msgstr "%s-signaali päätti %s-ohjelman"
 
 #: gcc.c:3772 opts-common.c:1326 opts-common.c:1358 opts-global.c:139
 #, gcc-internal-format
@@ -20941,9 +20932,9 @@ msgid "open /dev/zero: %m"
 msgstr "fopen %s: %m"
 
 #: ggc-page.c:2474 ggc-page.c:2480
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "can%'t write PCH file"
-msgstr "ei voi kirjoittaa tiedostoon %s: %m"
+msgstr "PCH-tiedostoa ei voi kirjoittaa"
 
 #: gimple-fold.c:1786 gimple-fold.c:2787
 #, fuzzy, gcc-internal-format
@@ -20961,9 +20952,8 @@ msgid "%G%qD destination unchanged after copying no bytes"
 msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-fold.c:2225 tree-ssa-strlen.c:2181
-#, fuzzy
 msgid "%G%qD specified bound %E equals destination size"
-msgstr "%qE esitelty funktion palauttavana funktiona"
+msgstr "%G%qD-määritelty raja %E on yhtäsuuri kuin kohteen kokoon"
 
 #: gimple-fold.c:2227
 #, fuzzy
@@ -21011,35 +21001,35 @@ msgid "%qE output truncated before the last format character"
 msgstr ""
 
 #: gimple-ssa-sprintf.c:2511 gimple-ssa-sprintf.c:2631
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE may write a terminating nul past the end of the destination"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%qE saattaa kirjoittaa päättävän nul-tavun kohteen lopun yli"
 
 #: gimple-ssa-sprintf.c:2513 gimple-ssa-sprintf.c:2633
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE writing a terminating nul past the end of the destination"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%qE kirjoittaa päättävän nul-tavun kohteen lopun yli"
 
 #: gimple-ssa-sprintf.c:2523
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing %wu byte into a region of size %wu"
 msgid_plural "%<%.*s%> directive writing %wu bytes into a region of size %wu"
-msgstr[0] "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivi kirjoittaa %wu tavun %wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivi kirjoittaa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2530
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing %wu byte into a region of size %wu"
 msgid_plural "%<%.*s%> directive output may be truncated writing %wu bytes into a region of size %wu"
-msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu tavu %wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2537
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing %wu byte into a region of size %wu"
 msgid_plural "%<%.*s%> directive output truncated writing %wu bytes into a region of size %wu"
-msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa %wu tavu %wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2548
 #, gcc-internal-format
@@ -21047,9 +21037,9 @@ msgid "%<%.*s%> directive output may be truncated writing up to %wu bytes into a
 msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2551
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing up to %wu bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoitettaessa jopa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2553
 #, gcc-internal-format
@@ -21057,14 +21047,14 @@ msgid "%<%.*s%> directive writing up to %wu bytes into a region of size %wu"
 msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2565
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing likely %wu or more bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa kaiketi ainakin %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2568
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing likely %wu or more bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa kaiketi ainakin %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2571
 #, gcc-internal-format
@@ -21077,9 +21067,9 @@ msgid "%<%.*s%> directive output may be truncated writing between %wu and %wu by
 msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu–%wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2583
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing between %wu and %wu bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin katkeaa kirjoittaessa %wu–%wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2586
 #, gcc-internal-format
@@ -21087,40 +21077,40 @@ msgid "%<%.*s%> directive writing between %wu and %wu bytes into a region of siz
 msgstr "%<%.*s%>-direktiivi kirjoittaa %wu–%wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2595
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing %wu or more bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa ainakin %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2598
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing %wu or more bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin katkeaa kirjoittaessa ainakin %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2600
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing %wu or more bytes into a region of size %wu"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivi kirjoittaa vähintään %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2642
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing %wu byte into a region of size between %wu and %wu"
 msgid_plural "%<%.*s%> directive writing %wu bytes into a region of size between %wu and %wu"
-msgstr[0] "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivi kirjoittaa %wu tavun %wu–%wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivi kirjoittaa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2649
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing %wu byte into a region of size between %wu and %wu"
 msgid_plural "%<%.*s%> directive output may be truncated writing %wu bytes into a region of size between %wu and %wu"
-msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu tavu %wu–%wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2657
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing %wu byte into a region of size between %wu and %wu"
 msgid_plural "%<%.*s%> directive output truncated writing %wu bytes into a region of size between %wu and %wu"
-msgstr[0] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
-msgstr[1] "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr[0] "%<%.*s%>-direktiivin katkeaa kirjoittaessa %wu tavu %wu–%wu tavun kokoiseen alueeseen"
+msgstr[1] "%<%.*s%>-direktiivin katkeaa kirjoittaessa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2669
 #, gcc-internal-format
@@ -21128,29 +21118,29 @@ msgid "%<%.*s%> directive output may be truncated writing up to %wu bytes into a
 msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2672
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing up to %wu bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2675
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing up to %wu bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2688
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing likely %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa kaiketi ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2691
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing likely %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa kaiketi ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2694
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing likely %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivi kirjoittanee ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2704
 #, gcc-internal-format
@@ -21158,49 +21148,48 @@ msgid "%<%.*s%> directive output may be truncated writing between %wu and %wu by
 msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa %wu–%wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2707
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing between %wu and %wu bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa %wu–%wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2710
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing between %wu and %wu bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivi kirjoittaa %wu–%wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2719
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output may be truncated writing %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2722
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output truncated writing %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivin tuloste saattaa katketa kirjoittaessa jopa %wu tavua %wu–%wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tuloste katkeaa kirjoittaessa ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2725
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive writing %wu or more bytes into a region of size between %wu and %wu"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivi kirjoittaa ainakin %wu tavua %wu–%wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2814
-#, fuzzy
 msgid "%G%<%.*s%> directive argument is null"
-msgstr "Funktion %s argumentti kohdassa %L on negatiivinen"
+msgstr "%G%<%.*s%>-direktiivin argumentti on null"
 
 #: gimple-ssa-sprintf.c:2887
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output of %wu bytes exceeds minimum required size of 4095"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin %wu tavun tuloste ylittää vaaditun vähimmäiskoon 4095"
 
 #: gimple-ssa-sprintf.c:2893
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output between %wu and %wu bytes exceeds minimum required size of 4095"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin %wu–%wu tavun tuloste ylittää vaaditun vähimmäiskoon 4095"
 
 #: gimple-ssa-sprintf.c:2900
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive output between %wu and %wu bytes may exceed minimum required size of 4095"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin %wu–%wu tavun tuloste saattaa ylittää vaaditun vähimmäiskoon 4095"
 
 #: gimple-ssa-sprintf.c:2930
 #, fuzzy, gcc-internal-format
@@ -21228,16 +21217,16 @@ msgid "%<%.*s%> directive output between %wu and %wu bytes may cause result to e
 msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
 
 #: gimple-ssa-sprintf.c:2974
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive argument is not a nul-terminated string"
-msgstr "Funktion %s argumentti kohdassa %L on negatiivinen"
+msgstr "%<%.*s%>-direktiivin argumentti ei ole nul-päätteinen merkkijono"
 
 #: gimple-ssa-sprintf.c:2987
 #, gcc-internal-format
 msgid "assuming directive output of %wu byte"
 msgid_plural "assuming directive output of %wu bytes"
-msgstr[0] ""
-msgstr[1] ""
+msgstr[0] "oletetaan direktiivin tuotos %wu-tavuiseksi"
+msgstr[1] "oletetaan direktiivin tuotos %wu-tavuiseksi"
 
 #: gimple-ssa-sprintf.c:2994
 #, fuzzy, gcc-internal-format
@@ -21252,71 +21241,71 @@ msgstr "direktiivin argumentti välillä [%E, %E]"
 #: gimple-ssa-sprintf.c:3000
 #, gcc-internal-format
 msgid "using the range [%E, %E] for directive argument"
-msgstr ""
+msgstr "käytetään väliä [%E, %E] direktiivin argumentille"
 
 #: gimple-ssa-sprintf.c:3020
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE output %wu byte into a destination of size %wu"
 msgid_plural "%qE output %wu bytes into a destination of size %wu"
-msgstr[0] "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
-msgstr[1] "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
+msgstr[0] "%qE tulosti %wu tavun %wu tavun kokoiseen kohteeseen"
+msgstr[1] "%qE tulosti %wu tavua %wu tavun kokoiseen kohteeseen"
 
 #: gimple-ssa-sprintf.c:3025
 #, gcc-internal-format
 msgid "%qE output between %wu and %wu bytes into a destination of size %wu"
-msgstr "%qE tulostaa %wu–%wu tavua %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti %wu–%wu tavua %wu tavun kokoiseen kohteeseen"
 
 #: gimple-ssa-sprintf.c:3030
 #, gcc-internal-format
 msgid "%qE output %wu or more bytes (assuming %wu) into a destination of size %wu"
-msgstr "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
 
 #: gimple-ssa-sprintf.c:3035
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE output %wu or more bytes into a destination of size %wu"
-msgstr "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti ainakin %wu tavua %wu tavun kokoiseen kohteeseen"
 
 #: gimple-ssa-sprintf.c:3046
 #, gcc-internal-format
 msgid "%qE output %wu byte"
 msgid_plural "%qE output %wu bytes"
-msgstr[0] ""
-msgstr[1] ""
+msgstr[0] "%qE tulosti %wu tavun"
+msgstr[1] "%qE tulosti %wu tavua"
 
 #: gimple-ssa-sprintf.c:3050
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE output between %wu and %wu bytes"
-msgstr "%qE tulostaa %wu–%wu tavua %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti %wu–%wu tavua"
 
 #: gimple-ssa-sprintf.c:3054
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE output %wu or more bytes (assuming %wu)"
-msgstr "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti ainakin %wu tavua (oletetaan %wu)"
 
 #: gimple-ssa-sprintf.c:3058
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE output %wu or more bytes"
-msgstr "%qE tulostaa vähintään %wu tavua (oletetaan %wu) %wu tavun kokoiseen kohteeseen"
+msgstr "%qE tulosti ainakin %wu tavua"
 
 #: gimple-ssa-sprintf.c:3433
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive width out of range"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin leveys sallitun välin ulkopuolella"
 
 #: gimple-ssa-sprintf.c:3467
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%.*s%> directive precision out of range"
-msgstr "%<%.*s%>-direktiivi kirjoittaa jopa %wu tavua %wu tavun kokoiseen alueeseen"
+msgstr "%<%.*s%>-direktiivin tarkkuus sallitun välin ulkopuolella"
 
 #: gimple-ssa-sprintf.c:4096
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "specified bound %wu exceeds maximum object size %wu"
-msgstr "paikallisten objektien kokonaiskoko on liian suuri"
+msgstr "määritelty raja %wu ylittää olion enimmäiskoon %wu"
 
 #: gimple-ssa-sprintf.c:4107
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "specified bound %wu exceeds %<INT_MAX%>"
-msgstr "paikallisten objektien kokonaiskoko on liian suuri"
+msgstr "määritelty raja %wu ylittää %<INT_MAX%>:in"
 
 #: gimple-ssa-sprintf.c:4128
 #, fuzzy, gcc-internal-format
@@ -21339,44 +21328,44 @@ msgid "%Gnull format string"
 msgstr "%s muotoilumerkkijonossa kohdassa %L"
 
 #: gimple-ssa-warn-alloca.c:531
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "use of %<alloca%>"
-msgstr "virheellinen %<auto%>:n käyttö muunnosoperaattorissa"
+msgstr "%<alloca%>:n käyttö"
 
 #: gimple-ssa-warn-alloca.c:567
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "argument to variable-length array may be too large"
-msgstr "käytetään muuttuvapituista taulukkoa"
+msgstr "muuttuvapituisen taulukon argumentti voi olla liian suuri"
 
 #: gimple-ssa-warn-alloca.c:569
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "argument to %<alloca%> may be too large"
-msgstr "blocks-argumentti on liian suuri, maksimi on %llu"
+msgstr "%<alloca%>:n argumentti voi olla liian suuri"
 
 #: gimple-ssa-warn-alloca.c:574
 #, gcc-internal-format
 msgid "limit is %wu bytes, but argument may be as large as %s"
-msgstr ""
+msgstr "raja on %wu tavua, mutta argumentin koko voi olla jopa %s"
 
 #: gimple-ssa-warn-alloca.c:585
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "argument to variable-length array is too large"
-msgstr "käytetään muuttuvapituista taulukkoa"
+msgstr "muuttuvapituisen taulukon argumentti on liian suuri"
 
 #: gimple-ssa-warn-alloca.c:587
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "argument to %<alloca%> is too large"
-msgstr "blocks-argumentti on liian suuri, maksimi on %llu"
+msgstr "%<alloca%>:n argumentti on liian suuri"
 
 #: gimple-ssa-warn-alloca.c:591
 #, gcc-internal-format
 msgid "limit is %wu bytes, but argument is %s"
-msgstr ""
+msgstr "raja on %wu tavua, mutta argumentti on %s"
 
 #: gimple-ssa-warn-alloca.c:599
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "variable-length array bound is unknown"
-msgstr "käytetään muuttuvapituista taulukkoa"
+msgstr "muuttuvapituisen taulukon raja on tuntematon"
 
 #: gimple-ssa-warn-alloca.c:600
 #, fuzzy, gcc-internal-format
@@ -21414,9 +21403,9 @@ msgid "argument to variable-length array is zero"
 msgstr "käytetään muuttuvapituista taulukkoa"
 
 #: gimple-ssa-warn-alloca.c:625
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "argument to %<alloca%> is zero"
-msgstr "%<__builtin_prefetch%>-funktion toinen argumentti on epäkelpo; käytetään nollaa"
+msgstr "%<alloca%>-funktion argumentti on nolla"
 
 #: gimple-ssa-warn-restrict.c:1437
 #, fuzzy
@@ -21550,9 +21539,9 @@ msgid "%G%qD pointer overflow between offset %s and size %s accessing array %qD
 msgstr ""
 
 #: gimple-ssa-warn-restrict.c:1722
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "array %qD declared here"
-msgstr "%qD esitelty täällä"
+msgstr "taulukko %qD esitelty täällä"
 
 #: gimple-ssa-warn-restrict.c:1727 gimple-ssa-warn-restrict.c:1733
 msgid "%G%qD pointer overflow between offset %s and size %s"
@@ -21870,9 +21859,9 @@ msgid "%<mutexinoutset%> kind in %<depend%> clause on a %<taskwait%> construct"
 msgstr "muuttuja %qD esitelty uudelleen funktiona"
 
 #: gimplify.c:12131 omp-low.c:2926
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<ordered%> construct with %<depend%> clause must be closely nested inside a loop with %<ordered%> clause with a parameter"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: gimplify.c:12149
 #, gcc-internal-format
@@ -22073,9 +22062,9 @@ msgstr "edellinen määrittely täällä"
 
 #: ipa-devirt.c:1027 ipa-devirt.c:1042 ipa-devirt.c:1323 ipa-devirt.c:1399
 #: ipa-devirt.c:1438 ipa-devirt.c:1456
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "a different type is defined in another translation unit"
-msgstr "%J%qD esitelty avoimeksi määrittelyn jälkeen"
+msgstr "erilainen tyyppi määritelty toisessa käännösyksikössä"
 
 #: ipa-devirt.c:1034
 #, gcc-internal-format
@@ -22113,9 +22102,9 @@ msgid "the incompatible type is defined here"
 msgstr "lueteltu tyyppi määritelty täällä"
 
 #: ipa-devirt.c:1213
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "array types have different bounds"
-msgstr "?:-lausekkeen operandeilla on eri tyypit, %qT ja %qT"
+msgstr "taulukkotyypeillä on eri rajat"
 
 #: ipa-devirt.c:1228
 #, fuzzy, gcc-internal-format
@@ -22616,14 +22605,14 @@ msgid "multiple %<default%> targets were set"
 msgstr "useita default-nimikkeitä samassa switch-lauseessa"
 
 #: omp-expand.c:2150
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<depend%> clause with %<sink%> modifier waiting for lexically later iteration"
-msgstr ""
+msgstr "argumenttien määrä ei vastaa prototyyppiä"
 
 #: omp-expand.c:2287
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<depend%> clause with %<sink%> modifier refers to iteration never in the iteration space"
-msgstr ""
+msgstr "argumenttien määrä ei vastaa prototyyppiä"
 
 #: omp-general.c:637
 #, fuzzy, gcc-internal-format
@@ -22766,9 +22755,9 @@ msgid "%<ordered%> region must be closely nested inside a loop region with an %<
 msgstr ""
 
 #: omp-low.c:2984
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<ordered%> region without %<depend%> clause may not be closely nested inside a loop region with an %<ordered%> clause with a parameter"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: omp-low.c:3015
 #, gcc-internal-format
@@ -23369,14 +23358,14 @@ msgid "pass %s needs a set_pass_param implementation to handle the extra argumen
 msgstr ""
 
 #: passes.c:1024
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "unrecognized option %<-fenable%>"
-msgstr "tunnistamaton valitsin"
+msgstr "tunnistamaton valitsin %<-fenable%>"
 
 #: passes.c:1026
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "unrecognized option %<-fdisable%>"
-msgstr "tunnistamaton valitsin"
+msgstr "tunnistamaton valitsin %<fdisable%>"
 
 #: passes.c:1034
 #, fuzzy, gcc-internal-format
@@ -23515,7 +23504,7 @@ msgstr "luetellun tyypin jäsenen %qE arvo ei ole kokonaislukuvakio"
 #: predict.c:2509
 #, gcc-internal-format
 msgid "probability %qE is outside the range [0.0, 1.0]"
-msgstr ""
+msgstr "todennäköisyys %qE ei ole välillä [0,0; 1.0]"
 
 #: predict.c:3483
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -23756,9 +23745,9 @@ msgid "RTL check: expected code '%s', '%s' or '%s', have '%s' in %s, at %s:%d"
 msgstr "verifiointi epäonnistui kohdassa PC=%d: %s"
 
 #: rtl.c:936
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "RTL check: attempt to treat non-block symbol as a block symbol in %s, at %s:%d"
-msgstr ""
+msgstr "verifiointi epäonnistui kohdassa PC=%d: %s"
 
 #: rtl.c:946
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -24006,9 +23995,9 @@ msgid "mixing different types of symbol in same comdat groups is not supported"
 msgstr ""
 
 #: symtab.c:1126
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "node is alone in a comdat group"
-msgstr ""
+msgstr "virheellinen sisäinen makro ”%s”"
 
 #: symtab.c:1133
 #, gcc-internal-format
@@ -24026,9 +24015,9 @@ msgid "implicit_section flag is set but section isn%'t"
 msgstr "funktio %qE esitelty implisiittisesti"
 
 #: symtab.c:1165
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "Both section and comdat group is set"
-msgstr ""
+msgstr "virheellinen sisäinen makro ”%s”"
 
 #: symtab.c:1177
 #, fuzzy, gcc-internal-format
@@ -25219,9 +25208,9 @@ msgid "BB %i is missing an edge"
 msgstr "fr30_print_operand: tunnistamaton %%b-koodi"
 
 #: tree-eh.c:4856
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "BB %i too many fallthru edges"
-msgstr ""
+msgstr "nimettömällä kentällä on vaillinainen tyyppi"
 
 #: tree-eh.c:4865
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -25913,9 +25902,9 @@ msgid "TYPE_MAIN_VARIANT has different TYPE_MAIN_VARIANT"
 msgstr "tyyppitäsmäämättömyys komponenttiviitteessä"
 
 #: tree.c:14324
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "TYPE_CANONICAL has different TYPE_CANONICAL"
-msgstr ""
+msgstr "tyyppitäsmäämättömyys komponenttiviitteessä"
 
 #: tree.c:14343
 #, fuzzy, gcc-internal-format
@@ -25958,14 +25947,14 @@ msgid "TYPE_BINFO type is not TYPE_MAIN_VARIANT"
 msgstr "tyyppitäsmäämättömyys komponenttiviitteessä"
 
 #: tree.c:14431
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "TYPE_METHOD_BASETYPE is not record nor union"
-msgstr ""
+msgstr "funktiokutsu epäsopivan tyypin läpi"
 
 #: tree.c:14442
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "TYPE_OFFSET_BASETYPE is not record nor union"
-msgstr ""
+msgstr "funktiokutsu epäsopivan tyypin läpi"
 
 #: tree.c:14460
 #, fuzzy, gcc-internal-format
@@ -26767,7 +26756,7 @@ msgstr "%qE-attribuutti pätee vain funktioihin"
 #: c-family/c-attribs.c:2894
 #, gcc-internal-format
 msgid "%qE attribute ignored on a function returning %qT"
-msgstr "%qE-attribuuttia ei huomioida %qT:n palauttavalle funktiolle"
+msgstr "%qE-attribuuttia ei huomioida %qT-tyypin palauttavalle funktiolle"
 
 #: c-family/c-attribs.c:2913
 #, fuzzy, gcc-internal-format
@@ -27042,9 +27031,9 @@ msgid "signed conversion from %qT to %qT changes the value of %qE"
 msgstr "muunnos tyypistä %qT tyyppiin %qT on moniselitteinen"
 
 #: c-family/c-common.c:1530 c-family/c-common.c:1592
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "conversion to %qT from %qT may change the sign of the result"
-msgstr "muunnos tyypistä %qT tyyppiin %qT on moniselitteinen"
+msgstr "muunnos tyypistä %qT tyyppiin %qT on saattaa muuttaa tuloksen etumerkin"
 
 #: c-family/c-common.c:1778
 #, gcc-internal-format
@@ -28729,9 +28718,9 @@ msgid "complex floating point overflow in expression of type %qT results in %qE"
 msgstr "kompleksiliukulukuylivuoto lausekkeessa"
 
 #: c-family/c-warn.c:227
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "logical %<or%> applied to non-boolean constant"
-msgstr ""
+msgstr "taulukon %qE koko ei ole kokonaislukutyyppiä"
 
 #: c-family/c-warn.c:231
 #, gcc-internal-format
@@ -29294,7 +29283,7 @@ msgstr "%<X<=Y<=Z%> -tyylisillä vertailuilla on eri merkitys kuin matematiikass
 #: c-family/c-warn.c:2021
 #, gcc-internal-format
 msgid "label %q+D defined but not used"
-msgstr "nimike %q+D määritelty mutta käytettämättä"
+msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #: c-family/c-warn.c:2023
 #, gcc-internal-format
@@ -29539,9 +29528,9 @@ msgid "%<-mcpu=%s%> is not valid"
 msgstr "-mcpu=%s ei ole kelvollinen"
 
 #: common/config/bfin/bfin-common.c:359
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mcpu=%s%> has invalid silicon revision"
-msgstr ""
+msgstr "-mcpu=%s ei ole kelvollinen"
 
 #: common/config/i386/i386-common.c:1340
 #, fuzzy, gcc-internal-format
@@ -29584,9 +29573,9 @@ msgid "%<-fsplit-stack%> currently only supported on GNU/Linux"
 msgstr ""
 
 #: common/config/i386/i386-common.c:1433
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-fsplit-stack%> requires assembler support for CFI directives"
-msgstr ""
+msgstr "ISO C90 ei tue joustavia taulukon jäseniä"
 
 #: common/config/ia64/ia64-common.c:58
 #, fuzzy, gcc-internal-format
@@ -29657,9 +29646,9 @@ msgid "%<-march=%s%>: first ISA subset must be %<e%>, %<i%> or %<g%>"
 msgstr ""
 
 #: common/config/riscv/riscv-common.c:378
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-march=%s%>: unsupported ISA subset %<%c%>"
-msgstr ""
+msgstr "valitsin -mcpu=%s on ristiriidassa valitsimen -march=%s kanssa"
 
 #: common/config/riscv/riscv-common.c:382
 #, gcc-internal-format
@@ -29672,9 +29661,9 @@ msgid "%<-march=%s%>: %s must separate with _"
 msgstr "%s %qs"
 
 #: common/config/riscv/riscv-common.c:486
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-march=%s%>: ISA string must begin with rv32 or rv64"
-msgstr ""
+msgstr "%s %qs"
 
 #: common/config/rx/rx-common.c:61
 #, gcc-internal-format
@@ -31128,24 +31117,24 @@ msgid "unknown core architecture %qs specified with %qs"
 msgstr "Funktio %qs:"
 
 #: config/avr/avr.c:765 config/visium/visium.c:422
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<-fpic%> is not supported"
-msgstr "-fPIC ei ole tuettu"
+msgstr "%<-fPIC%> ei ole tuettu"
 
 #: config/avr/avr.c:767 config/visium/visium.c:424
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<-fPIC%> is not supported"
-msgstr "-fPIC ei ole tuettu"
+msgstr "%<-fPIC%> ei ole tuettu"
 
 #: config/avr/avr.c:769
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<-fpie%> is not supported"
-msgstr "Ei ole tuettu"
+msgstr "%<-fpie%> ei ole tuettu"
 
 #: config/avr/avr.c:771
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<-fPIE%> is not supported"
-msgstr "Ei ole tuettu"
+msgstr "%<-fPIE%> ei ole tuettu"
 
 #: config/avr/avr.c:1047 config/avr/avr.c:1052 config/riscv/riscv.c:4787
 #, fuzzy, gcc-internal-format
@@ -31464,9 +31453,9 @@ msgid "unknown CRIS version specification in %<-march=%> or %<-mcpu=%> : %s"
 msgstr ""
 
 #: config/cris/cris.c:2719
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "unknown CRIS cpu version specification in %<-mtune=%> : %s"
-msgstr ""
+msgstr "Tuntematon argumenttiluettelofunktio kohdassa %L"
 
 #: config/cris/cris.c:2740
 #, fuzzy, gcc-internal-format
@@ -31792,9 +31781,9 @@ msgid "%<-mexr%> is used without %<-ms%> or %<-msx%>"
 msgstr "PROCEDURE-lauseen kohdassa %C on oltava geneerisessä rajapinnassa"
 
 #: config/h8300/h8300.c:381
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mno-exr%> valid only with %<-ms%> or %<-msx%> - Option ignored!"
-msgstr ""
+msgstr "PROCEDURE-lauseen kohdassa %C on oltava geneerisessä rajapinnassa"
 
 #: config/h8300/h8300.c:388
 #, fuzzy, gcc-internal-format
@@ -32102,9 +32091,9 @@ msgid "fixed ebp register requires %<target(\"accumulate-outgoing-args\")%>"
 msgstr ""
 
 #: config/i386/i386.c:4609
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mfentry%> isn%'t supported for 32-bit in combination with %<-fpic%>"
-msgstr ""
+msgstr "%qE-attribuutti pätee vain funktioihin"
 
 #: config/i386/i386.c:4612
 #, fuzzy, gcc-internal-format
@@ -32919,19 +32908,19 @@ msgid "%qs is an invalid argument to %<-mcpu=%>"
 msgstr "%qs-attribuutin virheellinen argumentti"
 
 #: config/microblaze/microblaze.c:1823
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mxl-multiply-high%> can be used only with %<-mcpu=v6.00.a%> or greater"
-msgstr ""
+msgstr "Valitsinta --pax-option voi käyttää vain POSIX-arkistoille"
 
 #: config/microblaze/microblaze.c:1840
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mxl-reorder%> can be used only with %<-mcpu=v8.30.a%> or greater"
-msgstr ""
+msgstr "Valitsinta --pax-option voi käyttää vain POSIX-arkistoille"
 
 #: config/microblaze/microblaze.c:1847
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mxl-reorder%> requires %<-mxl-pattern-compare%> for %<-mcpu=v8.30.a%>"
-msgstr ""
+msgstr "valitsin vaatii argumentin -- %s"
 
 #: config/microblaze/microblaze.c:1853
 #, gcc-internal-format
@@ -33593,9 +33582,9 @@ msgid "Unknown form for stack limit expression"
 msgstr ""
 
 #: config/nios2/nios2.c:1182
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "switch %<-mcustom-%s%> is required for double precision floating point"
-msgstr ""
+msgstr "Älä käytä laitteistoliukulukuja"
 
 #: config/nios2/nios2.c:1195
 #, gcc-internal-format
@@ -33748,14 +33737,14 @@ msgid "%<custom-%s=%> argument should be a non-negative integer"
 msgstr "%q+D:n ensimmäisen argumentin pitäisi olla %<int%>"
 
 #: config/nios2/nios2.c:4293
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<custom-%s=%> is not recognized as FPU instruction"
-msgstr ""
+msgstr "weakref ei ole tuettu tässä konfiguraatiossa"
 
 #: config/nios2/nios2.c:4300
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<%s%> is unknown"
-msgstr "%s: tuntematon merkki kentässä ”%s”"
+msgstr "%<%s%> on tuntematon"
 
 #: config/nvptx/mkoffload.c:109
 #, fuzzy, gcc-internal-format
@@ -34005,9 +33994,9 @@ msgid "missing open paren"
 msgstr "Avaa"
 
 #: config/rs6000/rs6000-c.c:67
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "missing number"
-msgstr "$-operandinumero puuttuu muotoilussa"
+msgstr "puuttuva luku"
 
 #: config/rs6000/rs6000-c.c:69
 #, fuzzy, gcc-internal-format
@@ -34015,9 +34004,9 @@ msgid "missing close paren"
 msgstr "Sulje"
 
 #: config/rs6000/rs6000-c.c:72
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "number must be 0 or 1"
-msgstr "{0} versio {1}"
+msgstr "luvun on oltava 0 tai 1"
 
 #: config/rs6000/rs6000-c.c:75
 #, fuzzy, gcc-internal-format
@@ -34936,9 +34925,9 @@ msgid "%<-mhard-dfp%> can%'t be used in conjunction with %<-msoft-float%>"
 msgstr ""
 
 #: config/s390/s390.c:15141
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mbackchain%> %<-mpacked-stack%> %<-mhard-float%> are not supported in combination"
-msgstr ""
+msgstr "-fPIC ei ole tuettu"
 
 #: config/s390/s390.c:15147
 #, fuzzy, gcc-internal-format
@@ -34972,9 +34961,9 @@ msgid "argument to %qs is too large (max. %d)"
 msgstr "blocks-argumentti on liian suuri, maksimi on %llu"
 
 #: config/s390/s390.c:15314
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<-mno-pic-data-is-text-relative%> cannot be used without %<-fpic%>/%<-fPIC%>"
-msgstr ""
+msgstr "PROCEDURE-lauseen kohdassa %C on oltava geneerisessä rajapinnassa"
 
 #. Value is not allowed for the target attribute.
 #: config/s390/s390.c:15481
@@ -36694,12 +36683,12 @@ msgstr "jäsenen %q+D kaksoiskappale"
 #: c/c-decl.c:8103
 #, gcc-internal-format
 msgid "empty struct has size 0 in C, size 1 in C++"
-msgstr ""
+msgstr "tyhjän structin koko on C:ssä 0, C++:ssa 1"
 
 #: c/c-decl.c:8106
 #, gcc-internal-format
 msgid "empty union has size 0 in C, size 1 in C++"
-msgstr ""
+msgstr "tyhjän unionin koko on C:ssä 0, C++:ssa 1"
 
 #: c/c-decl.c:8211
 #, gcc-internal-format
@@ -38564,9 +38553,9 @@ msgid "expected %<acq_rel%>, %<release%> or %<acquire%>"
 msgstr "  odotettiin luokkamallia, saatiin %qT"
 
 #: c/c-parser.c:16700 cp/parser.c:36276
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<flush%> list specified together with memory order clause"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: c/c-parser.c:16749 cp/parser.c:36876
 #, fuzzy, gcc-internal-format
@@ -40282,9 +40271,9 @@ msgid "variable length element type in array %<reduction%> clause"
 msgstr "käytetään muuttuvapituista taulukkoa"
 
 #: c/c-typeck.c:13943 c/c-typeck.c:14589 cp/semantics.c:7720
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<nowait%> clause must not be used together with %<copyprivate%>"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: c/c-typeck.c:13955 cp/semantics.c:7763
 #, fuzzy, gcc-internal-format
@@ -40478,9 +40467,9 @@ msgid "%<simdlen%> clause value is bigger than %<safelen%> clause value"
 msgstr ""
 
 #: c/c-typeck.c:14754 cp/semantics.c:7696
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<nonmonotonic%> schedule modifier specified together with %<ordered%> clause"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: c/c-typeck.c:14772 cp/semantics.c:7663
 #, fuzzy, gcc-internal-format
@@ -40488,9 +40477,9 @@ msgid "%<linear%> clause step is a parameter %qD not specified in %<uniform%> cl
 msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: c/c-typeck.c:14787 cp/semantics.c:7709
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "%<nogroup%> clause must not be used together with %<reduction%> clause"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: c/c-typeck.c:14953
 #, fuzzy, gcc-internal-format
@@ -41928,9 +41917,9 @@ msgid "assuming pointer to member %qD"
 msgstr "%qD ei ole %qD:n jäsen"
 
 #: cp/class.c:8049
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "(a pointer to member can only be formed with %<&%E%>)"
-msgstr ""
+msgstr "keskeytyskäsittelijät eivät voi olla MIPS16-funktioita"
 
 #: cp/class.c:8125 cp/class.c:8167
 #, fuzzy, gcc-internal-format
@@ -42896,7 +42885,7 @@ msgid "ambiguating new declaration of %q#D"
 msgstr "%q+D:lle ei ole edellistä esittelyä"
 
 #: cp/decl.c:1714
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "conflicting declaration %q#D"
 msgstr "ristiriitainen esittely %q#D"
 
@@ -42961,7 +42950,7 @@ msgid "redundant redeclaration of %qD in same scope"
 msgstr "%qD uudelleenesitellään tarpeettomasti samalla näkyvyysalueella"
 
 #: cp/decl.c:1980
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "deleted definition of %qD"
 msgstr "%qD:n poistettu määrittely"
 
@@ -44624,9 +44613,9 @@ msgid "member functions are implicitly friends of their class"
 msgstr "staattinen jäsenfunktio %q#D esitelty tyyppimääreillä"
 
 #: cp/decl.c:11871
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "extra qualification %<%T::%> on member %qs"
-msgstr "ylimääräinen %<;%>"
+msgstr "ylimääräinen kvalifiointi %<%T::%> jäsenelle %qs"
 
 #: cp/decl.c:11901
 #, fuzzy, gcc-internal-format
@@ -45788,7 +45777,7 @@ msgstr "ei argumentteja"
 #: cp/error.c:3796
 #, gcc-internal-format
 msgid "[...]"
-msgstr ""
+msgstr "[...]"
 
 #: cp/error.c:4150
 #, fuzzy, gcc-internal-format
@@ -46303,9 +46292,9 @@ msgid "non-constant array new length must be specified directly, not by typedef"
 msgstr ""
 
 #: cp/init.c:3011
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "non-constant array new length must be specified without parentheses around the type-id"
-msgstr ""
+msgstr "taulukkoindeksi ei-taulukkoalustimessa"
 
 #: cp/init.c:3021
 #, fuzzy, gcc-internal-format
@@ -48601,9 +48590,9 @@ msgid "expected class-key"
 msgstr "odotettiin %<class%>"
 
 #: cp/parser.c:24227
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "ISO C++ forbids typename key in template template parameter; use %<-std=c++17%> or %<-std=gnu++17%>"
-msgstr ""
+msgstr "attribuutti %qs pätee vain funktiotyyppeihin"
 
 #: cp/parser.c:24231
 #, fuzzy, gcc-internal-format
@@ -52187,7 +52176,7 @@ msgstr ""
 #: cp/typeck.c:9466 cp/typeck.c:9489
 #, gcc-internal-format
 msgid "remove %<std::move%> call"
-msgstr ""
+msgstr "poista %<std::move%>-kutsu"
 
 #: cp/typeck.c:9488
 #, fuzzy, gcc-internal-format
@@ -54955,9 +54944,9 @@ msgid "Variable %qs at %L may not be a C interoperable kind but it is BIND(C)"
 msgstr "BIND(C)-funktion ”%s” paluutyyppi kohdassa %L ei voi olla taulukko"
 
 #: fortran/decl.c:5708
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "Variable %qs in common block %qs at %L cannot be declared with BIND(C) since it is not a global"
-msgstr ""
+msgstr "BIND(C)-funktion ”%s” paluutyyppi kohdassa %L ei voi olla taulukko"
 
 #: fortran/decl.c:5722
 #, fuzzy, gcc-internal-format
@@ -57221,9 +57210,9 @@ msgid "Assumed-shape actual argument at %L is incompatible with the non-assumed-
 msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/interface.c:3322
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "Array-section actual argument at %L is incompatible with the non-assumed-shape dummy argument %qs due to VOLATILE attribute"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/interface.c:3342
 #, fuzzy, gcc-internal-format
@@ -58091,14 +58080,14 @@ msgid "NAMELIST %qs in READ statement at %L contains the symbol %qs which may no
 msgstr ""
 
 #: fortran/io.c:3387
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "NAMELIST object %qs in namelist %qs at %L is polymorphic and requires a defined input/output procedure"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/io.c:3397 fortran/resolve.c:14545
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "NAMELIST object %qs in namelist %qs at %L with ALLOCATABLE or POINTER components"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/io.c:3405
 #, fuzzy, gcc-internal-format
@@ -58860,9 +58849,9 @@ msgid "MOLD tag at %L conflicts with SOURCE tag at %L"
 msgstr "SAVE-attribuuttia kohdassa %L ei voida määritellä PURE-proseduurissa"
 
 #: fortran/match.c:4462
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Allocate-object at %L with a deferred type parameter requires either a type-spec or SOURCE tag or a MOLD tag"
-msgstr ""
+msgstr "kolme pistettä sisältävä parametriluettelo ei sovellu tyhjään parametrinimiluettelon esittelyyn"
 
 #: fortran/match.c:4474
 #, gcc-internal-format, gfc-internal-format
@@ -58948,9 +58937,9 @@ msgid "Variable %qs at %L in common block %qs at %C must be declared with a C in
 msgstr "BIND(C)-funktion ”%s” paluutyyppi kohdassa %L ei voi olla taulukko"
 
 #: fortran/match.c:5145
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "Variable %qs in common block %qs at %C cannot be bind(c) since it is not global"
-msgstr ""
+msgstr "BIND(C)-funktion ”%s” paluutyyppi kohdassa %L ei voi olla taulukko"
 
 #: fortran/match.c:5152
 #, fuzzy, gcc-internal-format
@@ -59831,9 +59820,9 @@ msgid "IF clause at %L requires a scalar LOGICAL expression"
 msgstr "decltypen argumentin on oltava lauseke"
 
 #: fortran/openmp.c:4038
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "IF clause without modifier at %L used together with IF clauses with modifiers"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: fortran/openmp.c:4115
 #, gcc-internal-format, gfc-internal-format
@@ -60039,9 +60028,9 @@ msgid "LINEAR clause modifier used on DO or SIMD construct at %L"
 msgstr ""
 
 #: fortran/openmp.c:4722
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "LINEAR clause specified together with ORDERED clause with argument at %L"
-msgstr ""
+msgstr "%<void%> vain parametrina ei ole oikeutettu"
 
 #: fortran/openmp.c:4727
 #, fuzzy, gcc-internal-format
@@ -60084,9 +60073,9 @@ msgid "SOURCE dependence type only allowed on ORDERED directive at %L"
 msgstr ""
 
 #: fortran/openmp.c:4871
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "%s must contain at least one MAP clause at %L"
-msgstr ""
+msgstr "%Hdatamäärittelyllä ei ole tyyppiä eikä tallennusluokkaa"
 
 #: fortran/openmp.c:4968
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -60219,9 +60208,9 @@ msgid "%s iteration variable present on clause other than LINEAR at %L"
 msgstr "”!$OMP DO”-iteraatiomuuttuja on läsnä muussa lauseessa kuin PRIVATE tai LASTPRIVATE kohdassa %L"
 
 #: fortran/openmp.c:5691
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "%s collapsed loops don't form rectangular iteration space at %L"
-msgstr ""
+msgstr "liian vähän argumentteja"
 
 #: fortran/openmp.c:5703
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -60254,9 +60243,9 @@ msgid "!$ACC LOOP iteration variable must be of type integer at %L"
 msgstr "”!$OMP DO”-iteraatiomuuttuja ei saa olla THREADPRIVATE kohdassa %L"
 
 #: fortran/openmp.c:5858
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "!$ACC LOOP %s loops don't form rectangular iteration space at %L"
-msgstr ""
+msgstr "liian vähän argumentteja"
 
 #: fortran/openmp.c:5870
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -60624,14 +60613,14 @@ msgid "Noncoarray component %s at %L of type LOCK_TYPE or with subcomponent of t
 msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3034
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Noncoarray component %s at %L of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must have a codimension or be a subcomponent of a coarray. (Variables of type %s may not have a codimension as %s at %L has a codimension or a coarray subcomponent)"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3044
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Component %s at %L of type EVENT_TYPE must have a codimension or be a subcomponent of a coarray, which is not possible as the component has the pointer attribute"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3050
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -60649,14 +60638,14 @@ msgid "Allocatable component %s at %L must have a codimension as it has a noncoa
 msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3064
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Noncoarray component %s at %L of type EVENT_TYPE or with subcomponent of type EVENT_TYPE must have a codimension or be a subcomponent of a coarray. (Variables of type %s may not have a codimension as already a coarray subcomponent exists)"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3071
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Noncoarray component %s at %L of type EVENT_TYPE or with subcomponent of type EVENT_TYPE must have a codimension or be a subcomponent of a coarray. (Variables of type %s may not have a codimension as %s at %L has a codimension or a coarray subcomponent)"
-msgstr ""
+msgstr "muuttuvakokoista objektia ei voi alustaa"
 
 #: fortran/parse.c:3123
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -61554,9 +61543,9 @@ msgid "ENTRY result %s cannot be an array in FUNCTION %s at %L"
 msgstr "Muuttujatyyppi on UNKNOWN sijoituksessa kohdassa %L"
 
 #: fortran/resolve.c:852
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "FUNCTION result %s cannot be a POINTER in FUNCTION %s at %L"
-msgstr ""
+msgstr "Muuttuja %s ei voida liittää PURE-proseduuriin kohdassa %C"
 
 #: fortran/resolve.c:856
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -61564,14 +61553,14 @@ msgid "ENTRY result %s cannot be a POINTER in FUNCTION %s at %L"
 msgstr "Muuttuja %s ei voida liittää PURE-proseduuriin kohdassa %C"
 
 #: fortran/resolve.c:894
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "FUNCTION result %s cannot be of type %s in FUNCTION %s at %L"
-msgstr ""
+msgstr "Muuttujatyyppi on UNKNOWN sijoituksessa kohdassa %L"
 
 #: fortran/resolve.c:899
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "ENTRY result %s cannot be of type %s in FUNCTION %s at %L"
-msgstr ""
+msgstr "Muuttujatyyppi on UNKNOWN sijoituksessa kohdassa %L"
 
 #: fortran/resolve.c:945
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -63120,9 +63109,9 @@ msgid "Procedure pointer result %qs at %L is missing the pointer attribute"
 msgstr "tyhjä esittely"
 
 #: fortran/resolve.c:12873
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Mismatch in ELEMENTAL attribute between MODULE PROCEDURE at %L and its interface in %s"
-msgstr ""
+msgstr "Syntaksivirhe PROCEDURE-lauseessa kohdassa %C"
 
 #: fortran/resolve.c:12881
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -63130,9 +63119,9 @@ msgid "Mismatch in PURE attribute between MODULE PROCEDURE at %L and its interfa
 msgstr "Syntaksivirhe PROCEDURE-lauseessa kohdassa %C"
 
 #: fortran/resolve.c:12889
-#, gcc-internal-format, gfc-internal-format
+#, fuzzy, gcc-internal-format, gfc-internal-format
 msgid "Mismatch in RECURSIVE attribute between MODULE PROCEDURE at %L and its interface in %s"
-msgstr ""
+msgstr "Syntaksivirhe PROCEDURE-lauseessa kohdassa %C"
 
 #: fortran/resolve.c:12898
 #, gcc-internal-format
@@ -63450,9 +63439,9 @@ msgid "CLASS variable %qs at %L cannot have the PARAMETER attribute"
 msgstr "Muuttujalla ”%s” kohdassa %L ei voi olla sekä POINTER- että BIND(C)-attribuutit"
 
 #: fortran/resolve.c:14705
-#, gcc-internal-format
+#, fuzzy, gcc-internal-format
 msgid "The object %qs at %L has a deferred LEN parameter %qs and is neither allocatable nor a pointer"
-msgstr ""
+msgstr "kolme pistettä sisältävä parametriluettelo ei sovellu tyhjään parametrinimiluettelon esittelyyn"
 
 #: fortran/resolve.c:14716
 #, gcc-internal-format
@@ -65217,9 +65206,9 @@ msgid "cannot read LTO decls from %s"
 msgstr "tiedoston ”%s” otsaketta ei voi lukea"
 
 #: lto/lto.c:2197
-#, fuzzy, gcc-internal-format, gfc-internal-format
+#, gcc-internal-format, gfc-internal-format
 msgid "Cannot open %s"
-msgstr "'%s' ei voi avata"
+msgstr "Tiedostoa %s ei voi avata"
 
 #: lto/lto.c:2218
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -65497,9 +65486,9 @@ msgid "could not find interface for class %qE"
 msgstr "ei löydetä luokkaa %qE"
 
 #: objc/objc-act.c:1685 objc/objc-act.c:6831 objc/objc-act.c:6962
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "class %qE is deprecated"
-msgstr "%qE on vanhentunut"
+msgstr "luokka %qE on vanhentunut"
 
 #: objc/objc-act.c:1714
 #, fuzzy, gcc-internal-format
@@ -66462,6 +66451,9 @@ msgstr "tunnistamaton rekisterinimi %qs"
 msgid "unknown vtable verify initialization priority %qs"
 msgstr "(%qs:n alustuksen lähistöllä)"
 
+#~ msgid "%<-Werror=%> argument %qs is not valid for %s"
+#~ msgstr "%<-Werror=%>-argumentti %qs ei ole kelvollinen %s-kielelle"
+
 #~ msgid "invalid %%t operand '"
 #~ msgstr "virheellinen %%t-operandi"
 
@@ -68642,7 +68634,7 @@ msgstr "(%qs:n alustuksen lähistöllä)"
 
 #, fuzzy
 #~ msgid "variable %q+D set but not used"
-#~ msgstr "nimike %q+D määritelty mutta käytettämättä"
+#~ msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #~ msgid "jump to label %q+D"
 #~ msgstr "hyppy nimiöön %q+D"
@@ -68659,7 +68651,7 @@ msgstr "(%qs:n alustuksen lähistöllä)"
 
 #, fuzzy
 #~ msgid "parameter %q+D set but not used"
-#~ msgstr "nimike %q+D määritelty mutta käytettämättä"
+#~ msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #~ msgid "%q+D declared here"
 #~ msgstr "%q+D esitelty täällä"
@@ -69487,10 +69479,6 @@ msgstr "(%qs:n alustuksen lähistöllä)"
 #~ msgid "%Hredefinition of %q#T"
 #~ msgstr "%q#T uudelleenmääritelty"
 
-#, fuzzy
-#~ msgid "%H%qs is not valid for %qs"
-#~ msgstr "%qs ei ole kelpo tulostetiedosto"
-
 #, fuzzy
 #~ msgid "%Hiteration variable %qD should not be firstprivate"
 #~ msgstr "sisäkkäisessä funktiossa käytetty rekisterimuuttujaa %qD"
diff --git a/gcc/po/zh_CN.po b/gcc/po/zh_CN.po
index 5701d2a5d9e..f18c00a6ddb 100644
--- a/gcc/po/zh_CN.po
+++ b/gcc/po/zh_CN.po
@@ -4,6 +4,7 @@
 # Meng Jie <zuxy.meng@gmail.com>, 2005-2014.
 # Jeff Bai <jeffbai@aosc.xyz>, 2015.
 # Mingye Wang (Arthur2e5) <arthur200126@gmail.com>, 2015, 2016.
+# Boyuan Yang <073plan@gmail.com>, 2019.
 #
 # Fellow translatiors:
 # Many of the fuzzy strings are caused by an addition of a period (".")
@@ -30,20 +31,19 @@
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gcc 6.1.0\n"
+"Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2016-04-30 17:13-0400\n"
-"Last-Translator: Mingye Wang (Arthur2e5) <arthur200126@gmail.com>\n"
+"PO-Revision-Date: 2019-08-19 15:13-0400\n"
+"Last-Translator: Boyuan Yang <073plan@gmail.com>\n"
 "Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
 "Language: zh_CN\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Bugs: Report translation errors to the Language-Team address.\n"
-"X-Poedit-Basepath: C:/MSYS/source/gcc-4.6.0/gcc\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Poedit 1.8.7\n"
+"X-Generator: Poedit 2.2.3\n"
 
 #: cfgrtl.c:2705
 msgid "flow control insn inside a basic block"
@@ -478,12 +478,10 @@ msgid "  -o <file>                Place the output into <file>.\n"
 msgstr "  -o <文件>                输出到 <文件>。\n"
 
 #: gcc.c:3597
-#, fuzzy
-#| msgid "  -pie                     Create a position independent executable.\n"
 msgid ""
 "  -pie                     Create a dynamically linked position independent\n"
 "                           executable.\n"
-msgstr "  -pie                     生成位置无关可执行文件。\n"
+msgstr "  -pie                     生成动态链接的位置无关可执行文件。\n"
 
 #: gcc.c:3599
 msgid "  -shared                  Create a shared library.\n"
@@ -668,10 +666,9 @@ msgid "  rewrite [options] <dir>               Rewrite coverage file contents\n"
 msgstr "  rewrite [选项] <目录>                  覆写测试覆盖率文件内容\n"
 
 #: gcov-tool.c:270
-#, fuzzy, c-format
-#| msgid "    -n, --normalize <long long>         Normalize the profile\n"
+#, c-format
 msgid "    -n, --normalize <int64_t>           Normalize the profile\n"
-msgstr "    -n, --normalize <long long>         归一化配置\n"
+msgstr "    -n, --normalize <int64_t>           归一化配置\n"
 
 #: gcov-tool.c:272
 #, c-format
@@ -774,10 +771,9 @@ msgstr ""
 "%s。\n"
 
 #: gcov-tool.c:528
-#, fuzzy, c-format
-#| msgid "Copyright %s 2014-2016 Free Software Foundation, Inc.\n"
+#, c-format
 msgid "Copyright %s 2019 Free Software Foundation, Inc.\n"
-msgstr "版权所有 %s 2014-2015 自由软件基金会。\n"
+msgstr "版权所有 %s 2019 自由软件基金会。\n"
 
 #: gcov-tool.c:531 gcov.c:925
 #, c-format
@@ -791,15 +787,12 @@ msgstr ""
 "包括没有适销性和某一专用目的下的适用性担保。\n"
 
 #: gcov.c:885
-#, fuzzy, c-format
-#| msgid ""
-#| "Usage: gcov [OPTION]... SOURCE|OBJ...\n"
-#| "\n"
+#, c-format
 msgid ""
 "Usage: gcov [OPTION...] SOURCE|OBJ...\n"
 "\n"
 msgstr ""
-"用法：gconv [选项]... 源文件|对象文件...\n"
+"用法：gconv [选项...] 源文件|对象文件...\n"
 "\n"
 
 #: gcov.c:886
@@ -844,22 +837,19 @@ msgid "  -h, --help                      Print this help, then exit\n"
 msgstr "  -h, --help                      打印此帮助并退出\n"
 
 #: gcov.c:894
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -i, --json-format               Output JSON intermediate format into .gcov.json.gz file\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -i, --json-format               以 JSON 中间格式输出至 .gcov.json.gz 文件\n"
 
 #: gcov.c:895
-#, fuzzy, c-format
-#| msgid "  -m, --demangled-names           Output demangled function names\n"
+#, c-format
 msgid "  -j, --human-readable            Output human readable numbers\n"
-msgstr "  -m, --demangled-names           输出解码后的函数名\n"
+msgstr "  -j, --human-readable            输出人类可读的数字\n"
 
 #: gcov.c:896
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -k, --use-colors                Emit colored output\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -k, --use-colors                使用带颜色的输出\n"
 
 #: gcov.c:897
 #, c-format
@@ -904,10 +894,9 @@ msgid "  -s, --source-prefix DIR         Source prefix to elide\n"
 msgstr "  -s, --source-prefix 目录        要略去的来源前缀\n"
 
 #: gcov.c:906
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -t, --stdout                    Output to stdout instead of a file\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -t, --stdout                    输出至标准输出而非文件\n"
 
 #: gcov.c:907
 #, c-format
@@ -920,10 +909,9 @@ msgid "  -v, --version                   Print version number, then exit\n"
 msgstr "  -v, --version                    打印版本号并退出\n"
 
 #: gcov.c:909
-#, fuzzy, c-format
-#| msgid "    -v, --verbose                       Verbose mode\n"
+#, c-format
 msgid "  -w, --verbose                   Print verbose informations\n"
-msgstr "    -v, --verbo      se                 输出更多信息\n"
+msgstr "  -w, --verbose                   输出详细信息\n"
 
 #: gcov.c:910
 #, fuzzy, c-format
@@ -937,10 +925,9 @@ msgid "gcov %s%s\n"
 msgstr "gcov %s%s\n"
 
 #: gcov.c:1250
-#, fuzzy, c-format
-#| msgid "Treat the input file as already preprocessed"
+#, c-format
 msgid "'%s' file is already processed\n"
-msgstr "将输入文件当作已经预处理过的"
+msgstr ""
 
 #: gcov.c:1364
 #, c-format
@@ -968,16 +955,14 @@ msgid "\n"
 msgstr "\n"
 
 #: gcov.c:1489
-#, fuzzy, c-format
-#| msgid "%s: Cannot open output file: %s\n"
+#, c-format
 msgid "Cannot open JSON output file %s\n"
-msgstr "%s：无法打开输出文件：%s\n"
+msgstr "无法打开 JSON 输出文件 %s\n"
 
 #: gcov.c:1497
-#, fuzzy, c-format
-#| msgid "Error writing output file '%s'\n"
+#, c-format
 msgid "Error writing JSON output file %s\n"
-msgstr "写入到输出文件 '%s' 时出错\n"
+msgstr "写入到 JSON 输出文件 %s 时出错\n"
 
 #: gcov.c:1664
 #, c-format
@@ -3473,8 +3458,9 @@ msgid "unknown move insn:"
 msgstr "无效的 move 指令："
 
 #: config/avr/avr.c:6279
+#, fuzzy
 msgid "bad shift insn:"
-msgstr "错误的 shift 指令"
+msgstr "错误的 shift 指令:"
 
 #: config/avr/avr.c:6387 config/avr/avr.c:6868 config/avr/avr.c:7283
 msgid "internal compiler error.  Incorrect shift:"
@@ -4204,10 +4190,9 @@ msgid "invalid %%q value"
 msgstr "无效 %%q 值"
 
 #: config/rs6000/rs6000.c:21141
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%t value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%t 值"
 
 #: config/rs6000/rs6000.c:21158
 #, c-format
@@ -4225,21 +4210,19 @@ msgid "invalid %%v value"
 msgstr "无效 %%v 值"
 
 #: config/rs6000/rs6000.c:21234
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%V value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%V 值"
 
 #: config/rs6000/rs6000.c:21251 config/xtensa/xtensa.c:2439
 #, c-format
 msgid "invalid %%x value"
-msgstr "无效的 %%x 值"
+msgstr "无效 %%x 值"
 
 #: config/rs6000/rs6000.c:21308
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%z value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%z 值"
 
 #: config/rs6000/rs6000.c:21377
 #, c-format
@@ -4626,7 +4609,7 @@ msgstr "或称"
 
 #: c/c-objc-common.c:213
 msgid "({anonymous})"
-msgstr "{{匿名}}"
+msgstr "({匿名})"
 
 #. If we have
 #. declaration-specifiers declarator decl-specs
@@ -4884,7 +4867,7 @@ msgstr "vtable for "
 
 #: cp/error.c:1186
 msgid "<return value> "
-msgstr "<返回值>"
+msgstr "<返回值> "
 
 #: cp/error.c:1201
 msgid "{anonymous}"
@@ -5196,9 +5179,8 @@ msgid "arguments '%s' and '%s' for intrinsic '%s'"
 msgstr "‘%s’和‘%s’用作内建函数‘%s’的参数"
 
 #: fortran/error.c:853
-#, fuzzy
 msgid "Fortran 2018 deleted feature:"
-msgstr "遵循 ISO Fortran 2008 标准"
+msgstr "Fortran 2018 删除的特性："
 
 #: fortran/error.c:855
 #, fuzzy
@@ -5207,7 +5189,7 @@ msgstr "遵循 ISO Fortran 2008 标准"
 
 #: fortran/error.c:857
 msgid "Fortran 2018:"
-msgstr ""
+msgstr "Fortran 2018："
 
 #: fortran/error.c:859
 #, fuzzy
@@ -5215,9 +5197,8 @@ msgid "Fortran 2008 obsolescent feature:"
 msgstr "遵循 ISO Fortran 2008 标准"
 
 #: fortran/error.c:865
-#, fuzzy
 msgid "GNU Extension:"
-msgstr "使用 PE 格式的 GNU 扩展来对齐 common 数据"
+msgstr "GNU 扩展："
 
 #: fortran/error.c:867
 #, fuzzy
@@ -5230,9 +5211,8 @@ msgid "Obsolescent feature:"
 msgstr "对声明中的过时用法给出警告"
 
 #: fortran/error.c:871
-#, fuzzy
 msgid "Deleted feature:"
-msgstr "%L处的 H 格式限定符已在 Fortran 95 中被删除"
+msgstr "删除的特性："
 
 #: fortran/expr.c:3632
 msgid "array assignment"
@@ -5919,10 +5899,8 @@ msgid "gsplit-dwarf is not supported on this platform"
 msgstr "%qE属性在此平台上不受支持"
 
 #: config/darwin.h:170
-#, fuzzy
-#| msgid "-fpic is not supported"
 msgid "rdynamic is not supported"
-msgstr "不支持 -fpic"
+msgstr "不支持 rdynamic"
 
 #: config/darwin.h:258
 msgid "-current_version only allowed with -dynamiclib"
@@ -6307,16 +6285,12 @@ msgid "Warn about zero-trip DO loops."
 msgstr "对长度为 0 的格式字符串给出警告"
 
 #: fortran/lang.opt:354
-#, fuzzy
-#| msgid "Enable preprocessing"
 msgid "Enable preprocessing."
-msgstr "启用预处理"
+msgstr "启用预处理。"
 
 #: fortran/lang.opt:362
-#, fuzzy
-#| msgid "Disable preprocessing"
 msgid "Disable preprocessing."
-msgstr "禁用预处理"
+msgstr "禁用预处理。"
 
 #: fortran/lang.opt:370
 #, fuzzy
@@ -6922,10 +6896,8 @@ msgid "Do not generate #line directives."
 msgstr "不生成 #line 指令"
 
 #: c-family/c.opt:257
-#, fuzzy
-#| msgid "-U<macro>\tUndefine <macro>"
 msgid "-U<macro>\tUndefine <macro>."
-msgstr "-U<宏>\t取消定义宏"
+msgstr "-U<宏>\t取消定义<宏>。"
 
 #: c-family/c.opt:261
 #, fuzzy
@@ -7116,10 +7088,8 @@ msgid "Warn about possibly nested block comments, and C++ comments spanning more
 msgstr "对可能嵌套的注释和长度超过一个物理行长的 C++ 注释给出警告"
 
 #: c-family/c.opt:437
-#, fuzzy
-#| msgid "Synonym for -Wcomment"
 msgid "Synonym for -Wcomment."
-msgstr "-Wcomment 的同义词"
+msgstr "-Wcomment 的同义词。"
 
 #: c-family/c.opt:441
 #, fuzzy
@@ -8054,16 +8024,12 @@ msgstr "可变参数函数必须使用基础的 AAPCS 变种"
 
 #: c-family/c.opt:1282 c-family/c.opt:1530 c-family/c.opt:1854
 #: c-family/c.opt:1858 c-family/c.opt:1874
-#, fuzzy
-#| msgid "No longer supported"
 msgid "No longer supported."
-msgstr "不再受支持"
+msgstr "不再支持。"
 
 #: c-family/c.opt:1286
-#, fuzzy
-#| msgid "Recognize the \"asm\" keyword"
 msgid "Recognize the \"asm\" keyword."
-msgstr "识别“asm”关键字"
+msgstr "识别“asm”关键字。"
 
 #: c-family/c.opt:1294
 #, fuzzy
@@ -8197,10 +8163,8 @@ msgid "Do not assume that standard C libraries and \"main\" exist."
 msgstr "不假定标准 C 库和“main”存在"
 
 #: c-family/c.opt:1505
-#, fuzzy
-#| msgid "Recognize GNU-defined keywords"
 msgid "Recognize GNU-defined keywords."
-msgstr "识别 GNU 定义的关键字"
+msgstr "识别 GNU 定义的关键字。"
 
 #: c-family/c.opt:1509
 #, fuzzy
@@ -8495,10 +8459,8 @@ msgid "When \"signed\" or \"unsigned\" is not given make the bitfield unsigned."
 msgstr "未指定“signed”或“unsigned”时默认位段为无符号的"
 
 #: c-family/c.opt:1834 ada/gcc-interface/lang.opt:85
-#, fuzzy
-#| msgid "Make \"char\" unsigned by default"
 msgid "Make \"char\" unsigned by default."
-msgstr "使“char”类型默认为无符号"
+msgstr "使“char”类型默认为无符号。"
 
 #: c-family/c.opt:1838
 #, fuzzy
@@ -8759,14 +8721,12 @@ msgid "Conform to the ISO 2011 C++ standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2059
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++11."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu++11。"
 
 #: c-family/c.opt:2063
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++14."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu++14。"
 
 #: c-family/c.opt:2067
 #, fuzzy
@@ -8775,9 +8735,8 @@ msgid "Conform to the ISO 2014 C++ standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2071
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++17."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu+17。"
 
 #: c-family/c.opt:2075
 #, fuzzy
@@ -8798,9 +8757,8 @@ msgid "Conform to the ISO 2011 C standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2087
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu11."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu11。"
 
 #: c-family/c.opt:2091 c-family/c.opt:2095
 #, fuzzy
@@ -8845,16 +8803,12 @@ msgid "Deprecated in favor of -std=iso9899:1999."
 msgstr "已弃用，为 -std=iso9899:1999 所取代"
 
 #: c-family/c.opt:2150
-#, fuzzy
-#| msgid "Enable traditional preprocessing"
 msgid "Enable traditional preprocessing."
-msgstr "启用传统预处理"
+msgstr "启用传统预处理。"
 
 #: c-family/c.opt:2154
-#, fuzzy
-#| msgid "-trigraphs\tSupport ISO C trigraphs"
 msgid "-trigraphs\tSupport ISO C trigraphs."
-msgstr "-trigraphs\t支持 ISO C 三元符"
+msgstr "-trigraphs\t支持 ISO C 三元符。"
 
 #: c-family/c.opt:2158
 #, fuzzy
@@ -9004,7 +8958,7 @@ msgstr "解析后显示代码树"
 
 #: d/lang.opt:242
 msgid "Ignore unsupported pragmas."
-msgstr ""
+msgstr "忽略不支持的 pragma。"
 
 #: d/lang.opt:246
 #, fuzzy
@@ -9272,7 +9226,7 @@ msgstr "总认为位段长与 int 相同"
 
 #: config/linux-android.opt:23
 msgid "Generate code for the Android platform."
-msgstr "为 Android 操作系统生成代码。"
+msgstr "为 Android 平台生成代码。"
 
 #: config/mmix/mmix.opt:24
 #, fuzzy
@@ -9700,10 +9654,8 @@ msgid "Generate code for a ColdFire v4e."
 msgstr "为 ColdFire v4e 生成代码"
 
 #: config/m68k/m68k.opt:123
-#, fuzzy
-#| msgid "Specify the target CPU"
 msgid "Specify the target CPU."
-msgstr "选择目标 CPU"
+msgstr "指定目标 CPU。"
 
 #: config/m68k/m68k.opt:127
 #, fuzzy
@@ -11831,10 +11783,8 @@ msgid "Set the max size of data eligible for the TDA area."
 msgstr "为 TDA 区域合格的数据设置最大尺寸"
 
 #: config/v850/v850.opt:82
-#, fuzzy
-#| msgid "Do not enforce strict alignment"
 msgid "Do not enforce strict alignment."
-msgstr "不强制严格对齐"
+msgstr "不强制严格对齐。"
 
 #: config/v850/v850.opt:86
 #, fuzzy
@@ -11842,22 +11792,16 @@ msgid "Put jump tables for switch statements into the .data section rather than
 msgstr "置放跳跃式表格用于开关叙述进入.data 区段而非.code 区段"
 
 #: config/v850/v850.opt:93
-#, fuzzy
-#| msgid "Compile for the v850 processor"
 msgid "Compile for the v850 processor."
-msgstr "为 v850 处理器编译"
+msgstr "为 v850 处理器编译。"
 
 #: config/v850/v850.opt:97
-#, fuzzy
-#| msgid "Compile for the v850e processor"
 msgid "Compile for the v850e processor."
-msgstr "为 v850e 处理器编译"
+msgstr "为 v850e 处理器编译。"
 
 #: config/v850/v850.opt:101
-#, fuzzy
-#| msgid "Compile for the v850e1 processor"
 msgid "Compile for the v850e1 processor."
-msgstr "为 v850e1 处理器编译"
+msgstr "为 v850e1 处理器编译。"
 
 #: config/v850/v850.opt:105
 #, fuzzy
@@ -11866,21 +11810,16 @@ msgid "Compile for the v850es variant of the v850e1."
 msgstr "为 v850e1 的 v850es 变种编译"
 
 #: config/v850/v850.opt:109
-#, fuzzy
-#| msgid "Compile for the v850e2 processor"
 msgid "Compile for the v850e2 processor."
-msgstr "为 v850e2 处理器编译"
+msgstr "为 v850e2 处理器编译。"
 
 #: config/v850/v850.opt:113
-#, fuzzy
-#| msgid "Compile for the v850e2v3 processor"
 msgid "Compile for the v850e2v3 processor."
-msgstr "为 v850e2v3 处理器编译"
+msgstr "为 v850e2v3 处理器编译。"
 
 #: config/v850/v850.opt:117
-#, fuzzy
 msgid "Compile for the v850e3v5 processor."
-msgstr "为 v850e2v3 处理器编译"
+msgstr "为 v850e2v3 处理器编译。"
 
 #: config/v850/v850.opt:124
 #, fuzzy
@@ -11919,9 +11858,8 @@ msgid "Enable support for the RH850 ABI.  This is the default."
 msgstr "启用使用 RX FPU 指令。这是默认值。"
 
 #: config/v850/v850.opt:155
-#, fuzzy
 msgid "Enable support for the old GCC ABI."
-msgstr "启用对巨型对象的支持"
+msgstr "启用对旧有 GCC ABI 的支持。"
 
 #: config/v850/v850.opt:159
 msgid "Support alignments of up to 64-bits."
@@ -11940,26 +11878,20 @@ msgid "Support legacy multi-threading."
 msgstr "支持传统多线程"
 
 #: config/lynx.opt:27
-#, fuzzy
-#| msgid "Use shared libraries"
 msgid "Use shared libraries."
-msgstr "使用共享库"
+msgstr "使用共享库。"
 
 #: config/lynx.opt:31
-#, fuzzy
-#| msgid "Support multi-threading"
 msgid "Support multi-threading."
-msgstr "支持多线程"
+msgstr "支持多线程。"
 
 #: config/nvptx/nvptx.opt:22 config/gcn/gcn.opt:47
-#, fuzzy
 msgid "Generate code for a 32-bit ABI."
-msgstr "生成 32 位 SHmedia 代码"
+msgstr "为 32 位 ABI 生成代码。"
 
 #: config/nvptx/nvptx.opt:26 config/gcn/gcn.opt:51
-#, fuzzy
 msgid "Generate code for a 64-bit ABI."
-msgstr "生成 64 位代码"
+msgstr "为 64 位 ABI 生成代码。"
 
 #: config/nvptx/nvptx.opt:30
 #, fuzzy
@@ -12034,9 +11966,8 @@ msgid "Treat data references as near, far or medium. medium is default."
 msgstr "对待数据参考作为接近，far 或中。中是缺省"
 
 #: config/cr16/cr16.opt:42
-#, fuzzy
 msgid "Generate code for CR16C architecture."
-msgstr "为 Android 操作系统生成代码。"
+msgstr "为 CR16C 架构生成代码。"
 
 #: config/cr16/cr16.opt:46
 #, fuzzy
@@ -12157,22 +12088,16 @@ msgid "Do not link against the device-specific library lib<MCU>.a."
 msgstr ""
 
 #: config/m32r/m32r.opt:34
-#, fuzzy
-#| msgid "Compile for the m32rx"
 msgid "Compile for the m32rx."
-msgstr "为 m32rx 编译"
+msgstr "为 m32rx 编译。"
 
 #: config/m32r/m32r.opt:38
-#, fuzzy
-#| msgid "Compile for the m32r2"
 msgid "Compile for the m32r2."
-msgstr "为 m32r2 编译"
+msgstr "为 m32r2 编译。"
 
 #: config/m32r/m32r.opt:42
-#, fuzzy
-#| msgid "Compile for the m32r"
 msgid "Compile for the m32r."
-msgstr "为 m32r 编译"
+msgstr "为 m32r 编译。"
 
 #: config/m32r/m32r.opt:46
 #, fuzzy
@@ -12259,16 +12184,12 @@ msgid "Specify main object for TPF-OS."
 msgstr "指定 TPF-OS 的主对象"
 
 #: config/s390/s390.opt:48
-#, fuzzy
-#| msgid "31 bit ABI"
 msgid "31 bit ABI."
-msgstr "31 位 ABI"
+msgstr "31 位 ABI。"
 
 #: config/s390/s390.opt:52
-#, fuzzy
-#| msgid "64 bit ABI"
 msgid "64 bit ABI."
-msgstr "64 位 ABI"
+msgstr "64 位 ABI。"
 
 #: config/s390/s390.opt:120
 #, fuzzy
@@ -12284,9 +12205,8 @@ msgstr "附加的调试输出"
 
 #: config/s390/s390.opt:128
 #, fuzzy
-#| msgid "ESA/390 architecture"
 msgid "ESA/390 architecture."
-msgstr "ESA/390 结构"
+msgstr "ESA/390 结构。"
 
 #: config/s390/s390.opt:132
 #, fuzzy
@@ -12739,9 +12659,8 @@ msgstr "生成使用硬件浮点指令的代码"
 #: config/sparc/sparc.opt:30 config/sparc/sparc.opt:34
 #: config/visium/visium.opt:37
 #, fuzzy
-#| msgid "Use hardware FP"
 msgid "Use hardware FP."
-msgstr "使用硬件浮点单元"
+msgstr "使用硬件浮点单元。"
 
 #: config/sparc/sparc.opt:38 config/visium/visium.opt:41
 #, fuzzy
@@ -12785,10 +12704,8 @@ msgid "Enable Local Register Allocation."
 msgstr "启用 clip 指令"
 
 #: config/sparc/sparc.opt:66
-#, fuzzy
-#| msgid "Compile for V8+ ABI"
 msgid "Compile for V8+ ABI."
-msgstr "为 V8+ ABI 编译"
+msgstr "为 V8+ ABI 编译。"
 
 #: config/sparc/sparc.opt:70
 #, fuzzy
@@ -12851,16 +12768,12 @@ msgid "Pointers are 32-bit."
 msgstr "指针是 32 位"
 
 #: config/sparc/sparc.opt:118
-#, fuzzy
-#| msgid "Use 64-bit ABI"
 msgid "Use 64-bit ABI."
-msgstr "使用 64 位 ABI"
+msgstr "使用 64 位 ABI。"
 
 #: config/sparc/sparc.opt:122
-#, fuzzy
-#| msgid "Use 32-bit ABI"
 msgid "Use 32-bit ABI."
-msgstr "使用 32 位 ABI"
+msgstr "使用 32 位 ABI。"
 
 #: config/sparc/sparc.opt:126
 #, fuzzy
@@ -12967,10 +12880,8 @@ msgid "Compile for 32-bit pointers."
 msgstr "为 32 位指针编译"
 
 #: config/rs6000/aix64.opt:32 config/rs6000/linux64.opt:28
-#, fuzzy
-#| msgid "Select code model"
 msgid "Select code model."
-msgstr "选择代码模型"
+msgstr "选择代码模型。"
 
 #: config/rs6000/aix64.opt:49
 #, fuzzy
@@ -13033,10 +12944,8 @@ msgid "Use extended PowerPC V2.05 move floating point to/from GPR instructions."
 msgstr "使用扩展 PowerPC V2.05 通用寄存器浮点转移指令"
 
 #: config/rs6000/rs6000.opt:153
-#, fuzzy
-#| msgid "Use AltiVec instructions"
 msgid "Use AltiVec instructions."
-msgstr "使用 AltiVec 指令"
+msgstr "使用 AltiVec 指令。"
 
 #: config/rs6000/rs6000.opt:157
 #, fuzzy
@@ -13242,16 +13151,12 @@ msgid "Do not use the AltiVec ABI extensions."
 msgstr "不使用位段指令"
 
 #: config/rs6000/rs6000.opt:358
-#, fuzzy
-#| msgid "Use the ELFv1 ABI"
 msgid "Use the ELFv1 ABI."
-msgstr "使用 ELFv1 ABI"
+msgstr "使用 ELFv1 ABI。"
 
 #: config/rs6000/rs6000.opt:362
-#, fuzzy
-#| msgid "Use the ELFv2 ABI"
 msgid "Use the ELFv2 ABI."
-msgstr "使用 ELFv2 ABI"
+msgstr "使用 ELFv2 ABI。"
 
 #: config/rs6000/rs6000.opt:382
 #, fuzzy
@@ -13477,10 +13382,8 @@ msgid "Assume all variable arg functions are prototyped."
 msgstr "假设所有可变参数函数都有原型"
 
 #: config/rs6000/sysv4.opt:103
-#, fuzzy
-#| msgid "Use EABI"
 msgid "Use EABI."
-msgstr "使用 EABI"
+msgstr "使用 EABI。"
 
 #: config/rs6000/sysv4.opt:107
 #, fuzzy
@@ -13776,10 +13679,8 @@ msgid "Use divide emulation."
 msgstr "使用除法指令"
 
 #: config/or1k/or1k.opt:67
-#, fuzzy
-#| msgid "Use the soft multiply emulation (default)"
 msgid "Use multiply emulation."
-msgstr "使用软件模拟乘法(默认)"
+msgstr "使用乘法模拟。"
 
 #: config/nios2/elf.opt:26
 #, fuzzy
@@ -66815,14 +66716,14 @@ msgid "Include directory %qs: %s"
 msgstr "不包含子目录注释"
 
 #: fortran/scanner.c:336
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "Nonexistent include directory %qs"
-msgstr "忽略不存在的目录“%s”\n"
+msgstr "不存在的 include 目录 %qs"
 
 #: fortran/scanner.c:341
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is not a directory"
-msgstr "不是目录"
+msgstr "%qs 不是目录"
 
 #: fortran/scanner.c:744
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -66893,9 +66794,9 @@ msgid "Illegal preprocessor directive"
 msgstr "%s:%d：无效的预处理指令"
 
 #: fortran/scanner.c:2471
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "Cannot open file %qs"
-msgstr "无法打开文件 %s\n"
+msgstr "无法打开文件 %qs"
 
 #: fortran/simplify.c:92
 #, gcc-internal-format, gfc-internal-format
@@ -69343,9 +69244,9 @@ msgid "%<-mfused-madd%> is deprecated; use %<-ffp-contract=%> instead"
 msgstr "已弃用%<-mfused-madd%>；请改用%<-ffp-contract=%>"
 
 #: config/microblaze/microblaze.opt:87
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is deprecated; use -fstack-check"
-msgstr "已弃用%qE：%s"
+msgstr "%qs 已弃用；请换用 -fstack-check"
 
 #: config/microblaze/microblaze.opt:95
 #, gcc-internal-format
@@ -69356,9 +69257,9 @@ msgstr "%qs 已弃用；请换用 -fno-zero-initialized-in-bss"
 #: config/arc/arc.opt:349 config/arc/arc.opt:353 config/arc/arc.opt:357
 #: config/arc/arc.opt:361 config/arc/arc.opt:364 config/arc/arc.opt:367
 #: config/arc/arc.opt:384
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is deprecated"
-msgstr "已弃用%qE"
+msgstr "%qs 已弃用"
 
 #: lto/lang.opt:28
 #, fuzzy, gcc-internal-format
@@ -69392,9 +69293,9 @@ msgid "unknown Control-Flow Protection Level %qs"
 msgstr "未知的栈重用级别%qs"
 
 #: common.opt:1777
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "unknown IRA algorithm %qs"
-msgstr "未知的 TLS 模型%qs"
+msgstr "未知的 IRA 算法 %qs"
 
 #: common.opt:1790
 #, fuzzy, gcc-internal-format
@@ -69435,7 +69336,7 @@ msgstr "未知的 TLS 模型%qs"
 #: common.opt:2530
 #, gcc-internal-format
 msgid "unknown TLS model %qs"
-msgstr "未知的 TLS 模型%qs"
+msgstr "未知的 TLS 模型 %qs"
 
 #: common.opt:2862
 #, fuzzy, gcc-internal-format
diff --git a/gcc/po/zh_TW.po b/gcc/po/zh_TW.po
index 691cf80297d..e23ea3cd7d9 100644
--- a/gcc/po/zh_TW.po
+++ b/gcc/po/zh_TW.po
@@ -3,15 +3,16 @@
 # This file is distributed under the same license as the gcc package.
 # Meng Jie <zuxyhere@eastday.com>, 2005.
 # Wei-Lun Chao <bluebat@member.fsf.org>, 2006.
+# pan93412 <pan93412@gmail.com>, 2020.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gcc 4.8.0\n"
+"Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2013-06-07 23:29+0800\n"
-"Last-Translator: Wei-Lun Chao <bluebat@member.fsf.org>\n"
-"Language-Team: Chinese (traditional) <zh-l10n@linux.org.tw>\n"
+"PO-Revision-Date: 2020-01-19 00:41+0800\n"
+"Last-Translator: pan93412 <pan93412@gmail.com>\n"
+"Language-Team: Chinese (traditional) <zh-l10n@lists.linux.org.tw>\n"
 "Language: zh_TW\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -7884,7 +7885,7 @@ msgstr "當多載將無號數提升為有號數時給出警告"
 #, fuzzy
 #| msgid "Warn about uncasted NULL used as sentinel"
 msgid "Warn about uncasted NULL used as sentinel."
-msgstr "將未作轉換的 NULL 做為哨兵時給出警告"
+msgstr "將未作轉換的 NULL 做為哨符時給出警告"
 
 #: c-family/c.opt:1087
 #, fuzzy
@@ -28899,12 +28900,12 @@ msgstr "要求的對齊邊界太大"
 #: c-family/c-common.c:5371
 #, gcc-internal-format
 msgid "not enough variable arguments to fit a sentinel"
-msgstr "變數引數太少，不足以填滿一個哨兵"
+msgstr "變數引數太少，不足以填滿一個哨符"
 
 #: c-family/c-common.c:5385
 #, gcc-internal-format
 msgid "missing sentinel in function call"
-msgstr "函式呼叫中缺少哨兵"
+msgstr "函式呼叫中缺少哨符"
 
 #: c-family/c-common.c:5490
 #, gcc-internal-format, gfc-internal-format
@@ -39571,7 +39572,7 @@ msgstr "對齊指定的用於 typedef %qE"
 #: c/c-parser.c:7307
 #, gcc-internal-format
 msgid "traditional C rejects the unary plus operator"
-msgstr "傳統 C 不接受單位元 + 運算子"
+msgstr "傳統 C 不接受一元 + 運算子"
 
 #: c/c-parser.c:7438
 #, fuzzy, gcc-internal-format
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 728aa9b0ed5..b76c7b0b758 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -1081,6 +1081,10 @@ reload_combine_recognize_pattern (rtx_insn *insn)
       struct reg_use *use = reg_state[regno].reg_use + i;
       if (GET_MODE (*use->usep) != mode)
 	return false;
+      /* Don't try to adjust (use (REGX)).  */
+      if (GET_CODE (PATTERN (use->insn)) == USE
+	  && &XEXP (PATTERN (use->insn), 0) == use->usep)
+	return false;
     }
 
   /* Look for (set (REGX) (CONST_INT))
diff --git a/gcc/predict.c b/gcc/predict.c
index 60a19d7edd1..eaab47f992a 100644
--- a/gcc/predict.c
+++ b/gcc/predict.c
@@ -3937,12 +3937,14 @@ compute_function_frequency (void)
   if (profile_status_for_fn (cfun) != PROFILE_READ)
     {
       int flags = flags_from_decl_or_type (current_function_decl);
-      if ((ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa_p ()
-	   && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa() == profile_count::zero ())
-	  || lookup_attribute ("cold", DECL_ATTRIBUTES (current_function_decl))
-	     != NULL)
+      if (lookup_attribute ("cold", DECL_ATTRIBUTES (current_function_decl))
+	  != NULL)
+	node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;
+      else if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa_p ()
+	       && (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ()
+		   == profile_count::zero ()))
 	{
-          node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;
+	  node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;
 	  warn_function_cold (current_function_decl);
 	}
       else if (lookup_attribute ("hot", DECL_ATTRIBUTES (current_function_decl))
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 268a38799d6..01af063a222 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -4793,7 +4793,7 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,
 	       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND
 		   ? val_signbit_known_set_p (inner_mode, nonzero)
 		   : extend_op != ZERO_EXTEND)
-	       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))
+	       || !MEM_P (SUBREG_REG (x)))
 	      && xmode_width > inner_width)
 	    nonzero
 	      |= (GET_MODE_MASK (GET_MODE (x)) & ~GET_MODE_MASK (inner_mode));
diff --git a/gcc/sanopt.c b/gcc/sanopt.c
index 5cb98e1b50e..159d720bc19 100644
--- a/gcc/sanopt.c
+++ b/gcc/sanopt.c
@@ -1170,9 +1170,12 @@ sanitize_rewrite_addressable_params (function *fun)
 	    continue;
 
 	  if (dump_file)
-	    fprintf (dump_file,
-		     "Rewriting parameter whose address is taken: %s\n",
-		     IDENTIFIER_POINTER (DECL_NAME (arg)));
+	    {
+	      fprintf (dump_file,
+		       "Rewriting parameter whose address is taken: ");
+	      print_generic_expr (dump_file, arg, dump_flags);
+	      fputc ('\n', dump_file);
+	    }
 
 	  SET_DECL_PT_UID (var, DECL_PT_UID (arg));
 
diff --git a/gcc/sel-sched.c b/gcc/sel-sched.c
index f6e94bfc15c..f127ff74599 100644
--- a/gcc/sel-sched.c
+++ b/gcc/sel-sched.c
@@ -3331,8 +3331,6 @@ sel_target_adjust_priority (expr_t expr)
   else
     new_priority = priority;
 
-  gcc_assert (new_priority >= 0);
-
   /* If the priority has changed, adjust EXPR_PRIORITY_ADJ accordingly.  */
   EXPR_PRIORITY_ADJ (expr) = new_priority - EXPR_PRIORITY (expr);
 
diff --git a/gcc/simplify-rtx.c b/gcc/simplify-rtx.c
index 89a46a933fa..50bbb79655b 100644
--- a/gcc/simplify-rtx.c
+++ b/gcc/simplify-rtx.c
@@ -3519,9 +3519,21 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,
 	{
 	  rtx tmp = gen_int_shift_amount
 	    (inner_mode, INTVAL (XEXP (SUBREG_REG (op0), 1)) + INTVAL (op1));
-	  tmp = simplify_gen_binary (code, inner_mode,
-				     XEXP (SUBREG_REG (op0), 0),
-				     tmp);
+
+	 /* Combine would usually zero out the value when combining two
+	    local shifts and the range becomes larger or equal to the mode.
+	    However since we fold away one of the shifts here combine won't
+	    see it so we should immediately zero the result if it's out of
+	    range.  */
+	 if (code == LSHIFTRT
+	     && INTVAL (tmp) >= GET_MODE_BITSIZE (inner_mode))
+	  tmp = const0_rtx;
+	 else
+	   tmp = simplify_gen_binary (code,
+				      inner_mode,
+				      XEXP (SUBREG_REG (op0), 0),
+				      tmp);
+
 	  return lowpart_subreg (int_mode, tmp, inner_mode);
 	}
 
diff --git a/gcc/symbol-summary.h b/gcc/symbol-summary.h
index 0219f3a81ea..74544fbf879 100644
--- a/gcc/symbol-summary.h
+++ b/gcc/symbol-summary.h
@@ -461,6 +461,8 @@ fast_function_summary<T *, V>::release ()
     if ((*m_vector)[i] != NULL)
       this->release ((*m_vector)[i]);
 
+  vec_free (m_vector);
+
   this->m_released = true;
 }
 
@@ -926,6 +928,8 @@ fast_call_summary<T *, V>::release ()
     if ((*m_vector)[i] != NULL)
       this->release ((*m_vector)[i]);
 
+  vec_free (m_vector);
+
   this->m_released = true;
 }
 
diff --git a/gcc/symtab.c b/gcc/symtab.c
index 29f6cdc4667..9a6a1eadd2d 100644
--- a/gcc/symtab.c
+++ b/gcc/symtab.c
@@ -1955,22 +1955,22 @@ symtab_node::nonzero_address ()
      bind to NULL. This is on by default on embedded targets only.
 
      Otherwise all non-WEAK symbols must be defined and thus non-NULL or
-     linking fails.  Important case of WEAK we want to do well are comdats.
-     Those are handled by later check for definition.
+     linking fails.  Important case of WEAK we want to do well are comdats,
+     which also must be defined somewhere.
 
      When parsing, beware the cases when WEAK attribute is added later.  */
-  if (!DECL_WEAK (decl)
+  if ((!DECL_WEAK (decl) || DECL_COMDAT (decl))
       && flag_delete_null_pointer_checks)
     {
       refuse_visibility_changes = true;
       return true;
     }
 
-  /* If target is defined and either comdat or not extern, we know it will be
+  /* If target is defined and not extern, we know it will be
      output and thus it will bind to non-NULL.
      Play safe for flag_delete_null_pointer_checks where weak definition may
      be re-defined by NULL.  */
-  if (definition && (!DECL_EXTERNAL (decl) || DECL_COMDAT (decl))
+  if (definition && !DECL_EXTERNAL (decl)
       && (flag_delete_null_pointer_checks || !DECL_WEAK (decl)))
     {
       if (!DECL_WEAK (decl))
@@ -2328,10 +2328,18 @@ symtab_node::output_to_lto_symbol_table_p (void)
      first place.  */
   if (VAR_P (decl) && DECL_HARD_REGISTER (decl))
     return false;
-  /* FIXME: Builtins corresponding to real functions probably should have
-     symbol table entries.  */
-  if (TREE_CODE (decl) == FUNCTION_DECL && fndecl_built_in_p (decl))
-    return false;
+  if (TREE_CODE (decl) == FUNCTION_DECL && !definition
+      && fndecl_built_in_p (decl))
+    {
+      /* Builtins like those for most math functions have actual implementations
+	 in libraries so make sure to output references into the symbol table to
+	 make those libraries referenced.  Note this is incomplete handling for
+	 now and only covers math functions.  */
+      if (builtin_with_linkage_p (decl))
+	return true;
+      else
+	return false;
+    }
 
   /* We have real symbol that should be in symbol table.  However try to trim
      down the refernces to libraries bit more because linker will otherwise
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index bc11ae4ae0b..cb0d46f50c0 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,1765 @@
+2020-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94046
+	* g++.target/i386/pr94046-1.C: New test.
+	* g++.target/i386/pr94046-2.C: New test.
+
+2020-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from master
+	PR target/90311
+	* gcc.c-torture/execute/pr90311.c: New test.
+
+2020-03-05  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* g++.dg/asan/asan_test.C (dg-options): Add
+	-Wno-alloc-size-larger-than.
+
+2020-03-05  Martin Sebor  <msebor@redhat.com>
+
+	Backport from trunk.
+	2020-02-21  Martin Sebor  <msebor@redhat.com>
+
+	PR gcov-profile/93753
+	* g++.dg/ext/flexary36.C: New test.
+
+2020-03-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92976
+	* gfortran.dg/select_type_48.f90 : New test.
+
+2020-03-04  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90938
+	* g++.dg/init/array55.C: New test.
+	* g++.dg/init/array56.C: New test.
+	* g++.dg/cpp2a/nontype-class33.C: New test.
+
+2020-03-04  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/20050603-3.c: Remove XFAILS.
+
+2020-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94002
+	* gcc.dg/pr94002.c: New test.
+
+2020-02-29  Peter Bergner  <bergner@linux.ibm.com>
+
+	Revert
+	2020-02-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93913
+	* gcc.target/powerpc/fold-vec-st-char.c (scan-assembler-times): Allow
+	stxv and stxvx instructions as well.
+	* gcc.target/powerpc/fold-vec-st-float.c: Likewise.
+	* gcc.target/powerpc/fold-vec-st-int.c: Likewise.
+	* gcc.target/powerpc/fold-vec-st-short.c: Likewise.
+
+	2020-02-20  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93658
+	* gcc.target/powerpc/pr93658.c: New test.
+
+2020-02-29  John David Anglin  <danglin@gcc.gnu.org>
+
+	* gcc.dg/pr90756.c: Add -fno-common option on hppa*-*-hpux*.
+	* gcc.dg/torture/20190327-1.c: Likewise.
+	* gcc.dg/torture/pr90020.c: Skip on hppa*-*-hpux*.
+
+	PR ada/91100
+	* gnat.dg/socket1.adb: Disable on hppa*-*-hpux*.
+
+2020-02-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93913
+	* gcc.target/powerpc/fold-vec-st-char.c (scan-assembler-times): Allow
+	stxv and stxvx instructions as well.
+	* gcc.target/powerpc/fold-vec-st-float.c: Likewise.
+	* gcc.target/powerpc/fold-vec-st-int.c: Likewise.
+	* gcc.target/powerpc/fold-vec-st-short.c: Likewise.
+
+2020-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/93949
+	* gcc.c-torture/compile/pr93949.c: New test.
+
+2020-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93945
+	* gcc.c-torture/execute/pr93945.c: New test.
+
+2020-02-26  Marek Polacek  <polacek@redhat.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92745 - bogus error when initializing array of vectors.
+	* g++.dg/cpp0x/initlist118.C: New test.
+	* g++.dg/cpp0x/initlist118.C: Add -Wno-psabi -w to dg-options.
+
+2020-02-26  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/93047
+	* gcc.dg/torture/stackalign/builtin-return-2.c: New test case.
+
+2020-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93820
+	* gcc.dg/pr93820.c: New test.
+
+2020-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93905
+	* g++.dg/cpp0x/pr93905.C: New test.
+
+2020-02-25  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2019-12-17  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/pr45701-1.c: Adjust for -mpure-code.
+	* gcc.target/arm/pr45701-2.c: Likewise.
+	* gcc.target/arm/pure-code/no-literal-pool.c: Add tests for
+	__fp16.
+	* gcc.target/arm/pure-code/pure-code.exp: Remove thumb2 and movt
+	conditions.
+	* gcc.target/arm/thumb1-Os-mult.c: Skip if -mpure-code is used.
+
+2020-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93908
+	* gcc.c-torture/execute/pr93908.c: New test.
+
+2019-02-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/lto24.adb: New test.
+	* gnat.dg/lto24_pkg1.ads: New helper.
+	* gnat.dg/lto24_pkg2.ad[sb]: Likewise.
+
+2020-02-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2020-02-19  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/93767
+	* gcc.dg/vect/pr93767.c: New test.
+
+2020-02-24  Mark Eggleston  <mark.eggleston@codethink.com>
+
+	Backported from master
+	2020-02-24  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/93835
+	* gfortran.dg/pr77351.f90 : Check for one error instead of two.
+	* gfortran.dg/pr93835.f08 : New test.
+
+2020-02-23  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from master
+	2020-02-20  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93658
+	* gcc.target/powerpc/pr93658.c: New test.
+
+2020-02-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-02-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93656
+	* gcc.target/i386/pr93656.c: New test.
+
+2020-02-19  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	* typebound_call_22.d03 : Remove xfail clause.
+
+2020-02-19  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backported from mainline
+	2020-02-18  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/93714
+	* gfortran.dg/char_pointer_assign_6.f90: Look for no target
+	message instead of length mismatch.
+	* gfortran.dg/pr93714_1.f90
+	* gfortran.dg/pr93714_2.f90
+
+2020-02-18  Hongtao Liu  <hongtao.liu@intel.com>
+
+	* g++.dg/other/i386-2.C: Add -mavx512vbmi2.
+	* g++.dg/other/i386-3.C: Ditto.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/92768
+	* gcc.dg/pr92768.c: New test.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/90313
+	* g++.dg/torture/pr90313.cc: New test.
+
+2020-02-18  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Back-ported from mainline
+	2020-02-18 Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	PR fortran/93580
+	* gfortran.dg/dg/pr93580.f90: New test.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/93434
+	* gcc.c-torture/execute/pr93434.c: New test.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/92710
+	* gcc.dg/vect/pr92710.c: New test.
+
+2020-02-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/92420
+	* gcc.dg/vect/pr92420.c: New test.
+
+2020-02-14 Hongtao Liu  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/avx512vbmi2-vpshld-1.c: New test.
+	* gcc.target/i386/avx512vbmi2-vpshrd-1.c: Ditto.
+	* gcc.target/i386/sse-12.c: Add -mavx512vbmi2.
+	* gcc.target/i386/sse-13.c: Ditto.
+	* gcc.target/i386/sse-14.c: Add -mavx512vbmi2 and tests.
+	* gcc.target/i386/sse-22.c: Ditto.
+
+2020-02-16  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/93743
+	* gcc.target/i386/pr93743.c : New test.
+
+2020-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/93744
+	* gcc.c-torture/execute/pr93744-1.c: New test.
+	* gcc.c-torture/execute/pr93744-2.c: New test.
+	* gcc.c-torture/execute/pr93744-3.c: New test.
+
+2020-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/61414
+	* g++.dg/cpp0x/enum39.C: New test.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-02-05  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90648
+	* gcc.dg/pr90648.c: New testcase.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93381
+	* gcc.dg/torture/pr93381.c: New testcase.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93439
+	* gfortran.dg/graphite/pr93439.f90: New testcase.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/93054
+	* gcc.dg/pr93054.c: New testcase.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-01-20  Richard Biener  <rguenther@suse.de>
+
+	PR debug/92763
+	* g++.dg/debug/pr92763.C: New testcase.
+
+2020-02-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-11-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/92704
+	* gcc.dg/torture/pr92704.c: New testcase.
+
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/93576
+	* gcc.dg/pr93576.c: New test.
+
+	PR target/93696
+	* gcc.target/i386/pr93696-1.c: New test.
+	* gcc.target/i386/pr93696-2.c: New test.
+	* gcc.target/i386/avx512bitalg-vpopcntw-1.c (TEST): Fix argument order
+	of _mm*_mask_popcnt_*.
+	* gcc.target/i386/avx512vpopcntdq-vpopcntq-1.c (TEST): Likewise.
+	* gcc.target/i386/avx512vpopcntdq-vpopcntd-1.c (TEST): Likewise.
+	* gcc.target/i386/avx512bitalg-vpopcntb-1.c (TEST): Likewise.
+	* gcc.target/i386/avx512bitalg-vpopcntb.c (foo): Likewise.
+	* gcc.target/i386/avx512bitalg-vpopcntbvl.c (foo): Likewise.
+	* gcc.target/i386/avx512vpopcntdq-vpopcntd.c (foo): Likewise.
+	* gcc.target/i386/avx512bitalg-vpopcntwvl.c (foo): Likewise.
+	* gcc.target/i386/avx512bitalg-vpopcntw.c (foo): Likewise.
+	* gcc.target/i386/avx512vpopcntdq-vpopcntq.c (foo): Likewise.
+
+	PR target/93673
+	* gcc.target/i386/avx512f-pr93673.c: New test.
+	* gcc.target/i386/avx512dq-pr93673.c: New test.
+	* gcc.target/i386/avx512bw-pr93673.c: New test.
+
+	Backported from mainline
+	2020-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93670
+	* gcc.target/i386/avx512vl-pr93670.c: New test.
+
+	2020-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93637
+	* gcc.target/i386/avx-pr93637.c: New test.
+
+	2020-02-08  Uroš Bizjak  <ubizjak@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/65782
+	* gcc.target/i386/pr65782.c: New test.
+
+	2020-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93557
+	* c-c++-common/Wunused-var-17.c: New test.
+
+	PR middle-end/93555
+	* c-c++-common/gomp/pr93555-1.c: New test.
+	* c-c++-common/gomp/pr93555-2.c: New test.
+	* gfortran.dg/gomp/pr93555.f90: New test.
+
+	2020-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93505
+	* gcc.c-torture/compile/pr93505.c: New test.
+
+	2020-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91118
+	* g++.dg/gomp/pr91118-1.C: New test.
+	* g++.dg/gomp/pr91118-2.C: New test.
+
+	PR fortran/93463
+	* gfortran.dg/goacc/pr93463.f90: New test.
+
+	2020-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93418
+	* gcc.target/i386/avx2-pr93418.c: New test.
+
+	2020-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93402
+	* gcc.c-torture/execute/pr93402.c: New test.
+
+2020-02-11  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from mainline
+	2020-01-31  Tamar Christina  <tamar.christina@arm.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/91838
+	* g++.dg/opt/pr91838.C: New test.
+
+2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libgcc/85334
+	* g++.target/i386/pr85334-1.C: New test.
+	* g++.target/i386/pr85334-2.C: Likewise.
+
+2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/85667
+	* gcc.target/i386/pr85667-10.c: New test.
+	* gcc.target/i386/pr85667-7.c: Likewise.
+	* gcc.target/i386/pr85667-8.c: Likewise.
+	* gcc.target/i386/pr85667-9.c: Likewise.
+
+2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93462
+	* gfortran.dg/goacc/atomic-1.f90: New.
+
+2020-02-03  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-21  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93309
+	* gfortran.dg/external_implicit_none_2.f90: New.
+
+2020-01-30  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2020-01-21  Kito Cheng  <kito.cheng@sifive.com>
+
+	PR target/93304
+	* gcc.target/riscv/pr93304.c: New test.
+
+2020-01-29  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline
+	2020-01-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/92424
+	* gcc.target/aarch64/pr92424-2.c: New test.
+	* gcc.target/aarch64/pr92424-3.c: New test.
+
+2020-01-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/i386/pr91298-1.c: xfail on Solaris/x86 with native
+	assembler.
+	* gcc.target/i386/pr91298-2.c: Likewise.
+
+2020-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93335
+	* gcc.c-torture/compile/pr93335.c: New test.
+
+	PR target/91298
+	* gcc.target/i386/pr91298-1.c: New test.
+	* gcc.target/i386/pr91298-2.c: New test.
+
+	* gfortran.dg/gomp/target-parallel1.f90: New test.
+	* gfortran.dg/goacc/pr93329.f90: Enable commented out target parallel
+	test.
+
+	PR fortran/93329
+	* gfortran.dg/goacc/pr93329.f90: New test.
+
+	Backported from mainline
+	2020-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93333
+	* gcc.c-torture/compile/pr93333.c: New test.
+
+	PR target/93073
+	* gcc.target/powerpc/pr93073.c: New test.
+
+	2020-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93228
+	* g++.dg/cpp1y/attr-deprecated-3.C: New test.
+
+	2020-01-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93009
+	* gcc.target/i386/avx512vl-pr93009.c: New test.
+
+	2020-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/93202
+	* gcc.target/riscv/pr93202.c: New test.
+
+	2020-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/93088
+	* gcc.target/i386/pr93088.c: New test.
+
+	2020-01-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/93087
+	* c-c++-common/cold-1.c: New test.
+
+	2019-12-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92438
+	* g++.dg/ext/attrib61.C: New test.
+
+	2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92992
+	* g++.dg/cpp0x/nullptr45.C: New test.
+
+2020-01-22  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-22  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93348
+	* gcc.c-torture/compile/pr93348-1.c: New test.
+
+2020-01-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR libfortran/93234
+	* gfortran.dg/inquire_pre.f90: New test.
+
+2020-01-20  Mark Eggleston  <mark.eggleston@codethink.com>
+
+	Backport from mainline
+	* gfortran.dg/pr93263_1.f90: Change scan-tree-dump-not to
+	scan-tree-dump.
+
+2020-01-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	PR middle-end/93246
+	* g++.dg/torture/pr93246.C: New testcase.
+
+2020-01-17  Mark Eggleston  <mark.eggleston@codethink.com>
+
+	Backport from mainline
+	Mark Eggleston  <mark.eggleston@codethink.com>
+	Tobias Burnus  <burnus@gcc.gnu.org>
+
+	* gfortran.dg/pr93263_1.f90: New test.
+	* gfortran.dg/pr93263_2.f90: New test.
+
+2020-01-15  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-15  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93072
+	* gcc.dg/inline-42.c, gcc.dg/inline-43.c: New tests.
+
+2020-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2020-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/93223
+	* g++.dg/ipa/pr93223.C: New test.
+
+2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/93241
+	* gcc.dg/c11-static-assert-10.c, gcc.dg/c99-const-expr-15.c: New
+	tests.
+
+2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2019-12-09  Joseph Myers  <joseph@codesourcery.com>
+
+	PR middle-end/91226
+	* gcc.dg/dfp/bid-non-canonical-d128-1.c,
+	gcc.dg/dfp/bid-non-canonical-d128-2.c,
+	gcc.dg/dfp/bid-non-canonical-d128-3.c,
+	gcc.dg/dfp/bid-non-canonical-d128-4.c,
+	gcc.dg/dfp/bid-non-canonical-d32-1.c,
+	gcc.dg/dfp/bid-non-canonical-d32-2.c,
+	gcc.dg/dfp/bid-non-canonical-d64-1.c,
+	gcc.dg/dfp/bid-non-canonical-d64-2.c: New tests.
+
+2020-01-10  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-12-17  Martin Jambor  <mjambor@suse.cz>
+
+        PR ipa/92971
+        * gcc.dg/ipa/ipcp-agg-12.c: New test.
+
+2020-01-10  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com>
+
+	Backport from trunk
+	PR target/93188
+	Backport from trunk
+	* gcc.target/arm/multilib.exp: Add new tests for rm-profile only.
+
+2020-01-10  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2020-01-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/84135
+	* gfortran.dg/coarray/codimension_3.f90: New.
+
+2020-01-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2020-01-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-version-1.c: Adjust test to use different
+	options for Darwin4-9 and Darwin10+.
+
+2020-01-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* c-c++-common/pr90677-2.c: New test.
+
+2019-12-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92961
+	* gfortran.dg/arith_divide_2.f90: New test.
+
+2019-12-21  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/92753
+	* gfortran.dg/inquiry_type_ref_5.f90 : New test.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-12-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92977
+	* gfortran.dg/gomp/pr92977.f90: New test.
+
+	2019-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92930
+	* gcc.dg/tree-ssa/pr92930.c: New test.
+
+	2019-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92904
+	* gcc.c-torture/execute/pr92904.c: New test.
+
+	2019-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92723
+	* gcc.dg/vect/pr92723.c: New test.
+
+	2019-12-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92831 - CWG 1299, not extending temporary lifetime for ?:
+	* g++.dg/cpp0x/temp-extend2.C: New test.
+
+	2019-12-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92781
+	* gfortran.dg/pr92781.f90: New test.
+
+	2019-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92756
+	* gfortran.dg/gomp/teams1.f90: New test.
+
+	2019-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92732
+	* g++.dg/cpp2a/bitfield3.C: Don't expect narrowing conversion
+	warnings.
+	* g++.dg/cpp2a/bitfield4.C: New test.
+
+	PR c++/92695
+	* g++.dg/cpp2a/constexpr-virtual14.C: New test.
+
+	2019-12-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92695
+	* g++.dg/cpp2a/constexpr-virtual15.C: New test.
+
+	2019-11-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60228
+	* g++.dg/gomp/openmp-simd-2.C: Don't expect bodies for
+	DECL_OMP_DECLARE_REDUCTION_P functions.
+
+	2019-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92695
+	* g++.dg/warn/inline3.C: New test.
+
+	2019-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/91944
+	* gfortran.dg/spread_size_limit_2.f90: New test.
+
+	PR c++/92524
+	* g++.dg/cpp0x/pr92524.C: New test.
+
+	2019-11-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92648
+	* g++.dg/cpp0x/gen-attrs-71.C: New test.
+
+	PR c++/61414
+	* g++.dg/cpp0x/enum23.C: Remove xfail.
+	* g++.dg/cpp0x/enum28.C: New test.
+
+	PR tree-optimization/92644
+	* g++.dg/opt/pr92644.C: New test.
+
+	2019-11-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/92615
+	* gcc.target/i386/pr92615.c: New test.
+
+	2019-11-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90677
+	* c-c++-common/pr90677.c: New test.
+
+	2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90842
+	* g++.dg/cpp1y/lambda-generic-90842.C: New test.
+
+2019-12-20  Roman Zhuykov  <zhroma@ispras.ru>
+
+	* gcc.dg/pr92951-1.c: Rename to ...
+	* gcc.dg/pr92591-1.c: ... this.
+	* gcc.dg/pr92951-2.c: Rename to ...
+	* gcc.dg/pr92591-2.c: ... this.
+
+2019-12-20  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-12-13  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/92591
+	* gcc.dg/pr92951-1.c: New test.
+	* gcc.dg/pr92951-2.c: New test.
+
+2019-12-17  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-12-16  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/92950
+	* gcc.target/s390/vector/pr92950.c: New test.
+
+2019-12-12  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/92898
+	* gfortran.dg/pr92898.f90: New test.
+
+2019-12-11 Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/92897
+	* gfortran.dg/pr92897.f90: New test.
+
+2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/lto23.adb: New test.
+
+2019-12-02  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Fix bugs relating to flexibly-sized objects in nios2 backend.
+
+	PR target/92499
+	* gcc.target/nios2/pr92499-1.c: New.
+	* gcc.target/nios2/pr92499-2.c: New.
+	* gcc.target/nios2/pr92499-3.c: New.
+
+2019-12-02  Li Jia He  <helijia@linux.ibm.com>
+
+	Partial backport from trunk
+	PR target/92098
+	2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR target/92132
+	* gcc.target/powerpc/pr92132-fp-1.c: New test.
+	* gcc.target/powerpc/pr92132-fp-2.c: New test.
+
+2019-11-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/91783
+	* gfortran.dg/dependency_56.f90: New test. Backport from trunk on
+	the off-chance that somebody backports something that will break
+	this test case.
+
+2019-11-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/92629
+	* gfortran.dg/pr92629.f90: New testcase.
+
+2019-11-29 Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-11-29 Tobias Burnus  <tobias@codesourcery.com>
+
+	PR ipa/84963
+	* gfortran.dg/goacc/pr84963.f90: Use dg-additional-options not
+	dg-options as otherwise -fopenacc is not used.
+
+2019-11-27  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/92222
+	* gcc.dg/torture/pr92222.c: New testcase.
+
+2019-11-26  Jerry DeLisle  <jvdelisle@gcc.ngu.org>
+
+	Backport from trunk
+	PR fortran/92100
+	gfortran.dg/streamio_18.f90: New test.
+
+2019-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Harald Anlauf <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/92569
+	* gfortran.dg/eof_6.f90: New test.
+
+2019-11-25  Tobias Burnus  <tobias@codesourcery.com
+
+	Backport from mainline
+	2019-10-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92050
+	* gfortran.dg/pr92050.f90: New.
+
+2019-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/addr14.adb: New test.
+
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91355
+	* g++.dg/torture/pr91355.C: New test.
+
+2019-11-20  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-13  David Edelsohn  <dje.gcc@gmail.com>
+
+	* gcc.target/powerpc/pr92090.c: Limit -mbig to powerpc64le-*-*.
+	* gcc.target/powerpc/pr92090-2.c: Likewise.
+
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* gcc.target/powerpc/pr92090-2.c: New test.
+
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* gcc.target/powerpc/pr92090.c: New test.
+
+2019-10-28  Michael Matz  <matz@suse.de>
+
+	Backport from mainline
+	PR middle-end/90796
+	* gcc.dg/unroll-and-jam.c: Disable loop-invariant motion and adjust.
+
+	PR middle-end/90796
+	* gcc.dg/unroll-and-jam.c: Add three invalid and one valid case.
+
+2019-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90767
+	* g++.dg/diagnostic/pr90767-1.C: New test.
+	* g++.dg/diagnostic/pr90767-2.C: New test.
+
+	PR middle-end/90840
+	* gcc.c-torture/compile/pr90840.c: New test.
+
+	PR target/90867
+	* gcc.target/i386/pr90867.c: New test.
+
+	PR c/90898
+	* gcc.dg/pr90898.c: New test.
+
+	Backported from mainline
+	2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92504
+	* g++.dg/gomp/pr92504.C: New test.
+
+2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91450
+	* gcc.c-torture/execute/pr91450-1.c: New test.
+	* gcc.c-torture/execute/pr91450-2.c: New test.
+
+2019-11-15  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	PR rtl-optimization/92430
+	* gcc.dg/pr92430.c: New test (from Arseny Solokha).
+
+2019-11-13  Claudiu Zissulescu <claziss@gmail.com>
+
+	Backport from mainline
+	* gcc.target/arc/delay-slot-limm.c: New test.
+	* gcc.target/arc/pic-2.c: New file.
+
+2019-11-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92470
+	PR fortran/92500
+	* gfortran.dg/ISO_Fortran_binding_17.c: Include
+	ISO_Fortran_binding.h with relative path.
+
+2019-11-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-11-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92470
+	* gfortran.dg/ISO_Fortran_binding_1.c (establish_c): Add assert for
+	lower_bound == 0.
+
+	2019-11-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92470
+	* gfortran.dg/ISO_Fortran_binding_17.c: New.
+	* gfortran.dg/ISO_Fortran_binding_17.f90: New.
+	* gfortran.dg/ISO_Fortran_binding_1.c (elemental_mult_c, allocate_c,
+	section_c, select_part_c): Update for CFI_{address} changes;
+	add asserts.
+
+2019-11-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90930
+	* gcc.dg/tree-ssa/reassoc-24.c: Adjust.
+	* gcc.dg/tree-ssa/reassoc-25.c: Likewise.
+
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92321
+	* gfortran.dg/matmul_blas_2.f90: New test.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92384
+	* g++.dg/torture/pr92384.C: New test.
+
+	Backported from mainline
+	2019-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92343
+	* g++.dg/cpp2a/attr-likely6.C: New test.
+
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/92296
+	* c-c++-common/cpp/pr92296-1.c: New test.
+	* c-c++-common/cpp/pr92296-2.c: New test.
+
+	PR middle-end/92231
+	* gcc.c-torture/compile/pr92231.c: New test.
+
+	2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92015
+	* g++.dg/cpp0x/constexpr-92015.C: New test.
+
+2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/compile/20191108-1.c: New test.
+	* gcc.target/sparc/overflow-1.c: Add -fno-pie to the options.
+	* gcc.target/sparc/overflow-2.c: Likewise.
+	* gcc.target/sparc/overflow-3.c: Likewise.
+	* gcc.target/sparc/overflow-4.c: Likewise.
+	* gcc.target/sparc/overflow-5.c: Likewise.
+
+2019-11-06  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	* gcc.target/s390/sigfpe-eh.c: New test.
+
+2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.dg/tree-ssa/gen-vect-26.c: Disable loop peeling check for
+	IBM Z.
+	* gcc.dg/tree-ssa/gen-vect-28.c: Likewise.
+
+2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.dg/tree-ssa/gen-vect-11.c: Add --param min-vect-loop-bound=0
+	for IBM Z.
+	* gcc.dg/tree-ssa/gen-vect-32.c: Likewise.
+
+2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/s390.exp
+	(check_effective_target_s390_useable_hw): Add inline asm for z14
+	and z15. Replace instruction for z13 with lochiz. Add register
+	clobbers. Check also for __zarch__ when doing the __VX__ test.
+
+2019-11-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/stubify-1.mm: Adjust options and scan-asm checks.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* objc.dg/stubify-1.m: Likewise.
+	* objc.dg/stubify-2.m: Likewise.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92208
+	* gfortran.dg/pr92208.f90: New.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92284
+	* gfortran.dg/bind_c_array_params_3_aux.c: Include
+	../../../libgfortran/ISO_Fortran_binding.h rather than
+	ISO_Fortran_binding.h.
+
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92284
+	* gfortran.dg/bind-c-intent-out.f90: Update expected dump;
+	extend comment.
+	* gfortran.dg/bind_c_array_params_3.f90: New.
+	* gfortran.dg/bind_c_array_params_3_aux.c: New.
+
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92277
+	* fortran.dg/pr92277.f90: New.
+
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-10-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/Wnonnull.c: Provide prototypes for strlen and memcpy.
+	Use __SIZE_TYPE__ instead of size_t.
+
+	Backport from mainline.
+	2019-10-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/Wnonnull.c: Add attributed function declarations for
+	memcpy and strlen for Darwin.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/indirect-thunk-1.c: Allow 'l' or 'L' in
+	indirection label prefix, for Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/pr32219-2.c: Likewise.
+	* gcc.target/i386/pr32219-3.c: Likewise.
+	* gcc.target/i386/pr32219-4.c: Likewise.
+	* gcc.target/i386/pr32219-7.c: Likewise.
+	* gcc.target/i386/pr32219-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/stubify-1.mm: Rename symbol stub option.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* objc.dg/stubify-1.m: Likewise.
+	* objc.dg/stubify-2.m: Likewise.
+
+2019-10-30  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-09  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* gcc.target/mips/cfgcleanup-jalr1.c: New test.
+	* gcc.target/mips/cfgcleanup-jalr2.c: New test.
+	* gcc.target/mips/cfgcleanup-jalr3.c: New test.
+
+2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92201
+	* g++.dg/other/pr92201.C: New test.
+
+2019-10-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91926
+	* gfortran.dg/ISO_Fortran_binding_13.f90: New test.
+	* gfortran.dg/ISO_Fortran_binding_13.c: Additional source.
+	* gfortran.dg/ISO_Fortran_binding_14.f90: New test.
+
+2019-10-28  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	Backport from mainline
+	PR target/70010
+	* gcc.target/powerpc/pr70010.c: Add -Wno-psabi.
+	* gcc.target/powerpc/pr70010-1.c: Require LTO.
+	* gcc.target/powerpc/pr70010-2.c: Require LTO.
+
+2019-10-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92225
+	* gcc.target/i386/pr92225.c: New test.
+
+2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	PR rtl-optimization/92007
+	* g++.dg/opt/pr92007.C: New test (from Arseny Solokha).
+
+2019-10-28  Peter Bergner <bergner@linux.ibm.com>
+	    Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/70010
+	* gcc.target/powerpc/pr70010.c: New test.
+	* gcc.target/powerpc/pr70010-1.c: New test.
+	* gcc.target/powerpc/pr70010-2.c: New test.
+	* gcc.target/powerpc/pr70010-3.c: New test.
+	* gcc.target/powerpc/pr70010-4.c: New test.
+
+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91863
+	* gfortran.dg/bind-c-intent-out.f90: New.
+
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* gfortran.dg/char_result_19.f90: New test.
+	* gfortran.dg/char_result_mod_19.f90: Module for the new test.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	   Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* gcc.target/arm/pr88167-1.c: New test.
+	* gcc.target/arm/pr88167-2.c: New test.
+
+2019-10-24  Mihail Ionescu  <mihail.ionescu@arm.com>
+
+	Backport from mainline
+	2019-10-18  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/multilib.exp: Add extra tests.
+
+2019-10-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91885
+	* gcc.dg/pr91885.c (__int64_t): Change from long to long long.
+	(__uint64_t): Change from unsigned long to unsigned long long.
+
+2019-10-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-26  Martin Liska  <mliska@suse.cz>
+
+	PR tree-optimization/91885
+	* gcc.dg/pr91885.c: New test.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20191023-1.c: New test.
+
+2019-10-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* g++.dg/debug/dwarf2/pr91887.C: New testcase.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92056
+	* gcc.c-torture/compile/pr92056.c: New test.
+
+	PR fortran/87752
+	* gfortran.dg/gomp/pr87752.f90: New test.
+
+	2019-10-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91734
+	* gcc.dg/pr91734.c: New test.
+
+	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91974
+	* g++.dg/cpp1z/eval-order5.C: New test.
+
+	2019-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91925
+	* g++.dg/conversion/packed2.C: New test.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* c-c++-common/gomp/pr88203-1.c: New test.
+	* c-c++-common/gomp/pr88203-2.c: New test.
+	* c-c++-common/gomp/pr88203-3.c: New test.
+
+	PR middle-end/91920
+	* c-c++-common/gomp/pr91920.c: New test.
+
+	2019-09-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89435
+	PR rtl-optimization/89795
+	PR rtl-optimization/91720
+	* gcc.dg/pr89435.c: New test.
+	* gcc.dg/pr89795.c: New test.
+	* gcc.dg/pr91720.c: New test.
+
+	PR tree-optimization/91723
+	* gcc.dg/vect/vect-fma-3.c: New test.
+
+	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91665
+	* gcc.dg/vect/pr91665.c: New test.
+
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91001
+	PR middle-end/91105
+	PR middle-end/91106
+	* gcc.c-torture/compile/pr91001.c: New test.
+
+	2019-09-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91632
+	* gcc.c-torture/execute/pr91632.c: New test.
+
+	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91623
+	* gcc.target/i386/pr91623.c: New test.
+
+	PR lto/91572
+	* g++.dg/lto/pr91572_0.C: New test.
+
+	2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91351
+	* g++.dg/opt/pr91351.C: New test.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* c-c++-common/gomp/pr91401-1.c: New test.
+	* c-c++-common/gomp/pr91401-2.c: New test.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* gfortran.dg/pr69455_1.f90: New test.
+	* gfortran.dg/pr69455_2.f90: Ditto.
+
+2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91586
+	* gfortran.dg/class_71.f90: New.
+
+2019-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83113
+	PR fortran/89943
+	* gfortran.dg/pr89943_1.f90: New test.
+	* gfortran.dg/pr89943_2.f90: Ditto.
+	* gfortran.dg/pr89943_3.f90: Ditto.
+	* gfortran.dg/pr89943_4.f90: Ditto.
+
+2019-10-17  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-15  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/92093
+	* gcc.target/powerpc/pr91275.c: Fix type and endian issues.
+
+2019-10-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/91606
+	* g++.dg/torture/pr91606.C: New testcase.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* gcc.dg/torture/pr91812.c: New testcase.
+
+2019-10-14  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk.
+	2019-09-26  Will Schmidt <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/pure-builtin-redundant-load.c:  New.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91715
+	* gfortran.dg/function_kinds_5.f90: Prune run-on error.
+	* gfortran.dg/pr85543.f90: Ditto.
+	* gfortran.dg/pr91715.f90: New test.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91649
+	* gfortran.dg/pr91649.f90: New test.
+
+2019-10-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91801
+	* gfortran.dg/pr91801.f90: New test.
+
+2019-10-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92022
+	* g++.dg/pr92022.C: New test.
+
+2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84487
+	* gfortran.dg/typebound_call_22.f03: xfail.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmdit@linux.ibm.com>
+
+	PR target/91275
+	* gcc.target/powerpc/pr91275.c: New.
+
+2019-10-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/47054
+	* gfortran.dg/pr47054_1.f90: New test
+	* gfortran.dg/pr47054_2.f90: Ditto.
+
+2019-10-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91942
+	* gfortran.dg/pr91587.f90: Update dg-error regex.
+	* gfortran.dg/pr91942.f90: New test.
+
+2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91785
+	* gfortran.dg/pr91785.f90: New test.
+
+2019-10-04  Dragan Mladjenovic <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-10-03  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	PR target/91769
+	* gcc.target/mips/pr91769.c: New test.
+
+2019-10-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+
+	2019-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR fortran/91716
+	* gfortran.dg/pr91716.f90: New test.
+
+2019-10-01 Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91864
+	* gcc/testsuite/gfortran.dg/pr91864.f90
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.ngu.org>
+
+	PR fortran/91802
+	* gfortran.dg/pr91802.f90: New test.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91714
+	* gfortran.dg/dec_type_print_3.f90: Update dg-error regex.
+	* gfortran.dg/pr91714.f90: New test.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91641
+	* gfortran.dg/pr91641.f90: New test.
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/nosplit-di-const-volatile_1.c: New test.
+
+2019-09-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-08-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/arm/acle/crc_hf_1.c: New test.
+
+2019-09-21  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91588
+	* gfortran.dg/associate_49.f90: New test.
+
+2019-09-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/pr91269.c: New test.
+
+2019-09-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91727
+	* gfortran.dg/pr91727.f90: New test.
+
+2019-09-19  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+		    Jim Wilson  <jimw@sifive.com>
+
+	PR target/91635
+	* gcc.c-torture/execute/pr91635.c: New test.
+	* gcc.target/riscv/shift-shift-4.c: New test.
+	* gcc.target/riscv/shift-shift-5.c: New test.
+
+2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91550
+	* gfortran.dg/do_subscript_6.f90: New test.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* gfortran.dg/warn_unused_dummy_argument_5.f90: New test.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91553
+	* gfortran.dg/pr91553.f90: New test.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91566
+	* gfortran.dg/pr91566.f90: New test.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91642
+	* gfortran.dg/pr91642.f90: New test.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20161111-1.c: XFAIL redundant zero-extension test.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* gcc.target/i386/pr87853.c: New test.
+
+	PR target/91704
+	* gcc.target/i386/pr91704.c: New test.
+
+2019-09-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91589
+	* gfortran.dg/pr91589.f90: New test.
+
+2019-09-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/91496
+	* gfortran.dg/pr91496.f90: New testcase.
+
+	PR fortran/91496
+	* gfortran.dg/directive_unroll_5.f90: Adjust error message.
+
+2019-09-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91660
+	* gfortran.dg/pdt_4.f03: Fix invalid code.
+	* gfortran.dg/pr91660_1.f90: New test.
+	* gfortran.dg/pr91660_2.f90: Ditto.
+
+2019-09-04  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-08-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/81800
+	* gcc.target/aarch64/no-inline-lrint_3.c: New test.
+
+2019-09-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91597
+	* gcc.c-torture/execute/pr91597.c: New test.
+
+2019-09-02  Steven G. Kargl  <kargl@gc.gnu.org>
+
+	PR fortran/91552
+	* gfortran.dg/pr91552.f90: New test.
+
+2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	PR c++/91155
+	* g++.dg/torture/pr91155.C: New test.
+
+2019-09-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190901-1.c: New test.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91587
+	* gfortran.dg/pr91587.f90: New test.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91565
+	* gfortran.dg/pr91565.f90: New test.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91564
+	* gfortran.dg/pr91564.f90: New test.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91551
+	* gfortran.dg/allocated_3.f90
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* gcc.target/powerpc/darn-3.c: New testcase.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* gcc.dg/torture/pr90278.c: New testcase.
+
+2019-08-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91568
+	* gfortran.dg/pr91568.f: New testcase.
+
+2019-08-28  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90637
+	* gcc.dg/gomp/pr90637.c: New testcase.
+
+2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	* gcc.target/mips/get-fcsr-3.c: New test.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190820-1.c: New test.
+
+2019-08-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91485
+	* gfortran.dg/pr91485.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91471
+	* gfortran.dg/pr91471.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78739
+	* fortran.dg/pr78739.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78719
+	* gfortran.dg/pr78719_1.f90: New test.
+	* gfortran.dg/pr78719_2.f90: Ditto.
+	* gfortran.dg/pr78719_3.f90: Ditto.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82992
+	* gfortran.dg/pr71649.f90: Adjust error messages.
+	* gfortran.dg/use_15.f90: Ditto.
+	* gfortran.dg/use_rename_8.f90: Ditto.
+
+2019-08-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91445
+	* gcc.dg/torture/pr91445.c: New testcase.
+
+	Backport from mainline
+	2019-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91091
+	* gcc.dg/tree-ssa/pr91091-2.c: New testcase.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* c-c++-common/array-1.c: New test.
+	* g++.dg/abi/mangle73.C: New test.
+	* g++.dg/cpp2a/nontype-class23.C: New test.
+	* g++.dg/init/array53.C: New test.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* g++.dg/lookup/missing-std-include-5.C: Limit test to C++14 and up.
+	* g++.dg/lookup/missing-std-include-6.C: Don't check make_unique in
+	test that runs for C++11.
+	* g++.dg/lookup/missing-std-include-8.C: Check make_unique here.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* gfortran.dg/pr87991.f90: New test.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* gfortran.dg/do_subsript_5.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* gfortran.dg/pr88072.f90: New test.
+	* gfortran.dg/unlimited_polymorphic_28.f90: Fix error message.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* gfortran.dg/deferred_character_34.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	* gfortran.dg/pr89647.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* gfortran.dg/pr87993.f90: New test.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* gfortran.dg/do_subscript_3.f90: New test.
+	* gfortran.dg/do_subscript_4.f90: New test.
+	* gfortran.dg/pr70754.f90: Use indices that to not overflow.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* gfortran.dg/pr91359_1.f: New test.
+	* gfortran.dg/pr91359_2.f: Ditto.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* gfortran.dg/allocated_1.f90: New test.
+	* gfortran.dg/allocated_2.f90: Ditto.
+
+2019-08-02  Tom Honermann  <tom@honermann.net>
+
+	PR c++/88095
+	* g++.dg/cpp2a/udlit-class-nttp-ctad.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg2.C: New test.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -427,7 +2189,7 @@
 	Backport from mainline.
 	2019-05-15  Iain Sandoe  <iain@sandoe.co.uk>
 
-	* lib/target-supports.exp 
+	* lib/target-supports.exp
 	(check_effective_target_powerpc_p8vector_ok): No support for Darwin.
 	(check_effective_target_powerpc_p9vector_ok): Likewise.
 	(check_effective_target_powerpc_float128_sw_ok): Likewise.
@@ -720,7 +2482,7 @@
 
 	Backport from mainline
 	PR fortran/91077
-	* gfortran.dg/pointer_array_11.f90 : New test.
+	* gfortran.dg/pointer_array_11.f90: New test.
 
 2019-07-05  Szabolcs Nagy  <szabolcs.nagy@arm.com>
 
@@ -803,7 +2565,7 @@
 	Backport fom mainline
 	2019-06-21  Jeff Law  <law@redhat.com>
 
-        PR tree-optimization/90949
+	PR tree-optimization/90949
 	* gcc.c-torture/execute/pr90949.c: New test.
 
 2019-06-26  Martin Jambor  <mjambor@suse.cz>
@@ -969,7 +2731,7 @@
        * gcc.target/i386/pr82699-6.c: Likewise
        * gcc.target/i386/returninst1.c: Likewise
        * gcc.target/i386/returninst2.c: Likewise
-       * gcc.target/i386/returninst3.c : Likewise
+       * gcc.target/i386/returninst3.c: Likewise
 
 2019-05-30  Iain Sandoe  <iain@sandoe.co.uk>
 
@@ -1131,7 +2893,7 @@
 
 	Backport from trunk
 	PR fortran/90498
-	* gfortran.dg/associate_48.f90 : New test.
+	* gfortran.dg/associate_48.f90: New test.
 
 2019-05-17  Jakub Jelinek  <jakub@redhat.com>
 
@@ -3801,21 +5563,21 @@
 2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/88117
-	* gfortran.dg/deferred_character_32.f90 : New test
+	* gfortran.dg/deferred_character_32.f90: New test
 
 2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/89385
-	* gfortran.dg/ISO_Fortran_binding_1.f90 : Correct test for
+	* gfortran.dg/ISO_Fortran_binding_1.f90: Correct test for
 	previously incorrect lbound for allocatable expressions. Also
 	correct stop values to avoid repetition.
-	* gfortran.dg/ISO_Fortran_binding_5.f90 : New test
-	* gfortran.dg/ISO_Fortran_binding_5.c : Support previous test.
+	* gfortran.dg/ISO_Fortran_binding_5.f90: New test
+	* gfortran.dg/ISO_Fortran_binding_5.c: Support previous test.
 
 	PR fortran/89366
-	* gfortran.dg/ISO_Fortran_binding_6.f90 : New test
-	* gfortran.dg/ISO_Fortran_binding_6.c : Support previous test.
-	* gfortran.dg/pr32599.f03 : Set standard to F2008.
+	* gfortran.dg/ISO_Fortran_binding_6.f90: New test
+	* gfortran.dg/ISO_Fortran_binding_6.c: Support previous test.
+	* gfortran.dg/pr32599.f03: Set standard to F2008.
 
 2019-02-22  David Malcolm  <dmalcolm@redhat.com>
 
@@ -4444,7 +6206,7 @@
 2019-02-09  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/89200
-	* gfortran.dg/array_reference_2.f90 : New test.
+	* gfortran.dg/array_reference_2.f90: New test.
 
 2019-02-09  Jakub Jelinek  <jakub@redhat.com>
 
@@ -4704,17 +6466,17 @@
 2019-02-02  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/88393
-	* gfortran.dg/alloc_comp_assign_16.f03 : New test.
+	* gfortran.dg/alloc_comp_assign_16.f03: New test.
 
 2019-02-02  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/88980
-	* gfortran.dg/realloc_on_assign_32.f90 : New test.
+	* gfortran.dg/realloc_on_assign_32.f90: New test.
 
 2019-02-02  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/88685
-	* gfortran.dg/pointer_array_component_3.f90 : New test.
+	* gfortran.dg/pointer_array_component_3.f90: New test.
 
 2019-02-02  Jakub Jelinek  <jakub@redhat.com>
 
diff --git a/gcc/testsuite/c-c++-common/Wunused-var-17.c b/gcc/testsuite/c-c++-common/Wunused-var-17.c
new file mode 100644
index 00000000000..ab995f8b674
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wunused-var-17.c
@@ -0,0 +1,19 @@
+/* PR c++/93557 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wunused-but-set-variable" } */
+
+typedef int VI __attribute__((vector_size (sizeof (int) * 4)));
+typedef float VF __attribute__((vector_size (sizeof (float) * 4)));
+
+void
+foo (VI *p, VF *q)
+{
+  VI a = (VI) { 1, 2, 3, 4 };			/* { dg-bogus "set but not used" } */
+  q[0] = __builtin_convertvector (a, VF);
+  VI b = p[1];					/* { dg-bogus "set but not used" } */
+  q[1] = __builtin_convertvector (b, VF);
+  VF c = (VF) { 5.0f, 6.0f, 7.0f, 8.0f };	/* { dg-bogus "set but not used" } */
+  p[2] = __builtin_convertvector (c, VI);
+  VF d = q[3];					/* { dg-bogus "set but not used" } */
+  p[3] = __builtin_convertvector (d, VI);
+}
diff --git a/gcc/testsuite/c-c++-common/array-1.c b/gcc/testsuite/c-c++-common/array-1.c
new file mode 100644
index 00000000000..5de9ade4d43
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/array-1.c
@@ -0,0 +1,247 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+#define assert(expr) ((expr) ? (void)0 : __builtin_abort ())
+
+void pr90947 (void)
+{
+  int vecsize = 4;
+  int index = 0;
+  static const char *a[4][4] =
+    {
+     { ".x", ".y", ".z", ".w" },
+     { ".xy", ".yz", ".zw", 0 },
+     { ".xyz", ".yzw", 0, 0 },
+     { "", 0, 0, 0 },
+    };
+
+  assert (vecsize >= 1 && vecsize <= 4);
+  assert (index >= 0 && index < 4);
+  assert (a[vecsize - 1][index]);
+}
+
+void f_a1_1 (void)
+{
+  {
+    const char* a[1][1] = { { 0 } };
+    assert (0 == a[0][0]);
+  }
+  {
+    const char* a[1][1] = { { "" } };
+    assert ('\0' == *a[0][0]);
+  }
+}
+
+void f_a2_1 (void)
+{
+  {
+    const char* a[2][1] = { { "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { 0 }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+}
+
+void f_a2_2 (void)
+{
+  {
+    const char* a[2][2] = { { "", "" }, { "", "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "", 0 } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { 0, "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", 0 }, { 0, "" } };
+    assert ('\0' == *a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0, 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+}
+
+void f_a2_2_2 (void)
+{
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { "", "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert ('\0' == *a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { 0, 0 }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { }, { } }, { { }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+}
+
+void f_sa2_2_2 (void)
+{
+  struct S { const char a[2], *s, c; };
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { "", "" } },
+        { }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s && 0 == a[0][0][0].c);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s && 0 == a[0][0][1].c);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s && 0 == a[0][1][0].c);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s && 0 == a[0][1][1].c);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s && 0 == a[1][0][0].c);
+    assert ('\0' == *a[1][0][1].a && '\0' == *a[1][0][1].s && 0 == a[1][0][1].c);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s && 0 == a[1][1][0].c);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s && 0 == a[1][1][1].c);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { } },
+        { { "", "" } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && '\0' == *a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { } },
+        { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+      },
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
diff --git a/gcc/testsuite/c-c++-common/cold-1.c b/gcc/testsuite/c-c++-common/cold-1.c
new file mode 100644
index 00000000000..3493623e1eb
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cold-1.c
@@ -0,0 +1,22 @@
+/* PR ipa/93087 */
+/* { dg-do compile { target nonpic } } */
+/* { dg-options "-O1 -Wsuggest-attribute=cold" } */
+
+extern void *getdata (void);
+extern int set_error (char const *message) __attribute__((cold));
+
+__attribute__((cold)) int
+set_nomem (void)	/* { dg-bogus "function might be candidate for attribute 'cold'" } */
+{
+  return set_error ("Allocation failed");
+}
+
+void *
+getdata_or_set_error (void)
+{
+  void *result;
+  result = getdata ();
+  if (!result)
+    set_nomem ();
+  return result;
+}
diff --git a/gcc/testsuite/c-c++-common/cpp/pr92296-1.c b/gcc/testsuite/c-c++-common/cpp/pr92296-1.c
new file mode 100644
index 00000000000..4bd69c8be87
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr92296-1.c
@@ -0,0 +1,32 @@
+/* PR preprocessor/92296 */
+/* { dg-do preprocess } */
+
+#pragma push_macro("__TIMESTAMP__")
+#pragma pop_macro("__TIMESTAMP__")
+
+#pragma push_macro("__TIME__")
+#pragma pop_macro("__TIME__")
+
+#pragma push_macro("__DATE__")
+#pragma pop_macro("__DATE__")
+
+#pragma push_macro("__FILE__")
+#pragma pop_macro("__FILE__")
+
+#pragma push_macro("__BASE_FILE__")
+#pragma pop_macro("__BASE_FILE__")
+
+#pragma push_macro("__LINE__")
+#pragma pop_macro("__LINE__")
+
+#pragma push_macro("__INCLUDE_LEVEL__")
+#pragma pop_macro("__INCLUDE_LEVEL__")
+
+#pragma push_macro("__COUNTER__")
+#pragma pop_macro("__COUNTER__")
+
+#pragma push_macro("__has_attribute")
+#pragma pop_macro("__has_attribute")
+
+#pragma push_macro("__has_cpp_attribute")
+#pragma pop_macro("__has_cpp_attribute")
diff --git a/gcc/testsuite/c-c++-common/cpp/pr92296-2.c b/gcc/testsuite/c-c++-common/cpp/pr92296-2.c
new file mode 100644
index 00000000000..15362a4bdc3
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr92296-2.c
@@ -0,0 +1,73 @@
+/* PR preprocessor/92296 */
+/* { dg-do preprocess } */
+/* { dg-options "-Wno-builtin-macro-redefined" } */
+
+#pragma push_macro("__TIMESTAMP__")
+#undef __TIMESTAMP__
+#define __TIMESTAMP__ "Thu Oct 31 12:00:00 2019"
+timestamp1 = __TIMESTAMP__
+#pragma pop_macro("__TIMESTAMP__")
+timestamp2 = __TIMESTAMP__
+
+#pragma push_macro("__TIME__")
+#undef __TIME__
+#define __TIME__ "12:00:00"
+time1 = __TIME__
+#pragma pop_macro("__TIME__")
+time2 = __TIME__
+
+#pragma push_macro("__DATE__")
+#undef __DATE__
+#define __DATE__ "Oct 31 2019"
+date1 = __DATE__
+#pragma pop_macro("__DATE__")
+date2 = __DATE__
+
+#pragma push_macro("__FILE__")
+#undef __FILE__
+#define __FILE__ "pr92296-3.c"
+file1 = __FILE__	/* { dg-final { scan-file pr92296-2.i "file1 = \"pr92296-3.c\"" } } */
+#pragma pop_macro("__FILE__")
+file2 = __FILE__	/* { dg-final { scan-file-not pr92296-2.i "file2 = \"pr92296-3.c\"" } } */
+
+#pragma push_macro("__BASE_FILE__")
+#undef __BASE_FILE__
+#define __BASE_FILE__ "pr92296-4.c"
+filebase1 = __BASE_FILE__	/* { dg-final { scan-file pr92296-2.i "filebase1 = \"pr92296-4.c\"" } } */
+#pragma pop_macro("__BASE_FILE__")
+filebase2 = __BASE_FILE__	/* { dg-final { scan-file-not pr92296-2.i "filebase2 = \"pr92296-4.c\"" } } */
+
+#pragma push_macro("__LINE__")
+#undef __LINE__		/* { dg-warning "undefining" } */
+#define __LINE__ 142
+line1 = __LINE__	/* { dg-final { scan-file pr92296-2.i "line1 = 142" } } */
+#pragma pop_macro("__LINE__")
+line2 = __LINE__	/* { dg-final { scan-file pr92296-2.i "line2 = 45" } } */
+
+#pragma push_macro("__INCLUDE_LEVEL__")
+#undef __INCLUDE_LEVEL__	/* { dg-warning "undefining" } */
+#define __INCLUDE_LEVEL__ 42
+includelevel1 = __INCLUDE_LEVEL__	/* { dg-final { scan-file pr92296-2.i "includelevel1 = 42" } } */
+#pragma pop_macro("__INCLUDE_LEVEL__")
+includelevel2 = __INCLUDE_LEVEL__	/* { dg-final { scan-file pr92296-2.i "includelevel2 = 0" } } */
+
+#pragma push_macro("__COUNTER__")
+#undef __COUNTER__	/* { dg-warning "undefining" } */
+#define __COUNTER__ 172
+counter1 = __COUNTER__	/* { dg-final { scan-file pr92296-2.i "counter1 = 172" } } */
+#pragma pop_macro("__COUNTER__")
+counter2 = __COUNTER__	/* { dg-final { scan-file-not pr92296-2.i "counter2 = 172" } } */
+
+#pragma push_macro("__has_attribute")
+#undef __has_attribute	/* { dg-warning "undefining" } */
+#define __has_attribute(x) 0
+hasattr1 = __has_attribute(noreturn)	/* { dg-final { scan-file pr92296-2.i "hasattr1 = 0" } } */
+#pragma pop_macro("__has_attribute")
+hasattr2 = __has_attribute(noreturn)	/* { dg-final { scan-file-not pr92296-2.i "hasattr2 = 0" } } */
+
+#pragma push_macro("__has_cpp_attribute")
+#undef __has_cpp_attribute	/* { dg-warning "undefining" } */
+#define __has_cpp_attribute(x) 0
+hasattrcpp1 = __has_cpp_attribute(noreturn)	/* { dg-final { scan-file pr92296-2.i "hasattrcpp1 = 0" } } */
+#pragma pop_macro("__has_cpp_attribute")
+hasattrcpp2 = __has_cpp_attribute(noreturn)	/* { dg-final { scan-file-not pr92296-2.i "hasattrcpp2 = 0" } } */
diff --git a/gcc/testsuite/c-c++-common/gomp/pr88203-1.c b/gcc/testsuite/c-c++-common/gomp/pr88203-1.c
new file mode 100644
index 00000000000..54a686487c9
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr88203-1.c
@@ -0,0 +1,61 @@
+/* PR c++/88203 */
+/* { dg-do compile } */
+/* { dg-additional-options "-std=c99" { target c } } */
+/* { dg-additional-options "-std=c++11" { target c++ } } */
+
+void foo (const char *);
+#pragma omp declare target to (foo)
+
+void
+f1 (void)
+{
+  #pragma omp parallel default(none)
+  foo (__func__);
+}
+
+void
+f2 (void)
+{
+  #pragma omp parallel default(none) shared(__func__)
+  foo (__func__);
+}
+
+void
+f3 (void)
+{
+  #pragma omp parallel default(none) firstprivate(__func__)
+  foo (__func__);
+}
+
+void
+f4 (void)
+{
+  foo (__func__);
+  #pragma omp parallel default(none)
+  foo (__func__);
+}
+
+void
+f5 (void)
+{
+  foo (__func__);
+  #pragma omp parallel default(none) shared(__func__)
+  foo (__func__);
+}
+
+void
+f6 (void)
+{
+  foo (__func__);
+  #pragma omp parallel default(none) firstprivate(__func__)
+  foo (__func__);
+}
+
+void
+f7 (void)
+{
+  #pragma omp target map(to: __func__)
+  foo (__func__);
+  #pragma omp task depend(inout:__func__)
+  foo (__func__);
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr88203-2.c b/gcc/testsuite/c-c++-common/gomp/pr88203-2.c
new file mode 100644
index 00000000000..90c4a720774
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr88203-2.c
@@ -0,0 +1,65 @@
+/* PR c++/88203 */
+/* { dg-do compile } */
+/* { dg-additional-options "-std=gnu99" { target c } } */
+/* { dg-additional-options "-std=gnu++11" { target c++ } } */
+
+void foo (const char *, const char *);
+#pragma omp declare target to (foo)
+
+void
+f1 (void)
+{
+  #pragma omp parallel default(none)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f2 (void)
+{
+  #pragma omp parallel default(none) shared(__FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp parallel default(none) shared(__FUNCTION__) firstprivate(__PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f3 (void)
+{
+  #pragma omp parallel default(none) firstprivate(__FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp parallel default(none) firstprivate(__FUNCTION__), shared(__PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f4 (void)
+{
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp parallel default(none)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f5 (void)
+{
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp parallel default(none) shared(__FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f6 (void)
+{
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp parallel default(none) firstprivate(__FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
+
+void
+f7 (void)
+{
+  #pragma omp target map(to: __FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+  #pragma omp task depend(inout:__FUNCTION__, __PRETTY_FUNCTION__)
+  foo (__FUNCTION__, __PRETTY_FUNCTION__);
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr88203-3.c b/gcc/testsuite/c-c++-common/gomp/pr88203-3.c
new file mode 100644
index 00000000000..6a9585d3281
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr88203-3.c
@@ -0,0 +1,28 @@
+/* PR c++/88203 */
+/* { dg-do compile } */
+/* { dg-additional-options "-std=c99" { target c } } */
+/* { dg-additional-options "-std=c++11" { target c++ } } */
+
+void foo (const char *);
+#pragma omp declare target to (foo)
+
+void
+f1 (void)
+{
+  #pragma omp parallel for lastprivate (__func__)	/* { dg-error "'__func__' is predetermined 'shared' for 'lastprivate'" } */
+  for (int i = 0; i < 2; i++)
+    foo (__func__);
+  #pragma omp parallel private (__func__)		/* { dg-error "'__func__' is predetermined 'shared' for 'private'" } */
+  foo (__func__);
+}
+
+void
+f2 (void)
+{
+  foo (__func__);
+  #pragma omp parallel default(none) private (__func__)		/* { dg-error "'__func__' is predetermined 'shared' for 'private'" } */
+  foo (__func__);
+  #pragma omp parallel for default(none) lastprivate (__func__)	/* { dg-error "'__func__' is predetermined 'shared' for 'lastprivate'" } */
+  for (int i = 0; i < 2; i++)
+    foo (__func__);
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr91401-1.c b/gcc/testsuite/c-c++-common/gomp/pr91401-1.c
new file mode 100644
index 00000000000..f588bf6f16c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr91401-1.c
@@ -0,0 +1,10 @@
+/* PR c/91401 */
+
+void
+foo (void)
+{
+  int i;
+  #pragma omp distribute parallel for schedule (static) dist_schedule (static)
+  for (i = 0; i < 64; i++)
+    ;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr91401-2.c b/gcc/testsuite/c-c++-common/gomp/pr91401-2.c
new file mode 100644
index 00000000000..f537e66e27c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr91401-2.c
@@ -0,0 +1,15 @@
+#pragma omp declare target
+void f0 (void);
+
+void
+f1 (void)
+{
+  int i;
+  #pragma omp distribute dist_schedule(static) dist_schedule(static)	/* { dg-warning "too many 'dist_schedule' clauses" } */
+  for (i = 0; i < 8; ++i)
+    f0 ();
+  #pragma omp distribute dist_schedule(static,2) dist_schedule(static,4) /* { dg-warning "too many 'dist_schedule' clauses" } */
+  for (i = 0; i < 8; ++i)
+    f0 ();
+}
+#pragma omp end declare target
diff --git a/gcc/testsuite/c-c++-common/gomp/pr91920.c b/gcc/testsuite/c-c++-common/gomp/pr91920.c
new file mode 100644
index 00000000000..604fd5986f8
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr91920.c
@@ -0,0 +1,19 @@
+/* PR middle-end/91920 */
+
+void bar (float *);
+
+void
+foo (void)
+{
+  int i;
+  float f[3] = { 0.0f, 0.0f, 0.0f };
+#pragma omp parallel for default(none) reduction(+:f[:3])
+  for (i = 0; i < 1000; i++)
+    {
+      int j;
+      float k[3] = { 0.25f, 0.5f, 0.75f };
+      for (j = 0; j < 3; j++)
+	f[j] += k[j];
+    }
+  bar (f);
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr93555-1.c b/gcc/testsuite/c-c++-common/gomp/pr93555-1.c
new file mode 100644
index 00000000000..2eb76a2d9de
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr93555-1.c
@@ -0,0 +1,18 @@
+/* PR middle-end/93555 */
+/* { dg-do compile } */
+
+#pragma omp declare simd
+#pragma omp declare simd inbranch
+int
+foo (int x)
+{
+  return x;
+}
+
+#pragma omp declare simd inbranch
+#pragma omp declare simd
+int
+bar (int x)
+{
+  return x;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr93555-2.c b/gcc/testsuite/c-c++-common/gomp/pr93555-2.c
new file mode 100644
index 00000000000..091f5bd5ff1
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr93555-2.c
@@ -0,0 +1,16 @@
+/* PR middle-end/93555 */
+/* { dg-do compile } */
+
+#pragma omp declare simd
+#pragma omp declare simd inbranch
+void
+foo (void)
+{
+}
+
+#pragma omp declare simd inbranch
+#pragma omp declare simd
+void
+bar (void)
+{
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr84305.c b/gcc/testsuite/c-c++-common/pr84305.c
similarity index 78%
rename from gcc/testsuite/gcc.c-torture/compile/pr84305.c
rename to gcc/testsuite/c-c++-common/pr84305.c
index 374fa67f593..27150dd5328 100644
--- a/gcc/testsuite/gcc.c-torture/compile/pr84305.c
+++ b/gcc/testsuite/c-c++-common/pr84305.c
@@ -1,3 +1,5 @@
+// { dg-additional-options -O3 }
+
 int res, a, b;
 void *foo;
 static void f2 (int arg) { res = ((int (*)[arg][b]) foo)[0][0][0]; }
diff --git a/gcc/testsuite/c-c++-common/pr90677-2.c b/gcc/testsuite/c-c++-common/pr90677-2.c
new file mode 100644
index 00000000000..1d125e01586
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr90677-2.c
@@ -0,0 +1,8 @@
+/* PR c/90677 */
+/* { dg-do compile } */
+/* { dg-options "-W -Wall" } */
+
+extern void foo (int, int, const char *, ...)
+  __attribute__ ((__format__ (__gcc_tdiag__, 3, 4)));
+struct cgraph_node;
+extern void bar (struct cgraph_node *);
diff --git a/gcc/testsuite/c-c++-common/pr90677.c b/gcc/testsuite/c-c++-common/pr90677.c
new file mode 100644
index 00000000000..897fbc6e13e
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr90677.c
@@ -0,0 +1,11 @@
+/* PR c/90677 */
+/* { dg-do compile } */
+/* { dg-options "-W -Wall" } */
+
+struct cgraph_node;
+union tree_node;
+typedef union tree_node *tree;
+union gimple_statement_d;
+typedef union gimple_statement_d *gimple;
+struct cgraph_node *cgraph_node (tree);
+void foo (int, const char *, ...) __attribute__((__format__(__gcc_diag__, 2, 3)));
diff --git a/gcc/testsuite/g++.dg/abi/mangle73.C b/gcc/testsuite/g++.dg/abi/mangle73.C
new file mode 100644
index 00000000000..2a5322a37c3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/abi/mangle73.C
@@ -0,0 +1,96 @@
+// { dg-do compile { target c++2a } }
+
+struct A
+{
+  char a[2][2];
+};
+
+template <A> struct B { };
+
+typedef B<A{ { { 0, 0 }, { 0, 0 } } }> AZZZZ;
+typedef B<A{ { { 0, 0 }, { 0 } } }>    AZZZ_;
+typedef B<A{ { { 0, 0 } } }>           AZZ__;
+typedef B<A{ { { 0 } } }>              AZ___;
+typedef B<A{ { { } } }>                A____;
+
+typedef B<A{ { { "" }, { "" } } }>     AS_S_;
+typedef B<A{ { { "" }, { 0, 0 } } }>   AS_ZZ;
+typedef B<A{ { { "" }, { 0 } } }>      AS_Z_;
+typedef B<A{ { { "" } } }>             AS___;
+
+
+// Verify that the types mangle the same.
+void a_zzzz (AZZZZ) { }
+// { dg-final { scan-assembler "_Z6a_zzzz1BIXtl1AEEE" } }
+
+void a_zzz_ (AZZZ_) { }
+// { dg-final { scan-assembler "_Z6a_zzz_1BIXtl1AEEE" } }
+
+void a_zz__ (AZZ__) { }
+// { dg-final { scan-assembler "_Z6a_zz__1BIXtl1AEEE" } }
+
+void a_z___ (AZ___) { }
+// { dg-final { scan-assembler "_Z6a_z___1BIXtl1AEEE" } }
+
+void a_____ (A____) { }
+// { dg-final { scan-assembler "_Z6a_____1BIXtl1AEEE" } }
+
+void a_s_s_ (AS_S_) { }
+// { dg-final { scan-assembler "_Z6a_s_s_1BIXtl1AEEE" } }
+
+void a_s_zz (AS_ZZ) { }
+// { dg-final { scan-assembler "_Z6a_s_zz1BIXtl1AEEE" } }
+
+void a_s_z_ (AS_Z_) { }
+// { dg-final { scan-assembler "_Z6a_s_z_1BIXtl1AEEE" } }
+
+void a_s___ (AS___) { }
+// { dg-final { scan-assembler "_Z6a_s___1BIXtl1AEEE" } }
+
+
+struct C
+{
+  struct { const char a[2][2], *p; } a[2];
+};
+
+template <C> struct D { };
+
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}, 0 }}}> DZZZZZZZZZZ;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}}}}> DZZZZZZZZZ_;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0 }}}}}>    DZZZZZZZZ__;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 } }}}}>          DZZZZZZZ___;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0 } }}}}>             DZZZZZZ____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }}}>                         DZZZZZ_____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}}}}>                             DZZZZ______;
+typedef D<C{{{{{ 0, 0 }, { 0 }}}}}>                                DZZZ_______;
+typedef D<C{{{{{ 0, 0 }}}}}>                                       DZZ________;
+typedef D<C{{{{{ 0 }}}}}>                                          DZ_________;
+typedef D<C{ }>                                                    D__________;
+
+typedef D<C{{{{{ "" }, { "" }}, 0 }, {{{ "" }, { "" }}, 0 }}}>     DS_S_ZS_S_Z;
+
+void d_zzzzzzzzzz (DZZZZZZZZZZ) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzzz1DIXtl1CEEE" } }
+void d_zzzzzzzzz_ (DZZZZZZZZZ_) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzz_1DIXtl1CEEE" } }
+void d_zzzzzzzz__ (DZZZZZZZZ__) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzz__1DIXtl1CEEE" } }
+void d_zzzzzzz___ (DZZZZZZZ___) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzz___1DIXtl1CEEE" } }
+void d_zzzzzz____ (DZZZZZZ____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzz____1DIXtl1CEEE" } }
+void d_zzzzz_____ (DZZZZZ_____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzz_____1DIXtl1CEEE" } }
+void d_zzzz______ (DZZZZ______) { }
+// { dg-final { scan-assembler "_Z12d_zzzz______1DIXtl1CEEE" } }
+void d_zzz_______ (DZZZ_______) { }
+// { dg-final { scan-assembler "_Z12d_zzz_______1DIXtl1CEEE" } }
+void d_zz________ (DZZ________) { }
+// { dg-final { scan-assembler "_Z12d_zz________1DIXtl1CEEE" } }
+void d_z_________ (DZ_________) { }
+// { dg-final { scan-assembler "_Z12d_z_________1DIXtl1CEEE" } }
+void d___________ (D__________) { }
+// { dg-final { scan-assembler "_Z12d___________1DIXtl1CEEE" } }
+
+void d_s_s_zs_s_z (DS_S_ZS_S_Z) { }
+// { dg-final { scan-assembler "_Z12d_s_s_zs_s_z1DIXtl1CEEE" } }
diff --git a/gcc/testsuite/g++.dg/asan/asan_test.C b/gcc/testsuite/g++.dg/asan/asan_test.C
index f3f7626ef3b..a151979946a 100644
--- a/gcc/testsuite/g++.dg/asan/asan_test.C
+++ b/gcc/testsuite/g++.dg/asan/asan_test.C
@@ -2,7 +2,7 @@
 // { dg-skip-if "" { *-*-* } { "*" } { "-O2" } }
 // { dg-skip-if "" { *-*-* } { "-flto" } { "" } }
 // { dg-additional-sources "asan_globals_test-wrapper.cc" }
-// { dg-options "-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl" }
+// { dg-options "-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -Wno-alloc-size-larger-than -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl" }
 // { dg-additional-options "-DASAN_NEEDS_SEGV=1" { target { ! arm*-*-* } } }
 // { dg-additional-options "-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0" { target arm*-*-* } }
 // { dg-additional-options "-DASAN_AVOID_EXPENSIVE_TESTS=1" { target { ! run_expensive_tests } } }
diff --git a/gcc/testsuite/g++.dg/concepts/concepts-pr88395.C b/gcc/testsuite/g++.dg/concepts/concepts-pr88395.C
new file mode 100644
index 00000000000..da5834bcc07
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/concepts-pr88395.C
@@ -0,0 +1,23 @@
+// { dg-options "-std=c++17 -fconcepts" }
+
+template <class T, class U>
+concept Concept2 = requires (T t, U u)
+{
+    t += u; // { dg-error "template instantiation depth" }
+};
+
+template <class T>
+concept Concept = Concept2 <T, T>;
+
+struct S
+{
+    template <Concept T>
+    constexpr S& operator += (T o);
+};
+
+constexpr S operator * (S a, S b)
+{
+    return a += b;
+}
+
+// { dg-prune-output "compilation terminated" }
diff --git a/gcc/testsuite/g++.dg/conversion/packed2.C b/gcc/testsuite/g++.dg/conversion/packed2.C
new file mode 100644
index 00000000000..7df74dc110b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/conversion/packed2.C
@@ -0,0 +1,15 @@
+// PR c++/91925
+// { dg-do compile { target c++11 } }
+// { dg-options "-fpack-struct" }
+
+struct A {};
+int foo (A);
+struct B {
+  A a;
+  decltype (foo (a)) p;
+};
+template <typename T> T bar (T);
+class C {
+  A a;
+  decltype (bar (a)) p;
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/alignas17.C b/gcc/testsuite/g++.dg/cpp0x/alignas17.C
new file mode 100644
index 00000000000..b736083affc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alignas17.C
@@ -0,0 +1,14 @@
+// PR c++/89357
+// { dg-do compile { target c++11 } }
+
+void g(int &);
+
+void f0() {
+  __attribute__((aligned(128))) static int x;
+  g(x);
+}
+
+void f1() {
+  alignas(128) int x;
+  g(x);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-92015.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-92015.C
new file mode 100644
index 00000000000..60f288ee993
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-92015.C
@@ -0,0 +1,7 @@
+// PR c++/92015
+// { dg-do compile { target c++11 } }
+
+struct S1 { char c[6] {'h', 'e', 'l', 'l', 'o', 0}; };
+struct S2 { char c[6] = "hello"; };
+static_assert (S1{}.c[0] == 'h', "");
+static_assert (S2{}.c[0] == 'h', "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C
new file mode 100644
index 00000000000..e94695efa2a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C
@@ -0,0 +1,24 @@
+// PR c++/86917
+// { dg-do compile { target c++11 } }
+
+struct A
+{
+  constexpr A () : c (0) {}
+  static const A z;
+  unsigned c;
+};
+
+struct B
+{				// This should really be target { ! c++2a }
+  typedef A W[4];		// { dg-error "paren" "" { xfail *-*-* } .+1 }
+  constexpr B () : w ({ A::z, A::z, A::z, A::z }) {} // { dg-error "constant" "" { xfail *-*-* } }
+  W w;
+};
+
+struct C
+{
+  C ();
+  B w[1];
+};
+
+C::C () { }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-array24.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-array24.C
new file mode 100644
index 00000000000..538969830ba
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-array24.C
@@ -0,0 +1,10 @@
+// PR c++/90951
+// { dg-do compile { target c++11 } }
+
+#define assert(expr) static_assert (expr, #expr)
+
+struct S { const char a[2]; };
+
+constexpr struct S a[1][1][1] = { };
+
+assert ('\0' == *a[0][0][0].a);
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-empty14.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty14.C
new file mode 100644
index 00000000000..ca4f9a55e5f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-empty14.C
@@ -0,0 +1,10 @@
+// PR c++/91953
+// { dg-do compile { target c++11 } }
+
+struct S {};
+
+template <class T> void
+foo (S s)
+{
+  constexpr S x = s;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-odr1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-odr1.C
new file mode 100644
index 00000000000..cf3f95f0565
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-odr1.C
@@ -0,0 +1,19 @@
+// PR c++/92062 - ODR-use ignored for static member of class template.
+// { dg-do run { target c++11 } }
+
+template<int> struct A {
+  static const bool x;
+  static_assert(&x, ""); // odr-uses A<...>::x
+};
+
+int g;
+
+template<int I>
+const bool A<I>::x = (g = 42, false);
+
+void f(A<0>) {}        // A<0> must be complete, so is instantiated
+int main()
+{
+  if (g != 42)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-odr2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-odr2.C
new file mode 100644
index 00000000000..0927488e569
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-odr2.C
@@ -0,0 +1,19 @@
+// PR c++/92062 - ODR-use ignored for static member of class template.
+// { dg-do run { target c++11 } }
+
+template<int> struct A {
+  static const bool x;
+  enum { force_instantiation =! &x}; // odr-uses A<...>::x
+};
+
+int g;
+
+template<int I>
+const bool A<I>::x = (g = 42, false);
+
+void f(A<0>) {}        // A<0> must be complete, so is instantiated
+int main()
+{
+  if (g != 42)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-static13.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-static13.C
new file mode 100644
index 00000000000..644f9f7f893
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-static13.C
@@ -0,0 +1,17 @@
+// PR c++/92003
+// { dg-do compile { target c++11 } }
+// { dg-prune-output "narrowing conversion" }
+
+constexpr char const* get_c_str() { return "abc"; }
+constexpr bool use_get_c_str_in_constexpr_context{get_c_str()}; // works
+
+template <char... Cs>
+struct string {
+  static constexpr char const* c_str() { return c; }
+
+ private:
+  static constexpr char c[]{Cs..., '\0'};
+};
+
+constexpr char const* cstr{string<'a', 'b', 'c'>::c_str()};
+constexpr bool use_cstr_in_constexpr_context{cstr}; // doesn't work
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum23.C b/gcc/testsuite/g++.dg/cpp0x/enum23.C
index b2378e1b366..53ad990bf93 100644
--- a/gcc/testsuite/g++.dg/cpp0x/enum23.C
+++ b/gcc/testsuite/g++.dg/cpp0x/enum23.C
@@ -5,5 +5,5 @@ enum class MyEnum { A = 1 };
 
 struct MyClass
 {
-  MyEnum Field1 : 3; // { dg-bogus "warning: 'MyClass::Field1' is too small" "" { xfail *-*-* } }
+  MyEnum Field1 : 3; // { dg-bogus "warning: 'MyClass::Field1' is too small" }
 };
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum38.C b/gcc/testsuite/g++.dg/cpp0x/enum38.C
new file mode 100644
index 00000000000..f0dd8a1fc6b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum38.C
@@ -0,0 +1,25 @@
+// PR c++/61414
+// { dg-do compile { target c++11 } }
+
+enum C { C0 = -4, C1 = 3 };
+enum D { D0 = 0, D1 = 15 };
+enum class E { E0 = -4, E1 = 3 };
+enum F : unsigned { F0 = 0, F1 = 15 };
+enum __attribute__((__mode__ (__QI__))) G { G0 = -4, G1 = 3 };
+enum __attribute__((__mode__ (__HI__))) H { H0 = 0, H1 = 15 };
+
+struct S
+{
+  C a : 2;	// { dg-warning "'S::a' is too small to hold all values of 'enum C'" }
+  C b : 3;	// { dg-bogus "'S::b' is too small to hold all values of 'enum C'" }
+  D c : 3;	// { dg-warning "'S::c' is too small to hold all values of 'enum D'" }
+  D d : 4;	// { dg-bogus "'S::d' is too small to hold all values of 'enum D'" }
+  E e : 2;	// { dg-warning "'S::e' is too small to hold all values of 'enum class E'" }
+  E f : 3;	// { dg-bogus "'S::f' is too small to hold all values of 'enum class E'" }
+  F g : 3;	// { dg-warning "'S::g' is too small to hold all values of 'enum F'" }
+  F h : 4;	// { dg-bogus "'S::h' is too small to hold all values of 'enum F'" }
+  G i : 2;	// { dg-warning "'S::i' is too small to hold all values of 'enum G'" }
+  G j : 3;	// { dg-bogus "'S::j' is too small to hold all values of 'enum G'" }
+  H k : 3;	// { dg-warning "'S::k' is too small to hold all values of 'enum H'" }
+  H l : 4;	// { dg-bogus "'S::l' is too small to hold all values of 'enum H'" }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum39.C b/gcc/testsuite/g++.dg/cpp0x/enum39.C
new file mode 100644
index 00000000000..676cf8463de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum39.C
@@ -0,0 +1,15 @@
+// PR c++/61414
+// { dg-do compile { target c++11 } }
+
+enum class E { E0 = -4, E1 = 3 };
+enum F : unsigned { F0 = 0, F1 = 15 };
+
+struct S
+{
+  E a : 2;	// { dg-warning "'S::a' is too small to hold all values of 'enum class E'" }
+  E b : 2;	// { dg-warning "'S::b' is too small to hold all values of 'enum class E'" }
+  E c : 3;	// { dg-bogus "'S::c' is too small to hold all values of 'enum class E'" }
+  F d : 3;	// { dg-warning "'S::d' is too small to hold all values of 'enum F'" }
+  F e : 3;	// { dg-warning "'S::e' is too small to hold all values of 'enum F'" }
+  F f : 4;	// { dg-bogus "'S::f' is too small to hold all values of 'enum F'" }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C
new file mode 100644
index 00000000000..6bede0659db
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C
@@ -0,0 +1,40 @@
+// PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-Wunused-parameter -Wno-pedantic" }
+
+void fn1([[maybe_unused]] int a) { }
+void fn2(int a [[maybe_unused]]) { }
+void fn3(__attribute__((unused)) int a) { }
+void fn4(int a __attribute__((unused))) { }
+
+struct S1 {
+  S1([[maybe_unused]] int a) { }
+};
+
+struct S2 {
+  S2([[maybe_unused]] int f, [[maybe_unused]] int a) { }
+};
+
+struct S3 {
+  S3(int a [[maybe_unused]]) { }
+};
+
+struct S4 {
+  S4(int f [[maybe_unused]], int a [[maybe_unused]]) { }
+};
+
+struct S5 {
+  S5(__attribute__((unused)) int a) { }
+};
+
+struct S6 {
+  S6(__attribute__((unused)) int f, __attribute__((unused)) int a) { }
+};
+
+struct S7 {
+  S7(int a __attribute__((unused))) { }
+};
+
+struct S8 {
+  S8(int f __attribute__((unused)), int a __attribute__((unused))) { }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C
new file mode 100644
index 00000000000..43173dbbdf4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C
@@ -0,0 +1,40 @@
+// PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-Wno-pedantic" }
+
+void fn1([[maybe_unused]] int);
+void fn2(int a [[maybe_unused]]);
+void fn3(__attribute__((unused)) int);
+void fn4(int __attribute__((unused)));
+
+struct S1 {
+  S1([[maybe_unused]] int);
+};
+
+struct S2 {
+  S2([[maybe_unused]] int, [[maybe_unused]] int);
+};
+
+struct S3 {
+  S3(int a [[maybe_unused]]);
+};
+
+struct S4 {
+  S4(int a [[maybe_unused]], int b [[maybe_unused]]);
+};
+
+struct S5 {
+  S5(__attribute__((unused)) int);
+};
+
+struct S6 {
+  S6(__attribute__((unused)) int, __attribute__((unused)) int);
+};
+
+struct S7 {
+  S7(int __attribute__((unused)));
+};
+
+struct S8 {
+  S8(int __attribute__((unused)), int __attribute__((unused)));
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/gen-attrs-71.C b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-71.C
new file mode 100644
index 00000000000..7876a2fba30
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-71.C
@@ -0,0 +1,7 @@
+// PR c++/92648
+// { dg-do compile { target c++11 } }
+
+int a [[gnu::no_such_attribute(![!(!)!]!,;;)]];	// { dg-warning "ignored" }
+int b [[no_such_namespace::nonexisting_attribute(linear(c, d : 2), reduction(*:e), linear(uval (f)))]];	// { dg-warning "ignored" }
+int c [[gnu::nonexisting_attribute()]];	// { dg-warning "ignored" }
+int d [[gnu::another_nonexistent_attr(1,"abcd",g+6)]];	// { dg-warning "ignored" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-array10.C b/gcc/testsuite/g++.dg/cpp0x/initlist-array10.C
new file mode 100644
index 00000000000..fb9e136b56e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-array10.C
@@ -0,0 +1,14 @@
+// PR c++/90966
+// { dg-do compile { target c++11 } }
+
+template<typename I>
+void f()
+{
+  using S = signed char;
+  constexpr const S v[]{0};
+}
+
+int main()
+{
+  f<int>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new2.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new2.C
new file mode 100644
index 00000000000..439b8dabacb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new2.C
@@ -0,0 +1,15 @@
+// PR c++/57082
+// { dg-do compile { target c++11 } }
+
+struct X
+{
+private:
+  ~X() {}
+};
+
+int main()
+{
+  new X;    // OK
+  new X();  // OK
+  new X{};  // { dg-bogus "" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist118.C b/gcc/testsuite/g++.dg/cpp0x/initlist118.C
new file mode 100644
index 00000000000..a2267661532
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist118.C
@@ -0,0 +1,26 @@
+// PR c++/92745 - bogus error when initializing array of vectors.
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wno-psabi -w" }
+
+template <typename a, int b> struct c {
+  typedef a d[b];
+};
+
+template <typename a, int b> struct array {
+  typename c<a, b>::d e;
+  a operator[](long);
+};
+
+template<class T>
+using vec4_t __attribute__((vector_size(4*sizeof(T)))) = float;
+
+array<vec4_t<float>, 4>
+transpose(array<vec4_t<float>, 4> col)
+{
+  array<vec4_t<float>, 4>
+    ret{vec4_t<float>{col[0][0], col[1][0], col[2][0], col[3][0]},
+        vec4_t<float>{col[0][1], col[1][1], col[2][1], col[3][1]},
+        vec4_t<float>{col[0][2], col[1][2], col[2][2], col[3][2]},
+        vec4_t<float>{col[0][3], col[1][3], col[2][3], col[3][3]}};
+  return ret;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template16.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template16.C
new file mode 100644
index 00000000000..faaff68b968
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template16.C
@@ -0,0 +1,15 @@
+// PR c++/93279
+// { dg-do compile { target c++11 } }
+
+template <typename T> struct B { using f = int; };
+template <typename T, int N> struct E {
+  template <typename U, typename B<E>::f = 0>
+  void operator*(U l) { [l](T m) { m * l; }; }
+};
+
+int
+main ()
+{
+  E<E<float, 4>, 1> n;
+  n * 4.f;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C
new file mode 100644
index 00000000000..8c5085cf0f1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C
@@ -0,0 +1,16 @@
+// PR c++/90538
+// { dg-do compile { target c++11 } }
+
+template <class... Ts>
+void f(Ts... ts)
+{
+  [=]{
+    f(ts...);
+    f(ts...);
+  }();
+}
+
+void g()
+{
+  f(1);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/nontype5.C b/gcc/testsuite/g++.dg/cpp0x/nontype5.C
new file mode 100644
index 00000000000..c31134581aa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nontype5.C
@@ -0,0 +1,17 @@
+// PR c++/91923 - failure-to-SFINAE with class type NTTP in C++17.
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+constexpr bool is_integral_(...) {
+    return false;
+}
+template<typename T, T = 1>
+constexpr bool is_integral_(long) {
+    return true;
+}
+
+static_assert(is_integral_<int>(42), "");
+static_assert(!is_integral_<void>(42), "");
+
+struct S {};
+static_assert(!is_integral_<S>(42), "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-template19.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template19.C
new file mode 100644
index 00000000000..f3e2cb87fd6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template19.C
@@ -0,0 +1,13 @@
+// PR c++/93676 - value-init crash in template.
+// { dg-do compile { target c++11 } }
+
+struct P {
+  int x = 0;
+};
+
+template<class T>
+struct S {
+  S() { new P[2][2]; }
+};
+
+S<int> s;
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr42.C b/gcc/testsuite/g++.dg/cpp0x/nullptr42.C
new file mode 100644
index 00000000000..2fb628df6d7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr42.C
@@ -0,0 +1,18 @@
+// PR c++/90473 - wrong code with nullptr in default argument.
+// { dg-do run { target c++11 } }
+
+int g;
+void f() { g++; }
+
+void fn1 (void* p = (f(), nullptr)) { }
+void fn2 (int p = (f(), 0)) { }
+
+int main()
+{
+  fn1 ();
+  if (g != 1)
+    __builtin_abort ();
+  fn2 ();
+  if (g != 2)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr45.C b/gcc/testsuite/g++.dg/cpp0x/nullptr45.C
new file mode 100644
index 00000000000..3ff226803df
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr45.C
@@ -0,0 +1,24 @@
+// PR c++/92992
+// { dg-do run { target c++11 } }
+
+int a;
+
+void
+bar (int, ...)
+{
+}
+
+decltype (nullptr)
+baz ()
+{
+  a++;
+  return nullptr;
+}
+
+int
+main ()
+{
+  bar (0, baz ());
+  if (a != 1)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/overload-conv-4.C b/gcc/testsuite/g++.dg/cpp0x/overload-conv-4.C
new file mode 100644
index 00000000000..6fcdbbaa6a4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/overload-conv-4.C
@@ -0,0 +1,23 @@
+// PR c++/90998 - ICE with copy elision in init by ctor and -Wconversion.
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wconversion" }
+
+struct B;
+
+struct A {
+    operator B();
+};
+
+struct B {
+    B(A const &rs);
+    B(B const &rs);
+};
+
+B
+f (A x)
+{
+  // C++14: we call B::B(A const &)
+  // C++17: we call A::operator B()
+  return B(x); // { dg-warning "choosing .A::operator B\\(\\). over .B::B\\(const A&\\)" "" { target c++17 } }
+  // { dg-warning "for conversion from .A. to .B." "" { target c++17 } .-1 }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr92524.C b/gcc/testsuite/g++.dg/cpp0x/pr92524.C
new file mode 100644
index 00000000000..ffbcd8f9f3a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr92524.C
@@ -0,0 +1,12 @@
+// PR c++/92524
+// { dg-do compile { target c++11 } }
+
+struct A { char a = '*'; };
+struct B { A b[64]; };
+
+void
+foo ()
+{
+  A a;
+  B{a};
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr93905.C b/gcc/testsuite/g++.dg/cpp0x/pr93905.C
new file mode 100644
index 00000000000..81c6266a795
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr93905.C
@@ -0,0 +1,18 @@
+// PR c++/93905
+// { dg-do compile { target c++11 } }
+
+enum class E { VALUE };
+
+struct B {
+  E e{E::VALUE};
+protected:
+  ~B () = default;  
+};
+
+struct D : B {};
+
+int
+main ()
+{
+  D d{};
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for19.C b/gcc/testsuite/g++.dg/cpp0x/range-for19.C
index e3f446f3700..6afaee577f2 100644
--- a/gcc/testsuite/g++.dg/cpp0x/range-for19.C
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for19.C
@@ -5,6 +5,6 @@
 int main()
 {
   auto a;        // { dg-error "no initializer" }
-  for(auto i: a) // { dg-error "deduce" }
+  for(auto i: a)
     ;
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/rv-conv3.C b/gcc/testsuite/g++.dg/cpp0x/rv-conv3.C
new file mode 100644
index 00000000000..5f727fcc0d5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/rv-conv3.C
@@ -0,0 +1,15 @@
+// PR c++/90546
+// { dg-do link { target c++11 } }
+
+struct Foo { };
+void test(const Foo&) {}
+Foo f;
+struct Bar {
+  template <class T> operator T&&();
+};
+template<> Bar::operator const Foo&&() {
+    return static_cast<Foo&&>(f);
+}
+int main() {
+  test(Bar{});
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/temp-extend2.C b/gcc/testsuite/g++.dg/cpp0x/temp-extend2.C
new file mode 100644
index 00000000000..0b904e3ffbc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/temp-extend2.C
@@ -0,0 +1,36 @@
+// PR c++/92831
+// { dg-do run { target c++11 } }
+
+template<typename T> using id = T;
+struct S { S () { s++; } ~S () { s--; } S (int) { s++; } static int s; };
+int S::s = 0;
+
+void
+bar (bool cond, bool cond2)
+{
+  if (S::s != (cond ? cond2 ? 7 : 5 : cond2 ? 8 : 9))
+    __builtin_abort ();
+}
+
+void
+foo (bool cond, bool cond2)
+{
+  int i = 1;
+  // temporary array has same lifetime as a
+  S&& a = id<S[3]>{1, 2, 3}[i];
+  // temporary S has same lifetime as b
+  const S& b = static_cast<const S&>(0);
+  // exactly one of the four temporaries is lifetime-extended
+  S&& c = cond ? cond2 ? id<S[3]>{1, 2, 3}[i] : static_cast<S&&>(0)
+	       : cond2 ? id<S[4]>{1, 2, 3, 4}[i] : id<S[5]>{1, 2, 3, 4, 5}[i];
+  bar (cond, cond2);
+}
+
+int
+main ()
+{
+  foo (true, true);
+  foo (true, false);
+  foo (false, true);
+  foo (false, false);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-parm1.C b/gcc/testsuite/g++.dg/cpp0x/variadic-parm1.C
new file mode 100644
index 00000000000..4300c781400
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-parm1.C
@@ -0,0 +1,17 @@
+// PR c++/93140
+// { dg-do compile { target c++11 } }
+
+int
+bar ()
+{
+  return 42;
+}
+
+template <typename... R>
+void foo (R... r, decltype (bar (r...)) x = 0) {}
+
+int
+main ()
+{
+  foo (3);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/attr-deprecated-3.C b/gcc/testsuite/g++.dg/cpp1y/attr-deprecated-3.C
new file mode 100644
index 00000000000..16e5018f9cf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/attr-deprecated-3.C
@@ -0,0 +1,13 @@
+// PR c++/93228
+// { dg-do compile { target c++14 } }
+
+template <typename T>
+struct [[deprecated("foo")]] bar {};	// { dg-message "declared here" }
+struct [[deprecated("baz")]] qux {}; 	// { dg-message "declared here" }
+
+void
+quux ()
+{
+  bar<int> b;	// { dg-warning "is deprecated: foo" }
+  qux c;	// { dg-warning "is deprecated: baz" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C
new file mode 100644
index 00000000000..69bdd9586eb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C
@@ -0,0 +1,19 @@
+// PR c++/91378
+// { dg-do compile { target c++14 } }
+
+struct B
+{
+  int i;
+};
+
+struct C
+{
+  template <class T> static auto
+  g(B b) noexcept(noexcept(b.i)) { }
+};
+
+template <class T>
+void h(T t)
+{
+  C::g<int>({});
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-incr2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-incr2.C
new file mode 100644
index 00000000000..0d22851e4b2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-incr2.C
@@ -0,0 +1,66 @@
+// PR c++/91705 - constexpr evaluation rejects ++/-- on floats.
+// { dg-do compile { target c++14 } }
+
+#define SA(X) static_assert((X),#X)
+
+template <class T>
+constexpr T fn1(T t)
+{
+  return ++t;
+}
+
+constexpr float fn2(float t)
+{
+  return ++t;
+}
+
+template <class T>
+constexpr T fn3(T t)
+{
+  return --t;
+}
+
+constexpr float fn4(float t)
+{
+  return --t;
+}
+
+template <class T>
+constexpr T fn5(T t)
+{
+  return t++;
+}
+
+constexpr float fn6(float t)
+{
+  return t++;
+}
+
+template <class T>
+constexpr T fn7(T t)
+{
+  return t--;
+}
+
+constexpr float fn8(float t)
+{
+  return t--;
+}
+
+constexpr double r1 = fn1(2.0f);
+SA(r1 == 3);
+constexpr double r2 = fn2(2.0f);
+SA(r2 == 3);
+constexpr double r3 = fn3(2.0f);
+SA(r3 == 1);
+constexpr double r4 = fn4(2.0f);
+SA(r4 == 1);
+
+constexpr double r5 = fn5(2.0f);
+SA(r5 == 2);
+constexpr double r6 = fn6(2.0f);
+SA(r6 == 2);
+constexpr double r7 = fn7(2.0f);
+SA(r7 == 2);
+constexpr double r8 = fn8(2.0f);
+SA(r8 == 2);
diff --git a/gcc/testsuite/g++.dg/cpp1y/dr1560.C b/gcc/testsuite/g++.dg/cpp1y/dr1560.C
deleted file mode 100644
index b21ca98e279..00000000000
--- a/gcc/testsuite/g++.dg/cpp1y/dr1560.C
+++ /dev/null
@@ -1,14 +0,0 @@
-// Core 1560
-// { dg-do compile { target c++14 } }
-
-struct A
-{
-  A();
-  A(const A&) = delete;
-};
-
-void f(bool b)
-{
-  A a;
-  b ? a : throw 42;
-}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-90842.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-90842.C
new file mode 100644
index 00000000000..e36aa547053
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-90842.C
@@ -0,0 +1,7 @@
+// PR c++/90842
+// { dg-do compile { target c++14 } }
+
+auto a = [](auto x) struct C { void foo (); } {};	// { dg-error "expected" }
+							// { dg-error "type-specifier invalid in lambda" "" { target *-*-* } .-1 }
+auto b = [](auto x) mutable typedef {};			// { dg-error "'typedef' invalid in lambda" }
+auto d = [](auto x) mutable friend {};			// { dg-error "'friend' invalid in lambda" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ref1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ref1.C
new file mode 100644
index 00000000000..a96fa1ce237
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ref1.C
@@ -0,0 +1,12 @@
+// PR c++/92852
+// { dg-do compile { target c++14 } }
+
+struct S { int operator<<(const int &); } glob;
+void foo()
+{
+  S& message_stream = glob;
+  auto format = [&message_stream](auto && x)
+		{ message_stream << x ; };
+  format(3);
+  format(4u);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C b/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C
index 0a40ebbee0f..6b4ed347eee 100644
--- a/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C
@@ -3,7 +3,7 @@
 
 template < class T = int > void f (T)
 {
-  auto g = [&a = f] () {};  // { dg-error "invalid initialization" }
+  auto g = [&a = f] () {};  // { dg-error "auto" }
 }
 
 int main ()
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-vla1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-vla1.C
new file mode 100644
index 00000000000..c9025c79aa7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-vla1.C
@@ -0,0 +1,16 @@
+// PR c++/90732
+// { dg-do compile { target c++14 } }
+// { dg-additional-options "-Wno-vla" }
+
+/*const*/ int SIZE = 100;
+
+template<typename T>
+int foo(T t) {
+  char buf[SIZE] = { 24 };
+  return [&buf](auto x){ return buf[x]; }(t);
+}
+
+int main() {
+  if (foo(0) != 24)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/nontype1.C b/gcc/testsuite/g++.dg/cpp1y/nontype1.C
new file mode 100644
index 00000000000..a37e996a3ff
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nontype1.C
@@ -0,0 +1,42 @@
+// PR c++/91129 - wrong error with binary op in template argument.
+// { dg-do compile { target c++14 } }
+
+template<class T, T v>
+struct C
+{
+  constexpr operator T() const { return v; }
+  constexpr auto operator()() const { return v; }
+};
+
+template<class T, int N>
+struct A
+{
+};
+
+template<int N>
+void foo ()
+{
+  A<int, C<int, 6>{}> a0;
+  A<int, !C<int, 6>{}> a1;
+  A<int, N / C<int, 6>{}> a2;
+  A<int, N % C<int, 6>{}> a3;
+  A<int, N * C<int, 6>{}> a4;
+  A<int, N ^ C<int, 6>{}> a5;
+  A<int, N | C<int, 6>{}> a6;
+  A<int, N & C<int, 6>{}> a7;
+  A<int, N + C<int, 6>{}> a8;
+  A<int, N - C<int, 6>{}> a9;
+  A<int, -C<int, 6>{}> a10;
+  A<int, (N >> C<int, 6>{})> a11;
+  A<int, N << C<int, 6>{}> a12;
+  A<int, ~C<int, 6>{}> a13;
+  A<int, N || C<int, 6>{}> a14;
+  A<int, N && C<int, 6>{}> a15;
+  A<int, N == C<int, 6>{}> a16;
+  A<int, N != C<int, 6>{}> a17;
+}
+
+int main()
+{
+  foo<10>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/paren5.C b/gcc/testsuite/g++.dg/cpp1y/paren5.C
new file mode 100644
index 00000000000..86a51356465
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/paren5.C
@@ -0,0 +1,12 @@
+// PR c++/93299 - ICE in tsubst_copy with parenthesized expression.
+// { dg-do compile { target c++14 } }
+
+template <typename> struct A {
+  enum { b = 8 };
+};
+
+template <int> struct __attribute__((aligned((A<int>::b)))) D { };
+struct S : D<0> { };
+
+template <int N> struct __attribute__((aligned((A<int>::b) + N))) D2 { };
+struct S2 : D2<0> { };
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ63.C b/gcc/testsuite/g++.dg/cpp1y/var-templ63.C
new file mode 100644
index 00000000000..a65f53b2963
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ63.C
@@ -0,0 +1,5 @@
+// PR c++/91740 - ICE with constexpr call and ?: in ARRAY_REF.
+// { dg-do compile { target c++14 } }
+
+constexpr bool f(const char*) { return true; }
+template<typename T> const char c = "FOO"[f("BAR") ? 1 : 0];
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda1.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda1.C
new file mode 100644
index 00000000000..64c4cd27fe6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda1.C
@@ -0,0 +1,16 @@
+// PR c++/93442
+// { dg-do compile { target c++17 } }
+
+struct bar {
+    int foo(){return 0;}
+};
+
+int foobar() {
+    if constexpr(true) {
+        return 0;
+    } else {
+        return [](){
+            return bar{};
+        }().foo();
+    }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if12.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if12.C
index f21a9896ff2..005aa80fc09 100644
--- a/gcc/testsuite/g++.dg/cpp1z/constexpr-if12.C
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if12.C
@@ -2,12 +2,13 @@
 // { dg-do compile { target c++17 } }
 
 struct T {
+  int i;
   constexpr auto foo() { return false; }
 };
 
 template <class MustBeTemplate>
 constexpr auto bf(T t) {
-    if constexpr(t.foo()) {	// { dg-error "constant expression" }
+    if constexpr(t.foo()) {
         return false;
     }
     return true;
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda25.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda25.C
new file mode 100644
index 00000000000..74db03ff569
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda25.C
@@ -0,0 +1,7 @@
+// PR c++/92531
+// { dg-do compile { target c++17 } }
+
+template <typename XK>
+void ky () noexcept ([]{}); // IFNDR
+// Optional error: void(*)() to bool conv in converted constant expression
+// { dg-prune-output "converted constant expression" }
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp50.C b/gcc/testsuite/g++.dg/cpp1z/decomp50.C
new file mode 100644
index 00000000000..5400a826948
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp50.C
@@ -0,0 +1,51 @@
+// PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr. 
+// { dg-do compile { target c++17 } }
+
+template <typename> struct B;
+template <typename _Tp> struct B<_Tp *> { typedef _Tp& reference; };
+struct C {
+  template <typename _Up> using rebind = _Up *;
+};
+template <typename _Iterator, typename> class D {
+public:
+  typename B<_Iterator>::reference operator*();
+  void operator++();
+};
+
+template <typename _Iterator, typename _Container>
+bool operator!=(D<_Iterator, _Container>, D<_Iterator, _Container>);
+template <typename _Tp> class F {
+public:
+  typedef _Tp value_type;
+};
+
+template <typename _Alloc> struct G {
+  template <typename _Tp> struct H { using type = C::rebind<_Tp>; };
+  using const_pointer = typename H<typename _Alloc::value_type>::type;
+};
+template <typename _Tp, typename _Alloc = F<_Tp>> class I {
+  typedef D<typename G<_Alloc>::const_pointer, int> const_iterator;
+
+public:
+  const_iterator begin();
+  const_iterator end();
+};
+
+struct A {
+  struct J {
+    int name;
+    int value;
+  };
+  I<J> members;
+  template <typename Key> const int *find(Key) {
+    for (const auto &[name, value] : members)
+      // See <https://gcc.gnu.org/ml/gcc-patches/2019-10/msg01107.html>
+      // for why we don't warn here.
+      return &value; // { dg-bogus "address of local variable" }
+    return nullptr;
+  }
+};
+int main() {
+  A a;
+  a.find("");
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/eval-order5.C b/gcc/testsuite/g++.dg/cpp1z/eval-order5.C
new file mode 100644
index 00000000000..a8f06ed421a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/eval-order5.C
@@ -0,0 +1,31 @@
+// PR c++/91974
+// { dg-do run }
+// { dg-options "-fstrong-eval-order" }
+
+extern "C" void abort ();
+
+bool ok = false;
+
+void
+foo (int x)
+{
+  if (x != 0)
+    abort ();
+  ok = true;
+}
+
+void
+bar (int)
+{
+  abort ();
+}
+
+int
+main ()
+{
+  typedef void (*T) (int);
+  T fn = foo;
+  fn ((fn = bar, 0));
+  if (fn != bar || !ok)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type22.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type22.C
new file mode 100644
index 00000000000..dd9924ff1b1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type22.C
@@ -0,0 +1,6 @@
+// PR c++/90731
+// { dg-do compile { target c++17 } }
+
+typedef void T() noexcept(true);
+T t;
+void t() noexcept(true);
diff --git a/gcc/testsuite/g++.dg/cpp2a/attr-likely6.C b/gcc/testsuite/g++.dg/cpp2a/attr-likely6.C
new file mode 100644
index 00000000000..a04021e5037
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/attr-likely6.C
@@ -0,0 +1,14 @@
+// PR c++/92343
+// { dg-do compile { target c++14 } }
+
+constexpr bool
+foo (bool x)
+{
+  if (x)
+    [[unlikely]] return true;
+  else
+    [[likely]] return false;
+}
+
+static_assert (foo (true), "");
+static_assert (!foo (false), "");
diff --git a/gcc/testsuite/g++.dg/cpp2a/bitfield3.C b/gcc/testsuite/g++.dg/cpp2a/bitfield3.C
index 511c8894703..5482da490e2 100644
--- a/gcc/testsuite/g++.dg/cpp2a/bitfield3.C
+++ b/gcc/testsuite/g++.dg/cpp2a/bitfield3.C
@@ -15,11 +15,9 @@ const int b = 0;
 struct S {
   int c : 5 = 2 * a;			// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
   int d : 6 { c + a };			// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
-					// { dg-warning "narrowing conversion of" "" { target *-*-* } .-1 }
   int e : true ? 7 : a = 3;
   int f : (true ? 8 : b) = d + a;	// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
   int g : (true ? 9 : b) { f + a };	// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
-					// { dg-warning "narrowing conversion of" "" { target *-*-* } .-1 }
   int h : 1 || new int { 0 };
   int i = g + a;
 };
@@ -28,11 +26,9 @@ template <bool V, int W>
 struct U {
   int j : W = 3 * a;			// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
   int k : W { j + a };			// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
-					// { dg-warning "narrowing conversion of" "" { target *-*-* } .-1 }
   int l : V ? 7 : a = 3;
   int m : (V ? W : b) = k + a;		// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
   int n : (V ? W : b) { m + a };	// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
-					// { dg-warning "narrowing conversion of" "" { target *-*-* } .-1 }
   int o : 1 || new int { 0 };
   int p = n + a;
 };
diff --git a/gcc/testsuite/g++.dg/cpp2a/bitfield4.C b/gcc/testsuite/g++.dg/cpp2a/bitfield4.C
new file mode 100644
index 00000000000..bbfa86cbb9e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/bitfield4.C
@@ -0,0 +1,12 @@
+// PR c++/92732
+// { dg-do compile { target c++17 } }
+// { dg-options "" }
+
+enum class byte : unsigned char { };
+using uint8_t = unsigned char;
+
+struct T
+{
+  byte a : 2 = byte{0};	// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
+  uint8_t b : 2 = 0;	// { dg-warning "default member initializers for bit-fields only available with" "" { target c++17_down } }
+} t;
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual14.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual14.C
new file mode 100644
index 00000000000..b29d3f6aefb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual14.C
@@ -0,0 +1,27 @@
+// PR c++/92695
+// { dg-do compile { target c++2a } }
+
+struct A {
+  virtual int get () = 0;
+  virtual int set (A *o) = 0;
+};
+struct B : A {
+  constexpr int get () override { return 10; }
+  constexpr int set (A *o) override { a = o; return 20; }
+  A *a {};
+};
+constexpr auto addressof = [] (A &n) { return &n; };
+struct C {
+  B b;
+  A *c { addressof (b) };
+  constexpr int add () { return c->set (addressof (b)); }
+};
+struct D {
+  B b[2];
+  A *c { addressof (b[0]) };
+  constexpr int add () { return c->set (addressof (b[0])); }
+};
+template <typename T>
+constexpr int get () { T f; return f.add (); }
+static_assert (get<C> () == 20);
+static_assert (get<D> () == 20);
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual15.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual15.C
new file mode 100644
index 00000000000..cb55aa3bb56
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual15.C
@@ -0,0 +1,7 @@
+// PR c++/92695
+// { dg-do compile { target c++2a } }
+
+struct A { virtual int get() = 0; };
+struct B : A { constexpr int get() override { return 10; } };
+struct D { B b[2]; A* c{&(b[0])}; };
+static_assert(D{}.c->get() == 10);
diff --git a/gcc/testsuite/g++.dg/cpp2a/no_unique_address3.C b/gcc/testsuite/g++.dg/cpp2a/no_unique_address3.C
new file mode 100644
index 00000000000..07108b8b715
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/no_unique_address3.C
@@ -0,0 +1,16 @@
+// PR c++/90432
+// { dg-do compile { target c++11 } }
+
+struct empty {};
+
+struct has_empty {
+  [[no_unique_address]] empty brace_or_equal_initialized{};
+};
+
+struct has_value {
+  int non_zero = 1;
+};
+
+struct pair : has_empty, has_value {};
+
+pair a;
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C
new file mode 100644
index 00000000000..ab9e80fd335
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C
@@ -0,0 +1,102 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Test to verify that the same specializations on non-type template
+// parameters of class types are in fact treated as the same.  Unlike
+// nontype-class15.C which involves only one-dimensional arrays this
+// test involves arrays of arrays and arrays of structs.
+// { dg-do compile { target c++2a } }
+
+struct AA3
+{
+  const char a[2][2][2];
+};
+
+template <AA3> struct BAA3 { };
+
+// Redeclare the same variable using different initialization forms
+// of the same constant to verify that they are in fact all recognized
+// as the same.
+extern BAA3<AA3{{{ "", "" }, { "", "" }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0, 0 } }}}> baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0 } }}}>    baa3;
+extern BAA3<AA3{{{ "", "" }, { "", {} }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "" }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0, 0 } }}}>     baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0 } }}}>        baa3;
+extern BAA3<AA3{{{ "", "" }, { {} }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { }}}>              baa3;
+extern BAA3<AA3{{{ "", "" }}}>                   baa3;
+extern BAA3<AA3{{{ "", { 0, 0 } }}}>             baa3;
+extern BAA3<AA3{{{ "", { 0 } }}}>                baa3;
+extern BAA3<AA3{{{ "", {} }}}>                   baa3;
+extern BAA3<AA3{{{ "" }}}>                       baa3;
+extern BAA3<AA3{{{ { 0, 0 } }}}>                 baa3;
+extern BAA3<AA3{{{ { 0 } }}}>                    baa3;
+extern BAA3<AA3{{{ {} }}}>                       baa3;
+extern BAA3<AA3{{{ }}}>                          baa3;
+extern BAA3<AA3{{ }}>                            baa3;
+extern BAA3<AA3{ }>                              baa3;
+
+extern BAA3<AA3{{{ "", "" }, { "", "1" }}}>        baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1', 0 } }}}> baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1' } }}}>    baa3_1;
+
+extern BAA3<AA3{{{ "", "" }, { "1", {} }}}>        baa3_2;
+extern BAA3<AA3{{{ "", "" }, { "1" }}}>            baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1', 0 } }}}>     baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1' } }}}>        baa3_2;
+
+extern BAA3<AA3{{{ "", "1" }}}>                    baa3_3;
+extern BAA3<AA3{{{ "", { '1', 0 } }}}>             baa3_3;
+extern BAA3<AA3{{{ "", { '1' } }}}>                baa3_3;
+
+extern BAA3<AA3{{{ "1" }}}>                        baa3_4;
+extern BAA3<AA3{{{ { '1', 0 } }}}>                 baa3_4;
+extern BAA3<AA3{{{ { '1' } }}}>                    baa3_4;
+
+struct AS2
+{
+  struct S { const char a[2], *p; } a[2];
+};
+
+template <AS2> struct BAS2 { };
+
+extern BAS2<AS2{{{ "", 0 }, { "", 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { {}, 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { "" }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { {} }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { }}}>       bas2;
+extern BAS2<AS2{{{ "", 0 }}}>            bas2;
+extern BAS2<AS2{{{ {}, 0 }}}>            bas2;
+extern BAS2<AS2{{{ "" }}}>               bas2;
+extern BAS2<AS2{{{ {} }}}>               bas2;
+extern BAS2<AS2{{{ }}}>                  bas2;
+extern BAS2<AS2{{ }}>                    bas2;
+extern BAS2<AS2{ }>                      bas2;
+
+struct AS2_2
+{
+  struct S { const char a[2], *p; } a[2][2];
+};
+
+template <AS2_2> struct BAS2_2 { };
+
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "", 0 }}}}> b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "" }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { {} }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { }}}}>       b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 } }}}>           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "" } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { {} } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { }}}}>                  b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { }}}>                     b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 }}}}>                           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "" }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { {} }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { }}}}>                                 b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }}}}>                                      b2_2;
+extern BAS2_2<AS2_2{{{{ "" }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ {} }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ }}}}>                                            b2_2;
+extern BAS2_2<AS2_2{{{ }}}>                                              b2_2;
+extern BAS2_2<AS2_2{{ }}>                                                b2_2;
+extern BAS2_2<AS2_2{ }>                                                  b2_2;
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class24.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class24.C
new file mode 100644
index 00000000000..aa96de36a80
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class24.C
@@ -0,0 +1,19 @@
+// PR c++/92150
+// { dg-do compile { target c++2a } }
+
+struct X {
+  int value;
+  // auto operator==(const X&) = default;
+};
+
+template<typename T, X N>
+struct b;
+
+template<typename T>
+inline constexpr bool is_b = false;
+
+template<typename T, X N>
+inline constexpr bool is_b<b<T, N>> = true;
+
+using my_b = b<int, X{1}>;
+static_assert(is_b<my_b>);
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class26.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class26.C
new file mode 100644
index 00000000000..315e0ac2309
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class26.C
@@ -0,0 +1,13 @@
+// { dg-do compile { target c++2a } }
+
+struct p { unsigned p_ {}; };
+
+template <p i> struct pp {};
+struct qq : public pp <p {}> {};
+
+template <p i> int f (pp <i> const &);
+
+int main ()
+{
+  return f (qq {});
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class33.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class33.C
new file mode 100644
index 00000000000..1b9dfb88918
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class33.C
@@ -0,0 +1,36 @@
+// PR c++/90938 - Initializing array with {1} works, but not {0}
+// { dg-do compile { target c++2a } }
+// { dg-options "-Wall" }
+
+struct A { int i; };
+struct B { A a[2]; };
+
+static const constexpr A a0 = { 0 };
+static const constexpr A a_ = { };
+
+template <B> struct X { };
+
+typedef X<B{ }>             XB;
+typedef X<B{{A{ }}}>        XB;
+typedef X<B{{A{ 0 }}}>      XB;
+typedef X<B{{a_}}>          XB;
+typedef X<B{{a0}}>          XB;
+typedef X<B{{a_, A{ }}}>    XB;
+typedef X<B{{a_, A{ 0 }}}>  XB;
+typedef X<B{{a_, a_}}>      XB;
+typedef X<B{{a_, a0}}>      XB;
+
+
+struct C { constexpr C () = default; };
+struct D { C c[2]; };
+
+static const constexpr C c_ = { };
+
+template <D> struct Y { };
+
+typedef Y<D{ }>             YD;
+typedef Y<D{C { }}>         YD;
+typedef Y<D{{c_}}>          YD;
+typedef Y<D{C{ }, C{ }}>    YD;
+typedef Y<D{C{ }, c_}>      YD;
+typedef Y<D{{c_, c_}}>      YD;
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C
new file mode 100644
index 00000000000..437fa9b5ab8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate handling of failed class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+// Missing deduction guide.
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5); // { dg-error "15:no matching function for call to" }
+                                // { dg-error "15:class template argument deduction failed" "" { target *-*-* } .-1 }
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C
new file mode 100644
index 00000000000..0f56b50871b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C
@@ -0,0 +1,20 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate rejection of class template parameter packs.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string...>
+int operator"" _udl();     // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C
new file mode 100644
index 00000000000..f6877a960c9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate support for class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5);
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C
new file mode 100644
index 00000000000..b5f110bf59b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C
@@ -0,0 +1,12 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that parameter packs are rejected.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class...>
+int operator"" _udl();      // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C
new file mode 100644
index 00000000000..20e97fcc6a5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C
@@ -0,0 +1,13 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that non-literal class types are rejected.
+// { dg-do compile { target c++2a } }
+
+struct non_literal_class {
+  constexpr non_literal_class(...) { }
+  ~non_literal_class() {}
+  // auto operator<=> (const non_literal_fixed_string&) = default;
+};
+
+template <non_literal_class> // { dg-error "11:is not a valid type for a template non-type parameter because it is not literal" }
+int operator"" _udl();       // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C
new file mode 100644
index 00000000000..dcaca3e4070
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C
@@ -0,0 +1,16 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate basic support.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class>
+constexpr int operator"" _udl() {
+  return 1;
+}
+
+static_assert("test"_udl == 1);
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C
new file mode 100644
index 00000000000..6cd99cc9bb8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C
@@ -0,0 +1,12 @@
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-g -fdebug-types-section" }
+class A {
+public:
+  A();
+  template <typename U> A(U);
+};
+template <class> struct B { typedef A type; };
+template <class R, typename... Args>
+int Bind(R(Args...), typename B<Args>::type...) { return 0; }
+void KeepBufferRefs(A, A) { A a, b(Bind(KeepBufferRefs, a, b)); }
diff --git a/gcc/testsuite/g++.dg/debug/pr92763.C b/gcc/testsuite/g++.dg/debug/pr92763.C
new file mode 100644
index 00000000000..16dccf3b56f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/pr92763.C
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// { dg-require-effective-target fopenmp }
+// { dg-additional-options "-fno-var-tracking-assignments -fopenmp" }
+
+struct A
+{
+  typedef int T;
+  #pragma omp declare reduction (y : T : [&omp_out, &omp_in]() { omp_out += omp_in; return 0; }()) initializer (omp_priv = [omp_orig]() { return omp_orig; }())
+  static void foo ();
+};
+
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+  #pragma omp parallel for reduction (y : r, s)
+  for (int i = 0; i < 1; i++)
+    {
+    }
+}
diff --git a/gcc/testsuite/g++.dg/debug/verify1.C b/gcc/testsuite/g++.dg/debug/verify1.C
new file mode 100644
index 00000000000..67e407251a1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/verify1.C
@@ -0,0 +1,64 @@
+// PR c++/92601
+// { dg-additional-options "-g -fchecking -std=c++17" }
+
+typedef int size_t;
+template <typename, int __v> struct integral_constant {
+  static constexpr int value = __v;
+};
+template <typename> struct A;
+template <typename _Tp> using __remove_cv_t = typename A<_Tp>::type;
+template <typename _Tp, typename _Up>
+struct B : integral_constant<bool, __is_same_as(_Tp, _Up)> {};
+template <typename...> class tuple;
+template <typename> struct A {
+  using type = tuple<const char *, const char *>;
+};
+template <typename> struct C { typedef __remove_cv_t<int> __type; };
+template <typename _Tp> class D {
+public:
+  typedef typename C<_Tp>::__type type;
+};
+template <bool> struct enable_if;
+template <int> struct F {};
+template <typename, typename> class G {
+public:
+  int operator*();
+  void operator++();
+};
+template <typename _Iterator, typename _Container>
+bool operator!=(G<_Iterator, _Container>, G<_Iterator, _Container>);
+template <typename> class H;
+template <typename = H<tuple<const char *, const char *>>> class vector {
+public:
+  typedef G<int, vector> iterator;
+  iterator begin();
+  iterator end();
+};
+template <typename> struct pack_c { typedef pack_c type; };
+template <typename, typename> struct make_index_pack_join;
+template <size_t... Left, size_t... Right>
+struct make_index_pack_join<pack_c<size_t, Left...>, pack_c<size_t, Right...>>
+    : pack_c<size_t> {};
+template <int N>
+struct I
+    : make_index_pack_join<typename I<N / 2>::type, typename I<N / 2>::type> {};
+template <> struct I<1> : pack_c<size_t> {};
+template <typename TTuple, typename>
+struct are_tuples_compatible_not_same
+    : F<B<typename D<TTuple>::type, int>::value> {};
+template <typename...> struct tuple_impl;
+template <size_t... Is, typename... Ts>
+struct tuple_impl<pack_c<size_t, Is...>, Ts...> {
+  template <typename UTuple, typename enable_if<are_tuples_compatible_not_same<
+                                 tuple<>, UTuple>::value>::type>
+  tuple_impl(UTuple &&);
+};
+template <typename... Ts> class tuple {
+  tuple_impl<typename I<sizeof...(Ts)>::type> _impl;
+  tuple(tuple &) = default;
+};
+vector message_handler_registrations;
+void fn1() {
+  for (auto t : message_handler_registrations)
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/diagnostic/pr90767-1.C b/gcc/testsuite/g++.dg/diagnostic/pr90767-1.C
new file mode 100644
index 00000000000..7d1cd3db398
--- /dev/null
+++ b/gcc/testsuite/g++.dg/diagnostic/pr90767-1.C
@@ -0,0 +1,15 @@
+// PR c++/90767
+// { dg-do compile }
+
+struct X {
+  int n;
+  void foo ();	// { dg-message "initializing argument 'this'" }
+
+  template<typename T>
+  operator T () const
+    {
+      if (n == 0)
+	foo ();	// { dg-error "cannot convert 'const X\\*' to 'X\\*'" }
+      return n;
+    }
+};
diff --git a/gcc/testsuite/g++.dg/diagnostic/pr90767-2.C b/gcc/testsuite/g++.dg/diagnostic/pr90767-2.C
new file mode 100644
index 00000000000..550762b2db9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/diagnostic/pr90767-2.C
@@ -0,0 +1,15 @@
+// PR c++/90767
+// { dg-do compile }
+
+struct A {
+  struct B { B (int) {} };
+
+  template <typename T>
+  void foo ()
+  {
+    int x = 0;
+    bar (x);	// { dg-error "cannot convert 'int' to 'A::B&'" }
+  }
+
+  void bar (B &arg) {}	// { dg-message "initializing argument 1" }
+};
diff --git a/gcc/testsuite/g++.dg/expr/cond15.C b/gcc/testsuite/g++.dg/expr/cond15.C
new file mode 100644
index 00000000000..4a9d057a757
--- /dev/null
+++ b/gcc/testsuite/g++.dg/expr/cond15.C
@@ -0,0 +1,13 @@
+// PR c++/90393
+
+struct S {
+  S();
+  S(const S&) {}
+};
+
+S f() {
+  const S m;
+  return true ? m : throw 0;
+}
+
+int main() {}
diff --git a/gcc/testsuite/g++.dg/expr/cond16.C b/gcc/testsuite/g++.dg/expr/cond16.C
new file mode 100644
index 00000000000..796828b25c0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/expr/cond16.C
@@ -0,0 +1,25 @@
+// PR c++/90393
+// { dg-do run }
+
+int c, d;
+
+struct string {
+  string(const char *p): s(p) { ++c; }
+  ~string() { ++d; }
+  string(const string& str): s(str.s) { ++c; }
+  const char* s;
+  bool empty() const { return !s; }
+};
+    
+string foo()
+{
+  string s("foo");
+  return s.empty() ? throw "empty" : s;
+}
+
+int main()
+{
+  foo();
+  if (c != d)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/ext/attr-trailing1.C b/gcc/testsuite/g++.dg/ext/attr-trailing1.C
new file mode 100644
index 00000000000..ff3fb901ddd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attr-trailing1.C
@@ -0,0 +1,14 @@
+// PR c++/90333
+// { dg-do compile { target c++11 } }
+
+auto l = [] [[nodiscard]] () -> int { return 0; };
+auto l2 = []() -> int __attribute ((warn_unused_result)) { return 0; };
+auto f() -> int __attribute ((warn_unused_result));
+auto f() -> int { return 0; }
+
+int main()
+{
+  l();				// { dg-warning "nodiscard" }
+  l2();				// { dg-warning "unused_result" }
+  f();				// { dg-warning "unused_result" }
+}
diff --git a/gcc/testsuite/g++.dg/ext/attrib61.C b/gcc/testsuite/g++.dg/ext/attrib61.C
new file mode 100644
index 00000000000..231830616ea
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attrib61.C
@@ -0,0 +1,26 @@
+// PR c++/92438
+// { dg-do compile }
+
+typedef struct S { int x; } T;
+T (foo) (T x);
+T __attribute__((unused)) bar (T x);
+struct S (__attribute__((unused)) baz) (T x);
+T (__attribute__((unused)) qux) (T x);
+
+struct U
+{
+  U (__attribute__((unused)) int);
+  U (__attribute__((unused)) corge) (int);
+};
+
+void
+test ()
+{
+  T a, b;
+  a = foo (b);
+  b = bar (a);
+  a = baz (b);
+  b = qux (a);
+  U u (5);
+  U v = u.corge (3);
+}
diff --git a/gcc/testsuite/g++.dg/ext/builtin14.C b/gcc/testsuite/g++.dg/ext/builtin14.C
new file mode 100644
index 00000000000..38d5a39fd73
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/builtin14.C
@@ -0,0 +1,4 @@
+// PR c++/90997
+
+template<class> void f ()
+{ __builtin_memset (0, 0, int(0.)); }
diff --git a/gcc/testsuite/g++.dg/ext/flexary36.C b/gcc/testsuite/g++.dg/ext/flexary36.C
new file mode 100644
index 00000000000..5bb827cfd0e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/flexary36.C
@@ -0,0 +1,123 @@
+/* PR c++/93753 - ICE on a flexible array followed by a member in
+   an anonymous struct with an initializer
+   { dg-do compile }
+   { dg-options "-Wall -Wno-unused-variable" } */
+
+struct {
+  int a[];          // { dg-error "flexible array member '<unnamed struct>::a' not at end of 'struct<unnamed>'" }
+  int b;
+} ax;
+
+struct {
+  int a[];          // { dg-error "flexible array member '<unnamed struct>::a' not at end of 'struct<unnamed>'" }
+  int b;
+} bx = { };
+
+struct {
+  int a[];          // { dg-error "flexible array member '<unnamed struct>::a' not at end of 'struct<unnamed>'" }
+  int b;
+} cx = { 0 };
+
+struct {
+  int a[];          // { dg-error "flexible array member '<unnamed struct>::a' not at end of 'struct<unnamed>'" }
+  int b;
+} dx = { 1 };
+
+
+union {
+  int a[];          // { dg-error "flexible array member in union" }
+  int b;
+} du = { 1 };
+
+
+struct A {
+  int a[];          // { dg-error "flexible array member 'A::a' not at end of 'struct A'" }
+  int b;
+} a;
+
+struct B {
+  int a[];          // { dg-error "flexible array member 'B::a' not at end of 'struct B'" }
+  int b;
+} b = { };
+
+struct C {
+  int a[];          // { dg-error "flexible array member 'C::a' not at end of 'struct C'" }
+  int b;
+} c = { 0 };
+
+struct D {
+  int a[];          // { dg-error "flexible array member 'D::a' not at end of 'struct D'" }
+  int b;
+} d = { 1 };
+
+
+struct E {
+  struct {
+    int a[];        // { dg-error " not at end " }
+    int b;
+  } e = { 1 };      // { dg-error "non-static initialization of a flexible array member" }
+};
+
+struct G {
+  struct {
+    int a[];        // { dg-error " not at end " }
+    int b;
+  };
+} g = { 1 };        // { dg-error "initialization of flexible array member in a nested context" }
+
+struct H {
+  int i;
+  struct {
+    int a[];        // { dg-error " not at end " }
+    int b;
+  };
+} h = { 1 };
+
+namespace {
+
+struct {
+  int a[];          // { dg-error " not at end of " }
+  int b;
+} ax;
+
+struct {
+  int a[];          // { dg-error " not at end " }
+  int b;
+} bx = { };
+
+struct {
+  int a[];          // { dg-error " not at end " }
+  int b;
+} cx = { 0 };
+
+struct {
+  int a[];          // { dg-error " not at end " }
+  int b;
+} dx = { 1 };
+
+
+struct A {
+  int a[];          // { dg-error " not at end of 'struct {anonymous}::A'" }
+  int b;
+} a;
+
+struct B {
+  int a[];          // { dg-error " not at end of 'struct {anonymous}::B'" }
+  int b;
+} b = { };
+
+struct C {
+  int a[];          // { dg-error " not at end of 'struct {anonymous}::C'" }
+  int b;
+} c = { 0 };
+
+struct D {
+  int a[];          // { dg-error " not at end of 'struct {anonymous}::D'" }
+  int b;
+} d = { 1 };
+
+}
+
+// { dg-prune-output "unnamed type with no linkage used to declare variable" }
+// { dg-prune-output "non-static data member initializers" }
+// { dg-prune-output "extended initializer lists" }
diff --git a/gcc/testsuite/g++.dg/ext/is_constructible4.C b/gcc/testsuite/g++.dg/ext/is_constructible4.C
new file mode 100644
index 00000000000..6dfe3c01661
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/is_constructible4.C
@@ -0,0 +1,18 @@
+// PR c++/93286
+// { dg-do compile { target c++14 } }
+
+struct A { static const bool value = true; };
+template <bool> using __bool_constant = A;
+template <typename... _Args>
+struct B : __bool_constant<__is_constructible(int, _Args...)> {};
+template <bool> using enable_if_t = int;
+template <typename... _Args> bool is_constructible_v = B<_Args...>::value;
+class C {
+  template <typename _Tp, typename = enable_if_t<is_constructible_v<_Tp>>>
+  C(_Tp &&);
+};
+using Effect_t = C;
+void fn1(Effect_t effect) {
+  int i;
+  [](int &effect) {}(i);
+}
diff --git a/gcc/testsuite/g++.dg/ext/is_final.C b/gcc/testsuite/g++.dg/ext/is_final.C
index b3875ad04ae..20e5d629ff5 100644
--- a/gcc/testsuite/g++.dg/ext/is_final.C
+++ b/gcc/testsuite/g++.dg/ext/is_final.C
@@ -43,3 +43,17 @@ static_assert( __is_final (Ff<int>), "Ff<int> is final" );
 static_assert( __is_final (Ff<A>),   "Ff<A> is final" );
 static_assert( __is_final (Ff<Af>),  "Ff<Af> is final" );
 
+// PR 85254
+
+template <class T> struct final_trait_wrap{ typedef T type; };
+
+template <class T> struct my_is_final
+{
+  static const bool value = __is_final(typename final_trait_wrap<T>::type);
+};
+
+struct final1 final {};
+template <typename T> struct final2 final {};
+
+static_assert( my_is_final<final1>::value, "final1 is final" );
+static_assert( my_is_final<final2<int>>::value, "final2<int> is final" );
diff --git a/gcc/testsuite/g++.dg/ext/visibility/ref-temp1.C b/gcc/testsuite/g++.dg/ext/visibility/ref-temp1.C
new file mode 100644
index 00000000000..b56bb52a73c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/ref-temp1.C
@@ -0,0 +1,11 @@
+// PR c++/91476
+// Test that hidden and internal visibility propagates to reference temps.
+
+// { dg-final { scan-assembler-not "(weak|globl)\[^\n\]*_ZGRN12_GLOBAL__N_13fooE_" } }
+namespace { const int &foo = 1; }
+
+const void *volatile p;
+int main()
+{
+  p = &foo;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C b/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C
index e31c1ebecf9..e66806845b7 100644
--- a/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C
+++ b/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C
@@ -36,8 +36,6 @@ void bar(int n, float *a, float *b)
     a[i] = b[i];
 }
 
-/* { dg-final { scan-tree-dump-times "Function void omp declare reduction operator\\+" 1 "original" } } */
-/* { dg-final { scan-tree-dump-times "Function void omp declare reduction foo" 2 "original" } } */
 /* { dg-final { scan-tree-dump-times "pragma omp simd reduction\\(u\\) reduction\\(t\\) reduction\\(\\+:s\\) aligned\\(a:32\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "pragma omp simd safelen\\(64\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-not "omp parallel" "original" } } */
diff --git a/gcc/testsuite/g++.dg/gomp/pr91118-1.C b/gcc/testsuite/g++.dg/gomp/pr91118-1.C
new file mode 100644
index 00000000000..f29d69db084
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr91118-1.C
@@ -0,0 +1,12 @@
+// PR c++/91118
+// { dg-do compile }
+// { dg-additional-options "-fsanitize=undefined" }
+
+#include <iostream>
+
+void
+foo ()
+{
+#pragma omp parallel default(none) shared(std::cerr)
+  std::cerr << "hello" << std::endl;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr91118-2.C b/gcc/testsuite/g++.dg/gomp/pr91118-2.C
new file mode 100644
index 00000000000..80f1e3e45c4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr91118-2.C
@@ -0,0 +1,14 @@
+// PR c++/91118
+// { dg-do compile }
+
+#include <typeinfo>
+
+struct S { virtual ~S (); };
+void bar (const std::type_info &, const std::type_info &);
+
+void
+foo (S *p)
+{
+  #pragma omp parallel default (none) firstprivate (p)
+    bar (typeid (*p), typeid (S));
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr92504.C b/gcc/testsuite/g++.dg/gomp/pr92504.C
new file mode 100644
index 00000000000..8df67621532
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr92504.C
@@ -0,0 +1,29 @@
+// PR c++/92504
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O2" }
+
+namespace std {
+  typedef __SIZE_TYPE__ size_t;
+  typedef __PTRDIFF_TYPE__ ptrdiff_t;
+}
+
+struct A {
+  A ();
+  A (const A &);
+  A & operator++ ();
+  bool operator != (const A &) const;
+  std::ptrdiff_t operator - (const A &);
+  A & operator += (std::size_t);
+  int a;
+  A & begin ();
+  A & end ();				// { dg-message "declared here" }
+};
+
+void
+bar ()
+{
+  A a;
+  #pragma omp for
+  for (auto b = a; b != a.end; ++b)	// { dg-error "invalid use of non-static member function" }
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/init/array53.C b/gcc/testsuite/g++.dg/init/array53.C
new file mode 100644
index 00000000000..2bf480561fe
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array53.C
@@ -0,0 +1,33 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Verify that initializers for arrays of elements of a class type with
+// "unusual" data members are correctly recognized as non-zero.
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+struct S
+{
+  const char *p;
+  static int i;
+  enum { e };
+  typedef int X;
+  int: 1, b:1;
+  union {
+    int c;
+  };
+  const char *q;
+};
+
+void f (void)
+{
+  const struct S a[2] =
+    {
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" },
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" }
+    };
+
+  if (!a[0].p || *a[0].p || !a[0].q || *a[0].q
+      || !a[1].p || *a[1].p || !a[1].q || *a[1].q)
+    __builtin_abort ();
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
diff --git a/gcc/testsuite/g++.dg/init/array54.C b/gcc/testsuite/g++.dg/init/array54.C
new file mode 100644
index 00000000000..f6be350ba72
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array54.C
@@ -0,0 +1,13 @@
+// PR c++/90947
+// { dg-do run { target c++11 } }
+
+#include <atomic>
+
+static std::atomic<int> a[1] { {1} };
+
+int
+main ()
+{
+  if (a[0].load () != 1)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/init/array55.C b/gcc/testsuite/g++.dg/init/array55.C
new file mode 100644
index 00000000000..70fb183b897
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array55.C
@@ -0,0 +1,27 @@
+/* PR c++/90938 - Initializing array with {1} works, but not {0}
+   { dg-do compile { target c++11 } } */
+
+struct A
+{
+  A () = delete;
+  A (int) = delete;
+};
+
+A a_[] = { 0 };            // { dg-error "use of deleted function 'A::A\\\(int\\\)'" }
+
+A a1[1] = { 0 };           // { dg-error "use of deleted function 'A::A\\\(int\\\)'" }
+
+
+struct B
+{
+  B () = delete;
+  B (int) = delete;
+  B (long);
+};
+
+B b_[] = { 0 };            // { dg-error "use of deleted function 'B::B\\\(int\\\)'" }
+
+B b1[1] = { 0 };           // { dg-error "use of deleted function 'B::B\\\(int\\\)'" }
+
+B b2[] = { 0L };
+B b3[1] = { 0L };
diff --git a/gcc/testsuite/g++.dg/init/array56.C b/gcc/testsuite/g++.dg/init/array56.C
new file mode 100644
index 00000000000..63e16663ec1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array56.C
@@ -0,0 +1,107 @@
+/* PR c++/90938 - Initializing array with {1} works, but not {0}
+   { dg-do compile { target c++11 } }
+   { dg-options "-O -Wall -fdump-tree-optimized" } */
+
+#define assert(e)						\
+  ((e) ? (void)0						\
+   : (__builtin_printf ("assertion failed on line %i: %s\n",	\
+			__LINE__, #e),				\
+      __builtin_abort ()))
+
+namespace A {
+
+struct X
+{
+  X () = default;
+  X (int n) : n (n + 1) { }
+  int n;
+};
+
+static_assert (__is_trivial (X), "X is trivial");
+
+static void test ()
+{
+  {
+    X x[] { 0 };
+    assert (1 == x->n);
+  }
+
+  {
+    X x[1] { 0 };
+    assert (1 == x->n);                     // fails
+  }
+
+  {
+    X x[2] { 0 };
+    assert (1 == x[0].n && 0 == x[1].n);    // fails
+  }
+
+  {
+    X x[] { 1, 0 };
+    assert (2 == x[0].n && 1 == x[1].n);    // passes
+  }
+
+  {
+    X x[2] { 1, 0 };
+    assert (2 == x[0].n && 1 == x[1].n);    // fails
+  }
+}
+
+}
+
+namespace B {
+
+struct X
+{
+  X () = default;
+  X (int *p) : p (p ? p : new int (1)) { }
+  int *p;
+};
+
+static_assert (__is_trivial (X), "X is trivial");
+
+static void test ()
+{
+  X x[1] { nullptr };
+  assert (*x->p == 1);   // fails
+
+  X y[1] { 0 };
+  assert (*y->p == 1);   // fails
+}
+
+}
+
+namespace C {
+
+static const char *vector_swizzle (int vecsize, int index)
+{
+  static const char *swizzle[4][4] =
+    {
+     { ".x", ".y", ".z", ".w" },
+     { ".xy", ".yz", ".zw", nullptr },
+     { ".xyz", ".yzw", nullptr, nullptr },
+     { "", nullptr, nullptr, nullptr },
+    };
+
+  assert (vecsize >= 1 && vecsize <= 4);
+  assert (index >= 0 && index < 4);
+  assert (swizzle[vecsize - 1][index]);
+
+  return swizzle[vecsize - 1][index];
+}
+
+static void test ()
+{
+  assert (!*vector_swizzle(4, 0));
+}
+
+}
+
+int main ()
+{
+  A::test ();
+  B::test ();
+  C::test ();
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
diff --git a/gcc/testsuite/g++.dg/ipa/pr93223.C b/gcc/testsuite/g++.dg/ipa/pr93223.C
new file mode 100644
index 00000000000..87f98b5e244
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr93223.C
@@ -0,0 +1,62 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -std=gnu++14" } */
+
+template <typename Function>
+bool run(const int item_count,
+         Function && process_range,
+         const int max_parallelism,
+         int* progress = nullptr)
+{
+    if (max_parallelism <= 1)
+    {
+        if (progress == nullptr)
+        {
+            return process_range(0);
+        }
+        else
+        {
+            auto result = true;
+            for (int i = 0; i != item_count && result; ++i)
+            {
+                (*progress)++;
+                result = process_range(i);
+            }
+            return result;
+        }
+    }
+
+    if (max_parallelism > 10)
+    {
+        if (progress == nullptr)
+        {
+            return process_range(0);
+        }
+        else
+        {
+            auto result = true;
+            for (int i = 0; i != item_count && result; ++i)
+            {
+                (*progress)++;
+                result = process_range(i);
+            }
+            return result;
+        }
+    }
+    return false;
+}
+
+namespace
+{
+__attribute__((optimize(0))) bool worker_fun(const int)
+{
+    return true;
+}
+}
+
+void demo(int n)
+{
+    for (int i = 0; i < n; ++i)
+    {
+        run(n, &worker_fun, n);
+    }
+}
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
index fe880a6263b..3ec9abd9316 100644
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
@@ -1,2 +1,3 @@
+// { dg-do compile { target c++14 } }
 using namespace std::complex_literals; // { dg-error "" }
 // { dg-message "#include <complex>" "" { target *-*-* } .-1 }
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
index d9eeb4284e8..a8f27473e6d 100644
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
@@ -11,15 +11,6 @@ void test_make_shared ()
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
-template<class T>
-void test_make_unique ()
-{
-  auto p = std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
-  // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
-  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
-  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
-}
-
 std::shared_ptr<int> test_shared_ptr; // { dg-error "'shared_ptr' in namespace 'std' does not name a template type" }
 // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
 
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
index 68b208299f2..73532c82968 100644
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
@@ -13,6 +13,15 @@ void test_make_shared ()
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
+template<class T>
+void test_make_unique ()
+{
+  std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
+  // { dg-message "'std::make_unique' is only available from C\\+\\+14 onwards" "" { target *-*-* } .-1 }
+  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
+  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
+}
+
 void test_array ()
 {
   std::array a; // { dg-error "'array' is not a member of 'std'" }
diff --git a/gcc/testsuite/g++.dg/lookup/pr91826.C b/gcc/testsuite/g++.dg/lookup/pr91826.C
new file mode 100644
index 00000000000..2b313ece8a7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/pr91826.C
@@ -0,0 +1,16 @@
+// PR 91826 bogus error with aliased namespace
+
+namespace N1 { class C1; }
+namespace A1 = N1;
+class A1::C1 {}; //Ok
+
+namespace N2
+{
+  namespace N { class C2; }
+  namespace A2 = N;
+  class A2::C2 {}; // { dg_bogus "does not enclose" }
+}
+
+namespace N3 { namespace N { class C3; } }
+namespace A3 = N3::N;
+class A3::C3 {}; //Ok
diff --git a/gcc/testsuite/g++.dg/lto/pr91572_0.C b/gcc/testsuite/g++.dg/lto/pr91572_0.C
new file mode 100644
index 00000000000..95a7e9fabf5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/pr91572_0.C
@@ -0,0 +1,12 @@
+// PR lto/91572
+// { dg-lto-do link }
+// { dg-lto-options { { -O -fPIC -flto } } }
+// { dg-require-effective-target shared }
+// { dg-require-effective-target fpic }
+// { dg-extra-ld-options "-shared" }
+
+void foo (char);
+namespace N {
+  class A { A (); };
+  A::A () { asm ("" : : "g" (0)); }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr91351.C b/gcc/testsuite/g++.dg/opt/pr91351.C
new file mode 100644
index 00000000000..f793a2f1b11
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr91351.C
@@ -0,0 +1,38 @@
+// PR tree-optimization/91351
+// { dg-do run }
+// { dg-options "-O2 -fstrict-enums" }
+
+enum E { e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12,
+	 e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25 };
+
+__attribute__((noipa)) void
+foo ()
+{
+  __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+bar ()
+{
+}
+
+__attribute__((noipa)) void
+baz (E e)
+{
+  switch (e)
+    {
+    case e11:
+    case e12:
+    case e13: foo (); break;
+    case e24: break;
+    case e14:
+    case e15: break;
+    default: bar (); break;
+    }
+}
+
+int
+main ()
+{
+  baz (e3);
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr91838.C b/gcc/testsuite/g++.dg/opt/pr91838.C
new file mode 100644
index 00000000000..fdf48094ade
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr91838.C
@@ -0,0 +1,11 @@
+/* { dg-do compile { target c++11 } } */
+/* { dg-additional-options "-O2 -Wno-psabi -w" } */
+/* { dg-additional-options "-masm=att" { target i?86-*-* x86_64-*-* } } */
+
+using T = unsigned char; // or ushort
+using V [[gnu::vector_size(8)]] = T;
+V f(V x) {
+  return x >> 8 * sizeof(T);
+}
+
+/* { dg-final { scan-assembler {pxor\s+%xmm0,\s+%xmm0} { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */
diff --git a/gcc/testsuite/g++.dg/opt/pr92007.C b/gcc/testsuite/g++.dg/opt/pr92007.C
new file mode 100644
index 00000000000..9434cc929dd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr92007.C
@@ -0,0 +1,32 @@
+// PR rtl-optimization/92007
+// { dg-do compile }
+// { dg-options "-O2 -fno-tree-dominator-opts -fno-tree-forwprop --param max-cse-insns=0 -Wno-return-type -std=gnu++98 -freorder-blocks-and-partition" }
+
+void
+sb (int *);
+
+class d4 {
+public:
+  ~d4();
+  void gb ();
+  int op () { return no; }
+  int wl () { return tf; }
+  bool ee () try { gb (); } catch (...) { return false; }
+  bool b1 () { return (tf == no) ? false : ee (); }
+
+private:
+  int no, tf;
+};
+
+void
+hs (int *v9)
+{
+  d4 p6;
+
+  p6.gb ();
+  if (p6.op () > p6.wl ())
+    {
+      p6.b1 ();
+      sb (v9);
+    }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr92644.C b/gcc/testsuite/g++.dg/opt/pr92644.C
new file mode 100644
index 00000000000..2f8a86f1fdb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr92644.C
@@ -0,0 +1,6 @@
+// PR tree-optimization/92644
+// { dg-do compile { target c++14 } }
+// { dg-options "-O2 -fno-early-inlining" }
+
+inline auto foo () { return nullptr; }
+int bar () { return foo () ? 1 : 0; }
diff --git a/gcc/testsuite/g++.dg/other/i386-2.C b/gcc/testsuite/g++.dg/other/i386-2.C
index a70d9f413a6..866768787ec 100644
--- a/gcc/testsuite/g++.dg/other/i386-2.C
+++ b/gcc/testsuite/g++.dg/other/i386-2.C
@@ -1,5 +1,5 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
-/* { dg-options "-O -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt  -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
+/* { dg-options "-O -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt  -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx512vbmi2 -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
 
 /* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,
    xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,
diff --git a/gcc/testsuite/g++.dg/other/i386-3.C b/gcc/testsuite/g++.dg/other/i386-3.C
index 73eb5e74c9a..3bc880e2500 100644
--- a/gcc/testsuite/g++.dg/other/i386-3.C
+++ b/gcc/testsuite/g++.dg/other/i386-3.C
@@ -1,5 +1,5 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
-/* { dg-options "-O -fkeep-inline-functions -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
+/* { dg-options "-O -fkeep-inline-functions -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx512vbmi2 -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
 
 /* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,
    xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,
diff --git a/gcc/testsuite/g++.dg/other/pr92201.C b/gcc/testsuite/g++.dg/other/pr92201.C
new file mode 100644
index 00000000000..15ba1a12525
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/pr92201.C
@@ -0,0 +1,7 @@
+// PR c++/92201
+
+int
+foo (void (*p) ())
+{
+  return (*reinterpret_cast<int (*)()> (p)) ();
+}
diff --git a/gcc/testsuite/g++.dg/overload/bit-field1.C b/gcc/testsuite/g++.dg/overload/bit-field1.C
new file mode 100644
index 00000000000..318caaaeb65
--- /dev/null
+++ b/gcc/testsuite/g++.dg/overload/bit-field1.C
@@ -0,0 +1,18 @@
+// PR c++/92859
+// { dg-do compile { target c++11 } }
+
+void f(int) = delete;
+
+struct ES { 
+  enum E { v }; 
+  friend void f(E) { }
+};
+
+struct S {
+  ES::E e : 1; 
+};
+
+int main() {
+  S s{}; 
+  f (s.e);
+}
diff --git a/gcc/testsuite/g++.dg/parse/operator8.C b/gcc/testsuite/g++.dg/parse/operator8.C
new file mode 100644
index 00000000000..c5ee3eb934a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/operator8.C
@@ -0,0 +1,13 @@
+// PR c++/91521 - wrong error with operator->.
+// { dg-do compile }
+
+struct foo {
+	int bar() { return 0; }
+	foo* operator->() { return this; }
+};
+
+int main()
+{
+	int pt(foo()->bar());
+	return pt;
+}
diff --git a/gcc/testsuite/g++.dg/pr92022.C b/gcc/testsuite/g++.dg/pr92022.C
new file mode 100644
index 00000000000..066d984ffc5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr92022.C
@@ -0,0 +1,13 @@
+// { dg-do compile { target alpha*-*-* } }
+// { dg-options "-O1 -g -fno-var-tracking -mcpu=ev4 -mieee" }
+
+struct a {
+  a(long);
+};
+long b;
+void c() {
+  a d(1);
+  double e = b;
+  for (; b;)
+    d = e;
+}
diff --git a/gcc/testsuite/g++.dg/template/deduce4.C b/gcc/testsuite/g++.dg/template/deduce4.C
new file mode 100644
index 00000000000..e2c165dc788
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/deduce4.C
@@ -0,0 +1,17 @@
+// PR c++/90505 - mismatch in template argument deduction.
+// { dg-do compile }
+
+template <typename T>
+struct S {
+  template <typename U, typename V>
+  static void foo(V) { }
+
+  void bar () { foo<int>(10); }
+};
+
+void
+test ()
+{
+  S<int> s;
+  s.bar ();
+}
diff --git a/gcc/testsuite/g++.dg/template/deduce5.C b/gcc/testsuite/g++.dg/template/deduce5.C
new file mode 100644
index 00000000000..9d382bfe03a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/deduce5.C
@@ -0,0 +1,17 @@
+// PR c++/90505 - mismatch in template argument deduction.
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct S {
+  template <typename U, typename V = void>
+  static void foo(U) { }
+
+  void bar () { foo<int>(10); }
+};
+
+void
+test ()
+{
+  S<int> s;
+  s.bar ();
+}
diff --git a/gcc/testsuite/g++.dg/template/deduce6.C b/gcc/testsuite/g++.dg/template/deduce6.C
new file mode 100644
index 00000000000..8fee6124f5a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/deduce6.C
@@ -0,0 +1,17 @@
+// PR c++/90505 - mismatch in template argument deduction.
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct S {
+  template <typename U = int, typename V>
+  static void foo(V) { }
+
+  void bar () { foo<>(10); }
+};
+
+void
+test ()
+{
+  S<int> s;
+  s.bar ();
+}
diff --git a/gcc/testsuite/g++.dg/template/deduce7.C b/gcc/testsuite/g++.dg/template/deduce7.C
new file mode 100644
index 00000000000..fbc28e5150d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/deduce7.C
@@ -0,0 +1,10 @@
+// PR c++/90505 - mismatch in template argument deduction.
+// { dg-do compile { target c++11 } }
+
+template <typename> class a {
+  using b = int;
+  using c = int;
+  b d;
+  void e() { g<c>(d); }
+  template <typename... f> static void g(f...);
+};
diff --git a/gcc/testsuite/g++.dg/torture/pr90313.cc b/gcc/testsuite/g++.dg/torture/pr90313.cc
new file mode 100644
index 00000000000..d9f183a2939
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr90313.cc
@@ -0,0 +1,33 @@
+// { dg-do run }
+
+#include <stddef.h>
+
+namespace std {
+  template<typename T, size_t N> struct array {
+    T elems[N];
+    const T &operator[](size_t i) const { return elems[i]; }
+  };
+}
+
+using Coordinates = std::array<double, 3>;
+
+Coordinates map(const Coordinates &c, size_t level)
+{
+  Coordinates result{ c[1], c[2], c[0] };
+
+  if (level != 0)
+    result = map (result, level - 1);
+
+  return result;
+}
+
+int main()
+{
+  Coordinates vecOfCoordinates = { 1.0, 2.0, 3.0 };
+
+  auto result = map(vecOfCoordinates, 1);
+  if (result[0] != 3 || result[1] != 1 || result[2] != 2)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr91155.C b/gcc/testsuite/g++.dg/torture/pr91155.C
new file mode 100644
index 00000000000..04e4f7ab41b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr91155.C
@@ -0,0 +1,18 @@
+/* PR c++/91155.  */
+
+template< char C > struct dummy {};
+
+template< typename T > const char *test()
+{
+  __builtin_printf ("test: %s\n", __PRETTY_FUNCTION__);
+  return __PRETTY_FUNCTION__;
+}
+
+int main()
+{
+    if (__builtin_strcmp ("const char* test() [with T = dummy<\'\\000\'>]", test< dummy< '\0' > > ()) != 0)
+    {};//      __builtin_abort ();
+    if (__builtin_strcmp ("const char* test() [with T = dummy<\'\\\'\'>]", test< dummy< '\'' > > ()) != 0)
+    {};//      __builtin_abort ();
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr91355.C b/gcc/testsuite/g++.dg/torture/pr91355.C
new file mode 100644
index 00000000000..7a385dc5bdd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr91355.C
@@ -0,0 +1,28 @@
+// PR tree-optimization/91355
+// { dg-do run }
+// { dg-options "-std=c++14" }
+
+unsigned int d = 0;
+
+struct S {
+  S () { d++; }
+  S (const S &) { d++; }
+  ~S () { d--; }
+};
+
+void
+foo (int i) throw (int) // { dg-warning "dynamic exception specifications are deprecated" }
+{
+  if (i == 0)
+    throw 3;
+  S d;
+  throw 3;
+}
+
+int
+main ()
+{
+  try { foo (1); } catch (...) {}
+  if (d)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr91606.C b/gcc/testsuite/g++.dg/torture/pr91606.C
new file mode 100644
index 00000000000..37a05a5e3a5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr91606.C
@@ -0,0 +1,109 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fstrict-aliasing" } */
+
+#include <cstdlib>
+#include <array>
+#include <type_traits>
+
+template <typename T1, typename T2>
+struct variant
+{
+  constexpr variant(T1 arg)
+      : f1(arg),
+      index(0)
+  {}
+
+  constexpr variant(T2 arg)
+      : f2(arg),
+      index(1)
+  {}
+
+  union
+    {
+      T1 f1;
+      T2 f2;
+    };
+  std::size_t index = 0;
+};
+
+template <typename T1, typename T2>
+constexpr const T1* get_if(const variant<T1, T2>* v)
+{
+  if (v->index != 0)
+    {
+      return nullptr;
+    }
+  return &v->f1;
+}
+
+template <typename T2, typename T1>
+constexpr const T2* get_if(const variant<T1, T2>* v)
+{
+  if (v->index != 1)
+    {
+      return nullptr;
+    }
+  return &v->f2;
+}
+
+template <typename T, size_t N>
+struct my_array
+{
+  constexpr const T* begin() const
+    {
+      return data;
+    }
+
+  constexpr const T* end() const
+    {
+      return data + N;
+    }
+
+  T data[N];
+};
+
+template <typename ...Ts>
+constexpr auto get_array_of_variants(Ts ...ptrs)
+{
+  return std::array<variant<std::decay_t<Ts>...>, sizeof...(Ts)>{ ptrs... };
+}
+
+template <typename T>
+constexpr auto get_member_functions();
+
+template <typename Member, typename Class>
+constexpr int getFuncId(Member (Class::*memFuncPtr))
+{
+  int idx = 0u;
+  for (auto &anyFunc : get_member_functions<Class>())
+    {
+      if (auto *specificFunc = get_if<Member (Class::*)>(&anyFunc))
+	{
+	  if (*specificFunc == memFuncPtr)
+	    {
+	      return idx;
+	    }
+	}
+      ++idx;
+    }
+  std::abort();
+}
+
+struct MyStruct
+{
+  void fun1(int /*a*/) {}
+
+  int fun2(char /*b*/, short /*c*/, bool /*d*/) { return 0; }
+
+};
+
+template <>
+constexpr auto get_member_functions<MyStruct>()
+{
+  return get_array_of_variants(&MyStruct::fun1, &MyStruct::fun2);
+}
+
+int main()
+{
+  return getFuncId(&MyStruct::fun1);
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr92384.C b/gcc/testsuite/g++.dg/torture/pr92384.C
new file mode 100644
index 00000000000..049a45a0154
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr92384.C
@@ -0,0 +1,38 @@
+// PR c++/92384
+// { dg-do run }
+
+struct S {};
+struct T : public S { S a, b, c, d, e, f, g, h, i, j, k, l, m; };
+struct U { long long a, b, c; };
+
+U
+foo (S, S, S, T, T, T, U g)
+{
+  return g;
+}
+
+__attribute__((noipa)) bool
+bar (S a, S b, S c, T d, T e, T f, U g, void **h)
+{
+  h[0] = (void *) &a;
+  h[1] = (void *) &b;
+  h[2] = (void *) &c;
+  h[3] = (void *) &d;
+  h[4] = (void *) &e;
+  h[5] = (void *) &f;
+  h[6] = (void *) &g;
+  asm volatile ("" : : "r" (h) : "memory");
+  return (h[0] != h[1] && h[1] != h[2] && h[2] != h[3]
+	  && h[3] != h[4] && h[4] != h[5] && h[5] != h[6]);
+}
+
+int
+main ()
+{
+  S a;
+  T b;
+  U c = { 1, 2, 3 };
+  void *d[7];
+  if (!bar (a, a, a, b, b, b, c, d))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr93246.C b/gcc/testsuite/g++.dg/torture/pr93246.C
new file mode 100644
index 00000000000..4c523443175
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr93246.C
@@ -0,0 +1,31 @@
+// { dg-do run }
+// { dg-additional-options "-fstrict-aliasing" }
+
+template <typename = void> struct Optional {
+  auto is_present() const { const bool &p = inner.present; return p; }
+  auto set_present() { if (not is_present()) inner.present = true; }
+  struct InnerType {
+    bool present = false;
+    char padding[1] = {0};
+  };
+  using inner_t = InnerType;
+  inner_t inner = {};
+};
+
+template <typename WrappedType> struct Wrapper {
+  auto operator-> () { return value; }
+  WrappedType *value;
+};
+
+void __attribute__((noipa)) foo(Optional<>& x) {}
+
+int main()
+{
+  Optional<> buf{};
+  foo(buf);
+  Wrapper<Optional<>> wo = {&buf};
+  wo->set_present();
+  auto x = wo->is_present();
+  if (!x)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C b/gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C
new file mode 100644
index 00000000000..ff384164901
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C
@@ -0,0 +1,18 @@
+// PR c++/87519 - bogus warning with -Wsign-conversion.
+// { dg-options "-Wsign-conversion" }
+
+typedef unsigned long int uint64_t;
+
+void f(unsigned long int a, int q)
+{
+  a += a + q; // { dg-warning "may change the sign" }
+
+  // Explicit cast should disable the warning.
+  a = a + static_cast<uint64_t>(q);
+  a = a + (uint64_t) q;
+  a = a + uint64_t(q);
+  a = a + static_cast<const uint64_t>(q);
+  a = a + (const uint64_t) q;
+  a = a + static_cast<unsigned long int>(q);
+  a = a + static_cast<const unsigned long int>(q);
+}
diff --git a/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C b/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C
new file mode 100644
index 00000000000..fcad34e000c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C
@@ -0,0 +1,5 @@
+// PR c++/90884
+// { dg-options "-Wctor-dtor-privacy" }
+// { dg-prune-output "In file included from" }
+
+#include "ctor-dtor-privacy-4.h"  // { dg-bogus "is public" }
diff --git a/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h b/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h
new file mode 100644
index 00000000000..d67fd26943e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h
@@ -0,0 +1,7 @@
+#pragma GCC system_header
+
+namespace std {
+struct __nonesuch {
+  __nonesuch(__nonesuch const &);
+};
+} // namespace std
diff --git a/gcc/testsuite/g++.dg/warn/inline3.C b/gcc/testsuite/g++.dg/warn/inline3.C
new file mode 100644
index 00000000000..0d4dc8ff268
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/inline3.C
@@ -0,0 +1,20 @@
+struct S {
+  inline virtual void foo () = 0;	// { dg-bogus "used but never defined" }
+#if __cplusplus > 201703L
+  constexpr virtual void bar () = 0;	// { dg-bogus "used but never defined" "" { target c++2a } }
+#else
+  inline virtual void bar () = 0;	// { dg-bogus "used but never defined" "" { target c++17_down }  }
+#endif
+  S () {}
+};
+struct T : public S {
+  inline virtual void foo () {}
+#if __cplusplus > 201703L
+  constexpr virtual void bar () {}
+#else
+  inline virtual void bar () {}
+#endif
+  T () {}
+};
+T t;
+void foo (S *s) { s->foo (); s->bar (); }
diff --git a/gcc/testsuite/g++.target/i386/pr85334-1.C b/gcc/testsuite/g++.target/i386/pr85334-1.C
new file mode 100644
index 00000000000..3c5ccad1714
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr85334-1.C
@@ -0,0 +1,55 @@
+// { dg-do run }
+// { dg-require-effective-target cet }
+// { dg-additional-options "-fexceptions -fnon-call-exceptions -fcf-protection" }
+
+// Delta between numbers of call stacks of pr85334-1.C and pr85334-2.C is 1.
+
+#include <signal.h>
+#include <stdlib.h>
+
+void sighandler (int signo, siginfo_t * si, void * uc)
+{
+  throw (5);
+}
+
+char *
+__attribute ((noinline, noclone))
+dosegv ()
+{    
+  * ((volatile int *)0) = 12;
+  return 0;
+}
+
+int
+__attribute ((noinline, noclone))
+func2 ()
+{
+  try {
+    dosegv ();
+  }
+  catch (int x) {
+    return (x != 5);
+  }
+  return 1;
+}
+
+int
+__attribute ((noinline, noclone))
+func1 ()
+{
+  return func2 ();
+}
+
+int main ()
+{
+  struct sigaction sa;
+  int status;
+
+  sa.sa_sigaction = sighandler;
+  sa.sa_flags = SA_SIGINFO;
+    
+  status = sigaction (SIGSEGV, & sa, NULL);
+  status = sigaction (SIGBUS, & sa, NULL);
+
+  return func1 ();
+}
diff --git a/gcc/testsuite/g++.target/i386/pr85334-2.C b/gcc/testsuite/g++.target/i386/pr85334-2.C
new file mode 100644
index 00000000000..e2b5afe78cb
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr85334-2.C
@@ -0,0 +1,48 @@
+// { dg-do run }
+// { dg-require-effective-target cet }
+// { dg-additional-options "-fexceptions -fnon-call-exceptions -fcf-protection" }
+
+// Delta between numbers of call stacks of pr85334-1.C and pr85334-2.C is 1.
+
+#include <signal.h>
+#include <stdlib.h>
+
+void sighandler (int signo, siginfo_t * si, void * uc)
+{
+  throw (5);
+}
+
+char *
+__attribute ((noinline, noclone))
+dosegv ()
+{    
+  * ((volatile int *)0) = 12;
+  return 0;
+}
+
+int
+__attribute ((noinline, noclone))
+func1 ()
+{
+  try {
+    dosegv ();
+  }
+  catch (int x) {
+    return (x != 5);
+  }
+  return 1;
+}
+
+int main ()
+{
+  struct sigaction sa;
+  int status;
+
+  sa.sa_sigaction = sighandler;
+  sa.sa_flags = SA_SIGINFO;
+    
+  status = sigaction (SIGSEGV, & sa, NULL);
+  status = sigaction (SIGBUS, & sa, NULL);
+
+  return func1 ();
+}
diff --git a/gcc/testsuite/g++.target/i386/pr94046-1.C b/gcc/testsuite/g++.target/i386/pr94046-1.C
new file mode 100644
index 00000000000..f2d472442d7
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr94046-1.C
@@ -0,0 +1,55 @@
+// PR target/94046
+// { dg-do compile }
+// { dg-options "-O2 -mavx2 -mxop" }
+
+#include <x86intrin.h>
+
+#define S(x) struct x { operator __##x (); };
+S (m128)
+S (m128d)
+S (m128i)
+S (m256)
+S (m256d)
+S (m256i)
+
+__m128
+f1 (m128 src, float const *base, m128i idx, m128 mask)
+{
+  return _mm_mask_i32gather_ps (src, base, idx, mask, 2);
+}
+
+__m256
+f2 (m256 src, float const *base, m256i idx, m256 mask)
+{
+  return _mm256_mask_i32gather_ps (src, base, idx, mask, 2);
+}
+
+__m128
+f3 (m128 src, float const *base, m128i idx, m128 mask)
+{
+  return _mm_mask_i64gather_ps (src, base, idx, mask, 2);
+}
+
+__m128d
+f4 (m128d x, m128d y, m128i c)
+{
+  return _mm_permute2_pd (x, y, c, 3);
+}
+
+__m128
+f5 (m128 x, m128 y, m128i c)
+{
+  return _mm_permute2_ps (x, y, c, 3);
+}
+
+__m256d
+f6 (m256d x, m256d y, m256i c)
+{
+  return _mm256_permute2_pd (x, y, c, 3);
+}
+
+__m256
+f7 (m256 x, m256 y, m256i c)
+{
+  return _mm256_permute2_ps (x, y, c, 3);
+}
diff --git a/gcc/testsuite/g++.target/i386/pr94046-2.C b/gcc/testsuite/g++.target/i386/pr94046-2.C
new file mode 100644
index 00000000000..abc8c3ee1ec
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr94046-2.C
@@ -0,0 +1,5 @@
+// PR target/94046
+// { dg-do compile }
+// { dg-options "-O0 -mavx2 -mxop" }
+
+#include "pr94046-1.C"
diff --git a/gcc/testsuite/gcc.c-torture/compile/20191108-1.c b/gcc/testsuite/gcc.c-torture/compile/20191108-1.c
new file mode 100644
index 00000000000..7929751bb06
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/20191108-1.c
@@ -0,0 +1,14 @@
+/* PR target/92095 */
+/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */
+
+typedef union {
+  double a;
+  int b[2];
+} c;
+
+double d(int e)
+{
+  c f;
+  (&f)->b[0] = 15728640;
+  return e ? -(&f)->a : (&f)->a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr90840.c b/gcc/testsuite/gcc.c-torture/compile/pr90840.c
new file mode 100644
index 00000000000..94a6f3f4baf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr90840.c
@@ -0,0 +1,19 @@
+/* PR middle-end/90840 */
+struct S { long long a; int b; };
+struct S foo (void);
+struct __attribute__((packed)) T { long long a; char b; };
+struct T baz (void);
+
+void
+bar (void)
+{
+  _Complex long double c;
+  *(struct S *) &c = foo ();
+}
+
+void
+qux (void)
+{
+  _Complex long double c;
+  *(struct T *) &c = baz ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr91001.c b/gcc/testsuite/gcc.c-torture/compile/pr91001.c
new file mode 100644
index 00000000000..4b6a017c860
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr91001.c
@@ -0,0 +1,31 @@
+/* PR middle-end/91001 */
+/* PR middle-end/91105 */
+/* PR middle-end/91106 */
+
+struct __attribute__((packed)) S { short b; char c; };
+struct T { short b, c, d; };
+struct __attribute__((packed)) R { int b; char c; };
+union __attribute__((aligned(128), transparent_union)) U { struct S c; } u;
+union __attribute__((aligned(32), transparent_union)) V { struct T c; } v;
+union __attribute__((aligned(32), transparent_union)) W { struct R c; } w;
+void foo (union U);
+void bar (union V);
+void baz (union W);
+
+void
+qux (void)
+{
+  foo (u);
+}
+
+void
+quux (void)
+{
+  bar (v);
+}
+
+void
+corge (void)
+{
+  baz (w);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr92056.c b/gcc/testsuite/gcc.c-torture/compile/pr92056.c
new file mode 100644
index 00000000000..d04da763e15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr92056.c
@@ -0,0 +1,18 @@
+/* PR tree-optimization/92056 */
+
+const char *d;
+
+void
+foo (int c, char *e, const char *a, const char *b)
+{
+  switch (c)
+    {
+    case 33:
+      for (;; d++)
+        if (__builtin_strcmp (b ? : "", d))
+          return;
+      break;
+    case 4:
+      __builtin_sprintf (e, a);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr92231.c b/gcc/testsuite/gcc.c-torture/compile/pr92231.c
new file mode 100644
index 00000000000..1813add63c6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr92231.c
@@ -0,0 +1,9 @@
+/* PR middle-end/92231 */
+
+extern int bar (void);
+
+int
+foo (void)
+{
+  return (&bar + 4096) ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr93333.c b/gcc/testsuite/gcc.c-torture/compile/pr93333.c
new file mode 100644
index 00000000000..801959bea75
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr93333.c
@@ -0,0 +1,10 @@
+/* PR target/93333 */
+
+unsigned
+foo (int b, int c, int d, unsigned long e, int x, int y, int g, int h,
+     unsigned i)
+{
+  e >>= b;
+  i >>= e & 31;
+  return i & 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr93335.c b/gcc/testsuite/gcc.c-torture/compile/pr93335.c
new file mode 100644
index 00000000000..c6e984cc6fe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr93335.c
@@ -0,0 +1,98 @@
+/* PR target/93335 */
+/* { dg-do compile { target int128 } } */
+
+int
+f1 (unsigned int x)
+{
+  return __builtin_sub_overflow_p (x, 4096, (unsigned __int128) 0);
+}
+
+int
+f2 (unsigned int x)
+{
+  return __builtin_sub_overflow_p (x, 4097, (unsigned __int128) 0);
+}
+
+int
+f3 (int x)
+{
+  return __builtin_sub_overflow_p (x, 4096, (__int128) 0);
+}
+
+int
+f4 (int x)
+{
+  return __builtin_sub_overflow_p (x, 4097, (__int128) 0);
+}
+
+int
+f5 (unsigned int x)
+{
+  return __builtin_sub_overflow_p (x, -4096, (unsigned __int128) 0);
+}
+
+int
+f6 (unsigned int x)
+{
+  return __builtin_sub_overflow_p (x, -4097, (unsigned __int128) 0);
+}
+
+int
+f7 (int x)
+{
+  return __builtin_sub_overflow_p (x, -4096, (__int128) 0);
+}
+
+int
+f8 (int x)
+{
+  return __builtin_sub_overflow_p (x, -4097, (__int128) 0);
+}
+
+int
+f9 (unsigned int x)
+{
+  return __builtin_add_overflow_p (x, 4096, (unsigned __int128) 0);
+}
+
+int
+f10 (unsigned int x)
+{
+  return __builtin_add_overflow_p (x, 4097, (unsigned __int128) 0);
+}
+
+int
+f11 (int x)
+{
+  return __builtin_add_overflow_p (x, 4096, (__int128) 0);
+}
+
+int
+f12 (int x)
+{
+  return __builtin_add_overflow_p (x, 4097, (__int128) 0);
+}
+
+int
+f13 (unsigned int x)
+{
+  return __builtin_add_overflow_p (x, -4096, (unsigned __int128) 0);
+}
+
+int
+f14 (unsigned int x)
+{
+  return __builtin_add_overflow_p (x, -4097, (unsigned __int128) 0);
+}
+
+int
+f15 (int x)
+{
+  return __builtin_add_overflow_p (x, -4096, (__int128) 0);
+}
+
+int
+f16 (int x)
+{
+  return __builtin_add_overflow_p (x, -4097, (__int128) 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr93348-1.c b/gcc/testsuite/gcc.c-torture/compile/pr93348-1.c
new file mode 100644
index 00000000000..d2edec565ee
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr93348-1.c
@@ -0,0 +1,5 @@
+int
+ya (void)
+{
+  return (long int) (1 / 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr93505.c b/gcc/testsuite/gcc.c-torture/compile/pr93505.c
new file mode 100644
index 00000000000..0627962eae5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr93505.c
@@ -0,0 +1,15 @@
+/* PR middle-end/93505 */
+
+unsigned a;
+
+unsigned
+foo (unsigned x)
+{
+  unsigned int y = 32 - __builtin_bswap64 (-a);
+  /* This would be UB (x << 32) at runtime.  Ensure we don't
+     invoke UB in the compiler because of that (visible with
+     bootstrap-ubsan).  */
+  x = x << y | x >> (-y & 31);
+  x >>= 31;
+  return x;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr93949.c b/gcc/testsuite/gcc.c-torture/compile/pr93949.c
new file mode 100644
index 00000000000..bbda0209802
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr93949.c
@@ -0,0 +1,7 @@
+/* PR c/93949 */
+
+void
+foo (void)
+{
+  register const double d[3] = { 0., 1., 2. };
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190820-1.c b/gcc/testsuite/gcc.c-torture/execute/20190820-1.c
new file mode 100644
index 00000000000..6a06eff7571
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20190820-1.c
@@ -0,0 +1,111 @@
+/* PR rtl-optimization/91347 */
+/* Reported by John David Anglin <danglin@gcc.gnu.org> */
+
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+typedef _Bool bool;
+typedef s32 int32_t;
+typedef u32 uint32_t;
+typedef u64 uint64_t;
+
+char hex_asc_upper[16];
+u16 decpair[100];
+
+static __attribute__ ((noipa)) void
+put_dec_full4 (char *buf, unsigned r)
+{
+ unsigned q;
+ q = (r * 0x147b) >> 19;
+ *((u16 *)buf) = decpair[r - 100*q];
+ buf += 2;
+ *((u16 *)buf) = decpair[q];
+}
+
+static __attribute__ ((noipa)) unsigned
+put_dec_helper4 (char *buf, unsigned x)
+{
+  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
+  put_dec_full4(buf, x - q * 10000);
+  return q;
+}
+
+static __attribute__ ((noipa)) char *
+put_dec (char *buf, unsigned long long n)
+{
+ uint32_t d3, d2, d1, q, h;
+ d1 = ((uint32_t)n >> 16);
+ h = (n >> 32);
+ d2 = (h ) & 0xffff;
+ d3 = (h >> 16);
+ q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
+ q = put_dec_helper4(buf, q);
+ q += 7671 * d3 + 9496 * d2 + 6 * d1;
+ q = put_dec_helper4(buf+4, q);
+ q += 4749 * d3 + 42 * d2;
+ q = put_dec_helper4(buf+8, q);
+ return buf;
+}
+
+struct printf_spec {
+ unsigned int type:8;
+ signed int field_width:24;
+ unsigned int flags:8;
+ unsigned int base:8;
+ signed int precision:16;
+} __attribute__((__packed__));
+
+static __attribute__ ((noipa)) char *
+number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
+{
+
+ char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
+ char sign;
+ char locase;
+ int need_pfx = ((spec.flags & 64) && spec.base != 10);
+ int i;
+ bool is_zero = num == 0LL;
+ int field_width = spec.field_width;
+ int precision = spec.precision;
+
+ i = 0;
+ if (num < spec.base)
+  tmp[i++] = hex_asc_upper[num] | locase;
+ else if (spec.base != 10) {
+  int mask = spec.base - 1;
+  int shift = 3;
+  if (spec.base == 16)
+   shift = 4;
+  else
+    __builtin_abort ();
+  do {
+   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
+   num >>= shift;
+  } while (num);
+ } else {
+  i = put_dec(tmp, num) - tmp;
+ }
+ return buf;
+}
+
+static __attribute__ ((noipa)) char *
+pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
+{
+ spec.base = 16;
+ spec.flags = 0;
+ return number(buf, end, 100, spec);
+}
+
+int
+main (void)
+{
+  struct printf_spec spec;
+  char *s = pointer_string (0, 0, 0, spec);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190901-1.c b/gcc/testsuite/gcc.c-torture/execute/20190901-1.c
new file mode 100644
index 00000000000..c78715ef2c1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20190901-1.c
@@ -0,0 +1,36 @@
+/* PR target/91472 */
+/* Reported by John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de> */
+
+typedef unsigned int gmp_uint_least32_t;
+
+union ieee_double_extract
+{
+  struct
+    {
+      gmp_uint_least32_t sig:1;
+      gmp_uint_least32_t exp:11;
+      gmp_uint_least32_t manh:20;
+      gmp_uint_least32_t manl:32;
+    } s;
+  double d;
+};
+
+double __attribute__((noipa))
+tests_infinity_d (void)
+{
+  union ieee_double_extract x;
+  x.s.exp = 2047;
+  x.s.manl = 0;
+  x.s.manh = 0;
+  x.s.sig = 0;
+  return x.d;
+}
+
+int
+main (void)
+{
+  double x = tests_infinity_d ();
+  if (x == 0.0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20191023-1.c b/gcc/testsuite/gcc.c-torture/execute/20191023-1.c
new file mode 100644
index 00000000000..3811ebca151
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20191023-1.c
@@ -0,0 +1,73 @@
+/* PR tree-optimization/92131 */
+/* Testcase by Armin Rigo <arigo@tunes.org> */
+
+long b, c, d, e, f, i;
+char g, h, j, k;
+int *aa;
+
+static void error (void) __attribute__((noipa));
+static void error (void) { __builtin_abort(); }
+
+static void see_me_here (void) __attribute__((noipa));
+static void see_me_here (void) {}
+
+static void aaa (void) __attribute__((noipa));
+static void aaa (void) {}
+
+static void a (void) __attribute__((noipa));
+static void a (void) {
+  long am, ao;
+  if (aa == 0) {
+    aaa();
+    if (j)
+      goto ay;
+  }
+  return;
+ay:
+  aaa();
+  if (k) {
+    aaa();
+    goto az;
+  }
+  return;
+az:
+  if (i)
+    if (g)
+      if (h)
+        if (e)
+          goto bd;
+  return;
+bd:
+  am = 0;
+  while (am < e) {
+    switch (c) {
+    case 8:
+      goto bh;
+    case 4:
+      return;
+    }
+  bh:
+    if (am >= 0)
+      b = -am;
+    ao = am + b;
+    f = ao & 7;
+    if (f == 0)
+      see_me_here();
+    if (ao >= 0)
+      am++;
+    else
+      error();
+  }
+}
+
+int main (void)
+{
+    j++;
+    k++;
+    i++;
+    g++;
+    h++;
+    e = 1;
+    a();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr90311.c b/gcc/testsuite/gcc.c-torture/execute/pr90311.c
new file mode 100644
index 00000000000..af8cde6d0f0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr90311.c
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/90311 */
+
+int a, b;
+
+int
+main ()
+{
+  unsigned long long x;
+  unsigned int c;
+  __builtin_add_overflow ((unsigned char) a, b, &c);
+  b -= c < (unsigned char) a;
+  x = b;
+  if (x)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c b/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c
new file mode 100644
index 00000000000..9aafc5f791a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c
@@ -0,0 +1,88 @@
+/* PR middle-end/91450 */
+
+__attribute__((noipa)) unsigned long long
+foo (int a, int b)
+{
+  unsigned long long r;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+bar (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+baz (int a, int b)
+{
+  unsigned long long r;
+  if (b >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+qux (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return 0;
+  if (b < 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+quux (int a, int b)
+{
+  unsigned long long r;
+  if (a < 0)
+    return 0;
+  if (b >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+int
+main ()
+{
+  if (foo (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (foo (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (bar (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (baz (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (qux (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (quux (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (foo (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (foo (1, -2) != -2ULL)
+    __builtin_abort ();
+  if (bar (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (baz (1, -2) != -2ULL)
+    __builtin_abort ();
+  if (qux (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (quux (1, -2) != -2ULL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c b/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c
new file mode 100644
index 00000000000..bfaabbb5ac6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c
@@ -0,0 +1,76 @@
+/* PR middle-end/91450 */
+
+__attribute__((noipa)) void
+foo (int a, int b)
+{
+  unsigned long long r;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+bar (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+baz (int a, int b)
+{
+  unsigned long long r;
+  if (b >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+qux (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return;
+  if (b < 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+quux (int a, int b)
+{
+  unsigned long long r;
+  if (a < 0)
+    return;
+  if (b >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (-4, 0);
+  foo (0, -4);
+  foo (0, 0);
+  bar (-4, 0);
+  baz (0, -4);
+  qux (-4, 0);
+  quux (0, -4);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91597.c b/gcc/testsuite/gcc.c-torture/execute/pr91597.c
new file mode 100644
index 00000000000..6a917cb58af
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91597.c
@@ -0,0 +1,48 @@
+/* PR tree-optimization/91597 */
+
+enum E { A, B, C };
+struct __attribute__((aligned (4))) S { enum E e; };
+
+enum E
+foo (struct S *o)
+{
+  if (((__UINTPTR_TYPE__) (o) & 1) == 0)
+    return o->e;
+  else
+    return A;
+}
+
+int
+bar (struct S *o)
+{
+  return foo (o) == B || foo (o) == C;
+}
+
+static inline void
+baz (struct S *o, int d)
+{
+  if (__builtin_expect (!bar (o), 0))
+    __builtin_abort ();
+  if (d > 2) return;
+  baz (o, d + 1);
+}
+
+void
+qux (struct S *o)
+{
+  switch (o->e)
+    {
+    case A: return;
+    case B: baz (o, 0); break;
+    case C: baz (o, 0); break;
+    }
+}
+
+struct S s = { C };
+
+int
+main ()
+{
+  qux (&s);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91632.c b/gcc/testsuite/gcc.c-torture/execute/pr91632.c
new file mode 100644
index 00000000000..c16c3da4efd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91632.c
@@ -0,0 +1,30 @@
+/* PR tree-optimization/91632 */
+/* { dg-additional-options "-fwrapv" } */
+
+static int
+__attribute__((noipa))
+foo (char x)
+{
+  switch (x)
+    {
+    case '"':
+    case '<':
+    case '>':
+    case '\\':
+    case '^':
+    case '`':
+    case '{':
+    case '|':
+    case '}':
+      return 0;
+    }
+  return 1;
+}
+
+int
+main ()
+{
+  if (foo ('h') == 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91635.c b/gcc/testsuite/gcc.c-torture/execute/pr91635.c
new file mode 100644
index 00000000000..878a491fc36
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91635.c
@@ -0,0 +1,57 @@
+/* PR target/91635 */
+
+#if __CHAR_BIT__ == 8 && __SIZEOF_SHORT__ == 2 \
+    && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
+unsigned short b, c;
+int u, v, w, x;
+
+__attribute__ ((noipa)) int
+foo (unsigned short c)
+{
+  c <<= __builtin_add_overflow (-c, -1, &b);
+  c >>= 1;
+  return c;
+}
+
+__attribute__ ((noipa)) int
+bar (unsigned short b)
+{
+  b <<= -14 & 15;
+  b = b >> -~1;
+  return b;
+}
+
+__attribute__ ((noipa)) int
+baz (unsigned short e)
+{
+  e <<= 1;
+  e >>= __builtin_add_overflow (8719476735, u, &v);
+  return e;
+}
+
+__attribute__ ((noipa)) int
+qux (unsigned int e)
+{
+  c = ~1;
+  c *= e;
+  c = c >> (-15 & 5);
+  return c + w + x;
+}
+#endif
+
+int
+main ()
+{
+#if __CHAR_BIT__ == 8 && __SIZEOF_SHORT__ == 2 \
+    && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
+  if (foo (0xffff) != 0x7fff)
+    __builtin_abort ();
+  if (bar (5) != 5)
+    __builtin_abort ();
+  if (baz (~0) != 0x7fff)
+    __builtin_abort ();
+  if (qux (2) != 0x7ffe)
+    __builtin_abort ();
+#endif
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr92904.c b/gcc/testsuite/gcc.c-torture/execute/pr92904.c
new file mode 100644
index 00000000000..25cb0b8c595
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr92904.c
@@ -0,0 +1,395 @@
+/* PR target/92904 */
+
+#include <stdarg.h>
+
+struct S { long long a, b; };
+struct __attribute__((aligned (16))) T { long long a, b; };
+struct U { double a, b, c, d; };
+struct __attribute__((aligned (32))) V { double a, b, c, d; };
+struct W { double a; long long b; };
+struct __attribute__((aligned (16))) X { double a; long long b; };
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+__int128 b;
+#endif
+struct S c;
+struct T d;
+struct U e;
+struct V f;
+struct W g;
+struct X h;
+
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+__attribute__((noipa)) __int128
+f1 (int x, ...)
+{
+  __int128 r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  r = va_arg (ap, __int128);
+  va_end (ap);
+  return r;
+}
+#endif
+
+__attribute__((noipa)) struct S
+f2 (int x, ...)
+{
+  struct S r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  r = va_arg (ap, struct S);
+  va_end (ap);
+  return r;
+}
+
+__attribute__((noipa)) struct T
+f3 (int x, ...)
+{
+  struct T r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  r = va_arg (ap, struct T);
+  va_end (ap);
+  return r;
+}
+
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+__attribute__((noipa)) void
+f4 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  b = va_arg (ap, __int128);
+  va_end (ap);
+}
+#endif
+
+__attribute__((noipa)) void
+f5 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  c = va_arg (ap, struct S);
+  va_end (ap);
+}
+
+__attribute__((noipa)) void
+f6 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, int);
+  d = va_arg (ap, struct T);
+  va_end (ap);
+}
+
+__attribute__((noipa)) struct U
+f7 (int x, ...)
+{
+  struct U r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, double);
+  r = va_arg (ap, struct U);
+  va_end (ap);
+  return r;
+}
+
+__attribute__((noipa)) struct V
+f8 (int x, ...)
+{
+  struct V r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, double);
+  r = va_arg (ap, struct V);
+  va_end (ap);
+  return r;
+}
+
+__attribute__((noipa)) void
+f9 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, double);
+  e = va_arg (ap, struct U);
+  va_end (ap);
+}
+
+__attribute__((noipa)) void
+f10 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    va_arg (ap, double);
+  f = va_arg (ap, struct V);
+  va_end (ap);
+}
+
+__attribute__((noipa)) struct W
+f11 (int x, ...)
+{
+  struct W r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    {
+      va_arg (ap, int);
+      va_arg (ap, double);
+    }
+  r = va_arg (ap, struct W);
+  va_end (ap);
+  return r;
+}
+
+__attribute__((noipa)) struct X
+f12 (int x, ...)
+{
+  struct X r;
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    {
+      va_arg (ap, int);
+      va_arg (ap, double);
+    }
+  r = va_arg (ap, struct X);
+  va_end (ap);
+  return r;
+}
+
+__attribute__((noipa)) void
+f13 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    {
+      va_arg (ap, int);
+      va_arg (ap, double);
+    }
+  g = va_arg (ap, struct W);
+  va_end (ap);
+}
+
+__attribute__((noipa)) void
+f14 (int x, ...)
+{
+  va_list ap;
+  va_start (ap, x);
+  while (x--)
+    {
+      va_arg (ap, int);
+      va_arg (ap, double);
+    }
+  h = va_arg (ap, struct X);
+  va_end (ap);
+}
+
+int
+main ()
+{
+  union Y {
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+    __int128 b;
+#endif
+    struct S c;
+    struct T d;
+    struct U e;
+    struct V f;
+    struct W g;
+    struct X h;
+  } u, v;
+  u.c.a = 0x5555555555555555ULL;
+  u.c.b = 0xaaaaaaaaaaaaaaaaULL;
+#define C(x) \
+  do {								\
+    if (u.c.a != x.c.a || u.c.b != x.c.b) __builtin_abort ();	\
+    u.c.a++;							\
+    u.c.b--;							\
+  } while (0)
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+  v.b = f1 (0, u.b); C (v);
+  v.b = f1 (1, 0, u.b); C (v);
+  v.b = f1 (2, 0, 0, u.b); C (v);
+  v.b = f1 (3, 0, 0, 0, u.b); C (v);
+  v.b = f1 (4, 0, 0, 0, 0, u.b); C (v);
+  v.b = f1 (5, 0, 0, 0, 0, 0, u.b); C (v);
+  v.b = f1 (6, 0, 0, 0, 0, 0, 0, u.b); C (v);
+  v.b = f1 (7, 0, 0, 0, 0, 0, 0, 0, u.b); C (v);
+  v.b = f1 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.b); C (v);
+  v.b = f1 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.b); C (v);
+#endif
+  v.c = f2 (0, u.c); C (v);
+  v.c = f2 (1, 0, u.c); C (v);
+  v.c = f2 (2, 0, 0, u.c); C (v);
+  v.c = f2 (3, 0, 0, 0, u.c); C (v);
+  v.c = f2 (4, 0, 0, 0, 0, u.c); C (v);
+  v.c = f2 (5, 0, 0, 0, 0, 0, u.c); C (v);
+  v.c = f2 (6, 0, 0, 0, 0, 0, 0, u.c); C (v);
+  v.c = f2 (7, 0, 0, 0, 0, 0, 0, 0, u.c); C (v);
+  v.c = f2 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.c); C (v);
+  v.c = f2 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.c); C (v);
+  v.d = f3 (0, u.d); C (v);
+  v.d = f3 (1, 0, u.d); C (v);
+  v.d = f3 (2, 0, 0, u.d); C (v);
+  v.d = f3 (3, 0, 0, 0, u.d); C (v);
+  v.d = f3 (4, 0, 0, 0, 0, u.d); C (v);
+  v.d = f3 (5, 0, 0, 0, 0, 0, u.d); C (v);
+  v.d = f3 (6, 0, 0, 0, 0, 0, 0, u.d); C (v);
+  v.d = f3 (7, 0, 0, 0, 0, 0, 0, 0, u.d); C (v);
+  v.d = f3 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.d); C (v);
+  v.d = f3 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.d); C (v);
+#if __SIZEOF_INT128__ == 2 * __SIZEOF_LONG_LONG__
+  f4 (0, u.b); v.b = b; C (v);
+  f4 (1, 0, u.b); v.b = b; C (v);
+  f4 (2, 0, 0, u.b); v.b = b; C (v);
+  f4 (3, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (4, 0, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (5, 0, 0, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (6, 0, 0, 0, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (7, 0, 0, 0, 0, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.b); v.b = b; C (v);
+  f4 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.b); v.b = b; C (v);
+#endif
+  f5 (0, u.c); v.c = c; C (v);
+  f5 (1, 0, u.c); v.c = c; C (v);
+  f5 (2, 0, 0, u.c); v.c = c; C (v);
+  f5 (3, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (4, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (5, 0, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (6, 0, 0, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (7, 0, 0, 0, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f5 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.c); v.c = c; C (v);
+  f6 (0, u.d); v.d = d; C (v);
+  f6 (1, 0, u.d); v.d = d; C (v);
+  f6 (2, 0, 0, u.d); v.d = d; C (v);
+  f6 (3, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (4, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (5, 0, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (6, 0, 0, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (7, 0, 0, 0, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (8, 0, 0, 0, 0, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  f6 (9, 0, 0, 0, 0, 0, 0, 0, 0, 0, u.d); v.d = d; C (v);
+  u.e.a = 1.25;
+  u.e.b = 2.75;
+  u.e.c = -3.5;
+  u.e.d = -2.0;
+#undef C
+#define C(x) \
+  do {								\
+    if (u.e.a != x.e.a || u.e.b != x.e.b			\
+	|| u.e.c != x.e.c || u.e.d != x.e.d) __builtin_abort ();\
+    u.e.a++;							\
+    u.e.b--;							\
+    u.e.c++;							\
+    u.e.d--;							\
+  } while (0)
+  v.e = f7 (0, u.e); C (v);
+  v.e = f7 (1, 0.0, u.e); C (v);
+  v.e = f7 (2, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (3, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (4, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (5, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.e = f7 (9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); C (v);
+  v.f = f8 (0, u.f); C (v);
+  v.f = f8 (1, 0.0, u.f); C (v);
+  v.f = f8 (2, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (3, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (4, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (5, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  v.f = f8 (9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); C (v);
+  f9 (0, u.e); v.e = e; C (v);
+  f9 (1, 0.0, u.e); v.e = e; C (v);
+  f9 (2, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (3, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (4, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (5, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f9 (9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.e); v.e = e; C (v);
+  f10 (0, u.f); v.f = f; C (v);
+  f10 (1, 0.0, u.f); v.f = f; C (v);
+  f10 (2, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (3, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (4, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (5, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  f10 (9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, u.f); v.f = f; C (v);
+  u.g.a = 9.5;
+  u.g.b = 0x5555555555555555ULL;
+#undef C
+#define C(x) \
+  do {								\
+    if (u.e.a != x.e.a || u.e.b != x.e.b) __builtin_abort ();	\
+    u.e.a++;							\
+    u.e.b--;							\
+  } while (0)
+  v.g = f11 (0, u.g); C (v);
+  v.g = f11 (1, 0, 0.0, u.g); C (v);
+  v.g = f11 (2, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (3, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (4, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (5, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (6, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (7, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (8, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.g = f11 (9, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); C (v);
+  v.h = f12 (0, u.h); C (v);
+  v.h = f12 (1, 0, 0.0, u.h); C (v);
+  v.h = f12 (2, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (3, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (4, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (5, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (6, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (7, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (8, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  v.h = f12 (9, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); C (v);
+  f13 (0, u.g); v.g = g; C (v);
+  f13 (1, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (2, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (3, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (4, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (5, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (6, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (7, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (8, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f13 (9, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.g); v.g = g; C (v);
+  f14 (0, u.h); v.h = h; C (v);
+  f14 (1, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (2, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (3, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (4, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (5, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (6, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (7, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (8, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  f14 (9, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, 0, 0.0, u.h); v.h = h; C (v);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93402.c b/gcc/testsuite/gcc.c-torture/execute/pr93402.c
new file mode 100644
index 00000000000..6487797d0aa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93402.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/93402 */
+
+struct S { unsigned int a; unsigned long long b; };
+
+__attribute__((noipa)) struct S
+foo (unsigned long long x)
+{
+  struct S ret;
+  ret.a = 0;
+  ret.b = x * 11111111111ULL + 111111111111ULL;
+  return ret;
+}
+
+int
+main ()
+{
+  struct S a = foo (1);
+  if (a.a != 0 || a.b != 122222222222ULL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93434.c b/gcc/testsuite/gcc.c-torture/execute/pr93434.c
new file mode 100644
index 00000000000..e786252794b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93434.c
@@ -0,0 +1,36 @@
+typedef struct creal_T {
+  double re;
+  double im;
+} creal_T;
+
+#define N 16
+int main() {
+  int k;
+  int i;
+  int j;
+  creal_T t2[N];
+  double inval;
+
+  inval = 1.0;
+  for (j = 0; j < N; ++j) {
+    t2[j].re = 0;
+    t2[j].im = 0;
+  }
+
+  for (j = 0; j < N/4; j++) {
+    i = j * 4;
+    t2[i].re = inval;
+    t2[i].im = inval;
+    k = i + 3;
+    t2[k].re = inval;
+    t2[k].im = inval;
+    t2[i] = t2[k];
+    t2[k].re = inval;
+  }
+
+  for (i = 0; i < 2; ++i)
+    if (t2[i].re != !i || t2[i].im != !i)
+      __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93744-1.c b/gcc/testsuite/gcc.c-torture/execute/pr93744-1.c
new file mode 100644
index 00000000000..3229c9b2bd6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93744-1.c
@@ -0,0 +1,14 @@
+/* PR tree-optimization/93744 */
+
+typedef int I;
+
+int
+main ()
+{
+  int a = 0;
+  I b = 0;
+  (a > 0) * (b |= 2);
+  if (b != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93744-2.c b/gcc/testsuite/gcc.c-torture/execute/pr93744-2.c
new file mode 100644
index 00000000000..0c1baaac77b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93744-2.c
@@ -0,0 +1,21 @@
+/* PR tree-optimization/93744 */
+
+int w;
+
+int
+foo (int x, int y, int z)
+{
+  int r = z - ((z - w++) & -(x < y));
+  return r;
+}
+
+int
+main ()
+{
+  w = 4;
+  if (foo (5, 7, 12) != 4 || w != 5)
+    __builtin_abort ();
+  if (foo (7, 5, 12) != 12 || w != 6)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93744-3.c b/gcc/testsuite/gcc.c-torture/execute/pr93744-3.c
new file mode 100644
index 00000000000..8542c7c53ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93744-3.c
@@ -0,0 +1,21 @@
+/* PR tree-optimization/93744 */
+
+int w;
+
+int
+foo (int x, int y, int z)
+{
+  int r = z + ((w++ - z) & -(x < y));
+  return r;
+}
+
+int
+main ()
+{
+  w = 4;
+  if (foo (5, 7, 12) != 4 || w != 5)
+    __builtin_abort ();
+  if (foo (7, 5, 12) != 12 || w != 6)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93908.c b/gcc/testsuite/gcc.c-torture/execute/pr93908.c
new file mode 100644
index 00000000000..cb6e3dda2ea
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93908.c
@@ -0,0 +1,54 @@
+/* PR rtl-optimization/93908 */
+
+struct T
+{
+  int b;
+  int c;
+  unsigned short d;
+  unsigned e:1, f:1, g:1, h:2, i:1, j:1;
+  signed int k:2;
+};
+
+struct S
+{
+  struct T s;
+  char c[64];
+} buf[2];
+
+__attribute__ ((noipa)) void *
+baz (void)
+{
+  static int cnt;
+  return (void *) &buf[cnt++];
+}
+
+static inline __attribute__ ((always_inline)) struct T *
+bar (const char *a)
+{
+  struct T *s;
+  s = baz ();
+  s->b = 1;
+  s->k = -1;
+  return s;
+}
+
+__attribute__ ((noipa)) void
+foo (const char *x, struct T **y)
+{
+  struct T *l = bar (x);
+  struct T *m = bar (x);
+  y[0] = l;
+  y[1] = m;
+}
+
+int
+main ()
+{
+  struct T *r[2];
+  foo ("foo", r);
+  if (r[0]->e || r[0]->f || r[0]->g || r[0]->h || r[0]->i || r[0]->j || r[0]->k != -1)
+    __builtin_abort ();
+  if (r[1]->e || r[1]->f || r[1]->g || r[1]->h || r[1]->i || r[1]->j || r[1]->k != -1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr93945.c b/gcc/testsuite/gcc.c-torture/execute/pr93945.c
new file mode 100644
index 00000000000..99e455cce52
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr93945.c
@@ -0,0 +1,45 @@
+/* PR tree-optimization/93945 */
+
+union U { char a[8]; struct S { unsigned int b : 8, c : 13, d : 11; } e; } u;
+
+__attribute__((noipa)) int
+foo (void)
+{
+  __builtin_memset (&u.a, 0xf4, sizeof (u.a));
+  return u.e.c;
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  asm volatile ("" : : "g" (&u) : "memory");
+  return u.e.c;
+}
+
+__attribute__((noipa)) int
+baz (void)
+{
+  __builtin_memset (&u.a, 0xf4, sizeof (u.a));
+  return u.e.d;
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  asm volatile ("" : : "g" (&u) : "memory");
+  return u.e.d;
+}
+
+int
+main ()
+{
+  int a = foo ();
+  int b = bar ();
+  if (a != b)
+    __builtin_abort ();
+  a = baz ();
+  b = qux ();
+  if (a != b)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/Wnonnull.c b/gcc/testsuite/gcc.dg/Wnonnull.c
index be89a5a755c..0ed06aabe68 100644
--- a/gcc/testsuite/gcc.dg/Wnonnull.c
+++ b/gcc/testsuite/gcc.dg/Wnonnull.c
@@ -2,7 +2,10 @@
    { dg-do compile }
    { dg-options "-O2 -Wall" } */
 
-#include <string.h>
+extern __SIZE_TYPE__ strlen (const char *__s)
+			     __attribute ((pure)) __attribute ((nonnull (1)));
+extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
+		     __SIZE_TYPE__ __n) __attribute ((nonnull (1, 2)));
 
 char buf[100];
 
@@ -14,9 +17,9 @@ struct Test
 
 __attribute ((nonnull (1, 2)))
 inline char*
-my_strcpy (char *restrict dst, const char *restrict src, size_t size)
+my_strcpy (char *restrict dst, const char *restrict src, __SIZE_TYPE__ size)
 {
-  size_t len = strlen (src);        /* { dg-warning "argument 1 null where non-null expected" } */
+  __SIZE_TYPE__ len = strlen (src); /* { dg-warning "argument 1 null where non-null expected" } */
   if (len < size)
     memcpy (dst, src, len + 1);     /* { dg-warning "argument 2 null where non-null expected" } */
   else
diff --git a/gcc/testsuite/gcc.dg/c11-static-assert-10.c b/gcc/testsuite/gcc.dg/c11-static-assert-10.c
new file mode 100644
index 00000000000..2fe210b6cc8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/c11-static-assert-10.c
@@ -0,0 +1,9 @@
+/* Test for constant expressions: casts with integer overflow.  PR
+   c/93241.  */
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -pedantic-errors" } */
+
+#include <limits.h>
+
+_Static_assert (0 ? (_Bool) (INT_MAX + 1) : 1, "");
+_Static_assert (0 ? (short) ((INT_MAX + 1) != 0) : 1, "");
diff --git a/gcc/testsuite/gcc.dg/c99-const-expr-15.c b/gcc/testsuite/gcc.dg/c99-const-expr-15.c
new file mode 100644
index 00000000000..b1744b67182
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/c99-const-expr-15.c
@@ -0,0 +1,9 @@
+/* Test for constant expressions: casts with integer overflow.  PR
+   c/93241.  */
+/* { dg-do compile } */
+/* { dg-options "-std=c99 -pedantic-errors" } */
+
+#include <limits.h>
+
+struct s { int a : (0 ? (_Bool) (INT_MAX + 1) : 1); };
+struct t { int a : (0 ? (short) ((INT_MAX + 1) != 0) : 1); };
diff --git a/gcc/testsuite/gcc.dg/darwin-version-1.c b/gcc/testsuite/gcc.dg/darwin-version-1.c
index 11cfceff399..ad7f7da3b63 100644
--- a/gcc/testsuite/gcc.dg/darwin-version-1.c
+++ b/gcc/testsuite/gcc.dg/darwin-version-1.c
@@ -1,10 +1,14 @@
 /* Basic test of the -mmacosx-version-min option.  */
 
-/* { dg-options "-mmacosx-version-min=10.1" } */
+/* Darwin4 corresponds to MacOS 10.0.  */
+/* { dg-options "-mmacosx-version-min=10.1" { target *-*-darwin[456789]* } } */
+/* Later Darwin linkers decline to link for less than Darwin8/MacOS 10.4.
+   However, we need to make the link for 10.6 because the relevant libgcc_s
+   shim files for 10.4 and 10.5 are also not installed in later SDKs.  */
+/* { dg-options "-mmacosx-version-min=10.6" { target *-*-darwin[123]* } } */
 /* { dg-do link { target *-*-darwin* } } */
 
 int main()
 {
   return 0;
 }
-
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-1.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-1.c
new file mode 100644
index 00000000000..eee5471cae0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-1.c
@@ -0,0 +1,30 @@
+/* Test non-canonical BID significands: _Decimal128.  Bug 91226.  */
+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
+/* { dg-options "-std=gnu2x -O2" } */
+
+extern void abort (void);
+extern void exit (int);
+
+union u
+{
+  _Decimal128 d128;
+  unsigned __int128 u128;
+};
+
+#define U128(hi, lo) (((unsigned __int128) lo) \
+		      | (((unsigned __int128) hi) << 64))
+
+int
+main (void)
+{
+  unsigned __int128 i = U128 (0x3041ed09bead87c0ULL, 0x378d8e6400000001ULL);
+  union u x;
+  _Decimal128 d128;
+  x.u128 = i;
+  d128 = x.d128;
+  volatile double d = d128;
+  if (d == 0)
+    exit (0);
+  else
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-2.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-2.c
new file mode 100644
index 00000000000..626712153b4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-2.c
@@ -0,0 +1,42 @@
+/* Test non-canonical BID significands: _Decimal128, case where
+   combination field starts 11.  Bug 91226.  */
+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
+/* { dg-options "-std=gnu2x -O2" } */
+
+extern void abort (void);
+extern void exit (int);
+
+union u
+{
+  _Decimal128 d128;
+  unsigned __int128 u128;
+};
+
+#define U128(hi, lo) (((unsigned __int128) lo) \
+		      | (((unsigned __int128) hi) << 64))
+
+int
+main (void)
+{
+  unsigned __int128 i = U128 (0x6e79000000000000ULL, 0x1ULL);
+  union u x;
+  _Decimal128 d128;
+  x.u128 = i;
+  d128 = x.d128;
+  volatile double d = d128;
+  if (d != 0)
+    abort ();
+  /* The above number should have quantum exponent 1234.  */
+  _Decimal128 t1233 = 0.e1233DL, t1234 = 0.e1234DL, t1235 = 0.e1235DL;
+  _Decimal128 dx;
+  dx = d128 + t1233;
+  if (__builtin_memcmp (&dx, &t1233, 16) != 0)
+    abort ();
+  dx = d128 + t1234;
+  if (__builtin_memcmp (&dx, &t1234, 16) != 0)
+    abort ();
+  dx = d128 + t1235;
+  if (__builtin_memcmp (&dx, &t1234, 16) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-3.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-3.c
new file mode 100644
index 00000000000..9190daedaf6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-3.c
@@ -0,0 +1,5 @@
+/* Test non-canonical BID significands: _Decimal128.  Bug 91226.  */
+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
+/* { dg-options "-std=gnu2x -O0" } */
+
+#include "bid-non-canonical-d128-1.c"
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-4.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-4.c
new file mode 100644
index 00000000000..b148ce445e7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d128-4.c
@@ -0,0 +1,6 @@
+/* Test non-canonical BID significands: _Decimal128, case where
+   combination field starts 11.  Bug 91226.  */
+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
+/* { dg-options "-std=gnu2x -O0" } */
+
+#include "bid-non-canonical-d128-2.c"
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-1.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-1.c
new file mode 100644
index 00000000000..b46b71cc3fc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-1.c
@@ -0,0 +1,26 @@
+/* Test non-canonical BID significands: _Decimal32.  Bug 91226.  */
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-std=gnu2x -O2" } */
+
+extern void abort (void);
+extern void exit (int);
+
+union u
+{
+  _Decimal32 d32;
+  unsigned int u32;
+};
+
+int
+main (void)
+{
+  union u x;
+  _Decimal32 d32;
+  x.u32 = 0x6cb89681U;
+  d32 = x.d32;
+  volatile double d = d32;
+  if (d == 0)
+    exit (0);
+  else
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-2.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-2.c
new file mode 100644
index 00000000000..11d64dce193
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d32-2.c
@@ -0,0 +1,5 @@
+/* Test non-canonical BID significands: _Decimal32.  Bug 91226.  */
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-std=gnu2x -O0" } */
+
+#include "bid-non-canonical-d32-1.c"
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-1.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-1.c
new file mode 100644
index 00000000000..87b106945d4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-1.c
@@ -0,0 +1,26 @@
+/* Test non-canonical BID significands: _Decimal64.  Bug 91226.  */
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-std=gnu2x -O2" } */
+
+extern void abort (void);
+extern void exit (int);
+
+union u
+{
+  _Decimal64 d64;
+  unsigned long long int u64;
+};
+
+int
+main (void)
+{
+  union u x;
+  _Decimal64 d64;
+  x.u64 = 0x6c7386f26fc10001ULL;
+  d64 = x.d64;
+  volatile double d = d64;
+  if (d == 0)
+    exit (0);
+  else
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-2.c b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-2.c
new file mode 100644
index 00000000000..3c10145a314
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/bid-non-canonical-d64-2.c
@@ -0,0 +1,5 @@
+/* Test non-canonical BID significands: _Decimal64.  Bug 91226.  */
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-std=gnu2x -O0" } */
+
+#include "bid-non-canonical-d64-1.c"
diff --git a/gcc/testsuite/gcc.dg/gomp/pr90637.c b/gcc/testsuite/gcc.dg/gomp/pr90637.c
new file mode 100644
index 00000000000..983e03e7574
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gomp/pr90637.c
@@ -0,0 +1,14 @@
+/* PR tree-optimization/90637 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O1 --param sink-frequency-threshold=90" } */
+
+int v;
+
+void
+foo (int c)
+{
+  int i;
+#pragma omp for simd if (c) lastprivate (v) schedule (static, 16)
+  for (i = 0; i < 64; ++i)
+    v = i;
+}
diff --git a/gcc/testsuite/gcc.dg/inline-42.c b/gcc/testsuite/gcc.dg/inline-42.c
new file mode 100644
index 00000000000..f5ccea8f3cf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-42.c
@@ -0,0 +1,50 @@
+/* Test inline functions declared in inner scopes.  Bug 93072.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  if (inline_1 == 0) ;
+  extern inline void inline_2 (void);
+  if (inline_2 == 0) ;
+  inline void inline_3 (void);
+  if (inline_3 == 0) ;
+  extern inline void inline_4 (void);
+  if (inline_4 == 0) ;
+  inline void inline_static_1 (void);
+  if (inline_static_1 == 0) ;
+  extern inline void inline_static_2 (void);
+  if (inline_static_2 == 0) ;
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
diff --git a/gcc/testsuite/gcc.dg/inline-43.c b/gcc/testsuite/gcc.dg/inline-43.c
new file mode 100644
index 00000000000..87b24450384
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-43.c
@@ -0,0 +1,50 @@
+/* Test inline functions declared in inner scopes.  Bug 93072.  */
+/* { dg-do compile } */
+/* { dg-options "-fgnu89-inline" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  if (inline_1 == 0) ;
+  extern inline void inline_2 (void);
+  if (inline_2 == 0) ;
+  inline void inline_3 (void);
+  if (inline_3 == 0) ;
+  extern inline void inline_4 (void);
+  if (inline_4 == 0) ;
+  inline void inline_static_1 (void);
+  if (inline_static_1 == 0) ;
+  extern inline void inline_static_2 (void);
+  if (inline_static_2 == 0) ;
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
diff --git a/gcc/testsuite/gcc.dg/ipa/ipcp-agg-12.c b/gcc/testsuite/gcc.dg/ipa/ipcp-agg-12.c
new file mode 100644
index 00000000000..5c57913803e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/ipcp-agg-12.c
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fno-ipa-sra -fdump-ipa-cp-details --param=ipa-cp-eval-threshold=2"  } */
+
+struct S
+{
+  int a, b, c;
+};
+
+int __attribute__((noinline)) foo (int i, struct S s);
+int __attribute__((noinline)) bar (int i, struct S s);
+int __attribute__((noinline)) baz (int i, struct S s);
+
+
+int __attribute__((noinline))
+bar (int i, struct S s)
+{
+  return baz (i, s);
+}
+
+int __attribute__((noinline))
+baz (int i, struct S s)
+{
+  return foo (i, s);
+}
+
+int __attribute__((noinline))
+foo (int i, struct S s)
+{
+  if (i == 2)
+    return 0;
+  else
+    return s.b * s.b + bar (i - 1, s);
+}
+
+volatile int g;
+
+void entry (void)
+{
+  struct S s;
+  s.b = 4;
+  g = bar (g, s);
+}
+
+
+void entry2 (void)
+{
+  struct S s;
+  s.b = 6;
+  g = baz (g, s);
+}
+
+
+/* { dg-final { scan-ipa-dump-times "adding an extra caller" 2 "cp" } } */
diff --git a/gcc/testsuite/gcc.dg/pr89435.c b/gcc/testsuite/gcc.dg/pr89435.c
new file mode 100644
index 00000000000..d72d087f5ce
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr89435.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/89435 */
+/* { dg-do run } */
+/* { dg-options "-O1 -fno-forward-propagate -fno-tree-forwprop -fno-tree-ccp" } */
+
+unsigned short a;
+unsigned int b, c, d, e, f;
+
+int
+main ()
+{
+#if __CHAR_BIT__ == 8 && __SIZEOF_INT__ == 4
+  unsigned char g = e = __builtin_mul_overflow_p (5, 542624702, 0);
+  d = __builtin_bswap64 (a);
+  b = __builtin_sub_overflow ((unsigned char) -e, (unsigned int) d, &g);
+  e = __builtin_mul_overflow (b, c, &a);
+  f = g + e;
+  if (f != 0xff)
+    __builtin_abort ();
+#endif
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr89795.c b/gcc/testsuite/gcc.dg/pr89795.c
new file mode 100644
index 00000000000..4ceaa433f3c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr89795.c
@@ -0,0 +1,25 @@
+/* PR rtl-optimization/89795 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-dce -fno-forward-propagate -fno-sched-pressure" } */
+
+unsigned char a;
+unsigned b, c, d;
+
+int
+main ()
+{
+#if __CHAR_BIT__ == 8
+  unsigned x;
+  int e, f;
+  unsigned char g;
+  e = __builtin_bswap32 (a);
+  f = __builtin_ffs (~(unsigned short) e);
+  a = __builtin_mul_overflow ((unsigned char) 0xf7, f, &g);
+  a |= __builtin_sub_overflow_p (c, 0, (unsigned char) 0);
+  d = g + b;
+  x = d;
+  if (x != 0xf7)
+    __builtin_abort ();
+#endif
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr90648.c b/gcc/testsuite/gcc.dg/pr90648.c
new file mode 100644
index 00000000000..bf1fa989478
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr90648.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern double copysign ();
+double foo (double x)
+{
+  return x * copysign (); /* { dg-warning "too few arguments" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr90756.c b/gcc/testsuite/gcc.dg/pr90756.c
index 3507aa29e70..a4ba64acd72 100644
--- a/gcc/testsuite/gcc.dg/pr90756.c
+++ b/gcc/testsuite/gcc.dg/pr90756.c
@@ -2,6 +2,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -Wno-psabi" } */
 /* { dg-additional-options "-mno-sse" { target ia32 } } */
+/* { dg-additional-options "-fno-common" { target hppa*-*-hpux* } } */
 
 typedef float B __attribute__((vector_size(4 * sizeof (float))));
 typedef unsigned long long C __attribute__((vector_size(4 * sizeof (long long))));
diff --git a/gcc/testsuite/gcc.dg/pr90898.c b/gcc/testsuite/gcc.dg/pr90898.c
new file mode 100644
index 00000000000..e992ea34cd9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr90898.c
@@ -0,0 +1,16 @@
+/* PR c/90898 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void *p;
+int bar (void);
+void baz (int *);
+
+void
+foo (void)
+{
+  p = __builtin_stack_save ();
+  int a[(bar (), 2)];
+  baz (a);
+  __builtin_stack_restore (p);
+}
diff --git a/gcc/testsuite/gcc.dg/pr91269.c b/gcc/testsuite/gcc.dg/pr91269.c
new file mode 100644
index 00000000000..8c03ba8dab2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr91269.c
@@ -0,0 +1,70 @@
+/* PR target/91269 */
+/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */
+
+/* { dg-do assemble } */
+/* { dg-options "-O2 -Wno-int-conversion" }  */
+/* { dg-additional-options "-fcall-used-g6 -fPIE -mcpu=niagara4" { target sparc*-*-* } } */
+
+struct m;
+
+enum { a = 2 };
+int b[1];
+int d[2715];
+int e, f, h;
+enum { i = 2 } j;
+inline int c(int k) {
+  char *cp;
+  if (k >= 62 && k <= 247)
+    cp = b[k];
+  if (cp)
+    return 65533;
+  return 2;
+}
+inline int g(int k) {
+  if (k < sizeof(d))
+    return e;
+  return 0;
+}
+
+int u(struct m*, char*, char*);
+
+int l(struct m *k, char n, long o, int *p) {
+  int q, flags = j, r, s, lasttwo = *p;
+  char inptr, outptr;
+  while (inptr) {
+    if (__builtin_expect(h, 0))
+      break;
+    unsigned ch = inptr;
+    if (lasttwo) {
+      long need = lasttwo >> 3;
+      if (__builtin_expect(need > n, 0))
+        break;
+    } else if (s == i) {
+      long t = c(ch);
+      if (t != 65533) {
+        int jch = g(ch);
+        if (jch & 8)
+          continue;
+      }
+    }
+    if (ch <= 5)
+      ;
+    else {
+      long t = c(ch);
+      if (t != 65533)
+        ;
+      else {
+        switch (f >> 8)
+        case 79:
+          q = f == 20308 || f == 20350;
+        if (q)
+          if (j)
+            r = u(k, &inptr, &outptr);
+        s = *p;
+        if (r)
+          if (o && flags & a)
+            break;
+      }
+    }
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/pr91720.c b/gcc/testsuite/gcc.dg/pr91720.c
new file mode 100644
index 00000000000..4abdace94da
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr91720.c
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/91720 */
+/* { dg-do run } */
+/* { dg-options "-Og -fno-forward-propagate -frerun-cse-after-loop -fno-tree-fre" } */
+
+unsigned a, b;
+
+int
+main ()
+{
+#if __CHAR_BIT__ == 8
+  unsigned c = 1;
+  unsigned long long d = 0;
+  unsigned char e = 0;
+  e = __builtin_sub_overflow (d, e, &a) ? 0 : 0x80;
+  e = e << 7 | e >> c;
+  __builtin_memmove (&d, &a, 2);
+  b = e;
+  if (b != 0x40)
+    __builtin_abort ();
+#endif
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr91734.c b/gcc/testsuite/gcc.dg/pr91734.c
new file mode 100644
index 00000000000..1cc3e40ccbc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr91734.c
@@ -0,0 +1,97 @@
+/* PR tree-optimization/91734 */
+/* { dg-do run } */
+/* { dg-add-options ieee } */
+/* { dg-additional-options "-O2 -std=gnu99" } */
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f1 (float x)
+{
+  return __builtin_sqrtf (x) < __FLT_MIN__;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f2 (float x)
+{
+  return __builtin_sqrtf (x) < 0x1.2dd3d0p-65f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f3 (float x)
+{
+  return __builtin_sqrtf (x) >= 0x1.2dd3d0p-65f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f4 (float x)
+{
+  return __builtin_sqrtf (x) >= 0x1.5642e6p+54f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f5 (float x)
+{
+  return __builtin_sqrtf (x) > 0x1.5642e6p+54f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f6 (float x)
+{
+  return __builtin_sqrtf (x) < 0x1.4da1cp-19f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f7 (float x)
+{
+  return __builtin_sqrtf (x) <= 0x1.4da1cp-19f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f8 (float x)
+{
+  return __builtin_sqrtf (x) < 0x1.50cb62p-65f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f9 (float x)
+{
+  return __builtin_sqrtf (x) <= 0x1.4fc00cp-73f;
+}
+
+__attribute__((noipa, optimize ("Ofast"))) int
+f10 (float x)
+{
+  return __builtin_sqrtf (x) < 0x1.001002p+0f;
+}
+
+int
+main ()
+{
+  if (__FLT_RADIX__ != 2
+      || __FLT_MANT_DIG__ != 24
+      || __FLT_MIN_EXP__ != -125
+      || __FLT_MAX_EXP__ != 128
+      || __FLT_HAS_DENORM__ != 1
+      || __FLT_HAS_INFINITY__ != 1)
+    return 0;
+  if (!f1 (0.0f) || f1 (0x1.0p-149f))
+    __builtin_abort ();
+  if (!f2 (0x1.63dbc0p-130f))
+    __builtin_abort ();
+  if (f3 (0x1.63dbc0p-130f))
+    __builtin_abort ();
+  if (!f4 (0x1.c996d0p+108f) || !f4 (0x1.c996cep+108f) || f4 (0x1.c996ccp+108f))
+    __builtin_abort ();
+  if (f5 (0x1.c996d0p+108f) || f5 (0x1.c996d2p+108f) || !f5 (0x1.c996d4p+108f))
+    __builtin_abort ();
+  if (!f6 (0x1.b2ce3p-38f) || f6 (0x1.b2ce32p-38f) || f6 (0x1.b2ce34p-38f))
+    __builtin_abort ();
+  if (!f7 (0x1.b2ce3p-38f) || !f7 (0x1.b2ce34p-38f) || !f7 (0x1.b2ce36p-38f) || f7 (0x1.b2ce38p-38f))
+    __builtin_abort ();
+  if (!f8 (0x1.bb166p-130f) || !f8 (0x1.bb168p-130f) || f8 (0x1.bb16ap-130f) || f8 (0x1.bb16cp-130f))
+    __builtin_abort ();
+  if (!f9 (0x1.8p-146f) || !f9 (0x1.ap-146f) || f9 (0x1.cp-146f) || f9 (0x1.ep-146f))
+    __builtin_abort ();
+  if (f10 (0x1.002004p+0f))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr91885.c b/gcc/testsuite/gcc.dg/pr91885.c
new file mode 100644
index 00000000000..35be32be559
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr91885.c
@@ -0,0 +1,47 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fprofile-generate" } */
+/* { dg-require-profiling "-fprofile-generate" } */
+
+typedef signed long long int __int64_t;
+typedef unsigned long long int __uint64_t;
+typedef __int64_t int64_t;
+typedef __uint64_t uint64_t;
+inline void
+BLI_endian_switch_int64 (int64_t *val)
+{
+  uint64_t tval = *val;
+  *val = ((tval >> 56)) | ((tval << 40) & 0x00ff000000000000ll)
+	 | ((tval << 24) & 0x0000ff0000000000ll)
+	 | ((tval << 8) & 0x000000ff00000000ll)
+	 | ((tval >> 8) & 0x00000000ff000000ll)
+	 | ((tval >> 24) & 0x0000000000ff0000ll)
+	 | ((tval >> 40) & 0x000000000000ff00ll) | ((tval << 56));
+}
+typedef struct anim_index_entry
+{
+  unsigned long long seek_pos_dts;
+  unsigned long long pts;
+} anim_index_entry;
+extern struct anim_index_entry *
+MEM_callocN (int);
+struct anim_index
+{
+  int num_entries;
+  struct anim_index_entry *entries;
+};
+struct anim_index *
+IMB_indexer_open (const char *name)
+{
+  char header[13];
+  struct anim_index *idx;
+  int i;
+  idx->entries = MEM_callocN (8);
+  if (((1 == 0) != (header[8] == 'V')))
+    {
+      for (i = 0; i < idx->num_entries; i++)
+	{
+	  BLI_endian_switch_int64 ((int64_t *) &idx->entries[i].seek_pos_dts);
+	  BLI_endian_switch_int64 ((int64_t *) &idx->entries[i].pts);
+	}
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr92430.c b/gcc/testsuite/gcc.dg/pr92430.c
new file mode 100644
index 00000000000..915606893ba
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr92430.c
@@ -0,0 +1,25 @@
+// PR rtl-optimization/92430
+// { dg-do compile }
+// { dg-options "-Os -fno-if-conversion -fno-tree-dce -fno-tree-loop-optimize -fno-tree-vrp" }
+
+int eb, ko;
+
+void
+e9 (int pe, int lx)
+{
+  int ir;
+
+  for (ir = 0; ir < 1; ++ir)
+    {
+      for (ko = 0; ko < 1; ++ko)
+        {
+          for (eb = 0; eb < 1; ++eb)
+            ko += pe;
+
+          for (ko = 0; ko < 1; ++ko)
+            ;
+        }
+
+      pe = ir = lx;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr92591-1.c b/gcc/testsuite/gcc.dg/pr92591-1.c
new file mode 100644
index 00000000000..0f9365d06e5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr92591-1.c
@@ -0,0 +1,11 @@
+/* PR rtl-optimization/92591 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fmodulo-sched -fweb -fno-dce -fno-ivopts -fno-sched-pressure -fno-tree-loop-distribute-patterns --param sms-dfa-history=1" } */
+/* { dg-additional-options "-mcpu=e500mc" { target { powerpc-*-* } } } */
+
+void
+wf (char *mr, int tc)
+{
+  while (tc-- > 0)
+    *mr++ = 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr92591-2.c b/gcc/testsuite/gcc.dg/pr92591-2.c
new file mode 100644
index 00000000000..04a80924650
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr92591-2.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/92591 */
+/* { dg-do compile } */
+/* { dg-options "-Os -fmodulo-sched -fmodulo-sched-allow-regmoves --param sms-dfa-history=8" } */
+
+#include "../gcc.c-torture/execute/pr61682.c"
diff --git a/gcc/testsuite/gcc.dg/pr92768.c b/gcc/testsuite/gcc.dg/pr92768.c
new file mode 100644
index 00000000000..e2a3f9ccacc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr92768.c
@@ -0,0 +1,7 @@
+/* PR tree-optimization/92768 */
+/* { dg-options "-O2 -fno-signed-zeros -fdump-tree-optimized -w -Wno-psabi" } */
+
+typedef float v4sf __attribute__((vector_size(16)));
+v4sf f () { return (v4sf) { 0.0, -0.0, 0.0, -0.0 }; }
+
+/* { dg-final { scan-tree-dump {{ 0\.0, -0\.0, 0\.0, -0\.0 }} "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/pr93054.c b/gcc/testsuite/gcc.dg/pr93054.c
new file mode 100644
index 00000000000..1d4680d28e6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr93054.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+__attribute__ ((returns_twice)) int
+bp (int);
+
+__attribute__ ((noreturn)) int
+cb (void)
+{
+  return bp (cb ()); /* { dg-warning "declared .noreturn." } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr93576.c b/gcc/testsuite/gcc.dg/pr93576.c
new file mode 100644
index 00000000000..13c34f3771f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr93576.c
@@ -0,0 +1,10 @@
+/* PR c/93576 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void
+foo (void)
+{
+  int b[] = { 0 };
+  (char (*)[(1, 7, 2)]) 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr93820.c b/gcc/testsuite/gcc.dg/pr93820.c
new file mode 100644
index 00000000000..98d8c20a178
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr93820.c
@@ -0,0 +1,26 @@
+/* PR tree-optimization/93820 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-dse" } */
+
+typedef int v4si __attribute__((vector_size(4 * sizeof (int))));
+int a[10];
+
+__attribute__((noipa)) int
+foo (int *p)
+{
+  a[6] = *p;
+  a[4] = 1;
+  *(((v4si *)&a[0]) + 1) = (v4si) { 0, 0, 0, 0 };
+  a[3] = 0;
+}
+
+int
+main ()
+{
+  int i = 0;
+  foo (&i);
+  for (i = 0; i < 10; i++)
+    if (a[i])
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94002.c b/gcc/testsuite/gcc.dg/pr94002.c
new file mode 100644
index 00000000000..05a02f3f15b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94002.c
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/94002 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fno-tree-dce -fno-tree-reassoc" } */
+/* { dg-additional-options "-fPIC" { target fpic } } */
+
+unsigned a, b;
+
+void
+foo (void)
+{
+  __builtin_sub_overflow (b, 44852956282LL, &a);
+  a += ~b;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/20190327-1.c b/gcc/testsuite/gcc.dg/torture/20190327-1.c
index bb20e7fba99..45093da768c 100644
--- a/gcc/testsuite/gcc.dg/torture/20190327-1.c
+++ b/gcc/testsuite/gcc.dg/torture/20190327-1.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-additional-options "-fno-common" { target hppa*-*-hpux* } } */
 
 typedef long v2di __attribute__((vector_size(16)));
 v2di v;
diff --git a/gcc/testsuite/gcc.dg/torture/pr90020.c b/gcc/testsuite/gcc.dg/torture/pr90020.c
index 1748243852a..27d1ea41ddd 100644
--- a/gcc/testsuite/gcc.dg/torture/pr90020.c
+++ b/gcc/testsuite/gcc.dg/torture/pr90020.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "No undefined weak" { hppa*-*-hpux* } } */
 /* { dg-require-weak "" } */
 /* { dg-additional-options "-Wl,-undefined,dynamic_lookup" { target *-*-darwin* } } */
 /* { dg-additional-options "-Wl,-flat_namespace" { target *-*-darwin[89]* } } */
diff --git a/gcc/testsuite/gcc.dg/torture/pr90278.c b/gcc/testsuite/gcc.dg/torture/pr90278.c
new file mode 100644
index 00000000000..617246a6d4c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr90278.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fexceptions -fnon-call-exceptions" } */
+
+double
+hc (void)
+{
+  double dp = 0.0;
+  double ek[1];
+
+  ek[0] = 1.0 / dp < 0.0;
+
+  return ek[0];
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr91445.c b/gcc/testsuite/gcc.dg/torture/pr91445.c
new file mode 100644
index 00000000000..1d24d456a57
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr91445.c
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { _Bool x; };
+
+void
+foo (struct S *s)
+{
+  __builtin_memset (s, 0x11, sizeof (struct S));
+  s->x = 1;
+}
+
+int
+main ()
+{
+  struct S s;
+  foo (&s);
+  char c;
+  __builtin_memcpy (&c, &s.x, 1);
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr91812.c b/gcc/testsuite/gcc.dg/torture/pr91812.c
new file mode 100644
index 00000000000..ebc67a01e33
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr91812.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } { "" } } */
+/* { dg-options "-fdump-tree-optimized-blocks" } */
+
+unsigned register1;
+unsigned register2;
+
+void busy_wait_for_register (int x)
+{
+  volatile unsigned* ptr;
+  switch(x) {
+    case 0x1111:
+    ptr = &register1;
+    break;
+
+    case 0x2222:
+    ptr = &register2;
+    break;
+
+    default:
+    return;
+  }
+  while (*ptr) {}
+}
+
+/* { dg-final { scan-tree-dump "loop depth 1" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/pr92222.c b/gcc/testsuite/gcc.dg/torture/pr92222.c
new file mode 100644
index 00000000000..f48010d6d31
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr92222.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-ftree-vectorize" } */
+
+unsigned char *a;
+int b;
+void f();
+void c()
+{
+  char *d;
+  int e;
+  for (; b; b++) {
+      e = 7;
+      for (; e >= 0; e--)
+	*d++ = a[b] & 1 << e ? '1' : '0';
+  }
+  f();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr92704.c b/gcc/testsuite/gcc.dg/torture/pr92704.c
new file mode 100644
index 00000000000..79994a39b54
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr92704.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fexceptions -fnon-call-exceptions -fno-tree-dce -ftree-loop-if-convert" } */
+int zr, yx;
+
+void __attribute__ ((simd))
+oj (int rd, int q7)
+{
+  int wo = (__UINTPTR_TYPE__)&rd;
+
+  while (q7 < 1)
+    {
+      int kv;
+      short int v3;
+
+      for (v3 = 0; v3 < 82; v3 += 3)
+        {
+        }
+
+      kv = zr ? 0 : v3;
+      yx = kv < rd;
+      zr = zr && yx;
+      ++q7;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr93381.c b/gcc/testsuite/gcc.dg/torture/pr93381.c
new file mode 100644
index 00000000000..cec4b5d8daa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr93381.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+
+static struct S { int *p1; int *p2; } s;
+typedef __UINTPTR_TYPE__ uintptr_t;
+int foo()
+{
+  int i = 1, j = 2;
+  struct S s;
+  int **p;
+  s.p1 = &i;
+  s.p2 = &j;
+  p = &s.p1;
+  uintptr_t pi = (uintptr_t)p;
+  pi = pi + sizeof (int *);
+  p = (int **)pi;
+  **p = 3;
+  return j;
+}
+
+int main()
+{
+  if (foo () != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/stackalign/builtin-return-2.c b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-return-2.c
new file mode 100644
index 00000000000..771910971d6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-return-2.c
@@ -0,0 +1,40 @@
+/* PR target/93047 */
+/* Originator: Andrew Church <gcczilla@achurch.org> */
+/* { dg-do run } */
+/* { dg-additional-options "-O3 -frename-registers" } */
+/* { dg-require-effective-target untyped_assembly } */
+
+#ifdef __MMIX__
+/* No parameters on stack for bar.  */
+#define STACK_ARGUMENTS_SIZE 0
+#else
+#define STACK_ARGUMENTS_SIZE 64
+#endif
+
+extern void abort(void);
+
+int foo(int n)
+{
+  return n+1;
+}
+
+int bar(int n)
+{
+  __builtin_return(__builtin_apply((void (*)(void))foo, __builtin_apply_args(),
+				   STACK_ARGUMENTS_SIZE));
+}
+
+int main(void)
+{
+  /* Allocate 64 bytes on the stack to make sure that __builtin_apply
+     can read at least 64 bytes above the return address.  */
+  char dummy[64];
+
+  __asm__ ("" : : "" (dummy));
+
+  if (bar(1) != 2)
+    abort();
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
index 650e73a5ee8..dd1c0ac3eba 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
@@ -1,6 +1,10 @@
 /* { dg-do run { target vect_cmdline_needed } } */
 /* { dg-options "-O2 -ftree-vectorize -fwrapv -fdump-tree-vect-details -fvect-cost-model=dynamic" } */
-/* { dg-options "-O2 -ftree-vectorize -fwrapv -fdump-tree-vect-details -fvect-cost-model=dynamic -mno-sse" { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-additional-options "-mno-sse" { target { i?86-*-* x86_64-*-* } } } */
+/* The IBM Z backend sets the min-vect-loop-bound param to 2 to avoid
+   awkward epilogue code generation in some cases.  This line needs to
+   be removed after finding an alternate way to fix this.  */
+/* { dg-additional-options "--param min-vect-loop-bound=0" { target { s390*-*-* } } } */
 
 #include <stdlib.h>
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c
index 8e5f1410612..b0933831ca6 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c
@@ -30,5 +30,6 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! avr-*-* } } } } */
+/* IBM Z does not require special alignment for vectorization.  */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! { avr-*-* s390*-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! { avr-*-* s390*-*-* } } } } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
index ce97e0970b5..e35b41d03b1 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
@@ -38,5 +38,6 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! avr-*-* } } } } */
+/* IBM Z does not require special alignment for vectorization.  */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! { avr-*-* s390*-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! { avr-*-* s390*-*-* } } } } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c
index 8fce4385d0b..2ec698968a9 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c
@@ -1,6 +1,10 @@
 /* { dg-do run { target vect_cmdline_needed } } */
 /* { dg-options "-O2 -ftree-vectorize -fdump-tree-vect-details -fno-vect-cost-model" } */
 /* { dg-additional-options "-mno-sse" { target { i?86-*-* x86_64-*-* } } } */
+/* The IBM Z backend sets the min-vect-loop-bound param to 2 to avoid
+   awkward epilogue code generation in some cases.  This line needs to
+   be removed after finding an alternate way to fix this.  */
+/* { dg-additional-options "--param min-vect-loop-bound=0" { target { s390*-*-* } } } */
 
 #include <stdlib.h>
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c
new file mode 100644
index 00000000000..b578de79cf1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+struct s { int x; };
+struct t { int x; };
+
+void swap(struct s* p, struct t* q)
+{
+  p->x = q->x;
+  q->x = p->x;
+}
+
+/* The second statement is redundant.  */
+/* { dg-final { scan-tree-dump-times "x = " 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times " = \[^;\]*x;" 1 "fre1" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr92930.c b/gcc/testsuite/gcc.dg/tree-ssa/pr92930.c
new file mode 100644
index 00000000000..67e604b6c50
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr92930.c
@@ -0,0 +1,19 @@
+/* PR tree-optimization/92930 */
+/* { dg-do compile { target untyped_assembly } } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-final { scan-tree-dump "__builtin_apply " "optimized" } } */
+/* { dg-final { scan-tree-dump "__builtin_apply_args" "optimized" } } */
+
+void foo (int a, int b, int c, int d, int e, int f, int g);
+
+static void bar (int a, ...)
+{
+  __builtin_apply (foo, __builtin_apply_args (), 20);
+}
+
+int
+main ()
+{
+  bar (1024, 1025, 1026, 1027, 1028, 1029, 1030);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c
index 4503cd74009..c320d1cb71b 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 --param tree-reassoc-width=2 -fdump-tree-reassoc1" } */
+/* { dg-options "-O2 --param tree-reassoc-width=2 -fdump-tree-reassoc2" } */
 
 unsigned int
 foo (void)
@@ -21,4 +21,4 @@ foo (void)
 
 /* Verify there are two pairs of __asm__ statements with no
    intervening stmts.  */
-/* { dg-final { scan-tree-dump-times "__asm__\[^;\n]*;\n *__asm__" 2 "reassoc1"} } */
+/* { dg-final { scan-tree-dump-times "__asm__\[^;\n]*;\n *__asm__" 2 "reassoc2"} } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c
index 553736bc391..dbb02683778 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 --param tree-reassoc-width=3 -fdump-tree-reassoc1-details" } */
+/* { dg-options "-O2 --param tree-reassoc-width=3 -fdump-tree-reassoc2-details" } */
 
 unsigned int
 foo (int a, int b, int c, int d)
@@ -15,4 +15,4 @@ foo (int a, int b, int c, int d)
 }
 
 /* Verify reassociation width was chosen to be 2.  */
-/* { dg-final { scan-tree-dump-times "Width = 2" 1 "reassoc1"} } */
+/* { dg-final { scan-tree-dump-times "Width = 2" 1 "reassoc2"} } */
diff --git a/gcc/testsuite/gcc.dg/unroll-and-jam.c b/gcc/testsuite/gcc.dg/unroll-and-jam.c
index 70910d318cb..7eb64217a05 100644
--- a/gcc/testsuite/gcc.dg/unroll-and-jam.c
+++ b/gcc/testsuite/gcc.dg/unroll-and-jam.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O3 -floop-unroll-and-jam --param unroll-jam-min-percent=0 -fdump-tree-unrolljam-details" } */
+/* { dg-options "-O3 -floop-unroll-and-jam -fno-tree-loop-im --param unroll-jam-min-percent=0 -fdump-tree-unrolljam-details" } */
 /* { dg-require-effective-target int32plus } */
 
 #include <stdio.h>
@@ -34,7 +34,7 @@ void checkb(void)
 #define TEST(name, body, test) \
 static void __attribute__((noinline,noclone)) name (unsigned long n, unsigned long m) \
 { \
-  unsigned long i, j; \
+  unsigned i, j; \
   for (i = 1; i < m; i++) { \
       for (j = 1; j < n; j++) { \
 	  body; \
@@ -58,9 +58,14 @@ TEST(foo3, aa[i+1][j-1]=aa[i][j] * aa[i][j] / 2, checkaa()) //notok, -1,1
 TEST(foo4, aa[i][j] = aa[i-1][j+1] * aa[i-1][j+1] / 2, checkaa()) //notok, -1,1
 TEST(foo5, aa[i][j] = aa[i+1][j+1] * aa[i+1][j+1] / 2, checkaa()) //ok, 1,1
 TEST(foo6, aa[i][j] = aa[i+1][j] * aa[i+1][j] / 2, checkaa()) //ok, -1,0
+TEST(foo61, aa[i][0] = aa[i+1][0] * aa[i+1][0] / 2, checkaa()) //notok, -1,0
+TEST(foo62, aa[i][j/2] = aa[i+1][j/2] * aa[i+1][j/2] / 2, checkaa()) //notok, not affine
+TEST(foo63, aa[i][j%2] = aa[i+1][j%2] * aa[i+1][j%2] / 2, checkaa()) //notok, not affine
 TEST(foo7, aa[i+1][j] = aa[i][j] * aa[i][j] / 2, checkaa()) //ok, 1,0
 TEST(foo9, b[j] = 3*b[j+1] + 1, checkb()) //notok, 0,-1
 TEST(foo10, b[j] = 3*b[j] + 1, checkb()) //ok, 0,0
+extern int f;
+TEST(foo11, f = b[i-1] = 1 + 3* b[i+1], checkb()) //ok, 2,0 but must reduce unroll factor to 2, (it would be incorrect with unroll-by-3, which the profitability would suggest)
 
 /* foo8 should work as well, but currently doesn't because the distance
    vectors we compute are too pessimistic.  We compute
@@ -68,6 +73,7 @@ TEST(foo10, b[j] = 3*b[j] + 1, checkb()) //ok, 0,0
    and the last one causes us to lose.  */
 TEST(foo8, b[j+1] = 3*b[j] + 1, checkb()) //ok, 0,1
 
+int f;
 unsigned int a[1024];
 unsigned int b[1024];
 unsigned int aa[16][1024];
@@ -88,10 +94,12 @@ void init(void)
     printf(" %s\n", #name); \
     init();for(i=0;i<4;i++)name##noopt(32,8); checka = checksum; \
     init();for(i=0;i<4;i++)name(32,8); \
+    if (checka != checksum) fail = 1; \
     printf("%sok %s\n", checka != checksum ? "NOT " : "", #name);
 
 int main()
 {
+  int fail = 0;
   int i;
   unsigned checka;
   RUN(foo1);
@@ -100,12 +108,18 @@ int main()
   RUN(foo4);
   RUN(foo5);
   RUN(foo6);
+  RUN(foo61);
+  RUN(foo62);
+  RUN(foo63);
   RUN(foo7);
   RUN(foo8);
   RUN(foo9);
   RUN(foo10);
-  return 0;
+  RUN(foo11);
+  if (fail)
+    __builtin_abort();
+  return fail;
 }
 
-/* Five loops should be unroll-jammed (actually six, but see above).  */
-/* { dg-final { scan-tree-dump-times "applying unroll and jam" 5 "unrolljam" } } */
+/* Six loops should be unroll-jammed (actually seven, but see above).  */
+/* { dg-final { scan-tree-dump-times "applying unroll and jam" 6 "unrolljam" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr91665.c b/gcc/testsuite/gcc.dg/vect/pr91665.c
new file mode 100644
index 00000000000..6b69ea030b1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr91665.c
@@ -0,0 +1,15 @@
+/* PR tree-optimization/91665 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Ofast" } */
+
+short int v;
+
+void
+foo (short int x, short int y)
+{
+  short int *p = &v;
+
+  x = 1;
+  while (x != 0)
+    x += ++y || (*p = x);
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr92420.c b/gcc/testsuite/gcc.dg/vect/pr92420.c
new file mode 100644
index 00000000000..e43539fbbd7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr92420.c
@@ -0,0 +1,48 @@
+/* { dg-additional-options "-mavx2" { target avx_runtime } } */
+
+#include "tree-vect.h"
+
+#define N 16
+struct C { int r, i; };
+struct C a[N], b[N], c[N], d[N], e[N];
+
+__attribute__((noipa)) static void
+foo (struct C *__restrict x, struct C *__restrict y, struct C *__restrict z, int w)
+{
+  int i;
+  for (int i = 0; i < w; i++)
+    {
+      z[i].r = x[i].r * y[-1 - i].r - x[i].i * y[-1 - i].i;
+      z[i].i = x[i].i * y[-1 - i].r + x[i].r * y[-1 - i].i;
+    }
+}
+
+__attribute__((noipa)) static void
+bar (struct C *__restrict x, struct C *__restrict y, struct C *__restrict z, int w)
+{
+  int i;
+  for (int i = 0; i < w; i++)
+    {
+      z[i].r = x[i].r * y[i].r - x[i].i * y[i].i;
+      z[i].i = x[i].i * y[i].r + x[i].r * y[i].i;
+    }
+}
+
+int
+main ()
+{
+  check_vect ();
+  int i;
+  for (i = 0; i < N; ++i)
+    {
+      a[i].r = N - i; a[i].i = i - N;
+      b[i].r = i - N; b[i].i = i + N;
+      c[i].r = -1 - i; c[i].i = 2 * N - 1 - i;
+    }
+  foo (a, b + N, d, N);
+  bar (a, c, e, N);
+  for (i = 0; i < N; ++i)
+    if (d[i].r != e[i].r || d[i].i != e[i].i)
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr92710.c b/gcc/testsuite/gcc.dg/vect/pr92710.c
new file mode 100644
index 00000000000..2986d4ce06a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr92710.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fopenmp-simd" } */
+
+#pragma omp declare simd
+_Bool foo (_Bool) __attribute__((const));
+
+void
+f (_Bool *restrict x, char *restrict y, char *restrict z)
+{
+  for (int i = 0; i < 128; ++i)
+    x[i] = foo (y[i] == z[i]);
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr92723.c b/gcc/testsuite/gcc.dg/vect/pr92723.c
new file mode 100644
index 00000000000..0d60883cadd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr92723.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+
+void
+foo (unsigned long long *x, unsigned long long *y, int z)
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    x[i] = (y[i] >> z) | (y[i] << (-z & (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ - 1)));
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr93767.c b/gcc/testsuite/gcc.dg/vect/pr93767.c
new file mode 100644
index 00000000000..5f95d7bd35b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr93767.c
@@ -0,0 +1,13 @@
+int
+main ()
+{
+  int a[10], b;
+  for (b = 6; b >= 3; b--)
+    {
+      a[b] = 1;
+      a[b + 2] = a[3];
+    }
+  if (a[5] != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/vect-fma-3.c b/gcc/testsuite/gcc.dg/vect/vect-fma-3.c
new file mode 100644
index 00000000000..b231a328fa5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/vect-fma-3.c
@@ -0,0 +1,17 @@
+/* PR tree-optimization/91723 */
+/* { dg-do compile { target { scalar_all_fma || { i?86-*-* x86_64-*-* } } } } */
+/* { dg-additional-options "-mfma" { target { i?86-*-* x86_64-*-* } } } */
+
+void
+foo (double *restrict r, const double *restrict a,
+     const double *restrict b, const double *restrict c)
+{
+  for (int i = 0; i < 1024; i++)
+    {
+      double x = __builtin_fma (a[i], b[i], c[i]);
+      x = __builtin_fma (a[i], b[i], x);
+      r[i] = x;
+    }
+}
+
+/* { dg-final { scan-tree-dump-times "LOOP VECTORIZED" 1 "vect" { target vect_double } } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c b/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c
new file mode 100644
index 00000000000..ca772cb999e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O3 -fno-math-errno -fno-fp-int-builtin-inexact" } */
+
+#define TEST(name, float_type, int_type, fn) void f_##name (float_type x) \
+{									  \
+  volatile int_type   b = __builtin_##fn (x);				  \
+}
+
+TEST (dld, double, long, lrint)
+TEST (flf, float , long, lrintf)
+
+TEST (did, double, int, lrint)
+TEST (fif, float , int, lrintf)
+
+/* { dg-final { scan-assembler-times "fcvtzs\tw\[0-9\]+, \[d,s\]\[0-9\]+" 2 } } */
+/* { dg-final { scan-assembler-times "bl\tlrint" 2 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c b/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c
new file mode 100644
index 00000000000..da5975ad165
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c
@@ -0,0 +1,15 @@
+/* Check that storing the 64-bit immediate to a volatile location is done
+   with a single store.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef unsigned long long u64;
+
+void bar (u64 *x)
+{
+  *(volatile u64 *)x = 0xabcdef10abcdef10ULL;
+}
+
+/* { dg-final { scan-assembler-times "str\tx..?, .*" 1 } } */
+/* { dg-final { scan-assembler-not "str\tw..?, .*" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-2.c b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
new file mode 100644
index 00000000000..0e75657a153
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
@@ -0,0 +1,12 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O1" } */
+
+/* Test the placement of the .LPFE1 label.  */
+
+void
+__attribute__ ((target("branch-protection=bti"),
+		patchable_function_entry (1, 0)))
+f10_bti ()
+{
+}
+/* { dg-final { scan-assembler "f10_bti:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-3.c b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
new file mode 100644
index 00000000000..0a1f74d4096
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
@@ -0,0 +1,12 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O1" } */
+
+/* Test the placement of the .LPFE1 label.  */
+
+void
+__attribute__ ((target("branch-protection=bti+pac-ret+leaf"),
+		patchable_function_entry (1, 0)))
+f10_pac ()
+{
+}
+/* { dg-final { scan-assembler "f10_pac:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/arc/delay-slot-limm.c b/gcc/testsuite/gcc.target/arc/delay-slot-limm.c
new file mode 100644
index 00000000000..e5de3c4badd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/delay-slot-limm.c
@@ -0,0 +1,52 @@
+/* We have encountered an issue that a "mov_s.ne" instruction *
+ * with  an  immediate  value  was put in the delay slot of a *
+ * branch:                                                    *
+ *                                                            *
+ * bne.d @.L1      # 33    [c=20 l=4]  *branch_insn           *
+ * mov_s.ne r0,7   # 35    [c=0 l=6]  *movsi_ne/2             *
+ *                                                            *
+ * This is not sanctioned and must not happen. The test below *
+ * is a reduced version of the source  code  leading  to  the *
+ * problem.                                                   */
+
+/* { dg-do compile }               */
+/* { dg-skip-if "" { ! { clmcpu } } } */
+/* { dg-options "-mcpu=archs -Og" } */
+typedef struct
+{
+  struct
+  {
+    int length;
+  } table;
+} room;
+
+struct house
+{
+  room *r;
+};
+
+int glob;
+
+_Bool bar();
+
+int func(struct house *h, int i, int whatever)
+{
+  for (;;)
+  {
+    _Bool a;
+    if (h && h->r[i].table.length == glob)
+    {
+      if (whatever)
+      {
+        a = bar();
+        if (__builtin_expect(!a, 0))
+          return 7;
+      }
+      break;
+    }
+  }
+  return 0;
+}
+
+/* no 'mov_s.ne r,limm' in a delay slot */
+/* { dg-final { scan-assembler-not "bne.d\.*\n\\s\+mov_s.ne\\s+r\[0-9\]+,7" } } */
diff --git a/gcc/testsuite/gcc.target/arc/pic-2.c b/gcc/testsuite/gcc.target/arc/pic-2.c
new file mode 100644
index 00000000000..4b0e17126e9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/pic-2.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-skip-if "PIC not available for ARC6xx" { arc6xx } } */
+/* { dg-options "-mno-sdata -O2 -fpic -fno-builtin" } */
+
+/* Check if we resolve correctly complex PIC addresses.  */
+
+char *foo (unsigned size)
+{
+  static char buf[32];
+  register int i;
+
+  if (size > 31)
+    size = 31;
+
+  for (i = 0; i < size; i++)
+    {
+      buf[i] = ' ';
+    }
+  buf[size] = '\0';
+  return buf;
+}
+
+/* { dg-final { scan-assembler "@buf.\[0-9\]\+@pcl-1" } } */
diff --git a/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c b/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c
new file mode 100644
index 00000000000..e6cbfc0b33e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c
@@ -0,0 +1,14 @@
+/* Test that using an Armv8-a hard-float target doesn't
+   break CRC intrinsics.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_hard_vfp_ok }  */
+/* { dg-options "-mfloat-abi=hard -march=armv8-a+simd+crc" } */
+
+#include <arm_acle.h>
+
+uint32_t
+foo (uint32_t a, uint32_t b)
+{
+  return __crc32cw (a, b);
+}
diff --git a/gcc/testsuite/gcc.target/arm/multilib.exp b/gcc/testsuite/gcc.target/arm/multilib.exp
index d82306ed630..2df3f9c3117 100644
--- a/gcc/testsuite/gcc.target/arm/multilib.exp
+++ b/gcc/testsuite/gcc.target/arm/multilib.exp
@@ -434,6 +434,22 @@ if {[multilib_config "aprofile"] } {
 	check_multi_dir $opts $dir
     }
 }
+if {[multilib_config "rmprofile"] && ![multilib_config "aprofile"]} {
+    foreach {opts dir} {
+	{-mcpu=cortex-a9 -mfpu=auto -mfloat-abi=soft} "thumb/v7/nofp"
+	{-mcpu=cortex-a8 -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-mcpu=cortex-a5 -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-mcpu=cortex-a53 -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-a+fp -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-a+fp -mfpu=auto -mfloat-abi=soft} "thumb/v7/nofp"
+	{-march=armv7-a+mp+simd -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-a -mfpu=vfpv4 -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-a+fp -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-a -mfpu=vfpv4 -mfloat-abi=soft} "thumb/v7/nofp"
+    } {
+	check_multi_dir $opts $dir
+    }
+}
 if {[multilib_config "rmprofile"] } {
     foreach {opts dir} {
 	{-mcpu=cortex-m0 -mfpu=auto -mfloat-abi=soft} "thumb/v6-m/nofp"
@@ -753,6 +769,28 @@ if {[multilib_config "rmprofile"] } {
 	{-march=armv8-m.main+fp.dp -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
 	{-march=armv8-m.main+fp+dsp -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
 	{-march=armv8-m.main+fp.dp+dsp -mfpu=fpv5-d16 -mfloat-abi=softfp} "thumb/v8-m.main+dp/softfp"
+	{-march=armv7-r+fp -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-r+fp -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-r+fp+idiv -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-r+fp+idiv -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-r+vfpv3-d16-fp16 -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-r+vfpv3-d16-fp16 -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-r+vfpv3-d16-fp16+idiv -mfpu=auto -mfloat-abi=softfp} "thumb/v7+fp/softfp"
+	{-march=armv7-r+vfpv3-d16-fp16+idiv -mfpu=auto -mfloat-abi=hard} "thumb/v7+fp/hard"
+	{-march=armv7-r+fp.sp -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv7-r+fp.sp -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv7-r+fp.sp+idiv -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv7-r+fp.sp+idiv -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv7-r+vfpv3xd -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv7-r+vfpv3xd -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv7-r+vfpv3xd+idiv -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv7-r+vfpv3xd+idiv -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv7-r+vfpv3xd-fp16+idiv -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv7-r+vfpv3xd-fp16+idiv -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv8-r+fp.sp -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv8-r+fp.sp -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
+	{-march=armv8-r+crc+fp.sp -mfpu=auto -mfloat-abi=softfp} "thumb/v7-r+fp.sp/softfp"
+	{-march=armv8-r+crc+fp.sp -mfpu=auto -mfloat-abi=hard} "thumb/v7-r+fp.sp/hard"
     } {
 	check_multi_dir $opts $dir
     }
diff --git a/gcc/testsuite/gcc.target/arm/pr45701-1.c b/gcc/testsuite/gcc.target/arm/pr45701-1.c
index 01db15abfd0..2060ae464b3 100644
--- a/gcc/testsuite/gcc.target/arm/pr45701-1.c
+++ b/gcc/testsuite/gcc.target/arm/pr45701-1.c
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
 /* { dg-options "-mthumb -Os" }  */
 /* { dg-final { scan-assembler "push\t\{r3" } } */
-/* { dg-final { scan-assembler-not "\[^\-\]r8" } } */
+/* { dg-final { scan-assembler-not "\[^\-e\]r8" } } */
 
 extern int hist_verify;
 extern int a1;
diff --git a/gcc/testsuite/gcc.target/arm/pr45701-2.c b/gcc/testsuite/gcc.target/arm/pr45701-2.c
index ce66d7509d1..23ca21319a4 100644
--- a/gcc/testsuite/gcc.target/arm/pr45701-2.c
+++ b/gcc/testsuite/gcc.target/arm/pr45701-2.c
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
 /* { dg-options "-mthumb -Os" }  */
 /* { dg-final { scan-assembler "push\t\{r3" } } */
-/* { dg-final { scan-assembler-not "\[^\-\]r8" } } */
+/* { dg-final { scan-assembler-not "\[^\-e\]r8" } } */
 
 extern int hist_verify;
 extern int a1;
diff --git a/gcc/testsuite/gcc.target/arm/pr88167-1.c b/gcc/testsuite/gcc.target/arm/pr88167-1.c
new file mode 100644
index 00000000000..517a86d6e4b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr88167-1.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-options "-O2 -mthumb" }  */
+
+void *retaddr;
+
+void foo (void) {
+  retaddr = __builtin_return_address (0);
+
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+			 "r8", "r9", "r10", "r11", "r12");
+}
+
+/* { dg-final { scan-assembler-not "mov\tlr," } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr88167-2.c b/gcc/testsuite/gcc.target/arm/pr88167-2.c
new file mode 100644
index 00000000000..6a303345eb9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr88167-2.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+int __attribute__((noclone, noinline))
+foo (int a, long long b) {
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3",
+			 "r8", "r9", "r10", "r11", "r12");
+  return (int) b;
+}
+
+int main ()
+{
+  if (foo (1, 0x1000000000000003LL) != 3)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
diff --git a/gcc/testsuite/gcc.target/arm/pure-code/no-literal-pool.c b/gcc/testsuite/gcc.target/arm/pure-code/no-literal-pool.c
index 4b893fd32f7..3de162091d9 100644
--- a/gcc/testsuite/gcc.target/arm/pure-code/no-literal-pool.c
+++ b/gcc/testsuite/gcc.target/arm/pure-code/no-literal-pool.c
@@ -1,12 +1,24 @@
 /* { dg-do compile } */
-/* { dg-options "-mpure-code" } */
+/* { dg-options "-mpure-code -mfp16-format=ieee" } */
 /* { dg-skip-if "" { *-*-* } { "-g" "-fpic" "-fPIC" } { "" } } */
 
+__fp16 hf;
 float sf;
 double df;
 long long l;
 static char *p = "Hello World";
 
+__fp16
+testsfp16 (__fp16 *p)
+{
+  hf = 1.3;
+  *p += hf;
+  if (*p > 1.1234f)
+    return 2.1234f;
+  else
+    return 3.1234f;
+}
+
 float
 testsf (float *p)
 {
diff --git a/gcc/testsuite/gcc.target/arm/pure-code/pure-code.exp b/gcc/testsuite/gcc.target/arm/pure-code/pure-code.exp
index bf7e4add03f..b05cfd6a28c 100644
--- a/gcc/testsuite/gcc.target/arm/pure-code/pure-code.exp
+++ b/gcc/testsuite/gcc.target/arm/pure-code/pure-code.exp
@@ -25,11 +25,8 @@ if ![info exists DEFAULT_CFLAGS] then {
     set DEFAULT_CFLAGS " -ansi -pedantic-errors"
 }
 
-# The -mpure-code option is only available for M-profile targets that support
-# the MOVT instruction.
-if {([check_effective_target_arm_thumb2_ok]
-     || [check_effective_target_arm_thumb1_movt_ok])
-    && [check_effective_target_arm_cortex_m]} then {
+# The -mpure-code option is only available for M-profile targets.
+if {[check_effective_target_arm_cortex_m]} then {
 # Initialize `dg'.
 dg-init
 
@@ -56,4 +53,4 @@ set LTO_TORTURE_OPTIONS ${saved-lto_torture_options}
 
 # All done.
 dg-finish
-}
+#}
diff --git a/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c b/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c
index b989c420830..92772d414a7 100644
--- a/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c
+++ b/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-Os" } */
+/* { dg-skip-if "-mpure-code generates an inline multiplication code sequence" { *-*-* } { "-mpure-code" } } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
 int
diff --git a/gcc/testsuite/gcc.target/i386/avx-pr93637.c b/gcc/testsuite/gcc.target/i386/avx-pr93637.c
new file mode 100644
index 00000000000..9e7a0a7c9c1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx-pr93637.c
@@ -0,0 +1,17 @@
+/* PR target/93637 */
+/* { dg-do compile } */
+/* { dg-options "-mavx -mno-avx2 -O3 --param sccvn-max-alias-queries-per-access=3" } */
+
+double
+foo (void)
+{
+  int i;
+  double r = 7.0;
+  double a[] = { 0.0, 0.0, -0.0, 0.0, 0.0, -0.0, 1.0, 0.0, 0.0, -0.0, 1.0, 0.0, 1.0, 1.0 };
+
+  for (i = 0; i < sizeof (a) / sizeof (a[0]); ++i)
+    if (a[i] == 0.0)
+      r = a[i];
+
+  return r;
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx2-pr93418.c b/gcc/testsuite/gcc.target/i386/avx2-pr93418.c
new file mode 100644
index 00000000000..67ed33ddf9d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx2-pr93418.c
@@ -0,0 +1,20 @@
+/* PR target/93418 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx2 -fdump-tree-optimized" } */
+/* { dg-final { scan-tree-dump-not "link_error" "optimized" } } */
+
+#include <x86intrin.h>
+
+void link_error (void);
+
+void
+foo (void)
+{
+  __m128i a = _mm_set1_epi32 (0xffffffffU);
+  __m128i b = _mm_setr_epi32 (16, 31, -34, 3);
+  __m128i c = _mm_sllv_epi32 (a, b);
+  __v4su d = (__v4su) c;
+  if (d[0] != 0xffff0000U || d[1] != 0x80000000U
+      || d[2] != 0 || d[3] != 0xfffffff8U)
+    link_error ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb-1.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb-1.c
index 3dcd48f7e2a..697757b8b73 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb-1.c
@@ -41,7 +41,7 @@ TEST (void)
   }
 
   res1.x = INTRINSIC (_popcnt_epi8)       (src.x);
-  res2.x = INTRINSIC (_mask_popcnt_epi8)  (src.x, mask, src0.x);
+  res2.x = INTRINSIC (_mask_popcnt_epi8)  (src0.x, mask, src.x);
   res3.x = INTRINSIC (_maskz_popcnt_epi8) (mask, src.x);
 
   if (UNION_CHECK (AVX512F_LEN, i_b) (res1, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb.c
index b23da58dbaf..246f925eede 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntb.c
@@ -13,7 +13,7 @@ int foo ()
   __mmask16 msk;
   __m512i c = _mm512_popcnt_epi8 (z);
   asm volatile ("" : "+v" (c));
-  c = _mm512_mask_popcnt_epi8 (z, msk, z1);
+  c = _mm512_mask_popcnt_epi8 (z1, msk, z);
   asm volatile ("" : "+v" (c));
   c = _mm512_maskz_popcnt_epi8 (msk, z);
   asm volatile ("" : "+v" (c));
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntbvl.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntbvl.c
index e6d60f7596c..8c7f45fc5f7 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntbvl.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntbvl.c
@@ -18,13 +18,13 @@ int foo ()
   __mmask16 msk16;
   __m256i c256 = _mm256_popcnt_epi8 (y);
   asm volatile ("" : "+v" (c256));
-  c256 = _mm256_mask_popcnt_epi8 (y, msk32, y_1);
+  c256 = _mm256_mask_popcnt_epi8 (y_1, msk32, y);
   asm volatile ("" : "+v" (c256));
   c256 = _mm256_maskz_popcnt_epi8 (msk32, y);
   asm volatile ("" : "+v" (c256));
   __m128i c128 = _mm_popcnt_epi8 (x);
   asm volatile ("" : "+v" (c128));
-  c128 = _mm_mask_popcnt_epi8 (x, msk16, x_1);
+  c128 = _mm_mask_popcnt_epi8 (x_1, msk16, x);
   asm volatile ("" : "+v" (c128));
   c128 = _mm_maskz_popcnt_epi8 (msk16, x);
   asm volatile ("" : "+v" (c128));
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw-1.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw-1.c
index 4f866db2f7a..0a725fe012a 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw-1.c
@@ -41,7 +41,7 @@ TEST (void)
   }
 
   res1.x = INTRINSIC (_popcnt_epi16)       (src.x);
-  res2.x = INTRINSIC (_mask_popcnt_epi16)  (src.x, mask, src0.x);
+  res2.x = INTRINSIC (_mask_popcnt_epi16)  (src0.x, mask, src.x);
   res3.x = INTRINSIC (_maskz_popcnt_epi16) (mask, src.x);
 
   if (UNION_CHECK (AVX512F_LEN, i_w) (res1, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw.c
index 2c49583b597..90663f480fc 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntw.c
@@ -13,7 +13,7 @@ int foo ()
   __mmask16 msk;
   __m512i c = _mm512_popcnt_epi16 (z);
   asm volatile ("" : "+v" (c));
-  c = _mm512_mask_popcnt_epi16 (z, msk, z1);
+  c = _mm512_mask_popcnt_epi16 (z1, msk, z);
   asm volatile ("" : "+v" (c));
   c = _mm512_maskz_popcnt_epi16 (msk, z);
   asm volatile ("" : "+v" (c));
diff --git a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntwvl.c b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntwvl.c
index b55adc6023a..3a646b57282 100644
--- a/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntwvl.c
+++ b/gcc/testsuite/gcc.target/i386/avx512bitalg-vpopcntwvl.c
@@ -18,13 +18,13 @@ int foo ()
   __mmask8 msk8;
   __m256i c256 = _mm256_popcnt_epi16 (y);
   asm volatile ("" : "+v" (c256));
-  c256 = _mm256_mask_popcnt_epi16 (y, msk16, y_1);
+  c256 = _mm256_mask_popcnt_epi16 (y_1, msk16, y);
   asm volatile ("" : "+v" (c256));
   c256 = _mm256_maskz_popcnt_epi16 (msk16, y);
   asm volatile ("" : "+v" (c256));
   __m128i c128 = _mm_popcnt_epi16 (x);
   asm volatile ("" : "+v" (c128));
-  c128 = _mm_mask_popcnt_epi16 (x, msk8, x_1);
+  c128 = _mm_mask_popcnt_epi16 (x_1, msk8, x);
   asm volatile ("" : "+v" (c128));
   c128 = _mm_maskz_popcnt_epi16 (msk8, x);
   asm volatile ("" : "+v" (c128));
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr93673.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr93673.c
new file mode 100644
index 00000000000..dc87ed20d1d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr93673.c
@@ -0,0 +1,30 @@
+/* PR target/93673 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512bw" } */
+
+#include <x86intrin.h>
+
+void
+foo (__mmask32 *c, __mmask64 *d)
+{
+  c[0] = _kshiftli_mask32 (c[0], 0);
+  c[1] = _kshiftri_mask32 (c[1], 0);
+  c[2] = _kshiftli_mask32 (c[2], 1);
+  c[3] = _kshiftri_mask32 (c[3], 1);
+  c[4] = _kshiftli_mask32 (c[4], 31);
+  c[5] = _kshiftri_mask32 (c[5], 31);
+  c[6] = _kshiftli_mask32 (c[6], 0x7f);
+  c[7] = _kshiftri_mask32 (c[7], 0x7f);
+  c[8] = _kshiftli_mask32 (c[8], 0xff);
+  c[9] = _kshiftri_mask32 (c[9], 0xff);
+  d[0] = _kshiftli_mask64 (d[0], 0);
+  d[1] = _kshiftri_mask64 (d[1], 0);
+  d[2] = _kshiftli_mask64 (d[2], 1);
+  d[3] = _kshiftri_mask64 (d[3], 1);
+  d[4] = _kshiftli_mask64 (d[4], 63);
+  d[5] = _kshiftri_mask64 (d[5], 63);
+  d[6] = _kshiftli_mask64 (d[6], 0x7f);
+  d[7] = _kshiftri_mask64 (d[7], 0x7f);
+  d[8] = _kshiftli_mask64 (d[8], 0xff);
+  d[9] = _kshiftri_mask64 (d[9], 0xff);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512dq-pr93673.c b/gcc/testsuite/gcc.target/i386/avx512dq-pr93673.c
new file mode 100644
index 00000000000..3ae1674e4a4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512dq-pr93673.c
@@ -0,0 +1,20 @@
+/* PR target/93673 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512dq" } */
+
+#include <x86intrin.h>
+
+void
+foo (__mmask8 *a)
+{
+  a[0] = _kshiftli_mask8 (a[0], 0);
+  a[1] = _kshiftri_mask8 (a[1], 0);
+  a[2] = _kshiftli_mask8 (a[2], 1);
+  a[3] = _kshiftri_mask8 (a[3], 1);
+  a[4] = _kshiftli_mask8 (a[4], 7);
+  a[5] = _kshiftri_mask8 (a[5], 7);
+  a[6] = _kshiftli_mask8 (a[6], 0x7f);
+  a[7] = _kshiftri_mask8 (a[7], 0x7f);
+  a[8] = _kshiftli_mask8 (a[8], 0xff);
+  a[9] = _kshiftri_mask8 (a[9], 0xff);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr93673.c b/gcc/testsuite/gcc.target/i386/avx512f-pr93673.c
new file mode 100644
index 00000000000..963823c8a78
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr93673.c
@@ -0,0 +1,20 @@
+/* PR target/93673 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512f" } */
+
+#include <x86intrin.h>
+
+void
+foo (__mmask16 *b)
+{
+  b[0] = _kshiftli_mask16 (b[0], 0);
+  b[1] = _kshiftri_mask16 (b[1], 0);
+  b[2] = _kshiftli_mask16 (b[2], 1);
+  b[3] = _kshiftri_mask16 (b[3], 1);
+  b[4] = _kshiftli_mask16 (b[4], 15);
+  b[5] = _kshiftri_mask16 (b[5], 15);
+  b[6] = _kshiftli_mask16 (b[6], 0x7f);
+  b[7] = _kshiftri_mask16 (b[7], 0x7f);
+  b[8] = _kshiftli_mask16 (b[8], 0xff);
+  b[9] = _kshiftri_mask16 (b[9], 0xff);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshld-1.c b/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshld-1.c
new file mode 100644
index 00000000000..0b29923b721
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshld-1.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512vbmi2 -mavx512bw -O2" } */
+/* { dg-final { scan-assembler-times "vpshldw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshldq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+
+#include <immintrin.h>
+
+volatile __m512i x,y;
+volatile __mmask32 m32;
+volatile __mmask16 m16;
+volatile __mmask8 m8;
+
+void extern
+avx512f_test (void)
+{
+  x = _mm512_shldi_epi16 (x, y, 3);
+  x = _mm512_maskz_shldi_epi16 (m32, x, y, 3);
+  x = _mm512_mask_shldi_epi16 (x, m32, y, x, 3);
+
+  x = _mm512_shldi_epi32 (x, y, 3);
+  x = _mm512_maskz_shldi_epi32 (m16, x, y, 3);
+  x = _mm512_mask_shldi_epi32 (x, m16, y, x, 3);
+
+  x = _mm512_shldi_epi64 (x, y, 3);
+  x = _mm512_maskz_shldi_epi64 (m8, x, y, 3);
+  x = _mm512_mask_shldi_epi64 (x, m8, y, x, 3);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshrd-1.c b/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshrd-1.c
new file mode 100644
index 00000000000..bb4de785244
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vbmi2-vpshrd-1.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512vbmi2 -mavx512bw -O2" } */
+/* { dg-final { scan-assembler-times "vpshrdw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdw\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdd\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+\[^\n\r]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vpshrdq\[ \\t\]+\[^\{\n\]*\\\$3\[^\n\r]*%zmm\[0-9\]+\[^\\n\\r]*%zmm\[0-9\]+\[^\\n\\r\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
+
+#include <immintrin.h>
+
+volatile __m512i x,y;
+volatile __mmask32 m32;
+volatile __mmask16 m16;
+volatile __mmask8 m8;
+
+void extern
+avx512f_test (void)
+{
+  x = _mm512_shrdi_epi16 (x, y, 3);
+  x = _mm512_maskz_shrdi_epi16 (m32, x, y, 3);
+  x = _mm512_mask_shrdi_epi16 (x, m32, y, x, 3);
+
+  x = _mm512_shrdi_epi32 (x, y, 3);
+  x = _mm512_maskz_shrdi_epi32 (m16, x, y, 3);
+  x = _mm512_mask_shrdi_epi32 (x, m16, y, x, 3);
+
+  x = _mm512_shrdi_epi64 (x, y, 3);
+  x = _mm512_maskz_shrdi_epi64 (m8, x, y, 3);
+  x = _mm512_mask_shrdi_epi64 (x, m8, y, x, 3);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr93009.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr93009.c
new file mode 100644
index 00000000000..4dfc4a9f3c3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr93009.c
@@ -0,0 +1,38 @@
+/* PR target/93009 */
+/* { dg-do run { target { avx512vl } } } */
+/* { dg-options "-O2 -mavx512vl" } */
+
+#define AVX512VL
+#define AVX512F_LEN 512
+#define AVX512F_LEN_HALF 256
+
+#include "avx512f-check.h"
+
+typedef double v2df __attribute__((vector_size (16)));
+
+__attribute__((noipa)) v2df
+foo (v2df x, v2df y, double *z)
+{
+  return x * y + (v2df) { z[0], z[0] };
+}
+
+__attribute__((noipa)) v2df
+bar (v2df x, v2df y, double *z)
+{
+  return y * x + (v2df) { z[0], z[0] };
+}
+
+static void
+test_256 (void)
+{
+}
+
+static void
+test_128 (void)
+{
+  double z = 5.0;
+  v2df x = foo ((v2df) { 1.0, 2.0 }, (v2df) { 3.0, 4.0 }, &z);
+  v2df y = bar ((v2df) { 6.0, 7.0 }, (v2df) { 8.0, 9.0 }, &z);
+  if (x[0] != 8.0 || x[1] != 13.0 || y[0] != 53.0 || y[1] != 68.0)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr93670.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr93670.c
new file mode 100644
index 00000000000..3f232a96901
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr93670.c
@@ -0,0 +1,77 @@
+/* PR target/93670 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512vl -mno-avx512dq" } */
+
+#include <x86intrin.h>
+
+__m128i
+f1 (__m256i x)
+{
+  return _mm256_extracti32x4_epi32 (x, 0);
+}
+
+__m128i
+f2 (__m256i x, __m128i w, __mmask8 m)
+{
+  return _mm256_mask_extracti32x4_epi32 (w, m, x, 0);
+}
+
+__m128i
+f3 (__m256i x, __mmask8 m)
+{
+  return _mm256_maskz_extracti32x4_epi32 (m, x, 0);
+}
+
+__m128
+f4 (__m256 x)
+{
+  return _mm256_extractf32x4_ps (x, 0);
+}
+
+__m128
+f5 (__m256 x, __m128 w, __mmask8 m)
+{
+  return _mm256_mask_extractf32x4_ps (w, m, x, 0);
+}
+
+__m128
+f6 (__m256 x, __mmask8 m)
+{
+  return _mm256_maskz_extractf32x4_ps (m, x, 0);
+}
+
+__m128i
+f7 (__m256i x)
+{
+  return _mm256_extracti32x4_epi32 (x, 1);
+}
+
+__m128i
+f8 (__m256i x, __m128i w, __mmask8 m)
+{
+  return _mm256_mask_extracti32x4_epi32 (w, m, x, 1);
+}
+
+__m128i
+f9 (__m256i x, __mmask8 m)
+{
+  return _mm256_maskz_extracti32x4_epi32 (m, x, 1);
+}
+
+__m128
+f10 (__m256 x)
+{
+  return _mm256_extractf32x4_ps (x, 1);
+}
+
+__m128
+f11 (__m256 x, __m128 w, __mmask8 m)
+{
+  return _mm256_mask_extractf32x4_ps (w, m, x, 1);
+}
+
+__m128
+f12 (__m256 x, __mmask8 m)
+{
+  return _mm256_maskz_extractf32x4_ps (m, x, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd-1.c b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd-1.c
index 245dcd4d534..e7d6bb4dd53 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd-1.c
@@ -40,7 +40,7 @@ TEST (void)
   }
 
   res1.x = INTRINSIC (_popcnt_epi32)       (src.x);
-  res2.x = INTRINSIC (_mask_popcnt_epi32)  (src.x, mask, src0.x);
+  res2.x = INTRINSIC (_mask_popcnt_epi32)  (src0.x, mask, src.x);
   res3.x = INTRINSIC (_maskz_popcnt_epi32) (mask, src.x);
 
   if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd.c b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd.c
index c70f226824e..b4d82f97032 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntd.c
@@ -22,19 +22,19 @@ int foo ()
   __mmask8 msk8;
   __m128i a = _mm_popcnt_epi32 (x);
   asm volatile ("" : "+v" (a));
-  a = _mm_mask_popcnt_epi32 (x, msk8, x_1);
+  a = _mm_mask_popcnt_epi32 (x_1, msk8, x);
   asm volatile ("" : "+v" (a));
   a = _mm_maskz_popcnt_epi32 (msk8, x);
   asm volatile ("" : "+v" (a));
   __m256i b = _mm256_popcnt_epi32 (y);
   asm volatile ("" : "+v" (b));
-  b = _mm256_mask_popcnt_epi32 (y, msk8, y_1);
+  b = _mm256_mask_popcnt_epi32 (y_1, msk8, y);
   asm volatile ("" : "+v" (b));
   b = _mm256_maskz_popcnt_epi32 (msk8, y);
   asm volatile ("" : "+v" (b));
   __m512i c = _mm512_popcnt_epi32 (z);
   asm volatile ("" : "+v" (c));
-  c = _mm512_mask_popcnt_epi32 (z, msk, z_1);
+  c = _mm512_mask_popcnt_epi32 (z_1, msk, z);
   asm volatile ("" : "+v" (c));
   c = _mm512_maskz_popcnt_epi32 (msk, z);
   asm volatile ("" : "+v" (c));
diff --git a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq-1.c b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq-1.c
index 27555c496d6..2144cf32c0d 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq-1.c
@@ -40,7 +40,7 @@ TEST (void)
   }
 
   res1.x = INTRINSIC (_popcnt_epi64)       (src.x);
-  res2.x = INTRINSIC (_mask_popcnt_epi64)  (src.x, mask, src0.x);
+  res2.x = INTRINSIC (_mask_popcnt_epi64)  (src0.x, mask, src.x);
   res3.x = INTRINSIC (_maskz_popcnt_epi64) (mask, src.x);
 
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq.c b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq.c
index 9f400c005f3..e87d6c999b6 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vpopcntdq-vpopcntq.c
@@ -21,19 +21,19 @@ int foo ()
   __mmask8 msk; 
   __m128i a = _mm_popcnt_epi64 (x);
   asm volatile ("" : "+v" (a));
-  a = _mm_mask_popcnt_epi64 (x, msk, x_1);
+  a = _mm_mask_popcnt_epi64 (x_1, msk, x);
   asm volatile ("" : "+v" (a));
   a = _mm_maskz_popcnt_epi64 (msk, x);
   asm volatile ("" : "+v" (a));
   __m256i b = _mm256_popcnt_epi64 (y);
   asm volatile ("" : "+v" (b));
-  b = _mm256_mask_popcnt_epi64 (y, msk, y_1);
+  b = _mm256_mask_popcnt_epi64 (y_1, msk, y);
   asm volatile ("" : "+v" (b));
   b = _mm256_maskz_popcnt_epi64 (msk, y);
   asm volatile ("" : "+v" (b));
   __m512i c = _mm512_popcnt_epi64 (z);
   asm volatile ("" : "+v" (c));
-  c = _mm512_mask_popcnt_epi64 (z, msk, z_1);
+  c = _mm512_mask_popcnt_epi64 (z_1, msk, z);
   asm volatile ("" : "+v" (c));
   c = _mm512_maskz_popcnt_epi64 (msk, z); 
   asm volatile ("" : "+v" (c));
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
index 052d24dabdf..e2914a8333c 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
index 2cfbd728b4b..d2b7c74b143 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
index 59bb08613b7..129fb2125f0 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
index 59640fab8f1..01996fb029f 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
index 8620bf1d836..1493e18243b 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
@@ -17,7 +17,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
index 42e83416965..3ddd4980b69 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
index 6a9c51337d9..43d5f95b4fb 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
@@ -17,7 +17,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
index 85ec57b5a8d..bf62636c63c 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
@@ -16,7 +16,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
index db1d8fb9979..27ba82932e4 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
@@ -17,7 +17,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
index 24fc43b3ba5..bdf15d36bac 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
@@ -16,7 +16,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
index 3dc02f80ff5..c30c331c23b 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
index c4adae23dd3..7edd7313027 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
index b800b40b055..8e391797c5e 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
index f68902ddc25..6033d13e8a7 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
@@ -15,6 +15,6 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
index 7301490d49c..ef3577d2934 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
index ef1ba02978d..f26a5fb9015 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
@@ -14,7 +14,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
index 58de8f0393e..3b8a1eeaffb 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
index 3be3ce07527..40d31803a2e 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
@@ -15,7 +15,7 @@ male_indirect_jump (long offset)
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-2.c b/gcc/testsuite/gcc.target/i386/pr32219-2.c
index cb587db47aa..b6212f7dd4c 100644
--- a/gcc/testsuite/gcc.target/i386/pr32219-2.c
+++ b/gcc/testsuite/gcc.target/i386/pr32219-2.c
@@ -20,5 +20,5 @@ foo ()
 /* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
 
 /* Darwin m32 defaults to PIC but common symbols need to be indirected.  */
-/* { dg-final { scan-assembler {movl[ \t]l_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-3.c b/gcc/testsuite/gcc.target/i386/pr32219-3.c
index f9cfca7d72c..a1b0df28d0d 100644
--- a/gcc/testsuite/gcc.target/i386/pr32219-3.c
+++ b/gcc/testsuite/gcc.target/i386/pr32219-3.c
@@ -24,4 +24,4 @@ foo ()
 
 /* For Darwin, we need PIC to allow PIE, but also we must indirect weak symbols so that
    they can be indirected.  Again, dyld knows how to deal with this. */
-/* { dg-final { scan-assembler {movl[ \t]l_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-4.c b/gcc/testsuite/gcc.target/i386/pr32219-4.c
index 0ac0674ae17..31d0710b7ed 100644
--- a/gcc/testsuite/gcc.target/i386/pr32219-4.c
+++ b/gcc/testsuite/gcc.target/i386/pr32219-4.c
@@ -21,4 +21,4 @@ foo ()
 /* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
 
 /* Darwin m32 equivalent (indirect and PIC).  */
-/* { dg-final { scan-assembler {movl[ \t]l_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-7.c b/gcc/testsuite/gcc.target/i386/pr32219-7.c
index 469e9e38b07..20fef8dd063 100644
--- a/gcc/testsuite/gcc.target/i386/pr32219-7.c
+++ b/gcc/testsuite/gcc.target/i386/pr32219-7.c
@@ -23,4 +23,4 @@ foo ()
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
 
 /* Darwin m32 equivalent (indirect and PIC).  */
-/* { dg-final { scan-assembler {movl[ \t]l_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-8.c b/gcc/testsuite/gcc.target/i386/pr32219-8.c
index 75eb287fc59..767928f049e 100644
--- a/gcc/testsuite/gcc.target/i386/pr32219-8.c
+++ b/gcc/testsuite/gcc.target/i386/pr32219-8.c
@@ -21,4 +21,4 @@ foo ()
 /* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
 
 /* Darwin m32 default to PIC but needs indirection for the weak symbol.  */
-/* { dg-final { scan-assembler {movl[ \t]l_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr65782.c b/gcc/testsuite/gcc.target/i386/pr65782.c
new file mode 100644
index 00000000000..298dca1be97
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr65782.c
@@ -0,0 +1,16 @@
+/* PR target/65782 */
+/* { dg-do assemble { target { avx512vl && { ! ia32 } } } } */
+/* { dg-options "-O2 -mavx512vl" } */
+
+void
+foo (void)
+{
+  register double x __asm ("xmm14");
+  register double y __asm ("xmm18");
+  asm ("" : "=x" (x));
+  asm ("" : "=v" (y));
+  x += y;
+  y += x;
+  asm ("" : : "x" (x));
+  asm ("" : : "v" (y));
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85667-10.c b/gcc/testsuite/gcc.target/i386/pr85667-10.c
new file mode 100644
index 00000000000..e8f3026227d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85667-10.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -masm=att" } */
+/* { dg-final { scan-assembler-times "movq\[ \t\]*%rcx, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movq\[ \t\]*%rdx, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movq\[ \t\]*%r8, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movq\[ \t\]*%r9, .*" 1 } } */
+/* { dg-final { scan-assembler-times "addsd\[ \t]*40\\\(%rsp\\\), .*" 1 } } */
+/* { dg-final { scan-assembler-times "movq\[^\n\r\]*, %rax" 1 } } */
+
+typedef struct
+{
+  double x;
+} Double;
+
+Double  __attribute__((ms_abi))
+fn1 (Double x1, Double x2, Double x3, Double x4, Double x5)
+{
+  Double v;
+  v.x = x1.x + x2.x + x3.x + x4.x + x5.x;
+  return v;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85667-7.c b/gcc/testsuite/gcc.target/i386/pr85667-7.c
new file mode 100644
index 00000000000..6bd860975a7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85667-7.c
@@ -0,0 +1,36 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O2" } */
+
+void abort (void);
+
+typedef struct
+{
+  float x;
+} Float;
+
+Float  __attribute__((ms_abi, noinline, noclone))
+fn1 (Float x1, Float x2, Float x3, Float x4, Float x5)
+{
+  Float v;
+  v.x = x1.x + x2.x + x3.x + x4.x + x5.x;
+  return v;
+}
+int main ()
+{
+  Float a, a1, a2, a3, a4, a5;
+  float x1 = 1.1;
+  float x2 = 3.1;
+  float x3 = 4.2;
+  float x4 = 14.2;
+  float x5 = -7.2;
+  float x = x1 + x2 + x3 + x4 + x5;
+  a1.x = x1;
+  a2.x = x2;
+  a3.x = x3;
+  a4.x = x4;
+  a5.x = x5;
+  a = fn1 (a1, a2, a3, a4, a5);
+  if (a.x == x);
+    return 0; 
+  abort ();   
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85667-8.c b/gcc/testsuite/gcc.target/i386/pr85667-8.c
new file mode 100644
index 00000000000..09a7593fdb3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85667-8.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -masm=att" } */
+/* { dg-final { scan-assembler-times "movd\[ \t\]*%ecx, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movd\[ \t\]*%edx, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movd\[ \t\]*%r8d, .*" 1 } } */
+/* { dg-final { scan-assembler-times "movd\[ \t\]*%r9d, .*" 1 } } */
+/* { dg-final { scan-assembler-times "addss\[ \t]*40\\\(%rsp\\\), .*" 1 } } */
+/* { dg-final { scan-assembler-times "movd\[^\n\r\]*, %eax" 1 } } */
+
+typedef struct
+{
+  float x;
+} Float;
+
+Float  __attribute__((ms_abi))
+fn1 (Float x1, Float x2, Float x3, Float x4, Float x5)
+{
+  Float v;
+  v.x = x1.x + x2.x + x3.x + x4.x + x5.x;
+  return v;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85667-9.c b/gcc/testsuite/gcc.target/i386/pr85667-9.c
new file mode 100644
index 00000000000..8c9279a18bf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85667-9.c
@@ -0,0 +1,36 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O2" } */
+
+void abort (void);
+
+typedef struct
+{
+  double x;
+} Double;
+
+Double  __attribute__((ms_abi, noinline, noclone))
+fn1 (Double x1, Double x2, Double x3, Double x4, Double x5)
+{
+  Double v;
+  v.x = x1.x + x2.x + x3.x + x4.x + x5.x;
+  return v;
+}
+int main ()
+{
+  Double a, a1, a2, a3, a4, a5;
+  double x1 = 1.1;
+  double x2 = 3.1;
+  double x3 = 4.2;
+  double x4 = 14.2;
+  double x5 = -7.2;
+  double x = x1 + x2 + x3 + x4 + x5;
+  a1.x = x1;
+  a2.x = x2;
+  a3.x = x3;
+  a4.x = x4;
+  a5.x = x5;
+  a = fn1 (a1, a2, a3, a4, a5);
+  if (a.x == x);
+    return 0; 
+  abort ();   
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr87853.c b/gcc/testsuite/gcc.target/i386/pr87853.c
new file mode 100644
index 00000000000..9a288879679
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr87853.c
@@ -0,0 +1,20 @@
+/* PR target/87853 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -msse2 -mno-sse3 -masm=att" } */
+/* { dg-final { scan-assembler-times "\tpcmpgtb\t%xmm" 2 } } */
+/* { dg-final { scan-assembler-not "\tpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m128i
+foo (__m128i x, __m128i y)
+{
+  return _mm_cmpgt_epi8 (x, y);
+}
+
+__m128i
+bar (__m128i x, __m128i y)
+{
+  return _mm_cmplt_epi8 (x, y);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr90867.c b/gcc/testsuite/gcc.target/i386/pr90867.c
new file mode 100644
index 00000000000..1ed96b582ed
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr90867.c
@@ -0,0 +1,30 @@
+/* PR target/90867 */
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O2 -msse2" } */
+
+unsigned long long freq = 3600000000UL;   /* 3.6 GHz = 3600.0 MHz */
+
+__attribute__((noipa)) void
+bar (double x)
+{
+  static double d = 3600000000.0;
+  if (x != d)
+    __builtin_abort ();
+  d /= 1000.0;
+}
+
+__attribute__ ((target ("arch=x86-64"))) int
+foo ()
+{
+  bar ((double) freq);
+  bar (1e-3 * freq);
+  bar (1e-6 * freq);
+  bar (1e-9 * freq);
+  return 0;
+}
+
+int
+main ()
+{
+  return foo ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr91298-1.c b/gcc/testsuite/gcc.target/i386/pr91298-1.c
new file mode 100644
index 00000000000..fc7950ca8ed
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr91298-1.c
@@ -0,0 +1,15 @@
+/* PR target/91298 */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -g -fdollars-in-identifiers" } */
+/* { dg-xfail-if "No support for $ in identifiers" { *-*-solaris2.* && { ! gas } } } */
+
+int $a[18];
+int *foo (void) { return &$a[0]; }
+int *bar (int x) { return &$a[x]; }
+int baz (void) { return $a[0]; }
+int qux (void) { return $a[4]; }
+int $quux (void) { return 1; }
+int corge (void) { return $quux (); }
+int grault (void) { return $quux () + 1; }
+typedef int (*fn) (void);
+fn foobar (void) { return $quux; }
diff --git a/gcc/testsuite/gcc.target/i386/pr91298-2.c b/gcc/testsuite/gcc.target/i386/pr91298-2.c
new file mode 100644
index 00000000000..f2d7d3a2907
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr91298-2.c
@@ -0,0 +1,6 @@
+/* PR target/91298 */
+/* { dg-do assemble { target fpic } } */
+/* { dg-options "-O2 -g -fdollars-in-identifiers -fpic" } */
+/* { dg-xfail-if "No support for $ in identifiers" { *-*-solaris2.* && { ! gas } } } */
+
+#include "pr91298-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr91623.c b/gcc/testsuite/gcc.target/i386/pr91623.c
new file mode 100644
index 00000000000..94de4f91c6d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr91623.c
@@ -0,0 +1,32 @@
+/* PR middle-end/91623 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -msse4.1 -mno-sse4.2" } */
+
+typedef long long V __attribute__((__vector_size__(16)));
+V e, h;
+int d;
+const int i;
+
+void foo (void);
+
+void
+bar (int k, int l)
+{
+  if (d && 0 <= k - 1 && l)
+    foo ();
+}
+
+void
+baz (void)
+{
+  V n = (V) { 1 };
+  V g = (V) {};
+  V o = g;
+  for (int f = 0; f < i; ++f)
+    {
+      V a = o == n;
+      h = a;
+      bar (f, i);
+      o = e;
+    }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr91704.c b/gcc/testsuite/gcc.target/i386/pr91704.c
new file mode 100644
index 00000000000..b996e24ad74
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr91704.c
@@ -0,0 +1,14 @@
+/* PR target/91704 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -mavx2 -mavx512f -masm=att" } */
+/* { dg-final { scan-assembler-times "\tvpcmpgtb\t%ymm" 1 } } */
+/* { dg-final { scan-assembler-not "\tvpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tvpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m256i
+foo (__m256i x, __m256i y)
+{
+  return _mm256_cmpgt_epi8 (x, y);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr92225.c b/gcc/testsuite/gcc.target/i386/pr92225.c
new file mode 100644
index 00000000000..b1232195b45
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr92225.c
@@ -0,0 +1,19 @@
+/* PR target/92225 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -msse2 -mno-sse4" } */
+
+void a (long);
+
+unsigned *b;
+
+void
+c ()
+{
+  long d = 2;
+  int e = 0;
+  
+  for (; e < 1024; e++)
+    if (b[e] > d)
+      d = b[e];
+  a (d);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr92615.c b/gcc/testsuite/gcc.target/i386/pr92615.c
new file mode 100644
index 00000000000..b84bfcdabbe
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr92615.c
@@ -0,0 +1,45 @@
+/* PR target/92615 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void *a;
+long long b;
+char c;
+
+void
+foo (void)
+{
+  void *p;
+  long long q;
+  char r;
+  __asm__ ("" : : "r" (&p), "r" (&q), "r" (&r));
+  __asm__ ("" : "=@cca" (p));
+  a = p;
+  __asm__ ("" : "=@cca" (q));
+  b = q;
+  __asm__ ("" : "=@cca" (r));
+  c = r;
+  __asm__ ("" : : "r" (&p), "r" (&q), "r" (&r));
+}
+
+void
+bar (void)
+{
+  void *p;
+  long long q;
+  char r;
+  __asm__ ("" : "=@cca" (p));
+  a = p;
+  __asm__ ("" : "=@cca" (q));
+  b = q;
+  __asm__ ("" : "=@cca" (r));
+  c = r;
+  __asm__ ("" : : "r" (p), "A" (q), "q" (r));
+}
+
+void
+baz (void)
+{
+  void *p = (void *) &p;
+  __asm__ __volatile__ ("" : "=@ccng" (p) : "r" (1));
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr93088.c b/gcc/testsuite/gcc.target/i386/pr93088.c
new file mode 100644
index 00000000000..dc986cfaa80
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93088.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/93088 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -funroll-loops -fno-tree-dominator-opts -fno-tree-vrp -w" } */
+
+#include "pr56348.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr93656.c b/gcc/testsuite/gcc.target/i386/pr93656.c
new file mode 100644
index 00000000000..f0ac8c8edaa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93656.c
@@ -0,0 +1,4 @@
+/* { dg-do run { target { ia32 && cet } } } */
+/* { dg-options "-O2 -fcf-protection" } */
+
+#include "pr67770.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr93696-1.c b/gcc/testsuite/gcc.target/i386/pr93696-1.c
new file mode 100644
index 00000000000..128bb98c066
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93696-1.c
@@ -0,0 +1,79 @@
+/* PR target/93696 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512bitalg -mavx512vpopcntdq -mavx512vl -mavx512bw -masm=att" } */
+/* { dg-final { scan-assembler-times "vpopcnt\[bwdq]\t%\[xyz]mm1, %\[xyz]mm0\{%k\[0-7]\}\[^\{]" 12 } } */
+/* { dg-final { scan-assembler-not "vmovdq\[au]\[0-9]" } } */
+
+#include <x86intrin.h>
+
+__m128i
+f1 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_mask_popcnt_epi64 (x, m, y);
+}
+
+__m128i
+f2 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_mask_popcnt_epi32 (x, m, y);
+}
+
+__m128i
+f3 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_mask_popcnt_epi16 (x, m, y);
+}
+
+__m128i
+f4 (__m128i x, __mmask16 m, __m128i y)
+{
+  return _mm_mask_popcnt_epi8 (x, m, y);
+}
+
+__m256i
+f5 (__m256i x, __mmask8 m, __m256i y)
+{
+  return _mm256_mask_popcnt_epi64 (x, m, y);
+}
+
+__m256i
+f6 (__m256i x, __mmask8 m, __m256i y)
+{
+  return _mm256_mask_popcnt_epi32 (x, m, y);
+}
+
+__m256i
+f7 (__m256i x, __mmask16 m, __m256i y)
+{
+  return _mm256_mask_popcnt_epi16 (x, m, y);
+}
+
+__m256i
+f8 (__m256i x, __mmask32 m, __m256i y)
+{
+  return _mm256_mask_popcnt_epi8 (x, m, y);
+}
+
+__m512i
+f9 (__m512i x, __mmask8 m, __m512i y)
+{
+  return _mm512_mask_popcnt_epi64 (x, m, y);
+}
+
+__m512i
+f10 (__m512i x, __mmask16 m, __m512i y)
+{
+  return _mm512_mask_popcnt_epi32 (x, m, y);
+}
+
+__m512i
+f11 (__m512i x, __mmask32 m, __m512i y)
+{
+  return _mm512_mask_popcnt_epi16 (x, m, y);
+}
+
+__m512i
+f12 (__m512i x, __mmask64 m, __m512i y)
+{
+  return _mm512_mask_popcnt_epi8 (x, m, y);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr93696-2.c b/gcc/testsuite/gcc.target/i386/pr93696-2.c
new file mode 100644
index 00000000000..25a298aea18
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93696-2.c
@@ -0,0 +1,79 @@
+/* PR target/93696 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx512bitalg -mavx512vpopcntdq -mavx512vl -mavx512bw -masm=att" } */
+/* { dg-final { scan-assembler-times "vpopcnt\[bwdq]\t%\[xyz]mm1, %\[xyz]mm0\{%k\[0-7]\}\{z\}" 12 } } */
+/* { dg-final { scan-assembler-not "vmovdq\[au]\[0-9]" } } */
+
+#include <x86intrin.h>
+
+__m128i
+f1 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_maskz_popcnt_epi64 (m, y);
+}
+
+__m128i
+f2 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_maskz_popcnt_epi32 (m, y);
+}
+
+__m128i
+f3 (__m128i x, __mmask8 m, __m128i y)
+{
+  return _mm_maskz_popcnt_epi16 (m, y);
+}
+
+__m128i
+f4 (__m128i x, __mmask16 m, __m128i y)
+{
+  return _mm_maskz_popcnt_epi8 (m, y);
+}
+
+__m256i
+f5 (__m256i x, __mmask8 m, __m256i y)
+{
+  return _mm256_maskz_popcnt_epi64 (m, y);
+}
+
+__m256i
+f6 (__m256i x, __mmask8 m, __m256i y)
+{
+  return _mm256_maskz_popcnt_epi32 (m, y);
+}
+
+__m256i
+f7 (__m256i x, __mmask16 m, __m256i y)
+{
+  return _mm256_maskz_popcnt_epi16 (m, y);
+}
+
+__m256i
+f8 (__m256i x, __mmask32 m, __m256i y)
+{
+  return _mm256_maskz_popcnt_epi8 (m, y);
+}
+
+__m512i
+f9 (__m512i x, __mmask8 m, __m512i y)
+{
+  return _mm512_maskz_popcnt_epi64 (m, y);
+}
+
+__m512i
+f10 (__m512i x, __mmask16 m, __m512i y)
+{
+  return _mm512_maskz_popcnt_epi32 (m, y);
+}
+
+__m512i
+f11 (__m512i x, __mmask32 m, __m512i y)
+{
+  return _mm512_maskz_popcnt_epi16 (m, y);
+}
+
+__m512i
+f12 (__m512i x, __mmask64 m, __m512i y)
+{
+  return _mm512_maskz_popcnt_epi8 (m, y);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr93743.c b/gcc/testsuite/gcc.target/i386/pr93743.c
new file mode 100644
index 00000000000..c0e9d2c3e2c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93743.c
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -mfpmath=387" } */
+
+void
+__attribute__((noinline))
+test (long double x, long double y)
+{
+  long double ldbl_n = __builtin_atan2l (x, y);
+  long double ldbl_s = __builtin_atan2l (y, x);  // arguments swapped
+
+  if (ldbl_n < 1.L ||  1.L < ldbl_s)
+    __builtin_abort ();
+
+  double dbl_n = __builtin_atan2  (x, y);
+  double dbl_s = __builtin_atan2  (y, x);  // arguments swapped
+
+  if (dbl_n < 1. ||  1. < dbl_s)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  long double x = 0.922766L;
+  long double y = 0.080466L;
+
+  test (x, y);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
index 3eaddee8c34..881f541772c 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
@@ -19,6 +19,6 @@ foo (void)
 /* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
index 2793f72cdc1..5687440bf31 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
@@ -19,6 +19,6 @@ foo (void)
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
index 63af6741e05..3d4497000dc 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
@@ -17,7 +17,7 @@ foo (void)
 /* { dg-final { scan-assembler "_?__x86_return_thunk:" } } */
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
-/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
 /* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/sse-12.c b/gcc/testsuite/gcc.target/i386/sse-12.c
index f7f55f4317e..84a231fba8f 100644
--- a/gcc/testsuite/gcc.target/i386/sse-12.c
+++ b/gcc/testsuite/gcc.target/i386/sse-12.c
@@ -3,7 +3,7 @@
    popcntintrin.h gfniintrin.h and mm_malloc.h are usable
    with -O -std=c89 -pedantic-errors.  */
 /* { dg-do compile } */
-/* { dg-options "-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
+/* { dg-options "-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512vbmi2 -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
 
 #include <x86intrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/sse-13.c b/gcc/testsuite/gcc.target/i386/sse-13.c
index e868f6d293f..c544fbd7c15 100644
--- a/gcc/testsuite/gcc.target/i386/sse-13.c
+++ b/gcc/testsuite/gcc.target/i386/sse-13.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512vl -mavx512dq -mavx512bw -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
+/* { dg-options "-O2 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512vl -mavx512dq -mavx512bw -mavx512vbmi -mavx512vbmi2 -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd" } */
 /* { dg-add-options bind_pic_locally } */
 
 #include <mm_malloc.h>
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 748339f7d47..99719325773 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O0 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mpconfig -mwbnoinvd" } */
+/* { dg-options "-O0 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx512vbmi2 -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mpconfig -mwbnoinvd" } */
 /* { dg-add-options bind_pic_locally } */
 
 #include <mm_malloc.h>
@@ -315,6 +315,24 @@ test_2 (_mm_sqrt_round_sd, __m128d, __m128d, __m128d, 9)
 test_2 (_mm_sqrt_round_ss, __m128, __m128, __m128, 9)
 test_2 (_mm_sub_round_sd, __m128d, __m128d, __m128d, 9)
 test_2 (_mm_sub_round_ss, __m128, __m128, __m128, 9)
+test_2 (_mm512_shrdi_epi16, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shrdi_epi32, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shrdi_epi64, __m512i, __m512i, __m512i, 1)
+test_2 (_mm256_shrdi_epi16, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shrdi_epi32, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shrdi_epi64, __m256i, __m256i, __m256i, 1)
+test_2 (_mm_shrdi_epi16, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shrdi_epi32, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shrdi_epi64, __m128i, __m128i, __m128i, 1)
+test_2 (_mm512_shldi_epi16, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shldi_epi32, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shldi_epi64, __m512i, __m512i, __m512i, 1)
+test_2 (_mm256_shldi_epi16, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shldi_epi32, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shldi_epi64, __m256i, __m256i, __m256i, 1)
+test_2 (_mm_shldi_epi16, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shldi_epi32, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shldi_epi64, __m128i, __m128i, __m128i, 1)
 test_2x (_mm512_cmp_round_pd_mask, __mmask8, __m512d, __m512d, 1, 8)
 test_2x (_mm512_cmp_round_ps_mask, __mmask16, __m512, __m512, 1, 8)
 test_2x (_mm512_maskz_roundscale_round_pd, __m512d, __mmask8, __m512d, 1, 8)
@@ -434,6 +452,24 @@ test_3 (_mm_fnmsub_round_sd, __m128d, __m128d, __m128d, __m128d, 9)
 test_3 (_mm_fnmsub_round_ss, __m128, __m128, __m128, __m128, 9)
 test_3 (_mm_mask_cmp_sd_mask, __mmask8, __mmask8, __m128d, __m128d, 1)
 test_3 (_mm_mask_cmp_ss_mask, __mmask8, __mmask8, __m128, __m128, 1)
+test_3 (_mm512_maskz_shrdi_epi16, __m512i, __mmask32, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shrdi_epi32, __m512i, __mmask16, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shrdi_epi64, __m512i, __mmask8,  __m512i,__m512i, 1)
+test_3 (_mm256_maskz_shrdi_epi16, __m256i, __mmask16, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shrdi_epi32, __m256i, __mmask8,  __m256i,__m256i, 1)
+test_3 (_mm256_maskz_shrdi_epi64, __m256i, __mmask8,  __m256i,__m256i, 1)
+test_3 (_mm_maskz_shrdi_epi16, __m128i, __mmask8,  __m128i, __m128i, 1)
+test_3 (_mm_maskz_shrdi_epi32, __m128i, __mmask8,  __m128i, __m128i, 1)
+test_3 (_mm_maskz_shrdi_epi64, __m128i, __mmask8,  __m128i, __m128i, 1)
+test_3 (_mm512_maskz_shldi_epi16, __m512i, __mmask32, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shldi_epi32, __m512i, __mmask16, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shldi_epi64, __m512i, __mmask8, __m512i, __m512i, 1)
+test_3 (_mm256_maskz_shldi_epi16, __m256i, __mmask16, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shldi_epi32, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shldi_epi64, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm_maskz_shldi_epi16, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shldi_epi32, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shldi_epi64, __m128i, __mmask8, __m128i, __m128i, 1)
 test_3v (_mm512_i32scatter_epi32, void *, __m512i, __m512i, 1)
 test_3v (_mm512_i32scatter_epi64, void *, __m256i, __m512i, 1)
 test_3v (_mm512_i32scatter_pd, void *, __m256i, __m512d, 1)
@@ -558,6 +594,24 @@ test_4 (_mm_mask3_fnmsub_round_sd, __m128d, __m128d, __m128d, __m128d, __mmask8,
 test_4 (_mm_mask3_fnmsub_round_ss, __m128, __m128, __m128, __m128, __mmask8, 9)
 test_4 (_mm_maskz_fnmsub_round_sd, __m128d, __mmask8, __m128d, __m128d, __m128d, 9)
 test_4 (_mm_maskz_fnmsub_round_ss, __m128, __mmask8, __m128, __m128, __m128, 9)
+test_4 (_mm512_mask_shrdi_epi16, __m512i, __m512i, __mmask32, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shrdi_epi32, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shrdi_epi64, __m512i, __m512i, __mmask8, __m512i, __m512i, 1)
+test_4 (_mm256_mask_shrdi_epi16, __m256i, __m256i, __mmask16, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shrdi_epi32, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shrdi_epi64, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm_mask_shrdi_epi16, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shrdi_epi32, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shrdi_epi64, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm512_mask_shldi_epi16, __m512i, __m512i, __mmask32, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shldi_epi32, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shldi_epi64, __m512i, __m512i, __mmask8, __m512i, __m512i, 1)
+test_4 (_mm256_mask_shldi_epi16, __m256i, __m256i, __mmask16, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shldi_epi32, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shldi_epi64, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm_mask_shldi_epi16, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shldi_epi32, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shldi_epi64, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
 test_4v (_mm512_mask_i32scatter_epi32, void *, __mmask16, __m512i, __m512i, 1)
 test_4v (_mm512_mask_i32scatter_epi64, void *, __mmask8, __m256i, __m512i, 1)
 test_4v (_mm512_mask_i32scatter_pd, void *, __mmask8, __m256i, __m512d, 1)
diff --git a/gcc/testsuite/gcc.target/i386/sse-22.c b/gcc/testsuite/gcc.target/i386/sse-22.c
index 0c62f2049c2..87f71ed2e2a 100644
--- a/gcc/testsuite/gcc.target/i386/sse-22.c
+++ b/gcc/testsuite/gcc.target/i386/sse-22.c
@@ -101,7 +101,7 @@
 
 
 #ifndef DIFFERENT_PRAGMAS
-#pragma GCC target ("sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,avx512vl,avx512bw,avx512dq,avx512vbmi,avx512ifma,avx5124fmaps,avx5124vnniw,avx512vpopcntdq,gfni,avx512bitalg")
+#pragma GCC target ("sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,avx512vl,avx512bw,avx512dq,avx512vbmi,avx512vbmi2,avx512ifma,avx5124fmaps,avx5124vnniw,avx512vpopcntdq,gfni,avx512bitalg")
 #endif
 
 /* Following intrinsics require immediate arguments.  They
@@ -218,7 +218,7 @@ test_4 (_mm_cmpestrz, int, __m128i, int, __m128i, int, 1)
 
 /* immintrin.h (AVX/AVX2/RDRND/FSGSBASE/F16C/RTM/AVX512F/SHA) */
 #ifdef DIFFERENT_PRAGMAS
-#pragma GCC target ("avx,avx2,rdrnd,fsgsbase,f16c,rtm,avx512f,avx512er,avx512cd,avx512pf,sha,avx512vl,avx512bw,avx512dq,avx512ifma,avx512vbmi,avx5124fmaps,avx5124vnniw,avx512vpopcntdq,gfni,avx512bitalg")
+#pragma GCC target ("avx,avx2,rdrnd,fsgsbase,f16c,rtm,avx512f,avx512er,avx512cd,avx512pf,sha,avx512vl,avx512bw,avx512dq,avx512ifma,avx512vbmi,avx512vbmi2,avx5124fmaps,avx5124vnniw,avx512vpopcntdq,gfni,avx512bitalg")
 #endif
 #include <immintrin.h>
 test_1 (_cvtss_sh, unsigned short, float, 1)
@@ -437,6 +437,24 @@ test_2 (_mm512_sub_round_pd, __m512d, __m512d, __m512d, 9)
 test_2 (_mm512_sub_round_ps, __m512, __m512, __m512, 9)
 test_2 (_mm_cmp_sd_mask, __mmask8, __m128d, __m128d, 1)
 test_2 (_mm_cmp_ss_mask, __mmask8, __m128, __m128, 1)
+test_2 (_mm512_shrdi_epi16, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shrdi_epi32, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shrdi_epi64, __m512i, __m512i, __m512i, 1)
+test_2 (_mm256_shrdi_epi16, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shrdi_epi32, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shrdi_epi64, __m256i, __m256i, __m256i, 1)
+test_2 (_mm_shrdi_epi16, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shrdi_epi32, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shrdi_epi64, __m128i, __m128i, __m128i, 1)
+test_2 (_mm512_shldi_epi16, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shldi_epi32, __m512i, __m512i, __m512i, 1)
+test_2 (_mm512_shldi_epi64, __m512i, __m512i, __m512i, 1)
+test_2 (_mm256_shldi_epi16, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shldi_epi32, __m256i, __m256i, __m256i, 1)
+test_2 (_mm256_shldi_epi64, __m256i, __m256i, __m256i, 1)
+test_2 (_mm_shldi_epi16, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shldi_epi32, __m128i, __m128i, __m128i, 1)
+test_2 (_mm_shldi_epi64, __m128i, __m128i, __m128i, 1)
 #ifdef __x86_64__
 test_2 (_mm_cvt_roundi64_sd, __m128d, __m128d, long long, 9)
 test_2 (_mm_cvt_roundi64_ss, __m128, __m128, long long, 9)
@@ -543,6 +561,24 @@ test_3 (_mm512_ternarylogic_epi32, __m512i, __m512i, __m512i, __m512i, 1)
 test_3 (_mm512_ternarylogic_epi64, __m512i, __m512i, __m512i, __m512i, 1)
 test_3 (_mm_mask_cmp_sd_mask, __mmask8, __mmask8, __m128d, __m128d, 1)
 test_3 (_mm_mask_cmp_ss_mask, __mmask8, __mmask8, __m128, __m128, 1)
+test_3 (_mm512_maskz_shrdi_epi16, __m512i, __mmask32, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shrdi_epi32, __m512i, __mmask16, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shrdi_epi64, __m512i, __mmask8, __m512i, __m512i, 1)
+test_3 (_mm256_maskz_shrdi_epi16, __m256i, __mmask16, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shrdi_epi32, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shrdi_epi64, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm_maskz_shrdi_epi16, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shrdi_epi32, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shrdi_epi64, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm512_maskz_shldi_epi16, __m512i, __mmask32, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shldi_epi32, __m512i, __mmask16, __m512i, __m512i, 1)
+test_3 (_mm512_maskz_shldi_epi64, __m512i, __mmask8, __m512i, __m512i, 1)
+test_3 (_mm256_maskz_shldi_epi16, __m256i, __mmask16, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shldi_epi32, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm256_maskz_shldi_epi64, __m256i, __mmask8, __m256i, __m256i, 1)
+test_3 (_mm_maskz_shldi_epi16, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shldi_epi32, __m128i, __mmask8, __m128i, __m128i, 1)
+test_3 (_mm_maskz_shldi_epi64, __m128i, __mmask8, __m128i, __m128i, 1)
 test_3v (_mm512_i32scatter_epi32, void *, __m512i, __m512i, 1)
 test_3v (_mm512_i32scatter_epi64, void *, __m256i, __m512i, 1)
 test_3v (_mm512_i32scatter_pd, void *, __m256i, __m512d, 1)
@@ -657,6 +693,24 @@ test_4 (_mm_mask3_fnmsub_round_sd, __m128d, __m128d, __m128d, __m128d, __mmask8,
 test_4 (_mm_mask3_fnmsub_round_ss, __m128, __m128, __m128, __m128, __mmask8, 9)
 test_4 (_mm_maskz_fnmsub_round_sd, __m128d, __mmask8, __m128d, __m128d, __m128d, 9)
 test_4 (_mm_maskz_fnmsub_round_ss, __m128, __mmask8, __m128, __m128, __m128, 9)
+test_4 (_mm512_mask_shrdi_epi16, __m512i, __m512i, __mmask32, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shrdi_epi32, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shrdi_epi64, __m512i, __m512i, __mmask8, __m512i, __m512i, 1)
+test_4 (_mm256_mask_shrdi_epi16, __m256i, __m256i, __mmask16, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shrdi_epi32, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shrdi_epi64, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm_mask_shrdi_epi16, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shrdi_epi32, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shrdi_epi64, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm512_mask_shldi_epi16, __m512i, __m512i, __mmask32, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shldi_epi32, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
+test_4 (_mm512_mask_shldi_epi64, __m512i, __m512i, __mmask8, __m512i, __m512i, 1)
+test_4 (_mm256_mask_shldi_epi16, __m256i, __m256i, __mmask16, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shldi_epi32, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm256_mask_shldi_epi64, __m256i, __m256i, __mmask8, __m256i, __m256i, 1)
+test_4 (_mm_mask_shldi_epi16, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shldi_epi32, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
+test_4 (_mm_mask_shldi_epi64, __m128i, __m128i, __mmask8, __m128i, __m128i, 1)
 test_4v (_mm512_mask_i32scatter_epi32, void *, __mmask16, __m512i, __m512i, 1)
 test_4v (_mm512_mask_i32scatter_epi64, void *, __mmask8, __m256i, __m512i, 1)
 test_4v (_mm512_mask_i32scatter_pd, void *, __mmask8, __m256i, __m512d, 1)
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c
new file mode 100644
index 00000000000..24c18262b1a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+extern void foo (void*);
+
+extern void bar (void*);
+
+void
+test (void* p)
+{
+   if (!p)
+	foo(p);
+   else
+	bar(p);
+}
+
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c
new file mode 100644
index 00000000000..9fd75c98773
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-additional-options "-fno-inline -fipa-ra -mcompact-branches=never" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+static int foo (void* p) { __asm__ (""::"r"(p):"$t0"); return 0; }
+
+static int bar (void* p) { return 1; }
+
+int
+test (void* p)
+{
+  int res = !p ? foo(p) : bar(p);
+
+  register int tmp __asm__("$t0") = -1;
+  __asm__ (""::"r"(tmp));
+
+  return res;
+}
+
+/* { dg-final { scan-assembler "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
+/* { dg-final { scan-assembler-not "\\.set\tnomacro\n\tjalr\t\\\$25" } } */
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c
new file mode 100644
index 00000000000..580c6ec069d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-additional-options "-fno-inline -fipa-ra -mcompact-branches=never" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+static int foo (void* p) { return 0; }
+
+static int bar (void* p) { return 1; }
+
+int
+test (void* p)
+{
+  int res = !p ? foo(p) : bar(p);
+
+  register int tmp __asm__("$t0") = -1;
+  __asm__ (""::"r"(tmp));
+
+  return res;
+}
+
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
+/* { dg-final { scan-assembler "\\.set\tnomacro\n\tjalr\t\\\$25" } } */
diff --git a/gcc/testsuite/gcc.target/mips/get-fcsr-3.c b/gcc/testsuite/gcc.target/mips/get-fcsr-3.c
new file mode 100644
index 00000000000..7bb97b6fbcd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/get-fcsr-3.c
@@ -0,0 +1,9 @@
+/* { dg-options "-mabi=64 -mhard-float" } */
+
+NOMIPS16 unsigned int
+foo (void)
+{
+  return __builtin_mips_get_fcsr () & 0x1;
+}
+
+/* { dg-final { scan-assembler "cfc1" } } */
diff --git a/gcc/testsuite/gcc.target/mips/pr91769.c b/gcc/testsuite/gcc.target/mips/pr91769.c
new file mode 100644
index 00000000000..c9ad70d7f75
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/pr91769.c
@@ -0,0 +1,19 @@
+/* PR target/91769 */
+/* { dg-do compile } */
+/* { dg-skip-if "naming registers makes this a code quality test" { *-*-* } { "-O0" "-g" } { "" } } */
+/* { dg-options "-EL -mgp32 -mhard-float" } */
+
+NOCOMPRESSION double
+foo (void)
+{
+  register double* pf __asm__ ("$a1");
+  __asm__ __volatile__ ("":"=r"(pf));
+  double f = *pf;
+
+  if (f != f)
+    f = -f;
+  return f;
+}
+
+/* { dg-final { scan-assembler-not "lw\t\\\$4,0\\(\\\$5\\)\n\tlw\t\\\$5,4\\(\\\$5\\)\n\tldc1\t\\\$.*,0\\(\\\$5\\)" } } */
+/* { dg-final { scan-assembler "lw\t\\\$4,0\\(\\\$5\\)\n\tlw\t\\\$5,4\\(\\\$5\\)\n\tmtc1\t\\\$4,\\\$.*\n\tmthc1\t\\\$5,\\\$.*" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/20050603-3.c b/gcc/testsuite/gcc.target/powerpc/20050603-3.c
index 1884241f316..4017d34f429 100644
--- a/gcc/testsuite/gcc.target/powerpc/20050603-3.c
+++ b/gcc/testsuite/gcc.target/powerpc/20050603-3.c
@@ -12,9 +12,8 @@ void rotins (unsigned int x)
   b.y = (x<<12) | (x>>20);
 }
 
-/* The XFAILs are PR68803.  */
-/* { dg-final { scan-assembler-not {\mrlwinm} { xfail powerpc64le-*-* } } } */
+/* { dg-final { scan-assembler-not {\mrlwinm} } } */
 /* { dg-final { scan-assembler-not {\mrldic} } } */
 /* { dg-final { scan-assembler-not {\mrot[lr]} } } */
 /* { dg-final { scan-assembler-not {\ms[lr][wd]} } } */
-/* { dg-final { scan-assembler-times {\mrl[wd]imi} 1 { xfail powerpc64le-*-* } } } */
+/* { dg-final { scan-assembler-times {\mrl[wd]imi} 1 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/darn-3.c b/gcc/testsuite/gcc.target/powerpc/darn-3.c
new file mode 100644
index 00000000000..477901fde70
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/darn-3.c
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-options "-O2 -mdejagnu-cpu=power9" } */
+
+static int darn32(void) { return __builtin_darn_32(); }
+
+int four(void)
+{
+	int sum = 0;
+	int i;
+	for (i = 0; i < 4; i++)
+		sum += darn32();
+	return sum;
+}
+
+/* { dg-final { scan-assembler-times {(?n)\mdarn .*,0\M} 4 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-1.c b/gcc/testsuite/gcc.target/powerpc/pr70010-1.c
new file mode 100644
index 00000000000..4b3abb7d8fe
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-1.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -flto -mvsx" } */
+/* { dg-require-effective-target lto } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo () /* { dg-error "inlining failed in call to .* target specific option mismatch" } */
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo (); /* { dg-message "called from here" } */
+  c = a + b;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-2.c b/gcc/testsuite/gcc.target/powerpc/pr70010-2.c
new file mode 100644
index 00000000000..0c04c5390db
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-2.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -flto -mno-vsx" } */
+/* { dg-require-effective-target lto } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo ()
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo ();
+  c = a + b;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-3.c b/gcc/testsuite/gcc.target/powerpc/pr70010-3.c
new file mode 100644
index 00000000000..bca31875632
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mno-vsx" } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo ()
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo ();
+  c = a + b;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-4.c b/gcc/testsuite/gcc.target/powerpc/pr70010-4.c
new file mode 100644
index 00000000000..c575cff1b52
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-4.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mvsx" } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo () /* { dg-error "inlining failed in call to .* target specific option mismatch" } */
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo (); /* { dg-message "called from here" } */
+  c = a + b;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010.c b/gcc/testsuite/gcc.target/powerpc/pr70010.c
new file mode 100644
index 00000000000..679034fae43
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -finline-functions -Wno-psabi -mvsx" } */
+/* { dg-final { scan-assembler {\mbl \.?vadd_no_vsx\M} } } */
+
+typedef int vec_t __attribute__((vector_size(16)));
+
+static vec_t
+__attribute__((__target__("no-vsx")))
+vadd_no_vsx (vec_t a, vec_t b)
+{
+  return a + b;
+}
+
+vec_t
+__attribute__((__target__("vsx")))
+call_vadd_no_vsx (vec_t x, vec_t y, vec_t z)
+{
+  return vadd_no_vsx (x, y) - z;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr91275.c b/gcc/testsuite/gcc.target/powerpc/pr91275.c
new file mode 100644
index 00000000000..cd461158af7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr91275.c
@@ -0,0 +1,26 @@
+/* Test that we generate vpmsumd correctly without a swap error.  */
+
+/* { dg-do run { target { p8vector_hw } } } */
+/* { dg-options "-O2 -std=gnu11" } */
+
+#include <altivec.h>
+
+int main() {
+
+  const unsigned long long r0l = 0x8e7dfceac070e3a0;
+  vector unsigned long long r0 = (vector unsigned long long) {r0l, 0}, v;
+  const vector unsigned long long pd
+    = (vector unsigned long long) {0xc2LLU << 56, 0};
+
+  v = __builtin_crypto_vpmsumd ((vector unsigned long long) {r0[0], 0}, pd);
+
+#if __LITTLE_ENDIAN__
+  if (v[0] != 0x4000000000000000 || v[1] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#else
+  if (v[1] != 0x4000000000000000 || v[0] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#endif
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92090-2.c b/gcc/testsuite/gcc.target/powerpc/pr92090-2.c
new file mode 100644
index 00000000000..1710dfdd52a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92090-2.c
@@ -0,0 +1,45 @@
+/* { dg-do compile } */
+/* { dg-options "-mdejagnu-cpu=power8 -Os -w" } */
+/* { dg-additional-options "-mbig" { target powerpc64le-*-* } } */
+
+/* Verify that we don't ICE.  */
+
+int a;
+static _Atomic long double b, c, d, m;
+double n;
+extern int foo (void);
+extern void bar (int, int, int, int);
+
+void
+bug (void)
+{
+  b = 1.79769313486231580793728971405301199e308L;
+  for (int i = 0; i < 10000; i++)
+    if (__builtin_isinf (n))
+      b;
+  c = 1;
+  int e, f, g, h;
+  while (a)
+    ;
+  for (int i; i; i++)
+    {
+      double j = c /= foo ();
+      if (__builtin_isinf (j))
+	{
+	  if (foo == 1 << 31)
+	    e++;
+	  f++;
+	  c = 0;
+	}
+      else
+	{
+	  if (foo == 1 << 30)
+	    g++;
+	  h++;
+	  c = 1;
+	}
+    }
+  bar (e, f, g, h);
+  d = 1.79769313486231580793728971405301199e308L;
+  m = 1;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92090.c b/gcc/testsuite/gcc.target/powerpc/pr92090.c
new file mode 100644
index 00000000000..77c9f843533
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92090.c
@@ -0,0 +1,43 @@
+/* { dg-do compile } */
+/* { dg-options "-mdejagnu-cpu=power8 -Os" } */
+/* { dg-additional-options "-mbig" { target powerpc64le-*-* } } */
+
+/* Verify that we don't ICE.  */
+
+_Atomic int a;
+_Atomic long double b, c;
+int j;
+void foo (void);
+void bar (int, int, int, int);
+
+void
+bug (void)
+{
+  b = 1;
+  int d, e, f, g;
+  while (a)
+    ;
+  for (int h = 0; h < 10000; h++)
+    {
+      double i = b /= 3;
+      foo ();
+      if (i)
+	{
+	  if (i == 1)
+	    d++;
+	  e++;
+	  b = 0;
+	}
+      else
+	{
+	  if (i == 2)
+	    f++;
+	  g++;
+	  b = 1;
+	}
+    }
+  bar (d, e, f, g);
+  c = 1;
+  for (int h; h; h++)
+    j = 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92098-int-1.c b/gcc/testsuite/gcc.target/powerpc/pr92098-int-1.c
new file mode 100644
index 00000000000..57fba774885
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92098-int-1.c
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-options "-O2 -ftree-vectorize -mdejagnu-cpu=power8 -fno-vect-cost-model -fdump-tree-vect-details" } */
+
+/* To test condition reduction vectorization, where comparison operands are of
+   signed int type and condition true/false values are integer type.  */
+
+#include <math.h>
+
+extern void
+abort (void) __attribute__ ((noreturn));
+
+#define N 27
+#define INT_TYPE signed int 
+
+__attribute__ ((noinline)) int
+test_eq (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] == min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) int
+test_ne (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] != min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) int
+test_gt (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] > min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) int
+test_ge (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] >= min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) int
+test_lt (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] < min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) int
+test_le (INT_TYPE *a, INT_TYPE min_v)
+{
+  int last = 0;
+
+  for (int i = 0; i < N; i++)
+    if (a[i] <= min_v)
+      last = i;
+
+  return last;
+}
+
+int
+main (void)
+{
+  int ret = 0;
+
+  INT_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,
+		   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};
+
+  INT_TYPE a2[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,
+		   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};
+
+  ret = test_eq (a1, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_ne (a1, 10);
+  if (ret != 26)
+    abort ();
+
+  ret = test_gt (a2, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_ge (a2, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_lt (a1, 10);
+  if (ret != 18)
+    abort ();
+
+  ret = test_le (a1, 10);
+  if (ret != 19)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "LOOP VECTORIZED" 6 "vect" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92098-int-2.c b/gcc/testsuite/gcc.target/powerpc/pr92098-int-2.c
new file mode 100644
index 00000000000..372c7af14a9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92098-int-2.c
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-options "-O2 -ftree-vectorize -mdejagnu-cpu=power8 -fno-vect-cost-model -fdump-tree-vect-details" } */
+
+/* To test condition reduction vectorization, where comparison operands are of
+   unsigned int type and condition true/false values are integer type.  */
+
+#include <math.h>
+
+extern void
+abort (void) __attribute__ ((noreturn));
+
+#define N 27
+#define INT_TYPE unsigned int 
+
+__attribute__ ((noinline)) unsigned int
+test_eq (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] == min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) unsigned int
+test_ne (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] != min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) unsigned int
+test_gt (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] > min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) unsigned int
+test_ge (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] >= min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) unsigned int
+test_lt (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] < min_v)
+      last = i;
+
+  return last;
+}
+
+__attribute__ ((noinline)) unsigned int
+test_le (INT_TYPE *a, INT_TYPE min_v)
+{
+  unsigned int last = 0;
+
+  for (unsigned int i = 0; i < N; i++)
+    if (a[i] <= min_v)
+      last = i;
+
+  return last;
+}
+
+int
+main (void)
+{
+  int ret = 0;
+
+  INT_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,
+		   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};
+
+  INT_TYPE a2[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,
+		   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};
+
+  ret = test_eq (a1, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_ne (a1, 10);
+  if (ret != 26)
+    abort ();
+
+  ret = test_gt (a2, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_ge (a2, 10);
+  if (ret != 19)
+    abort ();
+
+  ret = test_lt (a1, 10);
+  if (ret != 18)
+    abort ();
+
+  ret = test_le (a1, 10);
+  if (ret != 19)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "LOOP VECTORIZED" 6 "vect" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr93073.c b/gcc/testsuite/gcc.target/powerpc/pr93073.c
new file mode 100644
index 00000000000..6a0a4731148
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr93073.c
@@ -0,0 +1,16 @@
+/* PR target/93073 */
+/* { dg-do compile { target powerpc_vsx_ok } } */
+/* { dg-options "-mvsx -O1 -ffinite-math-only -fno-trapping-math" } */
+
+void bar (void);
+
+void
+foo (long double x, double y, double z)
+{
+  for (;;)
+    {
+      double a = x > 0.0 ? y : z;
+      if (a == 0.0)
+	bar ();
+    }
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c b/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c
new file mode 100644
index 00000000000..16ab6abfc3b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c
@@ -0,0 +1,47 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -fdump-tree-fre-all -mvsx" } */
+
+/* Verify we remove a redundant load that occurs both before and after
+we call a vector load builtin.
+This testcase is introduced as we updated a number of our vector load
+built-ins with the attribute of PURE instead of MEM, to indicate that
+those builtins only read from memory, versus reading from and writing
+to the same.
+This means we can identify the redundant load instructions in an earlier
+pass, and optimize them away.  */
+
+#include <altivec.h>
+
+vector signed short load_data;
+
+vector signed short foo()
+{
+	vector signed short r11,r12,r13;
+	r11 = load_data;
+	r12 = vec_xl (0, &load_data[0]);
+	r13 = load_data;
+	return (r11 + r12 + r13);
+}
+
+vector signed short biz()
+{
+	vector signed short r21,r22,r23;
+	r21 = load_data;
+	r22 = vec_lvehx (0, &load_data[0]);
+	r23 = load_data;
+	return (r21 + r22 + r23);
+}
+
+vector signed short bar()
+{
+	vector signed short r31,r32,r33;
+	r31 = load_data;
+	r32 = vec_lvx (0, &load_data[0]);
+	r33 = load_data;
+	return (r31 + r32 + r33);
+}
+
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r13_. = load_data;" 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r23_. = load_data;" 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r33_. = load_data;" 1 "fre1" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/pr93202.c b/gcc/testsuite/gcc.target/riscv/pr93202.c
new file mode 100644
index 00000000000..d8091b93179
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr93202.c
@@ -0,0 +1,10 @@
+/* PR inline-asm/93202 */
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-fpic" } */
+
+void
+foo (void)
+{
+  asm volatile ("%h0" :: "i" (&foo));	/* { dg-error "invalid use of '%h'" } */
+  asm volatile ("%R0" :: "i" (&foo));	/* { dg-error "invalid use of '%R'" } */
+}
diff --git a/gcc/testsuite/gcc.target/riscv/pr93304.c b/gcc/testsuite/gcc.target/riscv/pr93304.c
new file mode 100644
index 00000000000..f771e4859a9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr93304.c
@@ -0,0 +1,19 @@
+/* Verify the regrename won't rename registers to register which never used
+   before.  */
+/* { dg-do compile } */
+/* { dg-options "-O -frename-registers" } */
+
+static unsigned _t = 0;
+
+void __attribute__ ((interrupt))
+foo (void)
+{
+  _t++;
+}
+
+/* Register rename will try to use registers from the lower register
+   regradless of the REG_ALLOC_ORDER.
+   In theory, t0-t6 should not used in such small program if regrename
+   not executed incorrectly, because a5-a0 has higher priority in
+   REG_ALLOC_ORDER.  */
+/* { dg-final { scan-assembler-not "t\[0-6\]" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/shift-shift-4.c b/gcc/testsuite/gcc.target/riscv/shift-shift-4.c
new file mode 100644
index 00000000000..72a45ee87ae
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/shift-shift-4.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv32i -mabi=ilp32 -O2" } */
+
+/* One zero-extend shift can be eliminated by modifying the constant in the
+   greater than test.  Started working after modifying the splitter
+   lshrsi3_zero_extend_3+1 to use a temporary reg for the first split dest.  */
+int
+sub (int i)
+{
+  i &= 0x7fffffff;
+  return i > 0x7f800000;
+}
+/* { dg-final { scan-assembler-not "srli" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/shift-shift-5.c b/gcc/testsuite/gcc.target/riscv/shift-shift-5.c
new file mode 100644
index 00000000000..5b2ae89a471
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/shift-shift-5.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv64gc -mabi=lp64d -O2" } */
+
+/* Fails if lshrsi3_zero_extend_3+1 uses a temp reg which has no REG_DEST
+   note.  */
+unsigned long
+sub (long l)
+{
+  union u {
+    struct s { int a : 19; unsigned int b : 13; int x; } s;
+    long l;
+  } u;
+  u.l = l;
+  return u.s.b;
+}
+/* { dg-final { scan-assembler "srliw" } } */
diff --git a/gcc/testsuite/gcc.target/s390/pr93908.c b/gcc/testsuite/gcc.target/s390/pr93908.c
new file mode 100644
index 00000000000..e5949050a08
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr93908.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/93908 */
+/* { dg-do run { target s390_zEC12_hw } } */
+/* { dg-options "-O2 -march=zEC12 -mtune=z13" } */
+
+#include "../../gcc.c-torture/execute/pr93908.c"
diff --git a/gcc/testsuite/gcc.target/s390/s390.exp b/gcc/testsuite/gcc.target/s390/s390.exp
index 86f7e4398eb..ee94a806766 100644
--- a/gcc/testsuite/gcc.target/s390/s390.exp
+++ b/gcc/testsuite/gcc.target/s390/s390.exp
@@ -86,18 +86,22 @@ proc check_effective_target_s390_useable_hw { } {
 	int main (void)
 	{
 	    asm (".machinemode zarch" : : );
-	#if __ARCH__ >= 11
-	    asm ("lcbb %%r2,0(%%r15),0" : : );
+	#if __ARCH__ >= 13
+	    asm ("ncrk %%r2,%%r2,%%r2" : : : "r2");
+	#elif __ARCH__ >= 12
+	    asm ("agh %%r2,0(%%r15)" : : : "r2");
+	#elif __ARCH__ >= 11
+	    asm ("lochiz %%r2,42" : : : "r2");
 	#elif __ARCH__ >= 10
-	    asm ("risbgn %%r2,%%r2,0,0,0" : : );
+	    asm ("risbgn %%r2,%%r2,0,0,0" : : : "r2");
 	#elif __ARCH__ >= 9
-	    asm ("sgrk %%r2,%%r2,%%r2" : : );
+	    asm ("sgrk %%r2,%%r2,%%r2" : : : "r2");
 	#elif __ARCH__ >= 8
-	    asm ("rosbg %%r2,%%r2,0,0,0" : : );
+	    asm ("rosbg %%r2,%%r2,0,0,0" : : : "r2");
 	#elif __ARCH__ >= 7
-	    asm ("nilf %%r2,0" : : );
+	    asm ("nilf %%r2,0" : : : "r2");
 	#elif __ARCH__ >= 6
-	    asm ("lay %%r2,0(%%r15)" : : );
+	    asm ("lay %%r2,0(%%r15)" : : : "r2");
 	#elif __ARCH__ >= 5
 	    asm ("tam" : : );
 	#endif
@@ -107,8 +111,8 @@ proc check_effective_target_s390_useable_hw { } {
 	    asm ("etnd %0" : "=d" (nd));
 	  }
 	#endif
-	#ifdef __VX__
-	    asm ("vzero %%v0" : : );
+	#if defined (__VX__) && defined (__zarch__)
+	    asm ("vzero %%v0" : : : "v0");
 	#endif
 	  return 0;
 	}
diff --git a/gcc/testsuite/gcc.target/s390/sigfpe-eh.c b/gcc/testsuite/gcc.target/s390/sigfpe-eh.c
new file mode 100644
index 00000000000..52b0bf39d9e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/sigfpe-eh.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-march=z196 -O2 -fexceptions -fnon-call-exceptions" } */
+
+extern float f (void);
+extern float g (void);
+
+float h (float x, float y)
+{
+  return x < y ? f () : g ();
+}
diff --git a/gcc/testsuite/gcc.target/s390/vector/pr92950.c b/gcc/testsuite/gcc.target/s390/vector/pr92950.c
new file mode 100644
index 00000000000..5084ce9a95f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/vector/pr92950.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
+
+struct a {
+  int b;
+  char c;
+};
+struct a d = {1, 16};
+struct a *e = &d;
+
+int f = 0;
+
+int main() {
+  struct a g = {0, 0 };
+  f = 0;
+
+  for (; f <= 1; f++) {
+    g = d;
+    *e = g;
+  }
+
+  if (d.c != 16)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20161111-1.c b/gcc/testsuite/gcc.target/sparc/20161111-1.c
index eda8b0a9f12..8195fec8990 100644
--- a/gcc/testsuite/gcc.target/sparc/20161111-1.c
+++ b/gcc/testsuite/gcc.target/sparc/20161111-1.c
@@ -14,4 +14,4 @@ unsigned char ee_isdigit2(unsigned int i)
   return retval;
 }
 
-/* { dg-final { scan-assembler-not "and\t%" } } */
+/* { dg-final { scan-assembler-not "and\t%" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-1.c b/gcc/testsuite/gcc.target/sparc/overflow-1.c
index e3fa0d04573..75f69ba4f9d 100644
--- a/gcc/testsuite/gcc.target/sparc/overflow-1.c
+++ b/gcc/testsuite/gcc.target/sparc/overflow-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mcpu=v8" } */
+/* { dg-options "-O -fno-pie -mcpu=v8" } */
 /* { dg-require-effective-target ilp32 } */
 
 #include <stdbool.h>
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-2.c b/gcc/testsuite/gcc.target/sparc/overflow-2.c
index 9e42bd214de..feb3f194828 100644
--- a/gcc/testsuite/gcc.target/sparc/overflow-2.c
+++ b/gcc/testsuite/gcc.target/sparc/overflow-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mcpu=v8" } */
+/* { dg-options "-O -fno-pie -mcpu=v8" } */
 /* { dg-require-effective-target ilp32 } */
 
 #include <stdbool.h>
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-3.c b/gcc/testsuite/gcc.target/sparc/overflow-3.c
index 86dddfb09e6..52d6ab2b688 100644
--- a/gcc/testsuite/gcc.target/sparc/overflow-3.c
+++ b/gcc/testsuite/gcc.target/sparc/overflow-3.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
-/* { dg-options "-O" } */
+/* { dg-options "-O -fno-pie" } */
 
 #include <stdbool.h>
 #include <stdint.h>
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-4.c b/gcc/testsuite/gcc.target/sparc/overflow-4.c
index 019feee335c..c6121b958c3 100644
--- a/gcc/testsuite/gcc.target/sparc/overflow-4.c
+++ b/gcc/testsuite/gcc.target/sparc/overflow-4.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
-/* { dg-options "-O -mno-vis3 -mno-vis4" } */
+/* { dg-options "-O -fno-pie -mno-vis3 -mno-vis4" } */
 
 #include <stdbool.h>
 #include <stdint.h>
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-5.c b/gcc/testsuite/gcc.target/sparc/overflow-5.c
index 67d4ac38095..f00283f6e7b 100644
--- a/gcc/testsuite/gcc.target/sparc/overflow-5.c
+++ b/gcc/testsuite/gcc.target/sparc/overflow-5.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
-/* { dg-options "-O -mvis3" } */
+/* { dg-options "-O -fno-pie -mvis3" } */
 
 #include <stdbool.h>
 #include <stdint.h>
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c
index a6353c7cca6..a5714593c52 100644
--- a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c
@@ -1,6 +1,7 @@
 /* Test F2008 18.5: ISO_Fortran_binding.h functions.  */
 
 #include "../../../libgfortran/ISO_Fortran_binding.h"
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <complex.h>
@@ -33,13 +34,34 @@ int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc,
       || c_desc->rank != 2)
     return err;
 
-  for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)
-    for (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)
-      {
-	res_addr = CFI_address (a_desc, idx);
-	*res_addr = *(int*)CFI_address (b_desc, idx)
-		    * *(int*)CFI_address (c_desc, idx);
-      }
+  if (a_desc->attribute == CFI_attribute_other)
+    {
+      assert (a_desc->dim[0].lower_bound == 0);
+      assert (a_desc->dim[1].lower_bound == 0);
+      for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)
+	for (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)
+	  {
+	    res_addr = CFI_address (a_desc, idx);
+	    *res_addr = *(int*)CFI_address (b_desc, idx)
+			* *(int*)CFI_address (c_desc, idx);
+	  }
+    }
+  else
+    {
+      assert (a_desc->attribute == CFI_attribute_allocatable
+	      || a_desc->attribute == CFI_attribute_pointer);
+      for (idx[0] = a_desc->dim[0].lower_bound;
+	   idx[0] < a_desc->dim[0].extent + a_desc->dim[0].lower_bound;
+	   idx[0]++)
+	for (idx[1] = a_desc->dim[1].lower_bound;
+	     idx[1] < a_desc->dim[1].extent + a_desc->dim[1].lower_bound;
+	     idx[1]++)
+	  {
+	    res_addr = CFI_address (a_desc, idx);
+	    *res_addr = *(int*)CFI_address (b_desc, idx)
+			* *(int*)CFI_address (c_desc, idx);
+	  }
+    }
 
   return 0;
 }
@@ -57,15 +79,16 @@ int allocate_c(CFI_cdesc_t * da, CFI_index_t lower[], CFI_index_t upper[])
   CFI_index_t idx[2];
   int *res_addr;
 
+  if (da->attribute == CFI_attribute_other) return err;
   if (CFI_allocate(da, lower, upper, 0)) return err;
+  assert (da->dim[0].lower_bound == lower[0]);
+  assert (da->dim[1].lower_bound == lower[1]);
 
-
-  for (idx[0] = 0; idx[0] < da->dim[0].extent; idx[0]++)
-    for (idx[1] = 0; idx[1] < da->dim[1].extent; idx[1]++)
+  for (idx[0] = lower[0]; idx[0] < da->dim[0].extent + lower[0]; idx[0]++)
+    for (idx[1] = lower[1]; idx[1] < da->dim[1].extent + lower[1]; idx[1]++)
       {
 	res_addr = CFI_address (da, idx);
-	*res_addr = (int)((idx[0] + da->dim[0].lower_bound)
-			  * (idx[1] + da->dim[1].lower_bound));
+	*res_addr = (int)(idx[0] * idx[1]);
       }
 
   return 0;
@@ -86,6 +109,7 @@ int establish_c(CFI_cdesc_t * desc)
 		      CFI_attribute_pointer,
 		      CFI_type_struct,
 		      sizeof(t), 1, extent);
+  assert (desc->dim[0].lower_bound == 0);
   for (idx[0] = 0; idx[0] < extent[0]; idx[0]++)
     {
       res_addr = (t*)CFI_address (desc, idx);
@@ -118,10 +142,11 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)
 			  CFI_type_float, 0, 1, NULL);
       if (ind) return -1.0;
       ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);
+      assert (section.dim[0].lower_bound == lower[0]);
       if (ind) return -2.0;
 
       /* Sum over the section  */
-      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)
+      for (idx[0] = lower[0]; idx[0] < section.dim[0].extent + lower[0]; idx[0]++)
         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);
       return ans;
     }
@@ -138,10 +163,12 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)
       if (ind) return -1.0;
       ind = CFI_section((CFI_cdesc_t *)&section, source,
 			lower, upper, strides);
+      assert (section.rank == 1);
+      assert (section.dim[0].lower_bound == lower[0]);
       if (ind) return -2.0;
 
       /* Sum over the section  */
-      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)
+      for (idx[0] = lower[0]; idx[0] < section.dim[0].extent + lower[0]; idx[0]++)
         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);
       return ans;
     }
@@ -166,6 +193,8 @@ double select_part_c (CFI_cdesc_t * source)
 		      CFI_type_double_Complex, sizeof(double _Complex),
 		      2, extent);
   (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);
+  assert (comp_cdesc->dim[0].lower_bound == 0);
+  assert (comp_cdesc->dim[1].lower_bound == 0);
 
   /* Sum over comp_cdesc[4,:]  */
   size = comp_cdesc->dim[1].extent;
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.c b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.c
new file mode 100644
index 00000000000..1ac9fc89eb1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.c
@@ -0,0 +1,12 @@
+/* Test the fix for PR91926.  */
+
+/* Contributed by José Rui Faustino de Sousa  <jrfsousa@hotmail.com> */
+
+#include <stdlib.h>
+
+int ifb_echo(void*);
+
+int ifb_echo(void *this)
+{
+  return this == NULL ? 1 : 2;
+}
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.f90 b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.f90
new file mode 100644
index 00000000000..132a97cd4c4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_13.f90
@@ -0,0 +1,39 @@
+! { dg-do run { target c99_runtime } }
+! { dg-additional-sources ISO_Fortran_binding_13.c }
+!
+! Test the fix for PR91926. The additional source is the main program.
+!
+! Contributed by José Rui Faustino de Sousa  <jrfsousa@hotmail.com>
+!
+program ifb_p
+
+  implicit none
+
+  integer :: i = 42
+
+  interface
+    integer function ifb_echo_aux(this) bind(c, name="ifb_echo")
+      implicit none
+      type(*), dimension(..), & ! removing assumed rank solves segmentation fault
+        optional, intent(in) :: this
+    end function ifb_echo_aux
+  end interface
+
+  if (ifb_echo_aux() .ne. 1) STOP 1  ! worked
+  if (ifb_echo() .ne. 1) stop 2      ! segmentation fault
+  if (ifb_echo_aux(i) .ne. 2) stop 3 ! worked
+  if (ifb_echo(i) .ne. 2) stop 4     ! worked
+
+  stop
+
+contains
+
+  integer function ifb_echo(this)
+    type(*), dimension(..), &
+      optional, intent(in) :: this
+
+    ifb_echo = ifb_echo_aux(this)
+    return
+  end function ifb_echo
+
+end program ifb_p
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_14.f90 b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_14.f90
new file mode 100644
index 00000000000..388c5438252
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_14.f90
@@ -0,0 +1,41 @@
+! { dg-do run }
+!
+! Correct an error in the eveluation of the CFI descriptor attribute for
+! the case where the bind_C formal argument is not an assumed shape array
+! and not allocatable or pointer.
+!
+! Contributed by Gilles Gouaillardet  <gilles@rist.or.jp>
+!
+MODULE FOO
+INTERFACE
+SUBROUTINE dummy(buf) BIND(C, name="sync")
+type(*), dimension(..) :: buf
+END SUBROUTINE
+END INTERFACE
+END MODULE
+
+PROGRAM main
+    USE FOO
+    IMPLICIT NONE
+    integer(8) :: before, after
+
+    INTEGER, parameter :: n = 1
+
+    INTEGER, ALLOCATABLE :: buf(:)
+    INTEGER :: buf2(n)
+    INTEGER :: i
+
+    ALLOCATE(buf(n))
+    before = LOC(buf(1))
+    CALL dummy (buf)
+    after = LOC(buf(1))
+
+    if (before .NE. after) stop 1
+
+    before = LOC(buf2(1))
+    CALL dummy (buf)
+    after = LOC(buf2(1))
+
+    if (before .NE. after) stop 2
+
+END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.c b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.c
new file mode 100644
index 00000000000..14dfcc90c4e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.c
@@ -0,0 +1,25 @@
+/* PR fortran/92470  - to be used with ISO_Fortran_binding_17.f90 */
+
+#include <stdio.h>
+#include <assert.h>
+#include "../../../libgfortran/ISO_Fortran_binding.h"
+
+void Csub(const CFI_cdesc_t *, size_t, CFI_index_t invalid);
+
+void Csub(const CFI_cdesc_t * dv, size_t locd, CFI_index_t invalid) {
+
+   CFI_index_t lb[1];
+   lb[0] = dv->dim[0].lower_bound;
+   size_t ld = (size_t)CFI_address(dv, lb);
+
+   if (ld != locd)
+     printf ("In C function: CFI_address of dv = %I64x\n", ld);
+   assert( ld == locd );
+
+   lb[0] = invalid;
+   /* Shall return NULL and produce stderr diagnostic with -fcheck=array.  */
+   ld = (size_t)CFI_address(dv, lb);
+   assert (ld == 0);
+
+   return;
+}
diff --git a/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.f90 b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.f90
new file mode 100644
index 00000000000..fa341a7f3d4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.f90
@@ -0,0 +1,77 @@
+! { dg-do run }
+! { dg-additional-sources ISO_Fortran_binding_17.c }
+! { dg-options "-fcheck=all" }
+! { dg-warning "command line option '-fcheck=all' is valid for Fortran but not for C" "" { target *-*-* } 0 }
+!
+! PR fortran/92470
+!
+! https://github.com/j3-fortran/fortran_proposals/issues/57#issuecomment-552680503
+!
+! Unit Test #: Test-1.F2018-2.7.5
+! Author     : FortranFan
+! Reference  : The New Features of Fortran 2018, John Reid, August 2, 2018
+!              ISO/IEC JTC1/SC22/WG5 N2161
+! Description:
+! Test item 2.7.5 Fortran subscripting
+! void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);
+! that returns the C address of a scalar or of an element of an array using
+! Fortran sub-scripting.
+!
+   use, intrinsic :: iso_c_binding, only: c_int, c_size_t, c_loc
+   implicit none
+
+   integer, parameter :: LB_A = -2
+   integer, parameter :: UB_A = 1
+   character(len=*), parameter :: fmtg = "(*(g0,1x))"
+   character(len=*), parameter :: fmth = "(g0,1x,z0)"
+
+   blk1: block
+      interface
+         subroutine Csub(a, loc_a_1, invalid_idx) bind(C, name="Csub")
+            import :: c_size_t
+            type(*), intent(in) :: a(:)
+            integer(c_size_t), intent(in), value :: loc_a_1, invalid_idx
+         end subroutine
+      end interface
+
+      integer(c_int), target :: a( LB_A:UB_A )
+      integer(c_size_t) :: loc_a
+
+      print fmtg, "Block 1"
+
+      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a)
+      print fmth, "Address of a: ", loc_a
+
+      call Csub(a, loc_a, -1_c_size_t) ! LB starts at 0
+      call Csub(a, loc_a, 5_c_size_t)  ! 4 elements + 1
+      print *
+   end block blk1
+
+   blk2: block
+      interface
+         subroutine Csub(a, loc_a_1, invalid_idx) bind(C, name="Csub")
+            import :: c_int, c_size_t
+            integer(kind=c_int), allocatable, intent(in) :: a(:)
+            integer(c_size_t), intent(in), value :: loc_a_1, invalid_idx
+         end subroutine
+      end interface
+
+      integer(c_int), allocatable, target :: a(:)
+      integer(c_size_t) :: loc_a
+
+      print fmtg, "Block 2"
+
+      allocate( a( LB_A:UB_A ) )
+      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )
+      print fmth, "Address of a: ", loc_a
+
+      call Csub(a, loc_a, LB_A-1_c_size_t)
+      call Csub(a, loc_a, UB_A+1_c_size_t)
+      print *
+   end block blk2
+end
+
+! { dg-output "CFI_address: subscripts\\\[0\\\] is out of bounds. For dimension = 0, subscripts = -1, lower_bound = 0, upper bound = 4, extend = 4(\n|\r\n|\r)" }
+! { dg-output "CFI_address: subscripts\\\[0\\\] is out of bounds. For dimension = 0, subscripts = 5, lower_bound = 0, upper bound = 4, extend = 4(\n|\r\n|\r).*" }
+! { dg-output "CFI_address: subscripts\\\[0\\\] is out of bounds. For dimension = 0, subscripts = -3, lower_bound = -2, upper bound = 6, extend = 4(\n|\r\n|\r)" }
+! { dg-output "CFI_address: subscripts\\\[0\\\] is out of bounds. For dimension = 0, subscripts = 2, lower_bound = -2, upper bound = 6, extend = 4(\n|\r\n|\r)" }
diff --git a/gcc/testsuite/gfortran.dg/allocated_1.f90 b/gcc/testsuite/gfortran.dg/allocated_1.f90
new file mode 100644
index 00000000000..43260c24336
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocated_1.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .false.) stop 1
+   a2 = allocated(array=a)
+   if (a2 .neqv. .false.) stop 2
+
+   allocate(x)
+   allocate(a(2))
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .true.) stop 3
+   a2 = allocated(array=a)
+   if (a2 .neqv. .true.) stop 4
+
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/allocated_2.f90 b/gcc/testsuite/gfortran.dg/allocated_2.f90
new file mode 100644
index 00000000000..0ea186a4d13
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocated_2.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=a)   ! { dg-error "Scalar entity required" }
+   a2 = allocated(array=x)    ! { dg-error "Array entity required" }
+   a1 = allocated(scalar=x, array=a)   ! { dg-error "Too many arguments" }
+   a1 = allocated(array=a, scalar=x)   ! { dg-error "Too many arguments" }
+
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/allocated_3.f90 b/gcc/testsuite/gfortran.dg/allocated_3.f90
new file mode 100644
index 00000000000..66748d6142f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocated_3.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/91551
+! Contributed by Gerhard Steinmetz
+program p
+   if (allocated()) stop 1 ! { dg-error "requires an array or scalar allocatable" }
+end
diff --git a/gcc/testsuite/gfortran.dg/arith_divide_2.f90 b/gcc/testsuite/gfortran.dg/arith_divide_2.f90
new file mode 100644
index 00000000000..ffafa269a1b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/arith_divide_2.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR 92961 - this used to ICE. Original test case by Gerhard Steinmetz.
+program p
+   integer :: a((0)/0)    ! { dg-error "Division by zero" }
+   integer :: b(0/(0))    ! { dg-error "Division by zero" }
+   integer :: c((0)/(0))  ! { dg-error "Division by zero" }
+   integer :: d(0/0)      ! { dg-error "Division by zero" }
+   integer :: x = ubound(a,1) ! { dg-error "must be an array" }
+end
diff --git a/gcc/testsuite/gfortran.dg/associate_49.f90 b/gcc/testsuite/gfortran.dg/associate_49.f90
new file mode 100644
index 00000000000..1b205950556
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_49.f90
@@ -0,0 +1,34 @@
+! { dg-do run }
+!
+! Test the fix for PR91588, in which the declaration of 'a' caused
+! an ICE.
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(4), parameter :: parm = '7890'
+   associate (z => '1234')
+      block
+         integer(len(z)) :: a
+         if (kind(a) .ne. 4) stop 1
+      end block
+   end associate
+   associate (z => '123')
+      block
+         integer(len(z)+1) :: a
+         if (kind(a) .ne. 4) stop 2
+      end block
+   end associate
+   associate (z => 1_8)
+      block
+         integer(kind(z)) :: a
+         if (kind(a) .ne. 8) stop 3
+      end block
+   end associate
+   associate (z => parm)
+      block
+         integer(len(z)) :: a
+         if (kind(a) .ne. 4) stop 4
+      end block
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/bind-c-intent-out.f90 b/gcc/testsuite/gfortran.dg/bind-c-intent-out.f90
new file mode 100644
index 00000000000..39822c0753a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bind-c-intent-out.f90
@@ -0,0 +1,42 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! PR fortran/91863
+!
+! Contributed by G. Steinmetz
+!
+
+subroutine sub(x) bind(c)
+  implicit none (type, external)
+  integer, allocatable, intent(out) :: x(:)
+
+  allocate(x(3:5))
+  x(:) = [1, 2, 3]
+end subroutine sub
+
+
+program p
+  implicit none (type, external)
+  interface
+    subroutine sub(x) bind(c)
+      integer, allocatable, intent(out) :: x(:)
+    end
+  end interface
+  integer, allocatable :: a(:)
+
+  call sub(a)
+  if (.not.allocated(a)) stop 1
+  if (any(shape(a) /= [3])) stop 2
+  if (lbound(a,1) /= 3 .or. ubound(a,1) /= 5) stop 3
+  if (any(a /= [1, 2, 3])) stop 4
+end program p
+
+! "cfi" only appears in context of "a" -> bind-C descriptor
+! the intent(out) implies freeing in the callee (!), hence the "free"
+! It is the only 'free' as 'a' is part of the main program and, hence, implicitly has the SAVE attribute.
+! The  'cfi = 0' appears before the call due to the deallocate and when preparing the C descriptor
+! As cfi (i.e. the descriptor itself) is allocated in libgomp, it has to be freed after the call.
+
+! { dg-final { scan-tree-dump-times "__builtin_free" 2 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free \\(cfi\\.\[0-9\]+\\);" 2 "original" } }
+! { dg-final { scan-tree-dump-times "cfi\\.\[0-9\]+ = 0B;" 2 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/bind_c_array_params_3.f90 b/gcc/testsuite/gfortran.dg/bind_c_array_params_3.f90
new file mode 100644
index 00000000000..d5bad7d03f2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bind_c_array_params_3.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! { dg-additional-sources bind_c_array_params_3_aux.c }
+!
+! PR fortran/92284
+!
+! Contributed by José Rui Faustino de Sousa
+!
+program arr_p
+  use, intrinsic :: iso_c_binding, only: c_int
+  implicit none (type, external)
+
+  integer(kind=c_int), pointer :: arr(:)
+  integer :: i
+
+  nullify(arr)
+  call arr_set(arr)
+
+  if (.not.associated(arr)) stop 1
+  if (lbound(arr,dim=1) /= 1) stop 2
+  if (ubound(arr,dim=1) /= 9) stop 3
+  if (any (arr /= [(i, i=0,8)])) stop 4
+  deallocate(arr)
+
+contains
+
+  subroutine arr_set(this) !bind(c)
+    integer(kind=c_int), pointer, intent(out) :: this(:)
+
+    interface
+      subroutine arr_set_c(this) bind(c)
+        use, intrinsic :: iso_c_binding, only: c_int
+        implicit none
+        integer(kind=c_int), pointer, intent(out) :: this(:)
+      end subroutine arr_set_c
+    end interface
+
+    call arr_set_c(this)
+  end subroutine arr_set
+end program arr_p
diff --git a/gcc/testsuite/gfortran.dg/bind_c_array_params_3_aux.c b/gcc/testsuite/gfortran.dg/bind_c_array_params_3_aux.c
new file mode 100644
index 00000000000..07d1a033c5a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bind_c_array_params_3_aux.c
@@ -0,0 +1,26 @@
+/* Used by bind_c_array_params_3.f90.  */
+/* PR fortran/92284.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+
+#include "../../../libgfortran/ISO_Fortran_binding.h"
+
+void arr_set_c(CFI_cdesc_t*);
+
+void arr_set_c(CFI_cdesc_t *arr){
+  int i, stat, *auxp = NULL;
+  CFI_index_t   lb[] = {1};
+  CFI_index_t   ub[] = {9};
+  
+  assert(arr);
+  assert(arr->rank==1);
+  assert(!arr->base_addr);
+  stat = CFI_allocate(arr, lb, ub, sizeof(int));
+  assert(stat==CFI_SUCCESS);
+  auxp = (int*)arr->base_addr;
+  assert(auxp);
+  for(i=0; i<ub[0]-lb[0]+1; i++) auxp[i]=i;
+  return;
+}
diff --git a/gcc/testsuite/gfortran.dg/char_pointer_assign_6.f90 b/gcc/testsuite/gfortran.dg/char_pointer_assign_6.f90
index cd90bfc06e3..e0e116074ae 100644
--- a/gcc/testsuite/gfortran.dg/char_pointer_assign_6.f90
+++ b/gcc/testsuite/gfortran.dg/char_pointer_assign_6.f90
@@ -6,6 +6,6 @@ program main
   character (len=4) :: c
   s1 = 'abcd'
   p1 => s1(2:3) ! { dg-error "Unequal character lengths \\(20/2\\)" }
-  p1 => c(1:) ! { dg-error "Unequal character lengths \\(20/4\\)" }
-  p1 => c(:4) ! { dg-error "Unequal character lengths \\(20/4\\)" }
+  p1 => c(1:) ! { dg-error "Pointer assignment target" }
+  p1 => c(:4) ! { dg-error "Pointer assignment target" }
 end
diff --git a/gcc/testsuite/gfortran.dg/char_result_19.f90 b/gcc/testsuite/gfortran.dg/char_result_19.f90
new file mode 100644
index 00000000000..e66ebdcda53
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/char_result_19.f90
@@ -0,0 +1,24 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+!
+! Test the fix for PR86248
+!
+! Contributed by Bill Long  <longb@cray.com>
+!
+program test
+  use test_module
+  implicit none
+  integer :: i
+  character(:), allocatable :: chr
+  do i = 0, 2
+    chr = func_1 (i)
+    select case (i)
+      case (0)
+        if (chr .ne. 'el0') stop i
+      case (1)
+        if (chr .ne. 'el11') stop i
+      case (2)
+        if (chr .ne. 'el2') stop i
+    end select
+  end do
+end program test
diff --git a/gcc/testsuite/gfortran.dg/char_result_mod_19.f90 b/gcc/testsuite/gfortran.dg/char_result_mod_19.f90
new file mode 100644
index 00000000000..a2b5e94f1b6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/char_result_mod_19.f90
@@ -0,0 +1,18 @@
+! { dg-do  run }
+! { dg-additional-sources char_result_19.f90 }
+!
+! Module for char_result_19.f90
+! Tests fix for PR86248
+!
+module test_module
+  implicit none
+  public :: func_1
+  private
+  character(len=*),dimension(0:2),parameter :: darray = (/"el0 ","el11","el2 "/)
+contains
+  function func_1 (func_1_input) result(f)
+    integer, intent(in) :: func_1_input
+    character(len = len_trim (darray(func_1_input))) :: f
+    f = darray(func_1_input)
+  end function func_1
+end module test_module
diff --git a/gcc/testsuite/gfortran.dg/class_71.f90 b/gcc/testsuite/gfortran.dg/class_71.f90
new file mode 100644
index 00000000000..bc0ffcd2305
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_71.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+!
+! PR fortran/91586
+!
+! Contributed by G. Steinmetz
+!
+program p
+   type t
+      class(*), allocatable :: a
+   end type
+   class(t) :: x, y  ! { dg-error "must be dummy, allocatable or pointer" }
+   y = x  ! { dg-error "Nonallocatable variable must not be polymorphic in intrinsic assignment" }
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray/codimension_3.f90 b/gcc/testsuite/gfortran.dg/coarray/codimension_3.f90
new file mode 100644
index 00000000000..466ed883d52
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/codimension_3.f90
@@ -0,0 +1,76 @@
+! { dg-do run }
+!
+! PR fortran/84135
+!
+! Co-contributed by G. Steinmetz
+!
+! Ensure that coarray shape remains correct
+! after merging the shape from 'dimension'
+!
+program p
+   integer :: i
+   integer, dimension(3) :: x[2,*]
+   data (x(i:i+2:i+1), i=1,2) /1,2,3/
+   integer, dimension(3) :: y[2,3,-3:4,5,7:*] = [1,2,3]
+   integer :: z, z2[2:4,7:9,-2:2,-7:8,-4:*]
+   codimension :: z[2:4,7:9,-2:2,-7:8,-4:*]
+   integer, codimension[1:*] :: z3[2:4,7:9,-2:2,-7:8,-4:*]
+   dimension :: z(1:2,-3:-2,7:7), z2(1:2,-3:-2,7:7), z3(1:2,-3:-2,7:7)
+   integer, codimension[2:4,7:9,-2:2,-7:8,-4:*], dimension(1:2,-3:-2,7:7) :: z4
+   integer, codimension[*], dimension(1:2,-3:-2,7:7) :: z5[2:4,7:9,-2:2,-7:8,-4:*]
+   integer, codimension[2:4,7:9,-2:2,-7:8,-4:*], dimension(3) :: z6(1:2,-3:-2,7:7)
+   integer, codimension[*], dimension(4) :: z7(1:2,-3:-2,7:7)[2:4,7:9,-2:2,-7:8,-4:*]
+
+   if (any (lcobound(x) /= [1, 1])) stop 1
+   if (any (lcobound(y) /= [1, 1, -3, 1, 7])) stop 3
+   if (any (lcobound(z) /= [2,7,-2,-7,-4])) stop 4
+   if (any (lcobound(z2) /= lcobound(z))) stop 4
+   if (any (lcobound(z3) /= lcobound(z))) stop 5
+   if (any (lcobound(z4) /= lcobound(z))) stop 6
+   if (any (lcobound(z5) /= lcobound(z))) stop 7
+   if (any (lcobound(z6) /= lcobound(z))) stop 8
+   if (any (lcobound(z7) /= lcobound(z))) stop 9
+
+   if (any (lbound(x) /= [1])) stop 11
+   if (any (lbound(y) /= [1])) stop 12
+   if (any (lbound(z) /= [1,-3,7])) stop 13
+   if (any (lbound(z2) /= lbound(z))) stop 14
+   if (any (lbound(z3) /= lbound(z))) stop 15
+   if (any (lbound(z4) /= lbound(z))) stop 16
+   if (any (lbound(z5) /= lbound(z))) stop 17
+   if (any (lbound(z6) /= lbound(z))) stop 18
+   if (any (lbound(z7) /= lbound(z))) stop 19
+
+   if (any (ubound(x) /= [3])) stop 21
+   if (any (ubound(y) /= [3])) stop 22
+   if (any (ubound(z) /= [2,-2,7])) stop 23
+   if (any (ubound(z2) /= ubound(z))) stop 24
+   if (any (ubound(z3) /= ubound(z))) stop 25
+   if (any (ubound(z4) /= ubound(z))) stop 26
+   if (any (ubound(z5) /= ubound(z))) stop 27
+   if (any (ubound(z6) /= ubound(z))) stop 28
+   if (any (ubound(z7) /= ubound(z))) stop 29
+
+   if (any (ucobound(z2) /= ucobound(z))) stop 31
+   if (any (ucobound(z3) /= ucobound(z))) stop 32
+   if (any (ucobound(z4) /= ucobound(z))) stop 33
+   if (any (ucobound(z5) /= ucobound(z))) stop 34
+   if (any (ucobound(z6) /= ucobound(z))) stop 35
+   if (any (ucobound(z7) /= ucobound(z))) stop 36
+
+   if (num_images() == 1) then
+     if (any (ucobound(x) /= [2, lbound(x,dim=1)])) stop 37
+     if (any (ucobound(y) /= [2, 3, 4, 5, 7])) stop 38
+     if (any (ucobound(z) /= [4,9,2,8,-4])) stop 39
+   else
+     if (ucobound(x, dim=1) /= 2) stop 41
+     if (ucobound(y, dim=1) /= 2) stop 42
+     if (ucobound(y, dim=2) /= 3) stop 43
+     if (ucobound(y, dim=3) /= 4) stop 44
+     if (ucobound(y, dim=4) /= 5) stop 45
+     if (ucobound(z, dim=1) /= 4) stop 46
+     if (ucobound(z, dim=2) /= 9) stop 47
+     if (ucobound(z, dim=3) /= 2) stop 48
+     if (ucobound(z, dim=4) /= 8) stop 49
+   endif
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_type_print_3.f90 b/gcc/testsuite/gfortran.dg/dec_type_print_3.f90
index e5b455eea26..6836c257e14 100644
--- a/gcc/testsuite/gfortran.dg/dec_type_print_3.f90
+++ b/gcc/testsuite/gfortran.dg/dec_type_print_3.f90
@@ -8,9 +8,9 @@
 
 include 'dec_type_print.f90'
 
-! { dg-error "Invalid character in name" "" { target *-*-* } 52 }
+! { dg-error "Mangled derived type definition" "" { target *-*-* } 52 }
 ! { dg-error "Invalid character in name" "" { target *-*-* } 53 }
-! { dg-error "Invalid character in name" "" { target *-*-* } 54 }
+! { dg-error "Mangled derived type definition" "" { target *-*-* } 54 }
 ! { dg-error "Invalid character in name" "" { target *-*-* } 55 }
 ! { dg-error "Invalid character in name" "" { target *-*-* } 56 }
 ! { dg-error "Invalid character in name" "" { target *-*-* } 57 }
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_34.f90 b/gcc/testsuite/gfortran.dg/deferred_character_34.f90
new file mode 100644
index 00000000000..20408412879
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_34.f90
@@ -0,0 +1,10 @@
+! { dg-do run }
+! PR fortran/90561
+! This used to ICE.
+! Original test case by Gerhard Steinmetz.
+program p
+   character(:), allocatable :: z(:)
+   z = [character(2):: 'ab', 'xy']
+   z = z(2)
+   if (any(z /= 'xy')) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/dependency_56.f90 b/gcc/testsuite/gfortran.dg/dependency_56.f90
new file mode 100644
index 00000000000..97c0c814aed
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dependency_56.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 91783 - used to cause an ICE in dependency checking.
+! Test case by Gerhard Steinmetz.
+program p
+   class(*), allocatable :: a(:)
+   a = [1, 2, 3]
+   a = f(a)
+contains
+   function f(x) result(y)
+      class(*), allocatable, intent(in) :: x(:)
+      class(*), allocatable :: y(:)
+      y = x
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/directive_unroll_5.f90 b/gcc/testsuite/gfortran.dg/directive_unroll_5.f90
index b88b4b2c380..33f2fda537f 100644
--- a/gcc/testsuite/gfortran.dg/directive_unroll_5.f90
+++ b/gcc/testsuite/gfortran.dg/directive_unroll_5.f90
@@ -31,7 +31,7 @@ subroutine wrong3(a, b, n)
   integer :: a(n), b(n)
   integer (kind=4) :: i
 !GCC$ unroll 8
-  write (*,*) "wrong"! { dg-error "directive does not commence a loop" }
+  write (*,*) "wrong"! { dg-error "directive not at the start of a loop" }
   DO i=n, 1, -1
     call dummy2(a(i), b(i), i)
   ENDDO
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_3.f90 b/gcc/testsuite/gfortran.dg/do_subscript_3.f90
new file mode 100644
index 00000000000..2f62f58142b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_subscript_3.f90
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! PR fortran/91424
+! Check that only one warning is issued inside blocks, and that
+! warnings are also issued for contained subroutines.
+
+program main
+  real :: a(5)
+  block
+    integer :: j
+    do j=0, 5  ! { dg-warning "out of bounds" }
+       a(j) = 2. ! { dg-warning "out of bounds" }
+    end do
+  end block
+  call x
+contains
+  subroutine x
+    integer :: i
+    do i=1,6 ! { dg-warning "out of bounds" }
+       a(i) = 2.  ! { dg-warning "out of bounds" }
+    end do
+  end subroutine x
+end program main
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_4.f90 b/gcc/testsuite/gfortran.dg/do_subscript_4.f90
new file mode 100644
index 00000000000..c773fe75aff
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_subscript_4.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 91424 - this used to warn although the DO loop is zero trip.
+program main
+  implicit none
+  integer :: i
+  real :: a(2)
+  do i=1,3,-1
+     a(i) = 2.
+  end do
+  print *,a
+end program main
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_5.f90 b/gcc/testsuite/gfortran.dg/do_subscript_5.f90
new file mode 100644
index 00000000000..54a4f1ba51a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_subscript_5.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-additional-options "-Wdo-subscript" }
+! PR 90563 - this used to be rejected, wrongly
+! Original test case by Tobias Neumann
+program test
+      implicit none
+      integer, parameter :: swap(4) = [2,1,3,4]
+      real :: p(20)
+      integer :: j
+
+      p = 0.0
+
+      ! The following warnings are actually bogus, but we are not yet
+      ! clever enough to suppress them.
+      do j=1,6 ! { dg-warning "out of bounds" }
+          if (j<5) then
+              p(j) = p(swap(j)) ! { dg-warning "out of bounds" }
+          endif
+      enddo
+end program
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_6.f90 b/gcc/testsuite/gfortran.dg/do_subscript_6.f90
new file mode 100644
index 00000000000..d78b9d39056
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_subscript_6.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR 91550 - this used to cause an ICE
+! Test case by Gerhard Steinmetz
+program p
+   real :: a(3)
+   integer :: i
+   do i = 1, 3, .1 ! { dg-error "cannot be zero" }
+      a(i) = i
+   end do
+end
diff --git a/gcc/testsuite/gfortran.dg/eof_6.f90 b/gcc/testsuite/gfortran.dg/eof_6.f90
new file mode 100644
index 00000000000..1c155576b77
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/eof_6.f90
@@ -0,0 +1,23 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize" }
+! PR 92569 - the EOF condition was not recognized with
+! -ffrontend-optimize.  Originjal test case by Bill Lipa.
+program main
+  implicit none
+  real(kind=8) ::  tdat(1000,10)
+  real(kind=8) :: res (10, 3)
+  integer :: i, j, k, np
+
+  open (unit=20, status="scratch")
+  res = reshape([(real(i),i=1,30)], shape(res))
+  write (20,'(10G12.5)') res
+  rewind 20
+  do  j = 1,1000
+     read (20,*,end=1)(tdat(j,k),k=1,10)
+  end do
+      
+1 continue
+  np = j-1
+  if (np /= 3) stop 1
+  if (any(transpose(res) /= tdat(1:np,:))) stop 2
+end program main
diff --git a/gcc/testsuite/gfortran.dg/external_implicit_none_2.f90 b/gcc/testsuite/gfortran.dg/external_implicit_none_2.f90
new file mode 100644
index 00000000000..b2b1dd1e6d7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/external_implicit_none_2.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+!
+! PR fortran/93309
+!
+module m
+  implicit none(external)
+contains
+  subroutine s
+    implicit none(external) ! OK
+  end subroutine
+end module
+
+module m2
+  implicit none(external)
+contains
+  subroutine s
+    call foo(1)  ! { dg-error "not explicitly declared" }
+  end subroutine
+end module
+
+module m3
+  implicit none(external)
+contains
+  subroutine s
+    implicit none(external) ! OK
+    implicit none(external) ! { dg-error "Duplicate IMPLICIT NONE statement" }
+  end subroutine
+end module
diff --git a/gcc/testsuite/gfortran.dg/function_kinds_5.f90 b/gcc/testsuite/gfortran.dg/function_kinds_5.f90
index e48484ec30d..106431fe206 100644
--- a/gcc/testsuite/gfortran.dg/function_kinds_5.f90
+++ b/gcc/testsuite/gfortran.dg/function_kinds_5.f90
@@ -8,3 +8,4 @@
 real (bad_kind(0d0)) function foo () ! { dg-error "must be an intrinsic function" }
   foo = real (kind (foo))
 end function
+! { dg-prune-output "Bad kind expression for function" }
diff --git a/gcc/testsuite/gfortran.dg/goacc/atomic-1.f90 b/gcc/testsuite/gfortran.dg/goacc/atomic-1.f90
new file mode 100644
index 00000000000..579f0494b78
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/goacc/atomic-1.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+!
+! PR fortran/93462
+!
+! Contributed by G. Steinmetz
+!
+program p
+   integer :: n = 1
+   integer :: a
+!$acc atomic write
+   a = f(n) - f(n)
+contains
+   integer function f(x)
+      integer, intent(in) :: x
+      f = x
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/goacc/pr84963.f90 b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
index 4548082bee3..481f20711f5 100644
--- a/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
+++ b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
@@ -1,5 +1,5 @@
 ! PR ipa/84963
-! { dg-options "-O2" }
+! { dg-additional-options "-O2" }
 
 program p
    print *, sin([1.0, 2.0])
diff --git a/gcc/testsuite/gfortran.dg/goacc/pr93329.f90 b/gcc/testsuite/gfortran.dg/goacc/pr93329.f90
new file mode 100644
index 00000000000..b277bb1243c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/goacc/pr93329.f90
@@ -0,0 +1,223 @@
+! PR fortran/93329
+! { dg-do compile { target fopenmp } }
+! { dg-additional-options "-fopenmp" }
+
+  integer :: x, y, z
+  integer :: a(32)
+!$acc kernels copyout(x)
+!$omp target map(from:x)	! { dg-error "OMP TARGET directive cannot be specified within" }
+  x = 5
+!$omp end target
+!$acc end kernels
+  print *, x
+!$acc kernels
+!$omp atomic			! { dg-error "OMP ATOMIC directive cannot be specified within" }
+  x = x + 1
+!$omp end atomic
+!$acc end kernels
+!$acc kernels
+!$omp barrier			! { dg-error "OMP BARRIER directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp cancel parallel		! { dg-error "OMP CANCEL directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp cancellation point parallel	! { dg-error "OMP CANCELLATION POINT directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp flush			! { dg-error "OMP FLUSH directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp distribute		! { dg-error "OMP DISTRIBUTE directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp distribute parallel do	! { dg-error "OMP DISTRIBUTE PARALLEL DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp distribute parallel do simd	! { dg-error "OMP DISTRIBUTE PARALLEL DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp distribute simd		! { dg-error "OMP DISTRIBUTE SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp do simd			! { dg-error "OMP DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp simd			! { dg-error "OMP SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target data map(from: x)	! { dg-error "OMP TARGET DATA directive cannot be specified within" }
+!$omp end target data
+!$acc end kernels
+!$acc kernels
+!$omp target enter data map(to: x)	! { dg-error "OMP TARGET ENTER DATA directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp target exit data map(from: x)	! { dg-error "OMP TARGET EXIT DATA directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp target parallel		! { dg-error "OMP TARGET PARALLEL directive cannot be specified within" }
+!$omp end target parallel
+!$acc end kernels
+!$acc kernels
+!$omp target parallel do	! { dg-error "OMP TARGET PARALLEL DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target parallel do simd	! { dg-error "OMP TARGET PARALLEL DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!!$omp target simd
+!  do x = 0, 2
+!  end do
+!$acc end kernels
+!$acc kernels
+!$omp target teams		! { dg-error "OMP TARGET TEAMS directive cannot be specified within" }
+!$omp end target teams
+!$acc end kernels
+!$acc kernels
+!$omp target teams distribute	! { dg-error "OMP TARGET TEAMS DISTRIBUTE directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target teams distribute parallel do	! { dg-error "OMP TARGET TEAMS DISTRIBUTE PARALLEL DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target teams distribute parallel do simd	! { dg-error "OMP TARGET TEAMS DISTRIBUTE PARALLEL DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target teams distribute simd	! { dg-error "OMP TARGET TEAMS DISTRIBUTE SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp target update to(x)	! { dg-error "OMP TARGET UPDATE directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp taskgroup			! { dg-error "OMP TASKGROUP directive cannot be specified within" }
+!$omp end taskgroup
+!$acc end kernels
+!$acc kernels
+!$omp taskloop			! { dg-error "OMP TASKLOOP directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp taskloop simd		! { dg-error "OMP TASKLOOP SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp taskwait			! { dg-error "OMP TASKWAIT directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp taskyield			! { dg-error "OMP TASKYIELD directive cannot be specified within" }
+!$acc end kernels
+!$acc kernels
+!$omp teams			! { dg-error "OMP TEAMS directive cannot be specified within" }
+!$omp end teams
+!$acc end kernels
+!$acc kernels
+!$omp teams distribute		! { dg-error "OMP TEAMS DISTRIBUTE directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp teams distribute parallel do	! { dg-error "OMP TEAMS DISTRIBUTE PARALLEL DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp teams distribute parallel do simd	! { dg-error "OMP TEAMS DISTRIBUTE PARALLEL DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp teams distribute simd	! { dg-error "OMP TEAMS DISTRIBUTE SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp parallel do		! { dg-error "OMP PARALLEL DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp parallel do simd		! { dg-error "OMP PARALLEL DO SIMD directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+!$acc kernels
+!$omp parallel			! { dg-error "OMP PARALLEL directive cannot be specified within" }
+!$omp end parallel
+!$acc end kernels
+!$acc kernels
+!$omp parallel sections		! { dg-error "OMP PARALLEL SECTIONS directive cannot be specified within" }
+  y = 1
+!$omp section
+  z = 2
+!$omp end parallel sections
+!$acc end kernels
+!$acc kernels
+!$omp sections			! { dg-error "OMP SECTIONS directive cannot be specified within" }
+  y = 1
+!$omp section
+  z = 2
+!$omp end sections
+!$acc end kernels
+!$acc kernels
+!$omp ordered			! { dg-error "OMP ORDERED directive cannot be specified within" }
+!$omp end ordered
+!$acc end kernels
+!$acc kernels
+!$omp critical			! { dg-error "OMP CRITICAL directive cannot be specified within" }
+!$omp end critical
+!$acc end kernels
+!$acc kernels
+!$omp master			! { dg-error "OMP MASTER directive cannot be specified within" }
+!$omp end master
+!$acc end kernels
+!$acc kernels
+!$omp single			! { dg-error "OMP SINGLE directive cannot be specified within" }
+!$omp end single
+!$acc end kernels
+!$acc kernels
+!$omp task			! { dg-error "OMP TASK directive cannot be specified within" }
+!$omp end task
+!$acc end kernels
+!$acc kernels
+!$omp workshare			! { dg-error "OMP WORKSHARE directive cannot be specified within" }
+  a(:) = 1
+!$omp end workshare
+!$acc end kernels
+!$acc kernels
+!$omp parallel workshare	! { dg-error "OMP PARALLEL WORKSHARE directive cannot be specified within" }
+  a(:) = 1
+!$omp end parallel workshare
+!$acc end kernels
+!$acc kernels
+!$omp do			! { dg-error "OMP DO directive cannot be specified within" }
+  do x = 0, 2
+  end do
+!$acc end kernels
+end
diff --git a/gcc/testsuite/gfortran.dg/goacc/pr93463.f90 b/gcc/testsuite/gfortran.dg/goacc/pr93463.f90
new file mode 100644
index 00000000000..920892fdcda
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/goacc/pr93463.f90
@@ -0,0 +1,15 @@
+! PR fortran/93463
+! { dg-do compile { target fopenmp } }
+! { dg-additional-options "-fopenmp" }
+
+program pr93463
+   integer :: i, x, y, z
+   !$omp parallel do
+   do i = 1, 4
+      !$acc enter data create(x)	! { dg-error "ACC ENTER DATA directive cannot be specified within" }
+      !$acc exit data copyout(x)	! { dg-error "ACC EXIT DATA directive cannot be specified within" }
+      !$acc cache(y)			! { dg-error "ACC CACHE directive cannot be specified within" }
+      !$acc wait(1)			! { dg-error "ACC WAIT directive cannot be specified within" }
+      !$acc update self(z)		! { dg-error "ACC UPDATE directive cannot be specified within" }
+   end do
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr87752.f90 b/gcc/testsuite/gfortran.dg/gomp/pr87752.f90
new file mode 100644
index 00000000000..072de218253
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr87752.f90
@@ -0,0 +1,12 @@
+! PR fortran/87752
+! { dg-do compile }
+! { dg-additional-options "-Ofast" }
+
+subroutine foo (n, u, v)
+  integer :: n
+  real, pointer :: u(:), v(:)
+  !$omp parallel do simd
+  do i = 1, n
+    u(:) = v(:)
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr92977.f90 b/gcc/testsuite/gfortran.dg/gomp/pr92977.f90
new file mode 100644
index 00000000000..0c31f470a94
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr92977.f90
@@ -0,0 +1,15 @@
+! PR fortran/92977
+! { dg-do compile }
+! { dg-additional-options "-O2" }
+
+program pr92977
+  integer :: n = 1
+  integer :: a
+!$omp atomic write
+  a = f(n) - f(n)
+contains
+  integer function f(x)
+    integer, intent(in) :: x
+    f = x
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr93555.f90 b/gcc/testsuite/gfortran.dg/gomp/pr93555.f90
new file mode 100644
index 00000000000..4a97fee07a7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr93555.f90
@@ -0,0 +1,11 @@
+! PR middle-end/93555
+! { dg-do compile }
+
+subroutine foo
+  !$omp declare simd(foo)
+  !$omp declare simd(foo) inbranch
+end
+subroutine bar
+  !$omp declare simd(bar) inbranch
+  !$omp declare simd(bar)
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/target-parallel1.f90 b/gcc/testsuite/gfortran.dg/gomp/target-parallel1.f90
new file mode 100644
index 00000000000..bb8561f1c73
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/target-parallel1.f90
@@ -0,0 +1,4 @@
+!$omp target parallel
+  print *, 'Hello, world'
+!$omp end target parallel
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/teams1.f90 b/gcc/testsuite/gfortran.dg/gomp/teams1.f90
new file mode 100644
index 00000000000..5456bc80479
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/teams1.f90
@@ -0,0 +1,8 @@
+! PR fortran/92756
+
+program pr92756
+  integer :: i
+  !$omp teams distribute parallel do	! { dg-error "'teams' construct not closely nested inside of 'target' construct" }
+  do i = 1, 64
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/graphite/pr93439.f90 b/gcc/testsuite/gfortran.dg/graphite/pr93439.f90
new file mode 100644
index 00000000000..e815ab929e1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/graphite/pr93439.f90
@@ -0,0 +1,21 @@
+! { dg-additional-options "-O2 -floop-parallelize-all -floop-unroll-and-jam -ftree-parallelize-loops=2" }
+
+module ai
+  integer, parameter :: dp = 8
+contains
+  subroutine qu(ja, nq, en, p5)
+    real(kind = dp) :: nq(ja), en(ja), p5(ja)
+    call tl(ja, nq, en, p5)
+  end subroutine qu
+
+  subroutine tl(ja, nq, en, p5)
+    real(kind = dp) :: nq(9), en(9 * ja), p5(3 * ja)
+    do mc = 1, ja
+       do mb = 1, 9
+          do ma = 1, 3
+             p5((mc - 1) * 3 + ma) = p5((mc - 1) * 3 + ma) - 1
+          end do
+       end do
+    end do
+  end subroutine tl
+end module ai
diff --git a/gcc/testsuite/gfortran.dg/inquire_pre.f90 b/gcc/testsuite/gfortran.dg/inquire_pre.f90
new file mode 100644
index 00000000000..c75248b4db7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inquire_pre.f90
@@ -0,0 +1,68 @@
+! { dg-do run }
+! PR93234 Inquire by UNIT on preopened unit failed on ROUND= and SIGN=
+program inquire_browse
+implicit none
+integer                              :: ios
+character(len=256)                   :: message
+   !==============================================================================================
+      character(len=20)              :: name           ; namelist/inquire/name
+      integer                        :: unit           ; namelist/inquire/unit
+      integer                        :: id             ; namelist/inquire/id
+   !==============================================================================================
+      integer                        :: recl           ; namelist/inquire/recl
+      integer                        :: nextrec        ; namelist/inquire/nextrec
+      integer                        :: pos            ; namelist/inquire/pos
+      integer                        :: size           ; namelist/inquire/size
+   !==============================================================================================
+   !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
+      character(len=20)              :: access         ; namelist/inquire/access
+      character(len=20)              :: sequential     ; namelist/inquire/sequential
+      character(len=20)              :: stream         ; namelist/inquire/stream
+      character(len=20)              :: direct         ; namelist/inquire/direct
+   !  ACTION    =  READ        | WRITE         |  READWRITE
+      character(len=20)              :: action         ; namelist/inquire/action
+      character(len=20)              :: read           ; namelist/inquire/read
+      character(len=20)              :: write          ; namelist/inquire/write
+      character(len=20)              :: readwrite      ; namelist/inquire/readwrite
+   !  FORM      =  FORMATTED   |  UNFORMATTED
+      cHaracter(len=20)              :: form           ; namelist/inquire/form
+      character(len=20)              :: formatted      ; namelist/inquire/formatted
+      character(len=20)              :: unformatted    ; namelist/inquire/unformatted
+   !  POSITION  =  ASIS        |  REWIND       |  APPEND
+      character(len=20)              :: position       ; namelist/inquire/position
+   !==============================================================================================
+      character(len=20)              :: blank          ; namelist/inquire/blank
+      character(len=20)              :: decimal        ; namelist/inquire/decimal
+      character(len=20)              :: sign           ; namelist/inquire/sign
+      character(len=20)              :: round          ; namelist/inquire/round
+      character(len=20)              :: delim          ; namelist/inquire/delim
+      character(len=20)              :: encoding       ; namelist/inquire/encoding
+      character(len=20)              :: pad            ; namelist/inquire/pad
+   !==============================================================================================
+      logical                        :: named          ; namelist/inquire/named
+      logical                        :: opened         ; namelist/inquire/opened
+      logical                        :: exist          ; namelist/inquire/exist
+      integer                        :: number         ; namelist/inquire/number
+      logical                        :: pending        ; namelist/inquire/pending
+      character(len=20)              :: asynchronous   ; namelist/inquire/asynchronous
+   !==============================================================================================
+   unit=5
+   !!include "setunit_and_open.inc"
+   inquire(unit=unit,sign=sign)
+   inquire(unit=unit,round=round)
+         inquire(unit=unit,                                                                              &
+     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
+     &   name=name,position=position,                                                                    &
+     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
+     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
+     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
+     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
+     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
+     &   iostat=ios,err=999,iomsg=message)
+999  continue
+     if(ios.eq.0)then
+        !write(*,nml=inquire,delim='none')
+     else
+        stop 1
+     endif
+end program inquire_browse
diff --git a/gcc/testsuite/gfortran.dg/inquiry_type_ref_5.f90 b/gcc/testsuite/gfortran.dg/inquiry_type_ref_5.f90
new file mode 100644
index 00000000000..b27943ae496
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inquiry_type_ref_5.f90
@@ -0,0 +1,29 @@
+! { dg-do run }
+!
+! Test the fix for pr92753
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+module m
+   type t
+      character(3) :: c
+   end type
+   type u
+      complex :: z
+   end type
+   type(t), parameter :: x = t ('abc')
+   integer, parameter :: l = x%c%len           ! Used to ICE
+
+   type(u), parameter :: z = u ((42.0,-42.0))
+end
+program p
+   use m
+   call s (x%c%len)                            !   ditto
+
+   if (int (z%z%re) .ne. 42) stop 1            ! Produced wrong code and
+   if (int (z%z%re) .ne. -int (z%z%im)) stop 2 ! runtime seg fault
+contains
+   subroutine s(n)
+      if (n .ne. l) stop 3
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/matmul_blas_2.f90 b/gcc/testsuite/gfortran.dg/matmul_blas_2.f90
new file mode 100644
index 00000000000..237f4a10d89
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/matmul_blas_2.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-options "-O3 -fdump-tree-original -fexternal-blas" }
+! PR fortran/92321 - this used to cause an ICE.  Original test case
+! by Nathan Wukie.
+
+module mod_badmatmul
+    implicit none
+contains
+
+    subroutine test(c)
+        real, intent(inout) :: c(3,3)
+        real :: a(3,3), b(3,3)
+        c = matmul(a, b)
+    end subroutine test
+
+end module mod_badmatmul
+
+program main
+    use mod_badmatmul, only: test
+    implicit none
+
+    real :: a(3,3)
+    call test(a)
+
+end program main
diff --git a/gcc/testsuite/gfortran.dg/pdt_4.f03 b/gcc/testsuite/gfortran.dg/pdt_4.f03
index 0bb58f91c67..c1af65a5248 100644
--- a/gcc/testsuite/gfortran.dg/pdt_4.f03
+++ b/gcc/testsuite/gfortran.dg/pdt_4.f03
@@ -97,9 +97,9 @@ contains
     type (mytype(4, *)) :: arg      ! OK
   end subroutine
   subroutine bar(arg)               ! { dg-error "is neither allocatable nor a pointer" }
-    type (thytype(8, :, 4) :: arg
+    type (thytype(8, :, 4)) :: arg
   end subroutine
   subroutine foobar(arg)            ! OK
-    type (thytype(8, *, 4) :: arg
+    type (thytype(8, *, 4)) :: arg
   end subroutine
 end
diff --git a/gcc/testsuite/gfortran.dg/pr47054_1.f90 b/gcc/testsuite/gfortran.dg/pr47054_1.f90
new file mode 100644
index 00000000000..3665edbd72b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr47054_1.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fcray-pointer" }
+! PR fortran/47054
+subroutine host_sub
+   implicit none
+   real xg
+   pointer (paxg, xg)
+   call internal_sub
+   contains 
+      subroutine internal_sub
+         implicit none
+         real xg
+         pointer (paxg, xg)
+      end subroutine internal_sub
+end subroutine host_sub
diff --git a/gcc/testsuite/gfortran.dg/pr47054_2.f90 b/gcc/testsuite/gfortran.dg/pr47054_2.f90
new file mode 100644
index 00000000000..3b7c4aaf815
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr47054_2.f90
@@ -0,0 +1,41 @@
+! { dg-do compile }
+! { dg-options "-fcray-pointer" }
+! PR fortran/47054
+! Code contributed by Deji Akingunola <deji_aking at yahoo dot ca>
+subroutine host_sub(F_su,F_nk)
+   implicit none
+   
+   integer :: F_nk
+   real,dimension(F_nk) :: F_su
+      integer G_ni, G_nj
+      real*8 G_xg_8, G_yg_8
+      pointer (paxg_8, G_xg_8(G_ni))
+      pointer (payg_8, G_yg_8(G_nj))
+      common / G_p / paxg_8,payg_8
+      common / G / G_ni, G_nj
+   
+   call internal_sub(F_su,F_nk)
+   return
+contains 
+   
+   subroutine internal_sub(F_su,F_nk)
+      implicit none
+      integer G_ni, G_nj
+      real*8 G_xg_8, G_yg_8
+      pointer (paxg_8, G_xg_8(G_ni))
+      pointer (payg_8, G_yg_8(G_nj))
+      common / G_p / paxg_8,payg_8
+      common / G / G_ni, G_nj
+     
+      integer :: F_nk
+      real,dimension(F_nk) :: F_su 
+      integer k,k2
+      
+      k2 = 0
+      do k = 1, F_nk, 2
+         k2 = k2+1
+               F_su(k) = F_su(k) + 1.0
+      enddo
+      return
+   end subroutine internal_sub
+end subroutine host_sub
diff --git a/gcc/testsuite/gfortran.dg/pr69455_1.f90 b/gcc/testsuite/gfortran.dg/pr69455_1.f90
new file mode 100644
index 00000000000..fe62e5c1b0b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr69455_1.f90
@@ -0,0 +1,14 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_float, ik => c_int
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_double, ik => c_int64_t
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
+
diff --git a/gcc/testsuite/gfortran.dg/pr69455_2.f90 b/gcc/testsuite/gfortran.dg/pr69455_2.f90
new file mode 100644
index 00000000000..8f9fb35021f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr69455_2.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL32, ik => INT32
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL64, ik => INT64
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr70754.f90 b/gcc/testsuite/gfortran.dg/pr70754.f90
index d7e790cc036..593acf917ee 100644
--- a/gcc/testsuite/gfortran.dg/pr70754.f90
+++ b/gcc/testsuite/gfortran.dg/pr70754.f90
@@ -18,12 +18,13 @@ contains
     integer (ii4), dimension(40,40) :: c
     integer  i, j
 
-    do i=1,20
-      b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
-             + 34 * a(i,j-1) + a(i+1,j+1) &
-             + a(i+1,j-1) + a(i-1,j+1) &
-             + a(i-1,j-1)
-      c(i,j) = 123
+    j = 10
+    do i=11,30
+       b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
+            + 34 * a(i,j-1) + a(i+1,j+1) &
+            + a(i+1,j-1) + a(i-1,j+1) &
+            + a(i-1,j-1)
+       c(i,j) = 123
     end do
 
     where ((xyz(:,:,2) /= 0) .and. (c /= 0))
diff --git a/gcc/testsuite/gfortran.dg/pr71649.f90 b/gcc/testsuite/gfortran.dg/pr71649.f90
index f20b7687e6f..c01389acfcf 100644
--- a/gcc/testsuite/gfortran.dg/pr71649.f90
+++ b/gcc/testsuite/gfortran.dg/pr71649.f90
@@ -1,13 +1,13 @@
 ! { dg-do compile }
 ! PR71649 Internal Compiler Error
-SUBROUTINE Compiler_Options ( Options, Version, WriteOpt )
-   USE ISO_FORTRAN_ENV, ONLY : Compiler_Version, Compiler_Options ! { dg-error "already declared" }
+SUBROUTINE Compiler_Options ( Options, Version, WriteOpt )        ! { dg-error "\(1\)" }
+   USE ISO_FORTRAN_ENV, ONLY : Compiler_Version, Compiler_Options ! { dg-error "conflicts with the" }
    IMPLICIT NONE
    CHARACTER (LEN=*), INTENT(OUT) :: Options
    CHARACTER (LEN=*), INTENT(OUT) :: Version
    LOGICAL, INTENT(IN), OPTIONAL  :: WriteOpt
-   Version = Compiler_Version()
-   Options = Compiler_Options() ! { dg-error "Unexpected use of subroutine name" }
+   Version = Compiler_Version()  ! { dg-error "has no IMPLICIT type" }
+   Options = Compiler_Options()  ! { dg-error "Unexpected use of subroutine name" }
    RETURN
 END SUBROUTINE Compiler_Options
 
diff --git a/gcc/testsuite/gfortran.dg/pr77351.f90 b/gcc/testsuite/gfortran.dg/pr77351.f90
index 76ce5c528b2..e3e8bc4f64b 100644
--- a/gcc/testsuite/gfortran.dg/pr77351.f90
+++ b/gcc/testsuite/gfortran.dg/pr77351.f90
@@ -1,6 +1,8 @@
 ! { dg-do compile }
+!
+! PR93835 resulted in different but valid error message
 program p
    integer :: z(4) = [1, 2, 3, 4]
-   print *, any(shape(z) /= [4,1])  ! { dg-error "shape for elemental binary" }
+   print *, any(shape(z) /= [4,1])  ! { dg-error "Shapes for operands at .1. and .2. are not conformable" }
 end
-! { dg-excess-errors "operands are incommensurate" }
+
diff --git a/gcc/testsuite/gfortran.dg/pr78719_1.f90 b/gcc/testsuite/gfortran.dg/pr78719_1.f90
new file mode 100644
index 00000000000..f5a99c23eee
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78719_1.f90
@@ -0,0 +1,29 @@
+! { dg-do run }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g
+      end
+end program p
diff --git a/gcc/testsuite/gfortran.dg/pr78719_2.f90 b/gcc/testsuite/gfortran.dg/pr78719_2.f90
new file mode 100644
index 00000000000..59abebedd16
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78719_2.f90
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   real :: g
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g            ! { dg-error "Invalid procedure pointer" }
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g   ! { dg-error "has an explicit interface" }
+      end
+
+end program p        ! { dg-error "Syntax error" }
diff --git a/gcc/testsuite/gfortran.dg/pr78719_3.f90 b/gcc/testsuite/gfortran.dg/pr78719_3.f90
new file mode 100644
index 00000000000..8e7f6ac9781
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78719_3.f90
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   class(t) :: g     ! { dg-error "must be dummy, allocatable or pointer" }
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g            ! { dg-error "Invalid procedure pointer" }
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g   ! { dg-error "has an explicit interface" }
+      end
+
+end program p        ! { dg-error "Syntax error" }
diff --git a/gcc/testsuite/gfortran.dg/pr78739.f90 b/gcc/testsuite/gfortran.dg/pr78739.f90
new file mode 100644
index 00000000000..4b36b76ab21
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78739.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-w" }
+! PR fortran/78739
+! Code contributed Gerhard Steinmetz
+function f(n)
+   f() = n    ! { dg-error "conflicts with function name" }
+end
+
+function g()
+   g(x) = x   ! { dg-error "conflicts with function name" }
+end
+
+function a()  ! This should cause an error, but cannot be easily detected!
+   a() = x
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85543.f90 b/gcc/testsuite/gfortran.dg/pr85543.f90
index d3f83276a7f..b0faa8d5927 100644
--- a/gcc/testsuite/gfortran.dg/pr85543.f90
+++ b/gcc/testsuite/gfortran.dg/pr85543.f90
@@ -6,3 +6,4 @@ contains
    real(z()) function f()  ! { dg-error "in initialization expression at" }
    end
 end
+! { dg-prune-output "Bad kind expression for function" }
diff --git a/gcc/testsuite/gfortran.dg/pr87991.f90 b/gcc/testsuite/gfortran.dg/pr87991.f90
new file mode 100644
index 00000000000..435871ec779
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr87991.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-w" }
+! PR fortran/87991
+program p
+   type t
+      character(:), pointer :: c
+   end type
+   type(t) :: x
+   allocate (character(3) :: x%c)
+   data x%c /'abc'/   ! { dg-error "has the pointer attribute" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr87993.f90 b/gcc/testsuite/gfortran.dg/pr87993.f90
new file mode 100644
index 00000000000..96d353d64f8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr87993.f90
@@ -0,0 +1,8 @@
+! { dg-do run }
+! Code contributed by Gerhard Steinmetz <gscfq at t-online dot de>
+program p
+   integer, parameter :: a(2) = 1
+   integer, parameter :: b = a%kind
+   if (any(a /= 1)) stop 1
+   if (b /= kind(a)) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88072.f90 b/gcc/testsuite/gfortran.dg/pr88072.f90
new file mode 100644
index 00000000000..5bc6af498dc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88072.f90
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! PR fortran/88072
+! Original code contributed by Andrew Wood <andrew at fluidgravity dot co.uk>
+module m1
+
+   implicit none
+
+   type, abstract, public :: t1
+      integer, dimension(:), allocatable :: i
+      contains
+         procedure(f1), deferred :: f
+   end type t1
+
+   type, extends(t1), public :: t2 ! { dg-error "must be ABSTRACT because" }
+      contains
+         procedure :: f => f2    ! { dg-error "mismatch for the overriding" }
+   end type t2
+
+   abstract interface
+      function f1(this)          ! { dg-error "must be dummy, allocatable or" }
+         import
+         class(t1) :: this
+         class(t1) :: f1
+      end function f1
+   end interface
+   contains
+      type(t2) function f2(this)
+         class(t2) :: this
+      end function f2
+end module m1
diff --git a/gcc/testsuite/gfortran.dg/pr89647.f90 b/gcc/testsuite/gfortran.dg/pr89647.f90
new file mode 100644
index 00000000000..1d4dc2d0582
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89647.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! Code contributed by Ian Harvey  <ian_harvey at bigpond dot com>
+  MODULE m1
+    IMPLICIT NONE
+    PUBLIC :: False
+    PUBLIC :: True
+  CONTAINS
+    FUNCTION False() RESULT(b)
+      LOGICAL :: b
+      b = .FALSE.
+    END FUNCTION False
+    
+    FUNCTION True() RESULT(b)
+      LOGICAL :: b
+      b = .TRUE.
+    END FUNCTION True
+  END MODULE m1
+
+  MODULE m2
+    USE m1
+    IMPLICIT NONE
+    TYPE, ABSTRACT :: t_parent
+    CONTAINS
+      PROCEDURE(False), DEFERRED, NOPASS :: Binding
+    END TYPE t_parent
+  CONTAINS
+    SUBROUTINE s
+      TYPE, EXTENDS(t_parent) :: t_extension
+      CONTAINS
+        PROCEDURE, NOPASS :: Binding => True
+      END TYPE t_extension
+    END SUBROUTINE s
+  END MODULE m2
diff --git a/gcc/testsuite/gfortran.dg/pr89943_1.f90 b/gcc/testsuite/gfortran.dg/pr89943_1.f90
new file mode 100644
index 00000000000..3aa9c36d628
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89943_1.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/89943
+! Code contributed by Alberto Luaces  <aluaces at udc dot se>
+module Foo_mod
+
+   implicit none
+
+   interface
+      module subroutine runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer(c_int32_t) , intent(in) :: ndim
+      end subroutine runFoo4C
+   end interface
+
+   contains
+
+end module Foo_mod
+
+submodule(Foo_mod) Foo_smod
+
+   contains
+
+      module subroutine runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer(c_int32_t) , intent(in) :: ndim
+      end subroutine runFoo4C
+
+end submodule Foo_smod
+
diff --git a/gcc/testsuite/gfortran.dg/pr89943_2.f90 b/gcc/testsuite/gfortran.dg/pr89943_2.f90
new file mode 100644
index 00000000000..ac69ec3af56
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89943_2.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! PR fortran/89943
+! Code contributed by Alberto Luaces  <aluaces at udc dot se>
+module Foo_mod
+
+   implicit none
+
+   interface
+      module function runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer runFoo4c
+         integer(c_int32_t) , intent(in) :: ndim
+      end function runFoo4C
+   end interface
+
+   contains
+
+end module Foo_mod
+
+submodule(Foo_mod) Foo_smod
+
+   contains
+
+      module function runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer runFoo4c
+         integer(c_int32_t) , intent(in) :: ndim
+      end function runFoo4C
+
+end submodule Foo_smod
+
diff --git a/gcc/testsuite/gfortran.dg/pr89943_3.f90 b/gcc/testsuite/gfortran.dg/pr89943_3.f90
new file mode 100644
index 00000000000..38b723e2458
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89943_3.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+module Foo_mod
+
+   implicit none
+
+   interface
+      module subroutine runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer(c_int32_t) , intent(in) :: ndim
+      end subroutine runFoo4C
+   end interface
+
+   contains
+
+end module Foo_mod
+
+submodule(Foo_mod) Foo_smod
+
+   contains
+
+      module subroutine runFoo4C(ndim) bind(C, name="runFu")   ! { dg-error "Mismatch in BIND" }
+         use, intrinsic :: iso_c_binding                 ! { dg-error "Unexpected USE statement" }
+         implicit none                                   ! { dg-error "Unexpected IMPLICIT NONE statement" }
+         integer(c_int32_t) , intent(in) :: ndim         ! { dg-error "Unexpected data declaration" }
+      end subroutine runFoo4C                            ! { dg-error " Expecting END SUBMODULE" }
+
+end submodule Foo_smod
diff --git a/gcc/testsuite/gfortran.dg/pr89943_4.f90 b/gcc/testsuite/gfortran.dg/pr89943_4.f90
new file mode 100644
index 00000000000..8eba2eda171
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89943_4.f90
@@ -0,0 +1,29 @@
+! { dg-do compile }
+module Foo_mod
+
+   implicit none
+
+   interface
+      module function runFoo4C(ndim) bind(C, name="runFoo")
+         use, intrinsic :: iso_c_binding
+         implicit none
+         integer runFoo4c
+         integer(c_int32_t) , intent(in) :: ndim
+      end function runFoo4C
+   end interface
+
+   contains
+
+end module Foo_mod
+
+submodule(Foo_mod) Foo_smod
+
+   contains
+
+      module function runFoo4C(ndim) bind(C, name="runFu")  ! { dg-error "Mismatch in BIND" }
+         use, intrinsic :: iso_c_binding     ! { dg-error "Unexpected USE statement in" }
+         implicit none                       ! { dg-error "Unexpected IMPLICIT NONE statement" }
+         integer(c_int32_t) , intent(in) :: ndim   ! { dg-error "Unexpected data declaration" }
+      end function runFoo4C                  ! { dg-error "Expecting END SUBMODULE" }
+
+end submodule Foo_smod
diff --git a/gcc/testsuite/gfortran.dg/pr91359_1.f b/gcc/testsuite/gfortran.dg/pr91359_1.f
new file mode 100644
index 00000000000..82423142e98
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91359_1.f
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero()
+         goto 2
+1        return
+2        zero = .false.
+         if (.not.zero) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr91359_2.f b/gcc/testsuite/gfortran.dg/pr91359_2.f
new file mode 100644
index 00000000000..7b81a3092b5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91359_2.f
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero() result(a)
+         goto 2
+1        return
+2        a = .false.
+         if (.not.a) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr91471.f90 b/gcc/testsuite/gfortran.dg/pr91471.f90
new file mode 100644
index 00000000000..fa798444c1d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91471.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/91471
+! Code contributed by Sameeran Joshi <SameeranJayant dot Joshi at amd dot com>
+!
+! This invalid code (x(1) is referenced, but never set) caused an ICE due
+! to hitting a gfc_internal_error() in primary.c (gfc_variable_attr).  The
+! fix is to remove that gfc_internal_error().
+! 
+program dynamic
+   implicit none
+   integer, dimension(:), allocatable :: x
+   allocate(x(1))
+   stop x(1)
+end program dynamic
diff --git a/gcc/testsuite/gfortran.dg/pr91485.f90 b/gcc/testsuite/gfortran.dg/pr91485.f90
new file mode 100644
index 00000000000..a6d06877e85
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91485.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+module foo
+   implicit none
+   interface operator(.x.)
+      module procedure product
+   end interface operator(.x.)
+   contains
+      function product(x, y)
+         real, intent(in) :: x, y
+         real :: product
+         product = x * y
+      end function product
+end module foo
+
+module gfcbug155
+   implicit none
+   contains
+      subroutine print_prod (x, y)
+         use foo, only : operator(.x.)
+         implicit none
+         real :: x, y
+         print *, x .x. y
+      end subroutine print_prod
+end module gfcbug155
diff --git a/gcc/testsuite/gfortran.dg/pr91496.f90 b/gcc/testsuite/gfortran.dg/pr91496.f90
new file mode 100644
index 00000000000..cb316748f0e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91496.f90
@@ -0,0 +1,38 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+subroutine foo (a, b, c, n)
+  implicit none
+  real a(*), b(*), c(*)
+  integer :: i, n
+  external bar
+!DIR$ unroll (4)
+!GCC$ unroll 4
+  do i = 1, n
+     a(i) = b(i) + c(i)
+  end do
+!DIR$ ivdep
+!GCC$ ivdep
+  do i = 1, n
+     a(i) = b(i) + c(i)
+  end do
+!DIR$ vector
+!GCC$ vector
+  do i = 1, n
+     a(i) = b(i) + c(i)
+  end do
+!DIR$ novector
+!GCC$ novector
+  do i = 1, n
+     a(i) = b(i) + c(i)
+  end do
+!GCC$ ivdep
+!GCC$ vector
+  do i = 1, n
+     a(i) = b(i) + c(i)
+  end do
+!DIR$ noinline
+!GCC$ noinline          ! { dg-warning "Unclassifiable GCC directive" }
+  call bar (a)
+end subroutine foo
+! { dg-final { scan-tree-dump-times "ANNOTATE_EXPR" 6 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr91552.f90 b/gcc/testsuite/gfortran.dg/pr91552.f90
new file mode 100644
index 00000000000..bb959185cf9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91552.f90
@@ -0,0 +1,10 @@
+! { dg-do run }
+! PR fortran/91552
+! Code contributed by Gerhard Steinmetz.
+program p
+   real :: y(3), z(4)
+   y = 2.0 * [real :: 1, [2], 3]
+   z = 2.0 * [real :: 1, [2, [4]], 3]
+   if (any(y /= [2., 4., 6.])) stop 1
+   if (any(z /= [2., 4., 8., 6.])) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91553.f90 b/gcc/testsuite/gfortran.dg/pr91553.f90
new file mode 100644
index 00000000000..2d0b018dded
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91553.f90
@@ -0,0 +1,8 @@
+! { dg-do run }
+! Code contributed by Gerhard Steinmetz
+program p
+   complex z(1)
+   z = (1.0, 2.0) * [real :: (3.0 + 4.0)]
+   if (real(z(1)) /= 7.) stop 1
+   if (aimag(z(1)) /= 14.) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91564.f90 b/gcc/testsuite/gfortran.dg/pr91564.f90
new file mode 100644
index 00000000000..57783abe1f8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91564.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! PR fortran/91564
+! Contributed by Gerhard Steinmetz.
+program p
+   integer i, j
+   call kill (1, 2, 3)        ! { dg-error "shall be an INTENT" }
+   i = 42
+   call bar(i, j)
+end
+
+subroutine bar(n, m)
+   integer, intent(in) :: n
+   integer, intent(inout) :: m
+   call kill (1, 3, n)        ! { dg-error "shall be an INTENT" }
+   call kill (1, 3, m)
+end subroutine bar
diff --git a/gcc/testsuite/gfortran.dg/pr91565.f90 b/gcc/testsuite/gfortran.dg/pr91565.f90
new file mode 100644
index 00000000000..b43a57acf13
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91565.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! PR fortran/91565
+! Contributed by Gerhard Steinmetz
+program p
+   integer, parameter :: a(2) = [2,2]              ! { dg-error "\(1\)" }
+   print *, reshape([1,2,3,4,5,6], [2,3], order=a) ! { dg-error "not a permutation" }
+end
+
+subroutine foo
+   integer, parameter :: a(1) = 1                  ! { dg-error "\(1\)" }
+   print *, reshape([1,2,3,4,5,6], [2,3], order=a) ! { dg-error "are different" }
+end
+
+subroutine bar
+   integer, parameter :: a(1,2) = 1                ! { dg-error "\(1\)" }
+   print *, reshape([1,2,3,4,5,6], [2,3], order=a) ! { dg-error "are different" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91566.f90 b/gcc/testsuite/gfortran.dg/pr91566.f90
new file mode 100644
index 00000000000..fdb35b44199
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91566.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! Code contributed by Gerhard Steinmetz
+program p
+   call q
+   call r
+end program p
+
+subroutine q
+   print *, -merge([3,4], 0, [.false.,.true.])
+end
+
+subroutine r
+   print *, 2 + merge([3,4], 0, [.false.,.true.])
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91568.f b/gcc/testsuite/gfortran.dg/pr91568.f
new file mode 100644
index 00000000000..4ada559d692
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91568.f
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-Ofast" }
+      subroutine h3dall(z,hvec,hder,nterms)
+      complex *16 hvec(0:1),hder(0:1)
+      complex *16 z,zinv,ztmp/1.0/
+      zinv=1.0/z
+      do i=1,nterms
+         ztmp=zinv*i
+         hder(i)=hvec(i-1)-ztmp*hvec(i)
+      enddo
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr91587.f90 b/gcc/testsuite/gfortran.dg/pr91587.f90
new file mode 100644
index 00000000000..c304be116c0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91587.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/91587
+! Code contributed by Gerhard Steinmetz
+program p
+   backspace(err=!)  ! { dg-error "Invalid value for" }
+   flush(err=!)      ! { dg-error "Invalid value for" }
+   rewind(err=!)     ! { dg-error "Invalid value for" }
+end
+
+subroutine bar       ! An other matcher runs, and gives a different error.
+   endfile(err=!)    ! { dg-error "Expecting END" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91589.f90 b/gcc/testsuite/gfortran.dg/pr91589.f90
new file mode 100644
index 00000000000..d02cb64bfc2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91589.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+!
+! Check the fix for PR91589, in which the invalid expression caused an ICE.
+! Other statements using this invalid expression cause "Unclassifiable statement at..."
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      integer :: a
+   end type
+   type(t) :: x = t(1)
+   call sub (x%a%a)   ! { dg-error "Syntax error in argument list" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr91641.f90 b/gcc/testsuite/gfortran.dg/pr91641.f90
new file mode 100644
index 00000000000..1970824a946
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91641.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/91641
+! Code conyributed by Gerhard Steinmetz
+program p
+   real, pointer :: z(:)
+   print *, is_contiguous (null(z))    ! { dg-error "shall be an associated" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91642.f90 b/gcc/testsuite/gfortran.dg/pr91642.f90
new file mode 100644
index 00000000000..8c41cd2dae0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91642.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/91642
+! Code contributed by Gerhard Steinmetz
+program p
+   integer i
+   integer :: iol
+   integer, external :: null
+   i = 0
+   inquire (iolength=iol) i, null()
+   if (iol == 4) stop 1
+end
+
+subroutine q
+   integer i
+   integer :: iol
+   i = 0
+   inquire (iolength=iol) i, null() ! { dg-error "cannot appear in INQUIRE" }
+   if (iol == 4) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91649.f90 b/gcc/testsuite/gfortran.dg/pr91649.f90
new file mode 100644
index 00000000000..0e6acb9ac8d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91649.f90
@@ -0,0 +1,23 @@
+! { dg-do compile }
+! PR fortran/91649
+! Code originally contributed by Gerhard Steinmetz
+subroutine p
+   logical :: back = .true.
+   integer :: x(1) = findloc([1, 2, 1], '1', back=back) ! { dg-error "must be in type conformance" }
+   print *, x
+end
+
+subroutine q
+   type t
+   end type
+   logical :: back = .false.
+   integer :: x(1) = findloc([1, 2, 1], t(), back=back) ! { dg-error "must be of intrinsic type" }
+   print *, x
+end
+
+subroutine s
+   character(4) :: c = '1234'
+   integer :: x(1) = findloc([1, 2, 1], c, back=.true.) ! { dg-error "must be in type conformance" }
+   print *, x
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr91660_1.f90 b/gcc/testsuite/gfortran.dg/pr91660_1.f90
new file mode 100644
index 00000000000..53a1a808a7b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91660_1.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/91660
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   type (t x    ! { dg-error "Malformed type-spec" }
+   x = t()      ! { dg-error "Cannot convert" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91660_2.f90 b/gcc/testsuite/gfortran.dg/pr91660_2.f90
new file mode 100644
index 00000000000..0072aba1680
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91660_2.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/91660
+program foo
+   type(doubleprecision :: x   ! { dg-error "Malformed type-spec" }
+   type(double precision :: y  ! { dg-error "Malformed type-spec" }
+   type(character(len=3) :: a  ! { dg-error "Malformed type-spec" }
+   type(doublecomplex :: b     ! { dg-error "Malformed type-spec" }
+   type(double complex :: c    ! { dg-error "Malformed type-spec" }
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr91714.f90 b/gcc/testsuite/gfortran.dg/pr91714.f90
new file mode 100644
index 00000000000..8b855d90318
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91714.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! Contributed by Gerhard Steinmetz
+program p
+   typea          ! { dg-error "Mangled derived type" }
+      integer b
+   end type       ! { dg-error "Expecting END PROGRAM" }
+   type(a) :: c   ! { dg-error "is being used before it" }
+   c = a(1)
+   print *, c
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91715.f90 b/gcc/testsuite/gfortran.dg/pr91715.f90
new file mode 100644
index 00000000000..a3d9b8d1d9a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91715.f90
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! PR fortran/91715
+! Code contributed Gerhard Steinmetz
+character(1function f()  ! { dg-error "Syntax error in CHARACTER" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91727.f90 b/gcc/testsuite/gfortran.dg/pr91727.f90
new file mode 100644
index 00000000000..54276b45d33
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91727.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! Code contributed by Gerhard Steinmetz.
+program p
+   type t
+      class(*), allocatable :: a
+   end type
+   type(t) :: x
+   allocate (x%a, source=[1]) ! { dg-error "have the same rank as" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91785.f90 b/gcc/testsuite/gfortran.dg/pr91785.f90
new file mode 100644
index 00000000000..fb3d964fc06
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91785.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/91785
+! Code contributed by Gerhard Steinmetz
+program p
+   complex :: a(*)   ! { dg-error "Assumed size array at" }
+   real :: b(2)
+   b = a%im          ! { dg-error "upper bound in the last dimension" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91801.f90 b/gcc/testsuite/gfortran.dg/pr91801.f90
new file mode 100644
index 00000000000..d2d82b88464
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91801.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/91801
+! Code contributed by Gerhard Steinmetz
+program p
+   integer, parameter :: a(2) = [2,0]              ! { dg-error "Element with a value of" }
+   print *, reshape([1,2,3,4,5,6], [2,3], order=a) ! { dg-error "for the RESHAPE intrinsic near" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91802.f90 b/gcc/testsuite/gfortran.dg/pr91802.f90
new file mode 100644
index 00000000000..277d61aae82
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91802.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single" }
+! Code contributed by Gerhard Steinmetz
+! PR fortran/91802
+module m
+   real :: x
+   dimension ::   x(1,2,1,2,1,2,1,2)
+   codimension :: x[1,2,1,2,1,2,1,*] ! { dg-error "exceeds 15" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91864.f90 b/gcc/testsuite/gfortran.dg/pr91864.f90
new file mode 100644
index 00000000000..a17187dcdc0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91864.f90
@@ -0,0 +1,22 @@
+program p
+   integer :: i
+   read (*,*) i%kind   ! { dg-error "Expecting variable or io-implied-do" }
+end
+
+subroutine t
+   integer, allocatable :: x(:)
+   integer :: stat
+   allocate (x(3), stat=stat%kind)   ! { dg-error "cannot be a constant" }
+end
+
+subroutine u
+   integer, allocatable :: x(:)
+   integer :: stat
+   allocate (x(3), stat%kind=stat)   ! { dg-error "Unexpected constant" }
+end
+
+subroutine v
+   integer, allocatable :: x(:)
+   integer :: stat
+   deallocate (x, stat%kind=stat)   ! { dg-error "Unexpected constant" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr91942.f90 b/gcc/testsuite/gfortran.dg/pr91942.f90
new file mode 100644
index 00000000000..cd237d38660
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91942.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/91942
+! Code contributed by Gerhard Steinmetz
+program p
+   integer :: i
+   backspace (iostat=i%kind) ! { dg-error "Expecting a variable at" }
+   endfile (iostat=i%kind) ! { dg-error "Expecting END PROGRAM" }
+   flush (iostat=i%kind) ! { dg-error "Expecting a variable at" }
+   rewind (iostat=i%kind) ! { dg-error "Expecting a variable at" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr92050.f90 b/gcc/testsuite/gfortran.dg/pr92050.f90
new file mode 100644
index 00000000000..64193878d8f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92050.f90
@@ -0,0 +1,53 @@
+! { dg-do run }
+! { dg-options "-fcheck=all" }
+! { dg-shouldfail "above upper bound" }
+!
+! PR fortran/92050
+!
+!
+module buggy
+  implicit none (type, external)
+
+  type :: par
+  contains
+    procedure, public :: fun => fun_par
+  end type par
+
+  type comp
+    class(par), allocatable :: p
+  end type comp
+
+  type foo
+    type(comp), allocatable :: m(:)
+  end type foo
+
+contains
+
+  function fun_par(this)
+    class(par) :: this
+    integer    :: fun_par(1)
+    fun_par = 42
+  end function fun_par
+
+  subroutine update_foo(this)
+    class(foo) :: this
+    write(*,*) this%m(1)%p%fun()
+  end subroutine update_foo
+
+  subroutine bad_update_foo(this)
+    class(foo) :: this
+    write(*,*) this%m(2)%p%fun()
+  end subroutine bad_update_foo
+end module buggy
+
+program main
+  use buggy
+  implicit none (type, external)
+  type(foo) :: x
+  allocate(x%m(1))
+  allocate(x%m(1)%p)
+  call update_foo(x)
+  call bad_update_foo(x)
+end program main
+
+! { dg-output "At line 39 of file .*pr92050.f90.*Fortran runtime error: Index '2' of dimension 1 of array 'this%m' above upper bound of 1" }
diff --git a/gcc/testsuite/gfortran.dg/pr92208.f90 b/gcc/testsuite/gfortran.dg/pr92208.f90
new file mode 100644
index 00000000000..9de7f4b24b5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92208.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! PR fortran/92208
+!
+! Contributed by Nils Reiche
+!
+program stringtest
+  implicit none
+  integer, parameter :: noVars = 2
+
+!  print*, "varNames: ", createVarnames("var",noVars)
+  call function1(noVars,createVarnames("var",noVars),"path")
+
+contains
+
+function createVarnames(string,noVars) result(stringArray)
+  implicit none
+  character(len=*),                        intent(in)  :: string
+  integer,                                 intent(in)  :: noVars
+  character(len=len_trim(string)+6), dimension(noVars) :: stringArray
+  integer :: i
+  do i=1,noVars
+    write(stringArray(i),'(a,i0)') string, i
+  enddo
+end function createVarnames
+
+subroutine function1(noVars,varNames,path)
+  implicit none
+  integer, intent(in)  :: noVars
+  character(len=*), intent(in)  :: path
+  character(len=*), dimension(noVars) :: varNames
+
+  if (path /= 'path') stop 1
+  if (any(varNames /= ['var1', 'var2'])) stop 2
+  !print*, "function1-path    : ", trim(path)
+  !print*, "function1-varNames: ", varNames
+end subroutine function1
+
+end program stringtest
diff --git a/gcc/testsuite/gfortran.dg/pr92277.f90 b/gcc/testsuite/gfortran.dg/pr92277.f90
new file mode 100644
index 00000000000..5121063f5f3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92277.f90
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR fortran/92277
+!
+! Contributed by José Rui Faustino de Sousa
+!
+module arr_m
+  implicit none
+contains
+  subroutine arr_set(this, that)
+    integer, intent(out) :: this(..)
+    integer, optional, intent(out) :: that(..)
+
+    interface
+      subroutine arr_set_c(this) bind(c)
+        use, intrinsic :: iso_c_binding, only: c_int
+        implicit none
+        integer(kind=c_int), intent(out) :: this(..)
+      end subroutine arr_set_c
+      subroutine arr_set_c_opt(this) bind(c)
+        use, intrinsic :: iso_c_binding, only: c_int
+        implicit none
+        integer(kind=c_int), optional, intent(out) :: this(..)
+      end subroutine arr_set_c_opt
+    end interface
+
+    call arr_set_c(this)
+    call arr_set_c(that)
+    call arr_set_c_opt(this)
+    call arr_set_c_opt(that)
+  end subroutine arr_set
+end module arr_m
diff --git a/gcc/testsuite/gfortran.dg/pr92629.f90 b/gcc/testsuite/gfortran.dg/pr92629.f90
new file mode 100644
index 00000000000..5c2267ca6f1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92629.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! { dg-options "-fno-range-check" }
+!
+! Test the fix for PR92629.
+program bge_tests
+  if (bge (huge (1_1), 128_1)) stop 1
+  if (bge (    128_1 , 255_1)) stop 2
+  if (bge (huge (1_2), 32768_2)) stop 3
+  if (bge (huge (1_4), 2147483648_4)) stop 4
+  if (bge (huge (1_8), 9223372036854775808_8)) stop 5
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr92781.f90 b/gcc/testsuite/gfortran.dg/pr92781.f90
new file mode 100644
index 00000000000..67a1961205a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92781.f90
@@ -0,0 +1,11 @@
+! PR fortran/92781
+! { dg-do compile }
+
+function foo ()
+  character(:), allocatable :: foo
+  call bar ()
+  foo = 'abc'
+contains
+  subroutine bar
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr92897.f90 b/gcc/testsuite/gfortran.dg/pr92897.f90
new file mode 100644
index 00000000000..6e0f9836bb4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92897.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single" }
+! Test contributed by Gerhard Steinmetz
+type(t) function f()                    ! { dg-error "has not been declared" }
+   dimension :: t(1,2,1,2,1,2,1,2)
+   codimension :: t[1,2,1,2,1,2,1,*]    ! { dg-error "rank \\+ corank of" }
+end
+! { dg-prune-output "which has not been defined" }
diff --git a/gcc/testsuite/gfortran.dg/pr92898.f90 b/gcc/testsuite/gfortran.dg/pr92898.f90
new file mode 100644
index 00000000000..1c831eda1bb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr92898.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/92898
+! Code contributed by Gerhard Steinmetz
+program p
+  print *, is_contiguous (null())     ! { dg-error "shall be an associated" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93263_1.f90 b/gcc/testsuite/gfortran.dg/pr93263_1.f90
new file mode 100644
index 00000000000..3fa22476053
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93263_1.f90
@@ -0,0 +1,29 @@
+! { dg-do compile }
+! { dg-options "-fno-automatic -fdump-tree-original" }
+!
+! Test contributed by Mark Eggleston  <mark.eggleston@codethink.com>
+
+program main
+  implicit none
+  call check(2)
+end 
+
+recursive subroutine check(n)
+  implicit none
+  integer n, a
+  a = 10
+  print*,"n=",n
+  if (n==1) then
+    a=a-1
+    print*,"assigning a=",a
+  else
+    a=a-2
+    print*,"assigning a=",a
+    call check(n-1)
+  endif
+  print*,"a=",a
+end 
+
+! { dg-final { scan-tree-dump-not "static integer\\(kind=4\\) a" "original" } }
+! { dg-final { scan-tree-dump "integer\\(kind=4\\) a" "original" } }
+
diff --git a/gcc/testsuite/gfortran.dg/pr93263_2.f90 b/gcc/testsuite/gfortran.dg/pr93263_2.f90
new file mode 100644
index 00000000000..fd353c6b548
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93263_2.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+!
+! Test contributed by Tobias Burnus  <burnus@gcc.gnu.org>
+
+  integer :: cnt
+  cnt = 0
+  call sub()
+  if (cnt /= 5) stop 1
+contains
+  recursive subroutine sub()
+    save
+    logical :: first = .true.
+    integer :: i
+    cnt = cnt + 1
+    if (first) then
+      first = .false.
+      i = 1
+    end if
+    print *, "Hello", i
+    i = i + 1
+    if (i <= 5) call sub()
+  end subroutine
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93580.f90 b/gcc/testsuite/gfortran.dg/pr93580.f90
new file mode 100644
index 00000000000..4feaa112914
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93580.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/93580
+
+program p
+   integer, parameter :: n = 4
+   complex(n%re) :: x    ! { dg-error "The RE or IM part_ref at" }
+   complex(n%im) :: y    ! { dg-error "The RE or IM part_ref at" }
+   complex(n%len) :: z   ! { dg-error "The LEN part_ref at" }
+   character(n%im) :: a  ! { dg-error "The RE or IM part_ref at" }
+   character(n%re) :: b  ! { dg-error "The RE or IM part_ref at" }
+   character(n%len) :: c ! { dg-error "The LEN part_ref at" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93714_1.f90 b/gcc/testsuite/gfortran.dg/pr93714_1.f90
new file mode 100644
index 00000000000..40f4a4bf89f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93714_1.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 93714
+! Original test case from G. Steinmetz
+
+program test
+   character((1.)) :: a
+   character, pointer :: b => a
+end program
+
+! { dg-error "must be of INTEGER type" " " { target *-*-* } 6 }
+! { dg-error "does not have the TARGET attribute" " " { target *-*-* } 7 }
diff --git a/gcc/testsuite/gfortran.dg/pr93714_2.f90 b/gcc/testsuite/gfortran.dg/pr93714_2.f90
new file mode 100644
index 00000000000..86658f28859
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93714_2.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 93714
+! Original test case from G. Steinmetz
+
+program test
+   character((9.)) :: a
+   character(:), pointer :: b => a
+end program
+
+! { dg-error "must be of INTEGER type" " " { target *-*-* } 6 }
+! { dg-error "does not have the TARGET attribute" " " { target *-*-* } 7 }
diff --git a/gcc/testsuite/gfortran.dg/pr93835.f08 b/gcc/testsuite/gfortran.dg/pr93835.f08
new file mode 100644
index 00000000000..933e249e632
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93835.f08
@@ -0,0 +1,8 @@
+! {dg-do run }
+!
+! PR fortran/93835 - the following code resulted in an ICE
+!
+program p
+  if (any(findloc(shape(1), 1) .ne. 0)) stop 1
+end
+
diff --git a/gcc/testsuite/gfortran.dg/select_type_48.f90 b/gcc/testsuite/gfortran.dg/select_type_48.f90
new file mode 100644
index 00000000000..d9ad01ce4f6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_48.f90
@@ -0,0 +1,31 @@
+! { dg-do run }
+!
+! Test the fix for PR92976, in which the TYPE IS statement caused an ICE
+! because of the explicit bounds of 'x'.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      integer :: i
+   end type
+   class(t), allocatable :: c(:)
+   allocate (c, source = [t(1111),t(2222),t(3333)])
+   call s(c)
+   if (sum (c%i) .ne. 3333) stop 1
+contains
+   subroutine s(x)
+      class(t) :: x(2)
+      select type (x)
+! ICE as compiler attempted to assign descriptor to an array
+         type is (t)
+            x%i = 0
+! Make sure that bounds are correctly translated.
+            call counter (x)
+      end select
+   end
+   subroutine counter (arg)
+     type(t) :: arg(:)
+     if (size (arg, 1) .ne. 2) stop 2
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/spread_size_limit_2.f90 b/gcc/testsuite/gfortran.dg/spread_size_limit_2.f90
new file mode 100644
index 00000000000..3ea064e267f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/spread_size_limit_2.f90
@@ -0,0 +1,11 @@
+! PR fortran/91944
+! { dg-do compile }
+! { dg-options "-fmax-array-constructor=65535" }
+
+program pr91944
+  integer, parameter :: n = 10
+  integer, parameter :: m = 65536
+  integer :: i
+  integer :: x(n,m) = spread([(i,i=1,n)], dim=2, ncopies=m)	! { dg-error "requires an increase of the allowed 65535 upper limit" }
+  print *, x(n,m)
+end
diff --git a/gcc/testsuite/gfortran.dg/streamio_18.f90 b/gcc/testsuite/gfortran.dg/streamio_18.f90
new file mode 100644
index 00000000000..ee36238ecfa
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/streamio_18.f90
@@ -0,0 +1,23 @@
+! { dg-do run }
+! PR91200
+program foo
+  implicit none
+  integer fd
+  open(newunit=fd, file='test.dat', access='stream', form='formatted')
+  write(fd,'(A)') '$MeshFormat'
+  write(fd,'(A)') 'aabbccdd'
+  close(fd)
+  call readfile  ! Read test.dat
+contains
+  subroutine readfile
+     character(len=20) buf1, buf2
+     integer fd, m, n
+     open(newunit=fd, file='test.dat', access='stream', form='formatted')
+     inquire(fd, pos=m)
+     if (m /= 1) stop 'm /= 1'
+     read(fd, *) buf1
+     read(fd, *, pos=m) buf2        ! Reread by using pos=1
+     close(fd, status='delete')
+     if (buf1 /= buf2) stop 'wrong'
+  end subroutine readfile
+end program
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90
index b474a243233..a9f67273d5e 100644
--- a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90
@@ -21,7 +21,7 @@ implicit none
 
   type,abstract,extends(c_base) :: c_derived
   contains
-    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result \\(CLASS\\(\\*\\)/CLASS\\(c_base\\)\\)" }
+    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result" }
   end type c_derived
 
 contains
diff --git a/gcc/testsuite/gfortran.dg/use_15.f90 b/gcc/testsuite/gfortran.dg/use_15.f90
index bd5920aa033..eb5aa87cc8b 100644
--- a/gcc/testsuite/gfortran.dg/use_15.f90
+++ b/gcc/testsuite/gfortran.dg/use_15.f90
@@ -28,8 +28,8 @@ subroutine my_sub2 (a)
 end subroutine
 
 
-subroutine my_sub3 (a)
-  use test_mod2, my_sub3 => my_sub2  ! { dg-error "is also the name of the current program unit" }
+subroutine my_sub3 (a)              ! { dg-error "\(1\)" }
+  use test_mod2, my_sub3 => my_sub2 ! { dg-error "conflicts with the rename" }
   real a
   print *, a
 end subroutine
diff --git a/gcc/testsuite/gfortran.dg/use_rename_8.f90 b/gcc/testsuite/gfortran.dg/use_rename_8.f90
index ad3ab3977c5..b8b49d7a052 100644
--- a/gcc/testsuite/gfortran.dg/use_rename_8.f90
+++ b/gcc/testsuite/gfortran.dg/use_rename_8.f90
@@ -19,8 +19,8 @@ SUBROUTINE T
     USE MOO, ONLY: X => B
 END SUBROUTINE T
 
-SUBROUTINE C
-    USE MOO, ONLY: C  ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE C          ! { dg-error "\(1\)" }
+    USE MOO, ONLY: C  ! { dg-error "conflicts with the" }
 END SUBROUTINE C
 
 SUBROUTINE D
@@ -36,15 +36,15 @@ SUBROUTINE F
     USE MOO, ONLY: X => F
 END SUBROUTINE F
 
-SUBROUTINE X
-    USE MOO, ONLY: X => G ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE X              ! { dg-error "\(1\)" }
+    USE MOO, ONLY: X => G ! { dg-error "conflicts with the rename" }
 END SUBROUTINE X
 
-SUBROUTINE Y
-    USE MOO, ONLY: Y => H ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE Y              ! { dg-error "\(1\)" }
+    USE MOO, ONLY: Y => H ! { dg-error "conflicts with the rename" }
 END SUBROUTINE Y
 
-SUBROUTINE Z
-    USE MOO, ONLY: Z => I, Z => I ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE Z                        ! { dg-error "\(1\)" }
+    USE MOO, ONLY: Z => I, Z => I   ! { dg-error "conflicts with the rename" }
 END SUBROUTINE Z
 
diff --git a/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90 b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90
new file mode 100644
index 00000000000..fa93f1d7ff2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-additional-options "-Wunused-dummy-argument" }
+! PR 91557 - this used to generate a bogus warning
+! Test case by Gerhard Steinmetz
+program p
+   integer :: a, b
+   a = 1
+   call g
+contains
+   subroutine g
+      integer :: x, y
+      call h (x, y)
+      if ( a > 0 )   y = y - 1
+      b = y - x + 1
+   end
+end
diff --git a/gcc/testsuite/gnat.dg/addr14.adb b/gcc/testsuite/gnat.dg/addr14.adb
new file mode 100644
index 00000000000..e92c902f038
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/addr14.adb
@@ -0,0 +1,24 @@
+--  { dg-do run }
+
+with System;
+
+procedure Addr14 is
+
+  type Arr is array (1 .. 4) of aliased Integer;
+
+  A : Arr := (1, 2, 3, 4);
+  I : Natural := 0;
+
+  function Get_Address return System.Address is
+  begin
+    I := I + 1;
+    return A(I)'Address;
+  end;
+
+  Foo : Integer with Address => Get_Address;
+
+begin
+  if Foo /= 1 then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/lto23.adb b/gcc/testsuite/gnat.dg/lto23.adb
new file mode 100644
index 00000000000..88615c9a6c1
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/lto23.adb
@@ -0,0 +1,20 @@
+-- { dg-do compile }
+-- { dg-options "-flto" { target lto } }
+
+procedure Lto23 (N : Natural) is
+
+  type Root is tagged null record;
+
+  type Vec is array (Positive range <>) of Root;
+
+  type Rec is record
+    V : Vec (1 .. N);
+  end record;
+
+  type Arr is array (Positive range <>) of Rec;
+
+  A : Arr (1 .. 4);
+
+begin
+  null;
+end;
diff --git a/gcc/testsuite/gnat.dg/lto24.adb b/gcc/testsuite/gnat.dg/lto24.adb
new file mode 100644
index 00000000000..998b4478254
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/lto24.adb
@@ -0,0 +1,10 @@
+-- { dg-do link }
+-- { dg-options "-O -g -flto" { target lto } }
+
+with Lto24_Pkg1;
+
+procedure Lto24 is
+  R : Lto24_Pkg1.Rec (False);
+begin
+  R.Empty := True;
+end;
diff --git a/gcc/testsuite/gnat.dg/lto24_pkg1.ads b/gcc/testsuite/gnat.dg/lto24_pkg1.ads
new file mode 100644
index 00000000000..abe7e911787
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/lto24_pkg1.ads
@@ -0,0 +1,17 @@
+with Lto24_Pkg2;
+
+package Lto24_Pkg1 is
+
+  Max_Elem : constant Natural := Lto24_Pkg2.Get;
+
+  type Arr is array (Natural range <>) of Boolean;
+
+  type Rec (B : Boolean) is record
+     I : Integer;
+     case B is
+       when True => A : Arr (1 .. Max_Elem);
+       when False => Empty : Boolean;
+     end case;
+  end record;
+
+end Lto24_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/lto24_pkg2.adb b/gcc/testsuite/gnat.dg/lto24_pkg2.adb
new file mode 100644
index 00000000000..12fb34e5750
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/lto24_pkg2.adb
@@ -0,0 +1,8 @@
+package body Lto24_Pkg2 is
+
+  function Get return Natural is
+  begin
+    return 16;
+  end;
+
+end Lto24_Pkg2;
diff --git a/gcc/testsuite/gnat.dg/lto24_pkg2.ads b/gcc/testsuite/gnat.dg/lto24_pkg2.ads
new file mode 100644
index 00000000000..79a916ea0b7
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/lto24_pkg2.ads
@@ -0,0 +1,5 @@
+package Lto24_Pkg2 is
+
+  function Get return Natural;
+
+end Lto24_Pkg2;
diff --git a/gcc/testsuite/gnat.dg/socket1.adb b/gcc/testsuite/gnat.dg/socket1.adb
index a6bdade304b..154a7aff190 100644
--- a/gcc/testsuite/gnat.dg/socket1.adb
+++ b/gcc/testsuite/gnat.dg/socket1.adb
@@ -1,4 +1,4 @@
--- { dg-do run { target { ! "*-*-solaris2*" } } }
+-- { dg-do run { target { ! { hppa*-*-hpux* *-*-solaris2* } } } }
 
 with GNAT.Sockets; use GNAT.Sockets;
 procedure socket1 is
diff --git a/gcc/testsuite/obj-c++.dg/stubify-1.mm b/gcc/testsuite/obj-c++.dg/stubify-1.mm
index c2355437afc..e8f21882de9 100644
--- a/gcc/testsuite/obj-c++.dg/stubify-1.mm
+++ b/gcc/testsuite/obj-c++.dg/stubify-1.mm
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -32,8 +32,8 @@ extern "C" {
 }
 @end
 
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_objc_msgSend\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_objc_msgSend\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_bogonic\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_bogonic\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\\\$non_lazy_ptr" } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
diff --git a/gcc/testsuite/obj-c++.dg/stubify-2.mm b/gcc/testsuite/obj-c++.dg/stubify-2.mm
index a9f66cac5d2..1863f986ce0 100644
--- a/gcc/testsuite/obj-c++.dg/stubify-2.mm
+++ b/gcc/testsuite/obj-c++.dg/stubify-2.mm
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -30,4 +30,9 @@ extern int bogonic (int, int, int) ;
 
 /* Any symbol_ref of an un-stubified objc_msgSend is an error; look
    for "objc_msgSend" in quotes, without the $stub suffix. */
-/* { dg-final {  scan-rtl-dump-not "symbol_ref.*\"objc_msgSend\"" "jump" } } */
+
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_Z7bogoniciii\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L__Z7bogoniciii\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
diff --git a/gcc/testsuite/objc.dg/stubify-1.m b/gcc/testsuite/objc.dg/stubify-1.m
index 91bf73a14f7..641595ccfe4 100644
--- a/gcc/testsuite/objc.dg/stubify-1.m
+++ b/gcc/testsuite/objc.dg/stubify-1.m
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4" } */
+/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -28,8 +28,8 @@ extern int bogonic (int, int, int) ;
 }
 @end
 
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_objc_msgSend\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_objc_msgSend\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_bogonic\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_bogonic\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\\\$non_lazy_ptr" } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
diff --git a/gcc/testsuite/objc.dg/stubify-2.m b/gcc/testsuite/objc.dg/stubify-2.m
index eaf4b964e4b..2930e46fc13 100644
--- a/gcc/testsuite/objc.dg/stubify-2.m
+++ b/gcc/testsuite/objc.dg/stubify-2.m
@@ -1,10 +1,10 @@
 /* All calls must be properly stubified, m32 only.  */
 /* Testcase extracted from TextEdit:Document.m.  */
 
-/* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -30,4 +30,9 @@ extern int bogonic (int, int, int) ;
 
 /* Any symbol_ref of an un-stubified objc_msgSend is an error; look
    for "objc_msgSend" in quotes, without the $stub suffix.  */
-/* { dg-final { scan-rtl-dump-not "symbol_ref.*\"objc_msgSend\"" "jump" } } */
+
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index 32be59acfb0..0c4ae81aa05 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -3215,6 +3215,13 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)
 	  debug_generic_stmt (expr);
 	  return true;
 	}
+      if (MR_DEPENDENCE_CLIQUE (expr) != 0
+	  && MR_DEPENDENCE_CLIQUE (expr) > cfun->last_clique)
+	{
+	  error ("invalid clique in MEM_REF");
+	  debug_generic_stmt (expr);
+	  return true;
+	}
     }
   else if (TREE_CODE (expr) == TARGET_MEM_REF)
     {
@@ -3234,6 +3241,13 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)
 	  debug_generic_stmt (expr);
 	  return true;
 	}
+      if (MR_DEPENDENCE_CLIQUE (expr) != 0
+	  && MR_DEPENDENCE_CLIQUE (expr) > cfun->last_clique)
+	{
+	  error ("invalid clique in TARGET_MEM_REF");
+	  debug_generic_stmt (expr);
+	  return true;
+	}
     }
   else if (TREE_CODE (expr) == INDIRECT_REF)
     {
@@ -7677,6 +7691,9 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,
       after = bb;
     }
 
+  /* Adjust the maximum clique used.  */
+  dest_cfun->last_clique = saved_cfun->last_clique;
+
   loop->aux = NULL;
   loop0->aux = NULL;
   /* Loop sizes are no longer correct, fix them up.  */
@@ -9151,7 +9168,7 @@ generate_range_test (basic_block bb, tree index, tree low, tree high,
 		     tree *lhs, tree *rhs)
 {
   tree type = TREE_TYPE (index);
-  tree utype = unsigned_type_for (type);
+  tree utype = range_check_type (type);
 
   low = fold_convert (utype, low);
   high = fold_convert (utype, high);
diff --git a/gcc/tree-cfgcleanup.c b/gcc/tree-cfgcleanup.c
index 183b491ab1d..4bac38ab00c 100644
--- a/gcc/tree-cfgcleanup.c
+++ b/gcc/tree-cfgcleanup.c
@@ -101,6 +101,8 @@ convert_single_case_switch (gswitch *swtch, gimple_stmt_iterator &gsi)
   if (high)
     {
       tree lhs, rhs;
+      if (range_check_type (TREE_TYPE (index)) == NULL_TREE)
+	return false;
       generate_range_test (bb, index, low, high, &lhs, &rhs);
       cond = gimple_build_cond (LE_EXPR, lhs, rhs, NULL_TREE, NULL_TREE);
     }
diff --git a/gcc/tree-core.h b/gcc/tree-core.h
index fbed0c379b2..41d05294936 100644
--- a/gcc/tree-core.h
+++ b/gcc/tree-core.h
@@ -851,7 +851,8 @@ enum operand_equal_flag {
   /* Internal within inchash::add_expr:  */
   OEP_HASH_CHECK = 32,
   /* Makes operand_equal_p handle more expressions:  */
-  OEP_LEXICOGRAPHIC = 64
+  OEP_LEXICOGRAPHIC = 64,
+  OEP_BITWISE = 128
 };
 
 /* Enum and arrays used for tree allocation stats.
diff --git a/gcc/tree-dfa.c b/gcc/tree-dfa.c
index 9ba627c90b5..64991ba92fa 100644
--- a/gcc/tree-dfa.c
+++ b/gcc/tree-dfa.c
@@ -61,23 +61,23 @@ static void collect_dfa_stats (struct dfa_stats_d *);
 /* Renumber all of the gimple stmt uids.  */
 
 void
-renumber_gimple_stmt_uids (void)
+renumber_gimple_stmt_uids (struct function *fun)
 {
   basic_block bb;
 
-  set_gimple_stmt_max_uid (cfun, 0);
-  FOR_ALL_BB_FN (bb, cfun)
+  set_gimple_stmt_max_uid (fun, 0);
+  FOR_ALL_BB_FN (bb, fun)
     {
       gimple_stmt_iterator bsi;
       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))
 	{
 	  gimple *stmt = gsi_stmt (bsi);
-	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
+	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fun));
 	}
       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))
 	{
 	  gimple *stmt = gsi_stmt (bsi);
-	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
+	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fun));
 	}
     }
 }
diff --git a/gcc/tree-dfa.h b/gcc/tree-dfa.h
index 98810080c65..aa4ab7eb946 100644
--- a/gcc/tree-dfa.h
+++ b/gcc/tree-dfa.h
@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see
 #ifndef GCC_TREE_DFA_H
 #define GCC_TREE_DFA_H
 
-extern void renumber_gimple_stmt_uids (void);
+extern void renumber_gimple_stmt_uids (struct function *);
 extern void renumber_gimple_stmt_uids_in_blocks (basic_block *, int);
 extern void dump_variable (FILE *, tree);
 extern void debug_variable (tree);
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
index 98566e3fd19..2780a4b243f 100644
--- a/gcc/tree-if-conv.c
+++ b/gcc/tree-if-conv.c
@@ -2626,6 +2626,11 @@ combine_blocks (struct loop *loop)
       vphi = get_virtual_phi (bb);
       if (vphi)
 	{
+	  /* When there's just loads inside the loop a stray virtual
+	     PHI merging the uses can appear, update last_vdef from
+	     it.  */
+	  if (!last_vdef)
+	    last_vdef = gimple_phi_arg_def (vphi, 0);
 	  imm_use_iterator iter;
 	  use_operand_p use_p;
 	  gimple *use_stmt;
@@ -2657,6 +2662,10 @@ combine_blocks (struct loop *loop)
 	      if (gimple_vdef (stmt))
 		last_vdef = gimple_vdef (stmt);
 	    }
+	  else
+	    /* If this is the first load we arrive at update last_vdef
+	       so we handle stray PHIs correctly.  */
+	    last_vdef = gimple_vuse (stmt);
 	  if (predicated[i])
 	    {
 	      ssa_op_iter i;
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index 9fe8f26a771..d115fcb1a5b 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -4499,7 +4499,8 @@ reset_debug_bindings (copy_body_data *id, gimple_stmt_iterator gsi)
 /* If STMT is a GIMPLE_CALL, replace it with its inline expansion.  */
 
 static bool
-expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)
+expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,
+		    bitmap to_purge)
 {
   tree use_retvar;
   tree fn;
@@ -4644,7 +4645,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)
       gimple_call_set_fndecl (stmt, edge->callee->decl);
       update_stmt (stmt);
       id->src_node->remove ();
-      expand_call_inline (bb, stmt, id);
+      expand_call_inline (bb, stmt, id, to_purge);
       maybe_remove_unused_call_args (cfun, stmt);
       return true;
     }
@@ -5002,10 +5003,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)
     }
 
   if (purge_dead_abnormal_edges)
-    {
-      gimple_purge_dead_eh_edges (return_block);
-      gimple_purge_dead_abnormal_call_edges (return_block);
-    }
+    bitmap_set_bit (to_purge, return_block->index);
 
   /* If the value of the new expression is ignored, that's OK.  We
      don't warn about this for CALL_EXPRs, so we shouldn't warn about
@@ -5043,7 +5041,8 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)
    in a MODIFY_EXPR.  */
 
 static bool
-gimple_expand_calls_inline (basic_block bb, copy_body_data *id)
+gimple_expand_calls_inline (basic_block bb, copy_body_data *id,
+			    bitmap to_purge)
 {
   gimple_stmt_iterator gsi;
   bool inlined = false;
@@ -5055,7 +5054,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)
 
       if (is_gimple_call (stmt)
 	  && !gimple_call_internal_p (stmt))
-	inlined |= expand_call_inline (bb, stmt, id);
+	inlined |= expand_call_inline (bb, stmt, id, to_purge);
     }
 
   return inlined;
@@ -5068,6 +5067,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)
 static void
 fold_marked_statements (int first, hash_set<gimple *> *statements)
 {
+  auto_bitmap to_purge;
   for (; first < last_basic_block_for_fn (cfun); first++)
     if (BASIC_BLOCK_FOR_FN (cfun, first))
       {
@@ -5079,7 +5079,8 @@ fold_marked_statements (int first, hash_set<gimple *> *statements)
 	  if (statements->contains (gsi_stmt (gsi)))
 	    {
 	      gimple *old_stmt = gsi_stmt (gsi);
-	      tree old_decl = is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;
+	      tree old_decl
+		= is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;
 
 	      if (old_decl && fndecl_built_in_p (old_decl))
 		{
@@ -5123,8 +5124,7 @@ fold_marked_statements (int first, hash_set<gimple *> *statements)
 				 is mood anyway.  */
 			      if (maybe_clean_or_replace_eh_stmt (old_stmt,
 								  new_stmt))
-				gimple_purge_dead_eh_edges (
-				  BASIC_BLOCK_FOR_FN (cfun, first));
+				bitmap_set_bit (to_purge, first);
 			      break;
 			    }
 			  gsi_next (&i2);
@@ -5144,11 +5144,11 @@ fold_marked_statements (int first, hash_set<gimple *> *statements)
 						       new_stmt);
 
 		  if (maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt))
-		    gimple_purge_dead_eh_edges (BASIC_BLOCK_FOR_FN (cfun,
-								    first));
+		    bitmap_set_bit (to_purge, first);
 		}
 	    }
       }
+  gimple_purge_all_dead_eh_edges (to_purge);
 }
 
 /* Expand calls to inline functions in the body of FN.  */
@@ -5194,8 +5194,9 @@ optimize_inline_calls (tree fn)
      will split id->current_basic_block, and the new blocks will
      follow it; we'll trudge through them, processing their CALL_EXPRs
      along the way.  */
+  auto_bitmap to_purge;
   FOR_EACH_BB_FN (bb, cfun)
-    inlined_p |= gimple_expand_calls_inline (bb, &id);
+    inlined_p |= gimple_expand_calls_inline (bb, &id, to_purge);
 
   pop_gimplify_context (NULL);
 
@@ -5215,6 +5216,21 @@ optimize_inline_calls (tree fn)
   fold_marked_statements (last, id.statements_to_fold);
   delete id.statements_to_fold;
 
+  /* Finally purge EH and abnormal edges from the call stmts we inlined.
+     We need to do this after fold_marked_statements since that may walk
+     the SSA use-def chain.  */
+  unsigned i;
+  bitmap_iterator bi;
+  EXECUTE_IF_SET_IN_BITMAP (to_purge, 0, i, bi)
+    {
+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);
+      if (bb)
+	{
+	  gimple_purge_dead_eh_edges (bb);
+	  gimple_purge_dead_abnormal_call_edges (bb);
+	}
+    }
+
   gcc_assert (!id.debug_stmts.exists ());
 
   /* If we didn't inline into the function there is nothing to do.  */
diff --git a/gcc/tree-object-size.c b/gcc/tree-object-size.c
index f9ad7e83943..25c5ced57b7 100644
--- a/gcc/tree-object-size.c
+++ b/gcc/tree-object-size.c
@@ -890,6 +890,9 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)
   else
     expr_object_size (osi, var, then_);
 
+  if (object_sizes[object_size_type][varno] == unknown[object_size_type])
+    return reexamine;
+
   if (TREE_CODE (else_) == SSA_NAME)
     reexamine |= merge_object_sizes (osi, var, else_, 0);
   else
diff --git a/gcc/tree-parloops.c b/gcc/tree-parloops.c
index c5629cc8089..dad6e2884db 100644
--- a/gcc/tree-parloops.c
+++ b/gcc/tree-parloops.c
@@ -1498,7 +1498,6 @@ create_loop_fn (location_t loc)
   DECL_ARGUMENTS (decl) = t;
 
   allocate_struct_function (decl, false);
-  DECL_STRUCT_FUNCTION (decl)->last_clique = act_cfun->last_clique;
 
   /* The call to allocate_struct_function clobbers CFUN, so we need to restore
      it.  */
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index b27dbdd0cb7..f6c230b169c 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -562,6 +562,7 @@ extern rtl_opt_pass *make_pass_stack_ptr_mod (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_initialize_regs (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_combine (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_if_after_combine (gcc::context *ctxt);
+extern rtl_opt_pass *make_pass_jump_after_combine (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_ree (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_partition_blocks (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_match_asm_constraints (gcc::context *ctxt);
@@ -579,7 +580,6 @@ extern rtl_opt_pass *make_pass_clean_state (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_branch_prob (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_value_profile_transformations (gcc::context
 							      *ctxt);
-extern rtl_opt_pass *make_pass_postreload_jump (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_postreload_cse (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_gcse2 (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_split_after_reload (gcc::context *ctxt);
diff --git a/gcc/tree-predcom.c b/gcc/tree-predcom.c
index 8e83a715a24..dd66cdc12ca 100644
--- a/gcc/tree-predcom.c
+++ b/gcc/tree-predcom.c
@@ -767,6 +767,7 @@ split_data_refs_to_components (struct loop *loop,
   /* Don't do store elimination if loop has multiple exit edges.  */
   bool eliminate_store_p = single_exit (loop) != NULL;
   basic_block last_always_executed = last_always_executed_block (loop);
+  auto_bitmap no_store_store_comps;
 
   FOR_EACH_VEC_ELT (datarefs, i, dr)
     {
@@ -838,9 +839,13 @@ split_data_refs_to_components (struct loop *loop,
       else if (DR_IS_READ (dra) && ib != bad)
 	{
 	  if (ia == bad)
-	    continue;
+	    {
+	      bitmap_set_bit (no_store_store_comps, ib);
+	      continue;
+	    }
 	  else if (!determine_offset (dra, drb, &dummy_off))
 	    {
+	      bitmap_set_bit (no_store_store_comps, ib);
 	      merge_comps (comp_father, comp_size, bad, ia);
 	      continue;
 	    }
@@ -848,9 +853,13 @@ split_data_refs_to_components (struct loop *loop,
       else if (DR_IS_READ (drb) && ia != bad)
 	{
 	  if (ib == bad)
-	    continue;
+	    {
+	      bitmap_set_bit (no_store_store_comps, ia);
+	      continue;
+	    }
 	  else if (!determine_offset (dra, drb, &dummy_off))
 	    {
+	      bitmap_set_bit (no_store_store_comps, ia);
 	      merge_comps (comp_father, comp_size, bad, ib);
 	      continue;
 	    }
@@ -908,6 +917,17 @@ split_data_refs_to_components (struct loop *loop,
       comp->refs.quick_push (dataref);
     }
 
+  if (eliminate_store_p)
+    {
+      bitmap_iterator bi;
+      EXECUTE_IF_SET_IN_BITMAP (no_store_store_comps, 0, ia, bi)
+	{
+	  ca = component_of (comp_father, ia);
+	  if (ca != bad)
+	    comps[ca]->eliminate_store_p = false;
+	}
+    }
+
   for (i = 0; i < n; i++)
     {
       comp = comps[i];
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index 2be10e199ba..6ed5c8a1d23 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -2599,8 +2599,8 @@ stmt_kills_ref_p (gimple *stmt, tree ref)
 
 static bool
 maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,
-		  ao_ref *ref, tree vuse, unsigned int &limit, bitmap *visited,
-		  bool abort_on_visited,
+		  ao_ref *ref, tree vuse, bool tbaa_p, unsigned int &limit,
+		  bitmap *visited, bool abort_on_visited,
 		  void *(*translate)(ao_ref *, tree, void *, bool *),
 		  void *data)
 {
@@ -2634,7 +2634,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,
 	  /* An already visited PHI node ends the walk successfully.  */
 	  if (bitmap_bit_p (*visited, SSA_NAME_VERSION (PHI_RESULT (def_stmt))))
 	    return !abort_on_visited;
-	  vuse = get_continuation_for_phi (def_stmt, ref, limit,
+	  vuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,
 					   visited, abort_on_visited,
 					   translate, data);
 	  if (!vuse)
@@ -2649,7 +2649,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,
 	  if ((int)limit <= 0)
 	    return false;
 	  --limit;
-	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))
+	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))
 	    {
 	      bool disambiguate_only = true;
 	      if (translate
@@ -2681,7 +2681,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,
    Returns NULL_TREE if no suitable virtual operand can be found.  */
 
 tree
-get_continuation_for_phi (gimple *phi, ao_ref *ref,
+get_continuation_for_phi (gimple *phi, ao_ref *ref, bool tbaa_p,
 			  unsigned int &limit, bitmap *visited,
 			  bool abort_on_visited,
 			  void *(*translate)(ao_ref *, tree, void *, bool *),
@@ -2724,7 +2724,8 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,
       arg1 = PHI_ARG_DEF (phi, i);
       if (arg1 == arg0)
 	;
-      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, limit, visited,
+      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, tbaa_p,
+				   limit, visited,
 				   abort_on_visited,
 				   /* Do not translate when walking over
 				      backedges.  */
@@ -2768,7 +2769,7 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,
    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */
 
 void *
-walk_non_aliased_vuses (ao_ref *ref, tree vuse,
+walk_non_aliased_vuses (ao_ref *ref, tree vuse, bool tbaa_p,
 			void *(*walker)(ao_ref *, tree, void *),
 			void *(*translate)(ao_ref *, tree, void *, bool *),
 			tree (*valueize)(tree),
@@ -2809,7 +2810,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,
       if (gimple_nop_p (def_stmt))
 	break;
       else if (gimple_code (def_stmt) == GIMPLE_PHI)
-	vuse = get_continuation_for_phi (def_stmt, ref, limit,
+	vuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,
 					 &visited, translated, translate, data);
       else
 	{
@@ -2819,7 +2820,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,
 	      break;
 	    }
 	  --limit;
-	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))
+	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))
 	    {
 	      if (!translate)
 		break;
diff --git a/gcc/tree-ssa-alias.h b/gcc/tree-ssa-alias.h
index cee844973d9..ddd28ec3c75 100644
--- a/gcc/tree-ssa-alias.h
+++ b/gcc/tree-ssa-alias.h
@@ -131,11 +131,11 @@ extern bool call_may_clobber_ref_p (gcall *, tree);
 extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);
 extern bool stmt_kills_ref_p (gimple *, tree);
 extern bool stmt_kills_ref_p (gimple *, ao_ref *);
-extern tree get_continuation_for_phi (gimple *, ao_ref *,
+extern tree get_continuation_for_phi (gimple *, ao_ref *, bool,
 				      unsigned int &, bitmap *, bool,
 				      void *(*)(ao_ref *, tree, void *, bool *),
 				      void *);
-extern void *walk_non_aliased_vuses (ao_ref *, tree,
+extern void *walk_non_aliased_vuses (ao_ref *, tree, bool,
 				     void *(*)(ao_ref *, tree, void *),
 				     void *(*)(ao_ref *, tree, void *, bool *),
 				     tree (*)(tree), unsigned &, void *);
diff --git a/gcc/tree-ssa-ccp.c b/gcc/tree-ssa-ccp.c
index e6bcc216e7c..8db6a34e059 100644
--- a/gcc/tree-ssa-ccp.c
+++ b/gcc/tree-ssa-ccp.c
@@ -2079,8 +2079,6 @@ insert_clobber_before_stack_restore (tree saved_val, tree var,
     else if (gimple_assign_ssa_name_copy_p (stmt))
       insert_clobber_before_stack_restore (gimple_assign_lhs (stmt), var,
 					   visited);
-    else
-      gcc_assert (is_gimple_debug (stmt));
 }
 
 /* Advance the iterator to the previous non-debug gimple statement in the same
@@ -2105,9 +2103,9 @@ gsi_prev_dom_bb_nondebug (gimple_stmt_iterator *i)
 /* Find a BUILT_IN_STACK_SAVE dominating gsi_stmt (I), and insert
    a clobber of VAR before each matching BUILT_IN_STACK_RESTORE.
 
-   It is possible that BUILT_IN_STACK_SAVE cannot be find in a dominator when a
-   previous pass (such as DOM) duplicated it along multiple paths to a BB.  In
-   that case the function gives up without inserting the clobbers.  */
+   It is possible that BUILT_IN_STACK_SAVE cannot be found in a dominator when
+   a previous pass (such as DOM) duplicated it along multiple paths to a BB.
+   In that case the function gives up without inserting the clobbers.  */
 
 static void
 insert_clobbers_for_var (gimple_stmt_iterator i, tree var)
diff --git a/gcc/tree-ssa-dse.c b/gcc/tree-ssa-dse.c
index aa998f416c7..efe5b31cc0a 100644
--- a/gcc/tree-ssa-dse.c
+++ b/gcc/tree-ssa-dse.c
@@ -984,7 +984,7 @@ pass_dse::execute (function *fun)
 {
   need_eh_cleanup = BITMAP_ALLOC (NULL);
 
-  renumber_gimple_stmt_uids ();
+  renumber_gimple_stmt_uids (cfun);
 
   /* We might consider making this a property of each pass so that it
      can be [re]computed on an as-needed basis.  Particularly since
diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
index eeb6281c652..bbfa1bc6fae 100644
--- a/gcc/tree-ssa-forwprop.c
+++ b/gcc/tree-ssa-forwprop.c
@@ -2496,6 +2496,8 @@ pass_forwprop::execute (function *fun)
 		  {
 		    int did_something;
 		    did_something = forward_propagate_into_comparison (&gsi);
+		    if (maybe_clean_or_replace_eh_stmt (stmt, gsi_stmt (gsi)))
+		      bitmap_set_bit (to_purge, bb->index);
 		    if (did_something == 2)
 		      cfg_changed = true;
 		    changed = did_something != 0;
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index b7bbde4e402..bf9466b417f 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -3840,7 +3840,7 @@ pass_optimize_widening_mul::execute (function *fun)
 
   memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));
   calculate_dominance_info (CDI_DOMINATORS);
-  renumber_gimple_stmt_uids ();
+  renumber_gimple_stmt_uids (cfun);
 
   math_opts_dom_walker (&cfg_changed).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));
 
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
index 8bf09bdf2a0..19b37b43b8e 100644
--- a/gcc/tree-ssa-phiopt.c
+++ b/gcc/tree-ssa-phiopt.c
@@ -1365,7 +1365,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,
 
   /* Turn EQ/NE of extreme values to order comparisons.  */
   if ((cmp == NE_EXPR || cmp == EQ_EXPR)
-      && TREE_CODE (rhs) == INTEGER_CST)
+      && TREE_CODE (rhs) == INTEGER_CST
+      && INTEGRAL_TYPE_P (TREE_TYPE (rhs)))
     {
       if (wi::eq_p (wi::to_wide (rhs), wi::min_value (TREE_TYPE (rhs))))
 	{
@@ -1391,7 +1392,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,
       larger = rhs;
       /* If we have smaller < CST it is equivalent to smaller <= CST-1.
 	 Likewise smaller <= CST is equivalent to smaller < CST+1.  */
-      if (TREE_CODE (larger) == INTEGER_CST)
+      if (TREE_CODE (larger) == INTEGER_CST
+	  && INTEGRAL_TYPE_P (TREE_TYPE (larger)))
 	{
 	  if (cmp == LT_EXPR)
 	    {
@@ -1419,7 +1421,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,
       larger = gimple_cond_lhs (cond);
       /* If we have larger > CST it is equivalent to larger >= CST+1.
 	 Likewise larger >= CST is equivalent to larger > CST-1.  */
-      if (TREE_CODE (smaller) == INTEGER_CST)
+      if (TREE_CODE (smaller) == INTEGER_CST
+	  && INTEGRAL_TYPE_P (TREE_TYPE (smaller)))
 	{
 	  wi::overflow_type overflow;
 	  if (cmp == GT_EXPR)
diff --git a/gcc/tree-ssa-phiprop.c b/gcc/tree-ssa-phiprop.c
index d710582a915..e90ae6a89cb 100644
--- a/gcc/tree-ssa-phiprop.c
+++ b/gcc/tree-ssa-phiprop.c
@@ -338,8 +338,15 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
 	    && (!type
 		|| types_compatible_p
 		     (TREE_TYPE (gimple_assign_lhs (use_stmt)), type))
-	    /* We cannot replace a load that may throw or is volatile.  */
-	    && !stmt_can_throw_internal (cfun, use_stmt)))
+	    /* We cannot replace a load that may throw or is volatile.
+	       For volatiles the transform can change the number of
+	       executions if the load is inside a loop but the address
+	       computations outside (PR91812).  We could relax this
+	       if we guard against that appropriately.  For loads that can
+	       throw we could relax things if the moved loads all are
+	       known to not throw.  */
+	    && !stmt_can_throw_internal (cfun, use_stmt)
+	    && !gimple_has_volatile_ops (use_stmt)))
 	continue;
 
       /* Check if we can move the loads.  The def stmt of the virtual use
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 646feb6085f..8bd17b82368 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -1184,8 +1184,8 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,
 	  bitmap visited = NULL;
 	  /* Try to find a vuse that dominates this phi node by skipping
 	     non-clobbering statements.  */
-	  vuse = get_continuation_for_phi (phi, &ref, cnt, &visited, false,
-					   NULL, NULL);
+	  vuse = get_continuation_for_phi (phi, &ref, true,
+					   cnt, &visited, false, NULL, NULL);
 	  if (visited)
 	    BITMAP_FREE (visited);
 	}
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 7161c4c36c3..6794fbde29e 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -6013,12 +6013,7 @@ reassociate_bb (basic_block bb)
 		{
 		  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));
 		  int ops_num = ops.length ();
-		  int width = get_reassociation_width (ops_num, rhs_code, mode);
-
-		  if (dump_file && (dump_flags & TDF_DETAILS))
-		    fprintf (dump_file,
-			     "Width = %d was chosen for reassociation\n", width);
-
+		  int width;
 
 		  /* For binary bit operations, if there are at least 3
 		     operands and the last last operand in OPS is a constant,
@@ -6032,10 +6027,21 @@ reassociate_bb (basic_block bb)
 		      && TREE_CODE (ops.last ()->op) == INTEGER_CST)
 		    std::swap (*ops[0], *ops[ops_num - 1]);
 
-		  if (width > 1
-		      && ops.length () > 3)
-		    rewrite_expr_tree_parallel (as_a <gassign *> (stmt),
-						width, ops);
+		  /* Only rewrite the expression tree to parallel in the
+		     last reassoc pass to avoid useless work back-and-forth
+		     with initial linearization.  */
+		  if (!reassoc_insert_powi_p
+		      && ops.length () > 3
+		      && (width = get_reassociation_width (ops_num, rhs_code,
+							   mode)) > 1)
+		    {
+		      if (dump_file && (dump_flags & TDF_DETAILS))
+			fprintf (dump_file,
+				 "Width = %d was chosen for reassociation\n",
+				 width);
+		      rewrite_expr_tree_parallel (as_a <gassign *> (stmt),
+						  width, ops);
+		    }
 		  else
                     {
                       /* When there are three operands left, we want
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 9529d1669c9..32f45c95cdf 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -132,8 +132,6 @@ along with GCC; see the file COPYING3.  If not see
 /* There's no BB_EXECUTABLE but we can use BB_VISITED.  */
 #define BB_EXECUTABLE BB_VISITED
 
-static tree *last_vuse_ptr;
-static vn_lookup_kind vn_walk_kind;
 static vn_lookup_kind default_vn_walk_kind;
 
 /* vn_nary_op hashtable helpers.  */
@@ -1678,18 +1676,33 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)
   return NULL_TREE;
 }
 
+struct vn_walk_cb_data
+{
+  vn_walk_cb_data (vn_reference_t vr_, tree *last_vuse_ptr_,
+                   vn_lookup_kind vn_walk_kind_, bool tbaa_p_)
+    : vr (vr_), last_vuse_ptr (last_vuse_ptr_), vn_walk_kind (vn_walk_kind_),
+      tbaa_p (tbaa_p_)
+    {}
+
+  vn_reference_t vr;
+  tree *last_vuse_ptr;
+  vn_lookup_kind vn_walk_kind;
+  bool tbaa_p;
+};
+
 /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_
    with the current VUSE and performs the expression lookup.  */
 
 static void *
-vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *vr_)
+vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *data_)
 {
-  vn_reference_t vr = (vn_reference_t)vr_;
+  vn_walk_cb_data *data = (vn_walk_cb_data *)data_;
+  vn_reference_t vr = data->vr;
   vn_reference_s **slot;
   hashval_t hash;
 
-  if (last_vuse_ptr)
-    *last_vuse_ptr = vuse;
+  if (data->last_vuse_ptr)
+    *data->last_vuse_ptr = vuse;
 
   /* Fixup vuse and hash.  */
   if (vr->vuse)
@@ -1959,10 +1972,11 @@ basic_block vn_context_bb;
    *DISAMBIGUATE_ONLY is set to true.  */
 
 static void *
-vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
+vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 		       bool *disambiguate_only)
 {
-  vn_reference_t vr = (vn_reference_t)vr_;
+  vn_walk_cb_data *data = (vn_walk_cb_data *)data_;
+  vn_reference_t vr = data->vr;
   gimple *def_stmt = SSA_NAME_DEF_STMT (vuse);
   tree base = ao_ref_base (ref);
   HOST_WIDE_INT offseti, maxsizei;
@@ -1989,7 +2003,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 						      get_alias_set (lhs),
 						      TREE_TYPE (lhs), lhs_ops);
 	  if (lhs_ref_ok
-	      && !refs_may_alias_p_1 (ref, &lhs_ref, true))
+	      && !refs_may_alias_p_1 (ref, &lhs_ref, data->tbaa_p))
 	    {
 	      *disambiguate_only = true;
 	      return NULL;
@@ -2005,21 +2019,21 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
          we find a VN result with exactly the same value as the
 	 possible clobber.  In this case we can ignore the clobber
 	 and return the found value.  */
-      if (vn_walk_kind == VN_WALKREWRITE
+      if (data->vn_walk_kind == VN_WALKREWRITE
 	  && is_gimple_reg_type (TREE_TYPE (lhs))
 	  && types_compatible_p (TREE_TYPE (lhs), vr->type)
 	  && ref->ref)
 	{
-	  tree *saved_last_vuse_ptr = last_vuse_ptr;
+	  tree *saved_last_vuse_ptr = data->last_vuse_ptr;
 	  /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
-	  last_vuse_ptr = NULL;
+	  data->last_vuse_ptr = NULL;
 	  tree saved_vuse = vr->vuse;
 	  hashval_t saved_hashcode = vr->hashcode;
-	  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), vr);
+	  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), data);
 	  /* Need to restore vr->vuse and vr->hashcode.  */
 	  vr->vuse = saved_vuse;
 	  vr->hashcode = saved_hashcode;
-	  last_vuse_ptr = saved_last_vuse_ptr;
+	  data->last_vuse_ptr = saved_last_vuse_ptr;
 	  if (res && res != (void *)-1)
 	    {
 	      vn_reference_t vnresult = (vn_reference_t) res;
@@ -2072,7 +2086,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 	}
     }
 
-  if (*disambiguate_only)
+  /* If we are looking for redundant stores do not create new hashtable
+     entries from aliasing defs with made up alias-sets.  */
+  if (*disambiguate_only || !data->tbaa_p)
     return (void *)-1;
 
   /* If we cannot constrain the size of the reference we cannot
@@ -2097,7 +2113,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 	       || (INTEGRAL_TYPE_P (vr->type) && known_eq (ref->size, 8)))
 	      && CHAR_BIT == 8 && BITS_PER_UNIT == 8
 	      && offset.is_constant (&offseti)
-	      && offseti % BITS_PER_UNIT == 0))
+	      && offseti % BITS_PER_UNIT == 0
+	      && multiple_p (ref->size, BITS_PER_UNIT)))
       && poly_int_tree_p (gimple_call_arg (def_stmt, 2))
       && (TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR
 	  || TREE_CODE (gimple_call_arg (def_stmt, 0)) == SSA_NAME))
@@ -2342,7 +2359,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 
   /* 5) For aggregate copies translate the reference through them if
      the copy kills ref.  */
-  else if (vn_walk_kind == VN_WALKREWRITE
+  else if (data->vn_walk_kind == VN_WALKREWRITE
 	   && gimple_assign_single_p (def_stmt)
 	   && (DECL_P (gimple_assign_rhs1 (def_stmt))
 	       || TREE_CODE (gimple_assign_rhs1 (def_stmt)) == MEM_REF
@@ -2462,7 +2479,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
       *ref = r;
 
       /* Do not update last seen VUSE after translating.  */
-      last_vuse_ptr = NULL;
+      data->last_vuse_ptr = NULL;
 
       /* Keep looking for the adjusted *REF / VR pair.  */
       return NULL;
@@ -2470,7 +2487,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 
   /* 6) For memcpy copies translate the reference through them if
      the copy kills ref.  */
-  else if (vn_walk_kind == VN_WALKREWRITE
+  else if (data->vn_walk_kind == VN_WALKREWRITE
 	   && is_gimple_reg_type (vr->type)
 	   /* ???  Handle BCOPY as well.  */
 	   && (gimple_call_builtin_p (def_stmt, BUILT_IN_MEMCPY)
@@ -2620,7 +2637,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
       *ref = r;
 
       /* Do not update last seen VUSE after translating.  */
-      last_vuse_ptr = NULL;
+      data->last_vuse_ptr = NULL;
 
       /* Keep looking for the adjusted *REF / VR pair.  */
       return NULL;
@@ -2681,13 +2698,13 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,
     {
       ao_ref r;
       unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);
-      vn_walk_kind = kind;
+      vn_walk_cb_data data (&vr1, NULL, kind, true);
       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))
 	*vnresult =
-	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
+	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, true,
 						  vn_reference_lookup_2,
 						  vn_reference_lookup_3,
-						  vuse_valueize, limit, &vr1);
+						  vuse_valueize, limit, &data);
       gcc_checking_assert (vr1.operands == shared_lookup_references);
     }
 
@@ -2702,11 +2719,12 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,
    not exist in the hash table or if the result field of the structure
    was NULL..  VNRESULT will be filled in with the vn_reference_t
    stored in the hashtable if one exists.  When TBAA_P is false assume
-   we are looking up a store and treat it as having alias-set zero.  */
+   we are looking up a store and treat it as having alias-set zero.
+   *LAST_VUSE_PTR will be updated with the VUSE the value lookup succeeded.  */
 
 tree
 vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
-		     vn_reference_t *vnresult, bool tbaa_p)
+		     vn_reference_t *vnresult, bool tbaa_p, tree *last_vuse_ptr)
 {
   vec<vn_reference_op_s> operands;
   struct vn_reference_s vr1;
@@ -2720,7 +2738,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
   vr1.operands = operands
     = valueize_shared_reference_ops_from_ref (op, &valuezied_anything);
   vr1.type = TREE_TYPE (op);
-  vr1.set = tbaa_p ? get_alias_set (op) : 0;
+  vr1.set = get_alias_set (op);
   vr1.hashcode = vn_reference_compute_hash (&vr1);
   if ((cst = fully_constant_vn_reference_p (&vr1)))
     return cst;
@@ -2737,14 +2755,12 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
 	  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.type,
 					     vr1.operands))
 	ao_ref_init (&r, op);
-      if (! tbaa_p)
-	r.ref_alias_set = r.base_alias_set = 0;
-      vn_walk_kind = kind;
+      vn_walk_cb_data data (&vr1, last_vuse_ptr, kind, tbaa_p);
       wvnresult =
-	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
+	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, tbaa_p,
 						vn_reference_lookup_2,
 						vn_reference_lookup_3,
-						vuse_valueize, limit, &vr1);
+						vuse_valueize, limit, &data);
       gcc_checking_assert (vr1.operands == shared_lookup_references);
       if (wvnresult)
 	{
@@ -4099,10 +4115,8 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)
   tree result;
 
   last_vuse = gimple_vuse (stmt);
-  last_vuse_ptr = &last_vuse;
   result = vn_reference_lookup (op, gimple_vuse (stmt),
-				default_vn_walk_kind, NULL, true);
-  last_vuse_ptr = NULL;
+				default_vn_walk_kind, NULL, true, &last_vuse);
 
   /* We handle type-punning through unions by value-numbering based
      on offset and size of the access.  Be prepared to handle a
diff --git a/gcc/tree-ssa-sccvn.h b/gcc/tree-ssa-sccvn.h
index bd661bc651c..93718b2848f 100644
--- a/gcc/tree-ssa-sccvn.h
+++ b/gcc/tree-ssa-sccvn.h
@@ -234,7 +234,8 @@ vec<vn_reference_op_s> vn_reference_operands_for_lookup (tree);
 tree vn_reference_lookup_pieces (tree, alias_set_type, tree,
 				 vec<vn_reference_op_s> ,
 				 vn_reference_t *, vn_lookup_kind);
-tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool);
+tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool,
+			  tree * = NULL);
 void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);
 vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,
 					   vec<vn_reference_op_s> ,
diff --git a/gcc/tree-ssa-scopedtables.c b/gcc/tree-ssa-scopedtables.c
index e08e24dfcc1..26e081f2149 100644
--- a/gcc/tree-ssa-scopedtables.c
+++ b/gcc/tree-ssa-scopedtables.c
@@ -298,7 +298,7 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)
 	    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME
 	    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),
 		ref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)
-	    && walk_non_aliased_vuses (&ref, vuse2, vuse_eq, NULL, NULL,
+	    && walk_non_aliased_vuses (&ref, vuse2, true, vuse_eq, NULL, NULL,
 				       limit, vuse1) != NULL))
 	{
 	  if (insert)
diff --git a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
index fe762f54d96..2648b24f7d5 100644
--- a/gcc/tree-ssa-sink.c
+++ b/gcc/tree-ssa-sink.c
@@ -229,7 +229,7 @@ select_best_block (basic_block early_bb,
       /* If result of comparsion is unknown, preffer EARLY_BB.
 	 Thus use !(...>=..) rather than (...<...)  */
       && !(best_bb->count.apply_scale (100, 1)
-	   > (early_bb->count.apply_scale (threshold, 1))))
+	   >= early_bb->count.apply_scale (threshold, 1)))
     return best_bb;
 
   /* No better block found, so return EARLY_BB, which happens to be the
@@ -439,7 +439,10 @@ statement_sink_location (gimple *stmt, basic_block frombb,
 	  if (sinkbb == frombb)
 	    return false;
 
-	  *togsi = gsi_for_stmt (use);
+	  if (sinkbb == gimple_bb (use))
+	    *togsi = gsi_for_stmt (use);
+	  else
+	    *togsi = gsi_after_labels (sinkbb);
 
 	  return true;
 	}
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index f80b8e456b5..0ea0b461d2b 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -4928,10 +4928,10 @@ find_func_aliases (struct function *fn, gimple *origt)
 	      get_constraint_for_ptr_offset (gimple_assign_rhs1 (t),
 					     NULL_TREE, &rhsc);
 	    }
-	  else if ((CONVERT_EXPR_CODE_P (code)
-		    && !(POINTER_TYPE_P (gimple_expr_type (t))
-			 && !POINTER_TYPE_P (TREE_TYPE (rhsop))))
+	  else if (CONVERT_EXPR_CODE_P (code)
 		   || gimple_assign_single_p (t))
+	    /* See through conversions, single RHS are handled by
+	       get_constraint_for_rhs.  */
 	    get_constraint_for_rhs (rhsop, &rhsc);
 	  else if (code == COND_EXPR)
 	    {
@@ -4950,14 +4950,16 @@ find_func_aliases (struct function *fn, gimple *origt)
 	    ;
 	  else
 	    {
-	      /* All other operations are merges.  */
+	      /* All other operations are possibly offsetting merges.  */
 	      auto_vec<ce_s, 4> tmp;
 	      struct constraint_expr *rhsp;
 	      unsigned i, j;
-	      get_constraint_for_rhs (gimple_assign_rhs1 (t), &rhsc);
+	      get_constraint_for_ptr_offset (gimple_assign_rhs1 (t),
+					     NULL_TREE, &rhsc);
 	      for (i = 2; i < gimple_num_ops (t); ++i)
 		{
-		  get_constraint_for_rhs (gimple_op (t, i), &tmp);
+		  get_constraint_for_ptr_offset (gimple_op (t, i),
+						 NULL_TREE, &tmp);
 		  FOR_EACH_VEC_ELT (tmp, j, rhsp)
 		    rhsc.safe_push (*rhsp);
 		  tmp.truncate (0);
diff --git a/gcc/tree-switch-conversion.c b/gcc/tree-switch-conversion.c
index c3f2baf39d7..dd6dd8064de 100644
--- a/gcc/tree-switch-conversion.c
+++ b/gcc/tree-switch-conversion.c
@@ -605,7 +605,9 @@ switch_conversion::build_one_array (int num, tree arr_index_type,
   vec<constructor_elt, va_gc> *constructor = m_constructors[num];
   wide_int coeff_a, coeff_b;
   bool linear_p = contains_linear_function_p (constructor, &coeff_a, &coeff_b);
-  if (linear_p)
+  tree type;
+  if (linear_p
+      && (type = range_check_type (TREE_TYPE ((*constructor)[0].value))))
     {
       if (dump_file && coeff_a.to_uhwi () > 0)
 	fprintf (dump_file, "Linear transformation with A = %" PRId64
@@ -613,13 +615,12 @@ switch_conversion::build_one_array (int num, tree arr_index_type,
 		 coeff_b.to_shwi ());
 
       /* We must use type of constructor values.  */
-      tree t = unsigned_type_for (TREE_TYPE ((*constructor)[0].value));
       gimple_seq seq = NULL;
-      tree tmp = gimple_convert (&seq, t, m_index_expr);
-      tree tmp2 = gimple_build (&seq, MULT_EXPR, t,
-				wide_int_to_tree (t, coeff_a), tmp);
-      tree tmp3 = gimple_build (&seq, PLUS_EXPR, t, tmp2,
-				wide_int_to_tree (t, coeff_b));
+      tree tmp = gimple_convert (&seq, type, m_index_expr);
+      tree tmp2 = gimple_build (&seq, MULT_EXPR, type,
+				wide_int_to_tree (type, coeff_a), tmp);
+      tree tmp3 = gimple_build (&seq, PLUS_EXPR, type, tmp2,
+				wide_int_to_tree (type, coeff_b));
       tree tmp4 = gimple_convert (&seq, TREE_TYPE (name), tmp3);
       gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);
       load = gimple_build_assign (name, tmp4);
@@ -1350,7 +1351,7 @@ bit_test_cluster::find_bit_tests (vec<cluster *> &clusters)
 						  entire));
 	}
       else
-	for (int i = end - 1; i >=  start; i--)
+	for (int i = end - 1; i >= start; i--)
 	  output.safe_push (clusters[i]);
 
       end = start;
@@ -1483,7 +1484,7 @@ bit_test_cluster::emit (tree index_expr, tree index_type,
   unsigned int i, j, k;
   unsigned int count;
 
-  tree unsigned_index_type = unsigned_type_for (index_type);
+  tree unsigned_index_type = range_check_type (index_type);
 
   gimple_stmt_iterator gsi;
   gassign *shift_stmt;
@@ -1793,7 +1794,8 @@ switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)
   tree index_type = TREE_TYPE (index_expr);
   basic_block bb = gimple_bb (m_switch);
 
-  if (gimple_switch_num_labels (m_switch) == 1)
+  if (gimple_switch_num_labels (m_switch) == 1
+      || range_check_type (index_type) == NULL_TREE)
     return false;
 
   /* Find the default case target label.  */
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
index e0265b22dd5..255575f1198 100644
--- a/gcc/tree-tailcall.c
+++ b/gcc/tree-tailcall.c
@@ -479,6 +479,35 @@ find_tail_calls (basic_block bb, struct tailcall **ret)
       && !stmt_can_throw_external (cfun, stmt))
     return;
 
+  /* If the function returns a value, then at present, the tail call
+     must return the same type of value.  There is conceptually a copy
+     between the object returned by the tail call candidate and the
+     object returned by CFUN itself.
+
+     This means that if we have:
+
+	 lhs = f (&<retval>);    // f reads from <retval>
+				 // (lhs is usually also <retval>)
+
+     there is a copy between the temporary object returned by f and lhs,
+     meaning that any use of <retval> in f occurs before the assignment
+     to lhs begins.  Thus the <retval> that is live on entry to the call
+     to f is really an independent local variable V that happens to be
+     stored in the RESULT_DECL rather than a local VAR_DECL.
+
+     Turning this into a tail call would remove the copy and make the
+     lifetimes of the return value and V overlap.  The same applies to
+     tail recursion, since if f can read from <retval>, we have to assume
+     that CFUN might already have written to <retval> before the call.
+
+     The problem doesn't apply when <retval> is passed by value, but that
+     isn't a case we handle anyway.  */
+  tree result_decl = DECL_RESULT (cfun->decl);
+  if (result_decl
+      && may_be_aliased (result_decl)
+      && ref_maybe_used_by_stmt_p (call, result_decl))
+    return;
+
   /* We found the call, check whether it is suitable.  */
   tail_recursion = false;
   func = gimple_call_fndecl (call);
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index d71a39ffd78..17a4fc8e279 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -3228,14 +3228,14 @@ vect_compile_time_alias (dr_vec_info *a, dr_vec_info *b,
   if (tree_int_cst_compare (DR_STEP (a->dr), size_zero_node) < 0)
     {
       const_length_a = (-wi::to_poly_wide (segment_length_a)).force_uhwi ();
-      offset_a = (offset_a + access_size_a) - const_length_a;
+      offset_a -= const_length_a;
     }
   else
     const_length_a = tree_to_poly_uint64 (segment_length_a);
   if (tree_int_cst_compare (DR_STEP (b->dr), size_zero_node) < 0)
     {
       const_length_b = (-wi::to_poly_wide (segment_length_b)).force_uhwi ();
-      offset_b = (offset_b + access_size_b) - const_length_b;
+      offset_b -= const_length_b;
     }
   else
     const_length_b = tree_to_poly_uint64 (segment_length_b);
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 337e078df00..0308b26b808 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -6445,10 +6445,13 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 	  gcc_assert (TREE_CODE (base) == INTEGER_CST
 		      && TREE_CODE (step) == INTEGER_CST);
 	  cond_reduc_val = NULL_TREE;
+	  tree res = PHI_RESULT (STMT_VINFO_STMT (cond_stmt_vinfo));
+	  if (!types_compatible_p (TREE_TYPE (res), TREE_TYPE (base)))
+	    ;
 	  /* Find a suitable value, for MAX_EXPR below base, for MIN_EXPR
 	     above base; punt if base is the minimum value of the type for
 	     MAX_EXPR or maximum value of the type for MIN_EXPR for now.  */
-	  if (tree_int_cst_sgn (step) == -1)
+	  else if (tree_int_cst_sgn (step) == -1)
 	    {
 	      cond_reduc_op_code = MIN_EXPR;
 	      if (tree_int_cst_sgn (base) == -1)
diff --git a/gcc/tree-vect-patterns.c b/gcc/tree-vect-patterns.c
index ff952d6f464..badf4e7104e 100644
--- a/gcc/tree-vect-patterns.c
+++ b/gcc/tree-vect-patterns.c
@@ -2070,14 +2070,12 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
 
   *type_out = vectype;
 
-  if (dt == vect_external_def
-      && TREE_CODE (oprnd1) == SSA_NAME)
+  if (dt == vect_external_def && TREE_CODE (oprnd1) == SSA_NAME)
     ext_def = vect_get_external_def_edge (vinfo, oprnd1);
 
   def = NULL_TREE;
   scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);
-  if (TREE_CODE (oprnd1) == INTEGER_CST
-      || TYPE_MODE (TREE_TYPE (oprnd1)) == mode)
+  if (dt != vect_internal_def || TYPE_MODE (TREE_TYPE (oprnd1)) == mode)
     def = oprnd1;
   else if (def_stmt && gimple_assign_cast_p (def_stmt))
     {
@@ -2092,14 +2090,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
     {
       def = vect_recog_temp_ssa_var (type, NULL);
       def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd1);
-      if (ext_def)
-	{
-	  basic_block new_bb
-	    = gsi_insert_on_edge_immediate (ext_def, def_stmt);
-	  gcc_assert (!new_bb);
-	}
-      else
-	append_pattern_def_seq (stmt_vinfo, def_stmt);
+      append_pattern_def_seq (stmt_vinfo, def_stmt);
     }
   stype = TREE_TYPE (def);
   scalar_int_mode smode = SCALAR_INT_TYPE_MODE (stype);
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index 017bfa873f7..2abf480270c 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -129,6 +129,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)
   SLP_TREE_TWO_OPERATORS (node) = false;
   SLP_TREE_DEF_TYPE (node) = vect_internal_def;
   node->refcnt = 1;
+  node->max_nunits = 1;
 
   unsigned i;
   FOR_EACH_VEC_ELT (scalar_stmts, i, stmt_info)
@@ -150,8 +151,7 @@ typedef struct _slp_oprnd_info
      stmt.  */
   tree first_op_type;
   enum vect_def_type first_dt;
-  bool first_pattern;
-  bool second_pattern;
+  bool any_pattern;
 } *slp_oprnd_info;
 
 
@@ -171,8 +171,7 @@ vect_create_oprnd_info (int nops, int group_size)
       oprnd_info->def_stmts.create (group_size);
       oprnd_info->first_dt = vect_uninitialized_def;
       oprnd_info->first_op_type = NULL_TREE;
-      oprnd_info->first_pattern = false;
-      oprnd_info->second_pattern = false;
+      oprnd_info->any_pattern = false;
       oprnds_info.quick_push (oprnd_info);
     }
 
@@ -309,13 +308,11 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,
   tree oprnd;
   unsigned int i, number_of_oprnds;
   enum vect_def_type dt = vect_uninitialized_def;
-  bool pattern = false;
   slp_oprnd_info oprnd_info;
   int first_op_idx = 1;
   unsigned int commutative_op = -1U;
   bool first_op_cond = false;
   bool first = stmt_num == 0;
-  bool second = stmt_num == 1;
 
   if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))
     {
@@ -378,13 +375,12 @@ again:
 	  return -1;
 	}
 
-      if (second)
-	oprnd_info->second_pattern = pattern;
+      if (def_stmt_info && is_pattern_stmt_p (def_stmt_info))
+	oprnd_info->any_pattern = true;
 
       if (first)
 	{
 	  oprnd_info->first_dt = dt;
-	  oprnd_info->first_pattern = pattern;
 	  oprnd_info->first_op_type = TREE_TYPE (oprnd);
 	}
       else
@@ -1051,15 +1047,24 @@ vect_build_slp_tree (vec_info *vinfo,
 	dump_printf_loc (MSG_NOTE, vect_location, "re-using %sSLP tree %p\n",
 			 *leader ? "" : "failed ", *leader);
       if (*leader)
-	(*leader)->refcnt++;
+	{
+	  (*leader)->refcnt++;
+	  vect_update_max_nunits (max_nunits, (*leader)->max_nunits);
+	}
       return *leader;
     }
-  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size, max_nunits,
+  poly_uint64 this_max_nunits = 1;
+  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size,
+					&this_max_nunits,
 					matches, npermutes, tree_size,
 					max_tree_size, bst_map);
-  /* Keep a reference for the bst_map use.  */
   if (res)
-    res->refcnt++;
+    {
+      res->max_nunits = this_max_nunits;
+      vect_update_max_nunits (max_nunits, this_max_nunits);
+      /* Keep a reference for the bst_map use.  */
+      res->refcnt++;
+    }
   bst_map->put (stmts.copy (), res);
   return res;
 }
@@ -1218,7 +1223,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,
 	      /* ???  Rejecting patterns this way doesn't work.  We'd have to
 		 do extra work to cancel the pattern so the uses see the
 		 scalar version.  */
-	      && !is_pattern_stmt_p (SLP_TREE_SCALAR_STMTS (child)[0]))
+	      && !oprnd_info->any_pattern)
 	    {
 	      slp_tree grandchild;
 
@@ -1262,7 +1267,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,
 	  /* ???  Rejecting patterns this way doesn't work.  We'd have to
 	     do extra work to cancel the pattern so the uses see the
 	     scalar version.  */
-	  && !is_pattern_stmt_p (stmt_info))
+	  && !is_pattern_stmt_p (stmt_info)
+	  && !oprnd_info->any_pattern)
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_NOTE, vect_location,
@@ -1393,7 +1399,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,
 		  /* ???  Rejecting patterns this way doesn't work.  We'd have
 		     to do extra work to cancel the pattern so the uses see the
 		     scalar version.  */
-		  && !is_pattern_stmt_p (SLP_TREE_SCALAR_STMTS (child)[0]))
+		  && !oprnd_info->any_pattern)
 		{
 		  unsigned int j;
 		  slp_tree grandchild;
@@ -1463,9 +1469,10 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,
 
   dump_metadata_t metadata (dump_kind, loc.get_impl_location ());
   dump_user_location_t user_loc = loc.get_user_location ();
-  dump_printf_loc (metadata, user_loc, "node%s %p\n",
+  dump_printf_loc (metadata, user_loc, "node%s %p (max_nunits=%u)\n",
 		   SLP_TREE_DEF_TYPE (node) != vect_internal_def
-		   ? " (external)" : "", node);
+		   ? " (external)" : "", node,
+		   estimated_poly_value (node->max_nunits));
   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)
     dump_printf_loc (metadata, user_loc, "\tstmt %d %G", i, stmt_info->stmt);
   if (SLP_TREE_CHILDREN (node).is_empty ())
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 17769c88b6a..507f81b0a0e 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -2166,6 +2166,56 @@ perm_mask_for_reverse (tree vectype)
   return vect_gen_perm_mask_checked (vectype, indices);
 }
 
+/* A subroutine of get_load_store_type, with a subset of the same
+   arguments.  Handle the case where STMT_INFO is a load or store that
+   accesses consecutive elements with a negative step.  */
+
+static vect_memory_access_type
+get_negative_load_store_type (stmt_vec_info stmt_info, tree vectype,
+			      vec_load_store_type vls_type,
+			      unsigned int ncopies)
+{
+  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);
+  dr_alignment_support alignment_support_scheme;
+
+  if (ncopies > 1)
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "multiple types with negative step.\n");
+      return VMAT_ELEMENTWISE;
+    }
+
+  alignment_support_scheme = vect_supportable_dr_alignment (dr_info, false);
+  if (alignment_support_scheme != dr_aligned
+      && alignment_support_scheme != dr_unaligned_supported)
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "negative step but alignment required.\n");
+      return VMAT_ELEMENTWISE;
+    }
+
+  if (vls_type == VLS_STORE_INVARIANT)
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_NOTE, vect_location,
+			 "negative step with invariant source;"
+			 " no permute needed.\n");
+      return VMAT_CONTIGUOUS_DOWN;
+    }
+
+  if (!perm_mask_for_reverse (vectype))
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "negative step and reversing not supported.\n");
+      return VMAT_ELEMENTWISE;
+    }
+
+  return VMAT_CONTIGUOUS_REVERSE;
+}
+
 /* STMT_INFO is either a masked or unconditional store.  Return the value
    being stored.  */
 
@@ -2268,7 +2318,15 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,
 				 "Peeling for outer loop is not supported\n");
 	      return false;
 	    }
-	  *memory_access_type = VMAT_CONTIGUOUS;
+	  int cmp = compare_step_with_zero (stmt_info);
+	  if (cmp < 0)
+	    *memory_access_type = get_negative_load_store_type
+	      (stmt_info, vectype, vls_type, 1);
+	  else
+	    {
+	      gcc_assert (!loop_vinfo || cmp > 0);
+	      *memory_access_type = VMAT_CONTIGUOUS;
+	    }
 	}
     }
   else
@@ -2370,56 +2428,6 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,
   return true;
 }
 
-/* A subroutine of get_load_store_type, with a subset of the same
-   arguments.  Handle the case where STMT_INFO is a load or store that
-   accesses consecutive elements with a negative step.  */
-
-static vect_memory_access_type
-get_negative_load_store_type (stmt_vec_info stmt_info, tree vectype,
-			      vec_load_store_type vls_type,
-			      unsigned int ncopies)
-{
-  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);
-  dr_alignment_support alignment_support_scheme;
-
-  if (ncopies > 1)
-    {
-      if (dump_enabled_p ())
-	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
-			 "multiple types with negative step.\n");
-      return VMAT_ELEMENTWISE;
-    }
-
-  alignment_support_scheme = vect_supportable_dr_alignment (dr_info, false);
-  if (alignment_support_scheme != dr_aligned
-      && alignment_support_scheme != dr_unaligned_supported)
-    {
-      if (dump_enabled_p ())
-	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
-			 "negative step but alignment required.\n");
-      return VMAT_ELEMENTWISE;
-    }
-
-  if (vls_type == VLS_STORE_INVARIANT)
-    {
-      if (dump_enabled_p ())
-	dump_printf_loc (MSG_NOTE, vect_location,
-			 "negative step with invariant source;"
-			 " no permute needed.\n");
-      return VMAT_CONTIGUOUS_DOWN;
-    }
-
-  if (!perm_mask_for_reverse (vectype))
-    {
-      if (dump_enabled_p ())
-	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
-			 "negative step and reversing not supported.\n");
-      return VMAT_ELEMENTWISE;
-    }
-
-  return VMAT_CONTIGUOUS_REVERSE;
-}
-
 /* Analyze load or store statement STMT_INFO of type VLS_TYPE.  Return true
    if there is a memory access type that the vectorized form can use,
    storing it in *MEMORY_ACCESS_TYPE if so.  If we decide to use gathers
@@ -3279,7 +3287,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
       if (!vectype_in)
 	vectype_in = vectypes[i];
       else if (vectypes[i]
-	       && vectypes[i] != vectype_in)
+	       && !types_compatible_p (vectypes[i], vectype_in))
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
@@ -3907,7 +3915,16 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,
 	  || thisarginfo.dt == vect_external_def)
 	gcc_assert (thisarginfo.vectype == NULL_TREE);
       else
-	gcc_assert (thisarginfo.vectype != NULL_TREE);
+	{
+	  gcc_assert (thisarginfo.vectype != NULL_TREE);
+	  if (VECTOR_BOOLEAN_TYPE_P (thisarginfo.vectype))
+	    {
+	      if (dump_enabled_p ())
+		dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				 "vector mask arguments are not supported\n");
+	      return false;
+	    }
+	}
 
       /* For linear arguments, the analyze phase should have saved
 	 the base and step in STMT_VINFO_SIMD_CLONE_INFO.  */
@@ -8272,18 +8289,27 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
       compute_in_loop = true;
     }
 
+  bool diff_first_stmt_info
+    = first_stmt_info_for_drptr && first_stmt_info != first_stmt_info_for_drptr;
+
   if ((alignment_support_scheme == dr_explicit_realign_optimized
        || alignment_support_scheme == dr_explicit_realign)
       && !compute_in_loop)
     {
-      msq = vect_setup_realignment (first_stmt_info, gsi, &realignment_token,
-				    alignment_support_scheme, NULL_TREE,
-				    &at_loop);
+      /* If we have different first_stmt_info, we can't set up realignment
+	 here, since we can't guarantee first_stmt_info DR has been
+	 initialized yet, use first_stmt_info_for_drptr DR by bumping the
+	 distance from first_stmt_info DR instead as below.  */
+      if (!diff_first_stmt_info)
+	msq = vect_setup_realignment (first_stmt_info, gsi, &realignment_token,
+				      alignment_support_scheme, NULL_TREE,
+				      &at_loop);
       if (alignment_support_scheme == dr_explicit_realign_optimized)
 	{
 	  phi = as_a <gphi *> (SSA_NAME_DEF_STMT (msq));
 	  byte_offset = size_binop (MINUS_EXPR, TYPE_SIZE_UNIT (vectype),
 				    size_one_node);
+	  gcc_assert (!first_stmt_info_for_drptr);
 	}
     }
   else
@@ -8339,8 +8365,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 	      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr_info->dr));
 	      dataref_offset = build_int_cst (ref_type, 0);
 	    }
-	  else if (first_stmt_info_for_drptr
-		   && first_stmt_info != first_stmt_info_for_drptr)
+	  else if (diff_first_stmt_info)
 	    {
 	      dataref_ptr
 		= vect_create_data_ref_ptr (first_stmt_info_for_drptr,
@@ -8357,6 +8382,14 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,
 					    DR_INIT (ptrdr)));
 	      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,
 					     stmt_info, diff);
+	      if (alignment_support_scheme == dr_explicit_realign)
+		{
+		  msq = vect_setup_realignment (first_stmt_info_for_drptr, gsi,
+						&realignment_token,
+						alignment_support_scheme,
+						dataref_ptr, &at_loop);
+		  gcc_assert (!compute_in_loop);
+		}
 	    }
 	  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))
 	    vect_get_gather_scatter_ops (loop, stmt_info, &gs_info,
diff --git a/gcc/tree-vector-builder.h b/gcc/tree-vector-builder.h
index 0e36cd17139..13af74ad834 100644
--- a/gcc/tree-vector-builder.h
+++ b/gcc/tree-vector-builder.h
@@ -82,7 +82,7 @@ tree_vector_builder::new_vector (tree type, unsigned int npatterns,
 inline bool
 tree_vector_builder::equal_p (const_tree elt1, const_tree elt2) const
 {
-  return operand_equal_p (elt1, elt2, 0);
+  return operand_equal_p (elt1, elt2, OEP_BITWISE);
 }
 
 /* Return true if a stepped representation is OK.  We don't allow
diff --git a/gcc/tree-vectorizer.c b/gcc/tree-vectorizer.c
index d27104933a9..d89ec3b7c76 100644
--- a/gcc/tree-vectorizer.c
+++ b/gcc/tree-vectorizer.c
@@ -941,7 +941,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,
 	      fold_loop_internal_call (loop_vectorized_call,
 				       boolean_true_node);
 	      loop_vectorized_call = NULL;
-	      ret |= TODO_cleanup_cfg;
+	      ret |= TODO_cleanup_cfg | TODO_update_ssa_only_virtuals;
 	    }
 	}
       /* If outer loop vectorization fails for LOOP_VECTORIZED guarded
diff --git a/gcc/tree-vectorizer.h b/gcc/tree-vectorizer.h
index d5fd4690b1d..148b9a7f215 100644
--- a/gcc/tree-vectorizer.h
+++ b/gcc/tree-vectorizer.h
@@ -132,6 +132,9 @@ struct _slp_tree {
   unsigned int vec_stmts_size;
   /* Reference count in the SLP graph.  */
   unsigned int refcnt;
+  /* The maximum number of vector elements for the subtree rooted
+     at this node.  */
+  poly_uint64 max_nunits;
   /* Whether the scalar computations use two different operators.  */
   bool two_operators;
   /* The DEF type of this node.  */
@@ -1350,19 +1353,27 @@ vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)
 }
 
 /* Update maximum unit count *MAX_NUNITS so that it accounts for
-   the number of units in vector type VECTYPE.  *MAX_NUNITS can be 1
-   if we haven't yet recorded any vector types.  */
+   NUNITS.  *MAX_NUNITS can be 1 if we haven't yet recorded anything.  */
 
 static inline void
-vect_update_max_nunits (poly_uint64 *max_nunits, tree vectype)
+vect_update_max_nunits (poly_uint64 *max_nunits, poly_uint64 nunits)
 {
   /* All unit counts have the form current_vector_size * X for some
      rational X, so two unit sizes must have a common multiple.
      Everything is a multiple of the initial value of 1.  */
-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);
   *max_nunits = force_common_multiple (*max_nunits, nunits);
 }
 
+/* Update maximum unit count *MAX_NUNITS so that it accounts for
+   the number of units in vector type VECTYPE.  *MAX_NUNITS can be 1
+   if we haven't yet recorded any vector types.  */
+
+static inline void
+vect_update_max_nunits (poly_uint64 *max_nunits, tree vectype)
+{
+  vect_update_max_nunits (max_nunits, TYPE_VECTOR_SUBPARTS (vectype));
+}
+
 /* Return the vectorization factor that should be used for costing
    purposes while vectorizing the loop described by LOOP_VINFO.
    Pick a reasonable estimate if the vectorization factor isn't
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index 795d7184a65..2140101d7d2 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -1702,9 +1702,7 @@ extract_range_from_binary_expr (value_range_base *vr,
 	{
 	  /* For pointer types, we are really only interested in asserting
 	     whether the expression evaluates to non-NULL.  */
-	  if (!range_includes_zero_p (&vr0) && !range_includes_zero_p (&vr1))
-	    vr->set_nonnull (expr_type);
-	  else if (range_is_null (&vr0) || range_is_null (&vr1))
+	  if (range_is_null (&vr0) || range_is_null (&vr1))
 	    vr->set_null (expr_type);
 	  else
 	    vr->set_varying ();
@@ -1772,18 +1770,19 @@ extract_range_from_binary_expr (value_range_base *vr,
 	  combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);
 	  combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);
 
-	  /* If we have overflow for the constant part and the resulting
-	     range will be symbolic, drop to VR_VARYING.  */
-	  if (((bool)min_ovf && sym_min_op0 != sym_min_op1)
-	      || ((bool)max_ovf && sym_max_op0 != sym_max_op1))
+	  /* If the resulting range will be symbolic, we need to eliminate any
+	     explicit or implicit overflow introduced in the above computation
+	     because compare_values could make an incorrect use of it.  That's
+	     why we require one of the ranges to be a singleton.  */
+	  if ((sym_min_op0 != sym_min_op1 || sym_max_op0 != sym_max_op1)
+	      && ((bool)min_ovf || (bool)max_ovf
+		  || (min_op0 != max_op0 && min_op1 != max_op1)))
 	    {
 	      vr->set_varying ();
 	      return;
 	    }
 
 	  /* Adjust the range for possible overflow.  */
-	  min = NULL_TREE;
-	  max = NULL_TREE;
 	  set_value_range_with_overflow (type, min, max, expr_type,
 					 wmin, wmax, min_ovf, max_ovf);
 	  if (type == VR_VARYING)
diff --git a/gcc/tree.c b/gcc/tree.c
index 73102c4e75b..32e94e48132 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -265,7 +265,7 @@ static void print_type_hash_statistics (void);
 static void print_debug_expr_statistics (void);
 static void print_value_expr_statistics (void);
 
-static tree build_array_type_1 (tree, tree, bool, bool);
+static tree build_array_type_1 (tree, tree, bool, bool, bool);
 
 tree global_trees[TI_MAX];
 tree integer_types[itk_none];
@@ -5251,8 +5251,9 @@ fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,
      = map->get_or_insert (t, &existed);
   if (!existed)
     {
-      array = build_array_type_1 (t2, TYPE_DOMAIN (t),
-				  TYPE_TYPELESS_STORAGE (t), false);
+      array
+	= build_array_type_1 (t2, TYPE_DOMAIN (t), TYPE_TYPELESS_STORAGE (t),
+			      false, false);
       TYPE_CANONICAL (array) = TYPE_CANONICAL (t);
       if (!fld->pset.add (array))
 	add_tree_to_fld_list (array, fld);
@@ -5514,8 +5515,7 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)
 	  free_lang_data_in_binfo (TYPE_BINFO (type));
 	  /* We need to preserve link to bases and virtual table for all
 	     polymorphic types to make devirtualization machinery working.  */
-	  if (!BINFO_VTABLE (TYPE_BINFO (type))
-	      || !flag_devirtualize)
+	  if (!BINFO_VTABLE (TYPE_BINFO (type)))
 	    TYPE_BINFO (type) = NULL;
 	}
     }
@@ -5778,7 +5778,8 @@ free_lang_data_in_decl (tree decl, struct free_lang_data_d *fld)
       while (*nextp)
 	{
 	  tree var = *nextp;
-	  if (fndecl_built_in_p (var))
+	  if (TREE_CODE (var) == FUNCTION_DECL
+	      && fndecl_built_in_p (var))
 	    *nextp = TREE_CHAIN (var);
 	  else
 	    nextp = &TREE_CHAIN (var);
@@ -5937,8 +5938,9 @@ find_decls_types_r (tree *tp, int *ws, void *data)
     {
       for (tree *tem = &BLOCK_VARS (t); *tem; )
 	{
-	  if (TREE_CODE (*tem) != VAR_DECL
-	      || !auto_var_in_fn_p (*tem, DECL_CONTEXT (*tem)))
+	  if (TREE_CODE (*tem) != LABEL_DECL
+	      && (TREE_CODE (*tem) != VAR_DECL
+		  || !auto_var_in_fn_p (*tem, DECL_CONTEXT (*tem))))
 	    {
 	      gcc_assert (TREE_CODE (*tem) != RESULT_DECL
 			  && TREE_CODE (*tem) != PARM_DECL);
@@ -6107,6 +6109,13 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)
 	    {
 	      tree arg = gimple_op (stmt, i);
 	      find_decls_types (arg, fld);
+	      /* find_decls_types doesn't walk TREE_PURPOSE of TREE_LISTs,
+		 which we need for asm stmts.  */
+	      if (arg
+		  && TREE_CODE (arg) == TREE_LIST
+		  && TREE_PURPOSE (arg)
+		  && gimple_code (stmt) == GIMPLE_ASM)
+		find_decls_types (TREE_PURPOSE (arg), fld);
 	    }
 	}
     }
@@ -8359,11 +8368,12 @@ subrange_type_for_debug_p (const_tree type, tree *lowval, tree *highval)
 /* Construct, lay out and return the type of arrays of elements with ELT_TYPE
    and number of elements specified by the range of values of INDEX_TYPE.
    If TYPELESS_STORAGE is true, TYPE_TYPELESS_STORAGE flag is set on the type.
-   If SHARED is true, reuse such a type that has already been constructed.  */
+   If SHARED is true, reuse such a type that has already been constructed.
+   If SET_CANONICAL is true, compute TYPE_CANONICAL from the element type.  */
 
 static tree
 build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,
-		    bool shared)
+		    bool shared, bool set_canonical)
 {
   tree t;
 
@@ -8380,19 +8390,13 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,
   TYPE_TYPELESS_STORAGE (t) = typeless_storage;
   layout_type (t);
 
-  /* If the element type is incomplete at this point we get marked for
-     structural equality.  Do not record these types in the canonical
-     type hashtable.  */
-  if (TYPE_STRUCTURAL_EQUALITY_P (t))
-    return t;
-
   if (shared)
     {
       hashval_t hash = type_hash_canon_hash (t);
       t = type_hash_canon (hash, t);
     }
 
-  if (TYPE_CANONICAL (t) == t)
+  if (TYPE_CANONICAL (t) == t && set_canonical)
     {
       if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)
 	  || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type))
@@ -8404,7 +8408,7 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,
 	  = build_array_type_1 (TYPE_CANONICAL (elt_type),
 				index_type
 				? TYPE_CANONICAL (index_type) : NULL_TREE,
-				typeless_storage, shared);
+				typeless_storage, shared, set_canonical);
     }
 
   return t;
@@ -8415,7 +8419,8 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,
 tree
 build_array_type (tree elt_type, tree index_type, bool typeless_storage)
 {
-  return build_array_type_1 (elt_type, index_type, typeless_storage, true);
+  return
+    build_array_type_1 (elt_type, index_type, typeless_storage, true, true);
 }
 
 /* Wrapper around build_array_type_1 with SHARED set to false.  */
@@ -8423,7 +8428,7 @@ build_array_type (tree elt_type, tree index_type, bool typeless_storage)
 tree
 build_nonshared_array_type (tree elt_type, tree index_type)
 {
-  return build_array_type_1 (elt_type, index_type, false, false);
+  return build_array_type_1 (elt_type, index_type, false, false, true);
 }
 
 /* Return a representation of ELT_TYPE[NELTS], using indices of type
@@ -13861,9 +13866,9 @@ verify_type_variant (const_tree t, tree tv)
 	  debug_tree (TYPE_SIZE_UNIT (t));
 	  return false;
 	}
+      verify_variant_match (TYPE_NEEDS_CONSTRUCTING);
     }
   verify_variant_match (TYPE_PRECISION);
-  verify_variant_match (TYPE_NEEDS_CONSTRUCTING);
   if (RECORD_OR_UNION_TYPE_P (t))
     verify_variant_match (TYPE_TRANSPARENT_AGGR);
   else if (TREE_CODE (t) == ARRAY_TYPE)
@@ -14972,6 +14977,41 @@ default_is_empty_record (const_tree type)
   return default_is_empty_type (TYPE_MAIN_VARIANT (type));
 }
 
+/* Determine whether TYPE is a structure with a flexible array member,
+   or a union containing such a structure (possibly recursively).  */
+
+bool
+flexible_array_type_p (const_tree type)
+{
+  tree x, last;
+  switch (TREE_CODE (type))
+    {
+    case RECORD_TYPE:
+      last = NULL_TREE;
+      for (x = TYPE_FIELDS (type); x != NULL_TREE; x = DECL_CHAIN (x))
+	if (TREE_CODE (x) == FIELD_DECL)
+	  last = x;
+      if (last == NULL_TREE)
+	return false;
+      if (TREE_CODE (TREE_TYPE (last)) == ARRAY_TYPE
+	  && TYPE_SIZE (TREE_TYPE (last)) == NULL_TREE
+	  && TYPE_DOMAIN (TREE_TYPE (last)) != NULL_TREE
+	  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (last))) == NULL_TREE)
+	return true;
+      return false;
+    case UNION_TYPE:
+      for (x = TYPE_FIELDS (type); x != NULL_TREE; x = DECL_CHAIN (x))
+	{
+	  if (TREE_CODE (x) == FIELD_DECL
+	      && flexible_array_type_p (TREE_TYPE (x)))
+	    return true;
+	}
+      return false;
+    default:
+      return false;
+  }
+}
+
 /* Like int_size_in_bytes, but handle empty records specially.  */
 
 HOST_WIDE_INT
diff --git a/gcc/tree.h b/gcc/tree.h
index d650511c66f..2f8e37bb356 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -5900,6 +5900,7 @@ extern void gt_pch_nx (tree &, gt_pointer_operator, void *);
 
 extern bool nonnull_arg_p (const_tree);
 extern bool default_is_empty_record (const_tree);
+extern bool flexible_array_type_p (const_tree);
 extern HOST_WIDE_INT arg_int_size_in_bytes (const_tree);
 extern tree arg_size_in_bytes (const_tree);
 extern bool expr_type_first_operand_type_p (tree_code);
@@ -5946,12 +5947,12 @@ type_has_mode_precision_p (const_tree t)
 
    Note that it is different from the DECL_IS_BUILTIN accessor.  For
    instance, user declared prototypes of C library functions are not
-   DECL_IS_BUILTIN but may be DECL_BUILT_IN.  */
+   DECL_IS_BUILTIN but may be fndecl_built_in_p.  */
 
 inline bool
 fndecl_built_in_p (const_tree node)
 {
-  return (DECL_BUILT_IN_CLASS (node) != NOT_BUILT_IN);
+  return DECL_BUILT_IN_CLASS (node) != NOT_BUILT_IN;
 }
 
 /* Return true if a FUNCTION_DECL NODE is a GCC built-in function
@@ -5960,7 +5961,7 @@ fndecl_built_in_p (const_tree node)
 inline bool
 fndecl_built_in_p (const_tree node, built_in_class klass)
 {
-  return (fndecl_built_in_p (node) && DECL_BUILT_IN_CLASS (node) == klass);
+  return fndecl_built_in_p (node) && DECL_BUILT_IN_CLASS (node) == klass;
 }
 
 /* Return true if a FUNCTION_DECL NODE is a GCC built-in function
diff --git a/gcc/varasm.c b/gcc/varasm.c
index cb43248ec49..8f006dcff67 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -2585,20 +2585,16 @@ assemble_name_raw (FILE *file, const char *name)
     ASM_OUTPUT_LABELREF (file, name);
 }
 
-/* Like assemble_name_raw, but should be used when NAME might refer to
-   an entity that is also represented as a tree (like a function or
-   variable).  If NAME does refer to such an entity, that entity will
-   be marked as referenced.  */
-
-void
-assemble_name (FILE *file, const char *name)
+/* Return NAME that should actually be emitted, looking through
+   transparent aliases.  If NAME refers to an entity that is also
+   represented as a tree (like a function or variable), mark the entity
+   as referenced.  */
+const char *
+assemble_name_resolve (const char *name)
 {
-  const char *real_name;
-  tree id;
+  const char *real_name = targetm.strip_name_encoding (name);
+  tree id = maybe_get_identifier (real_name);
 
-  real_name = targetm.strip_name_encoding (name);
-
-  id = maybe_get_identifier (real_name);
   if (id)
     {
       tree id_orig = id;
@@ -2610,7 +2606,18 @@ assemble_name (FILE *file, const char *name)
       gcc_assert (! TREE_CHAIN (id));
     }
 
-  assemble_name_raw (file, name);
+  return name;
+}
+
+/* Like assemble_name_raw, but should be used when NAME might refer to
+   an entity that is also represented as a tree (like a function or
+   variable).  If NAME does refer to such an entity, that entity will
+   be marked as referenced.  */
+
+void
+assemble_name (FILE *file, const char *name)
+{
+  assemble_name_raw (file, assemble_name_resolve (name));
 }
 
 /* Allocate SIZE bytes writable static space with a gensym name
diff --git a/libbacktrace/ChangeLog b/libbacktrace/ChangeLog
index 93fcf483153..3fa0caa6f67 100644
--- a/libbacktrace/ChangeLog
+++ b/libbacktrace/ChangeLog
@@ -1,3 +1,13 @@
+2020-02-29  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-26  Ian Lance Taylor  <iant@golang.org>
+
+	PR libbacktrace/91908
+	* pecoff.c (backtrace_initialize): Explicitly cast unchecked
+	__sync_bool_compare_and_swap to void.
+	* xcoff.c (backtrace_initialize): Likewise.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libbacktrace/pecoff.c b/libbacktrace/pecoff.c
index da1982fd3ca..fcf9508d488 100644
--- a/libbacktrace/pecoff.c
+++ b/libbacktrace/pecoff.c
@@ -922,7 +922,8 @@ backtrace_initialize (struct backtrace_state *state,
       if (found_sym)
 	backtrace_atomic_store_pointer (&state->syminfo_fn, coff_syminfo);
       else
-	__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, coff_nosyms);
+	(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,
+					     coff_nosyms);
     }
 
   if (!state->threaded)
diff --git a/libbacktrace/xcoff.c b/libbacktrace/xcoff.c
index d50b5bc517e..bc60962fe04 100644
--- a/libbacktrace/xcoff.c
+++ b/libbacktrace/xcoff.c
@@ -1592,7 +1592,8 @@ backtrace_initialize (struct backtrace_state *state,
       if (found_sym)
 	backtrace_atomic_store_pointer (&state->syminfo_fn, xcoff_syminfo);
       else
-	__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, xcoff_nosyms);
+	(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,
+					     xcoff_nosyms);
     }
 
   if (!state->threaded)
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 99e2386de14..68c9237cf03 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,17 @@
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/92296
+	* internal.h (struct def_pragma_macro): Add is_builtin bitfield.
+	(_cpp_restore_special_builtin): Declare.
+	* init.c (_cpp_restore_special_builtin): New function.
+	* directives.c (do_pragma_push_macro): For NT_BUILTIN_MACRO
+	set is_builtin and don't try to grab definition.
+	(cpp_pop_definition): Use _cpp_restore_special_builtin to restore
+	builtin macros.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libcpp/directives.c b/libcpp/directives.c
index 1ada834da17..d78e4b7fc19 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -1564,6 +1564,8 @@ do_pragma_push_macro (cpp_reader *pfile)
   node = _cpp_lex_identifier (pfile, c->name);
   if (node->type == NT_VOID)
     c->is_undef = 1;
+  else if (node->type == NT_BUILTIN_MACRO)
+    c->is_builtin = 1;
   else
     {
       defn = cpp_macro_definition (pfile, node);
@@ -2452,6 +2454,11 @@ cpp_pop_definition (cpp_reader *pfile, struct def_pragma_macro *c)
 
   if (c->is_undef)
     return;
+  if (c->is_builtin)
+    {
+      _cpp_restore_special_builtin (pfile, c);
+      return;
+    }
 
   {
     size_t namelen;
diff --git a/libcpp/init.c b/libcpp/init.c
index 60d25889857..7f2f976037a 100644
--- a/libcpp/init.c
+++ b/libcpp/init.c
@@ -489,6 +489,25 @@ cpp_init_special_builtins (cpp_reader *pfile)
     }
 }
 
+/* Restore macro C to builtin macro definition.  */
+
+void
+_cpp_restore_special_builtin (cpp_reader *pfile, struct def_pragma_macro *c)
+{
+  size_t len = strlen (c->name);
+
+  for (const struct builtin_macro *b = builtin_array;
+       b < builtin_array + ARRAY_SIZE (builtin_array); b++)
+    if (b->len == len && memcmp (c->name, b->name, len + 1) == 0)
+      {
+	cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);
+	hp->type = NT_BUILTIN_MACRO;
+	if (b->always_warn_if_redefined)
+	  hp->flags |= NODE_WARN;
+	hp->value.builtin = (enum cpp_builtin_type) b->value;
+      }
+}
+
 /* Read the builtins table above and enter them, and language-specific
    macros, into the hash table.  HOSTED is true if this is a hosted
    environment.  */
diff --git a/libcpp/internal.h b/libcpp/internal.h
index 77a2a3becb3..496c9d63236 100644
--- a/libcpp/internal.h
+++ b/libcpp/internal.h
@@ -380,6 +380,8 @@ struct def_pragma_macro {
 
   /* Mark if we save an undefined macro.  */
   unsigned int is_undef : 1;
+  /* Nonzero if it was a builtin macro.  */
+  unsigned int is_builtin : 1;
 };
 
 /* A cpp_reader encapsulates the "state" of a pre-processor run.
@@ -712,6 +714,8 @@ extern void *_cpp_commit_buff (cpp_reader *pfile, size_t size);
 /* In init.c.  */
 extern void _cpp_maybe_push_include_file (cpp_reader *);
 extern const char *cpp_named_operator2name (enum cpp_ttype type);
+extern void _cpp_restore_special_builtin (cpp_reader *pfile,
+					  struct def_pragma_macro *);
 
 /* In directives.c */
 extern int _cpp_test_assertion (cpp_reader *, unsigned int *);
diff --git a/libdecnumber/ChangeLog b/libdecnumber/ChangeLog
index 1bef6d92f9d..90d5a978f7a 100644
--- a/libdecnumber/ChangeLog
+++ b/libdecnumber/ChangeLog
@@ -1,3 +1,14 @@
+2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	2019-12-09  Joseph Myers  <joseph@codesourcery.com>
+
+	PR middle-end/91226
+	* bid/bid2dpd_dpd2bid.c (_bid_to_dpd64): Handle non-canonical
+	significands.
+	(_bid_to_dpd128): Likewise.  Check for case where combination
+	field starts 1100, 1101 or 1110.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libdecnumber/bid/bid2dpd_dpd2bid.c b/libdecnumber/bid/bid2dpd_dpd2bid.c
index 63d3cecfe8d..36aa56c540d 100644
--- a/libdecnumber/bid/bid2dpd_dpd2bid.c
+++ b/libdecnumber/bid/bid2dpd_dpd2bid.c
@@ -189,6 +189,8 @@ _bid_to_dpd64 (_Decimal64 *pres, _Decimal64 *px) {
   if ((comb & 0xc00) == 0xc00) { /* G0..G1 = 11 -> exp is G2..G11 */
     exp = (comb) & 0x3ff;
     bcoeff = (x & 0x0007ffffffffffffull) | 0x0020000000000000ull;
+    if (bcoeff >= 10000000000000000ull)
+      bcoeff = 0;
   } else {
     exp = (comb >> 2) & 0x3ff;
     bcoeff = (x & 0x001fffffffffffffull);
@@ -298,9 +300,23 @@ _bid_to_dpd128 (_Decimal128 *pres, _Decimal128 *px) {
   if ((comb & 0x1e000) == 0x1e000) {
     res = x;
   } else { /* normal number */
-    exp = ((x.w[1] & 0x7fff000000000000ull) >> 49) & 0x3fff;
-    bcoeff.w[1] = (x.w[1] & 0x0001ffffffffffffull);
-    bcoeff.w[0] = x.w[0];
+    if ((comb & 0x18000) == 0x18000) {
+      /* Noncanonical significand (prepending 8 or 9 to any 110-bit
+	 trailing significand field produces a value above 10^34).  */
+      exp = (comb & 0x7fff) >> 1;
+      bcoeff.w[1] = 0;
+      bcoeff.w[0] = 0;
+    } else {
+      exp = ((x.w[1] & 0x7fff000000000000ull) >> 49) & 0x3fff;
+      bcoeff.w[1] = (x.w[1] & 0x0001ffffffffffffull);
+      bcoeff.w[0] = x.w[0];
+      if (bcoeff.w[1] > 0x1ed09bead87c0ull
+	  || (bcoeff.w[1] == 0x1ed09bead87c0ull
+	      && bcoeff.w[0] >= 0x378d8e6400000000ull)) {
+	bcoeff.w[1] = 0;
+	bcoeff.w[0] = 0;
+      }
+    }
     d1018 = reciprocals10_128[18];
     __mul_128x128_high (BH, bcoeff, d1018);
     amount = recip_scale[18];
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 348c54c0b3e..7630d6ef81d 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,73 @@
+2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libgcc/85334
+	* config/i386/shadow-stack-unwind.h (_Unwind_Frames_Increment):
+	New.
+
+2019-11-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg): Change argument 1 to
+	volatile void *.  Remove trap check.
+	(__kernel_cmpxchg2): Likewise.
+	(FETCH_AND_OP_2): Adjust operand types.
+	(OP_AND_FETCH_2): Likewise.
+	(FETCH_AND_OP_WORD): Likewise.
+	(OP_AND_FETCH_WORD): Likewise.
+	(COMPARE_AND_SWAP_2): Likewise.
+	(__sync_val_compare_and_swap_4): Likewise.
+	(__sync_bool_compare_and_swap_4): Likewise.
+	(SYNC_LOCK_TEST_AND_SET_2): Likewise.
+	(__sync_lock_test_and_set_4): Likewise.
+	(SYNC_LOCK_RELEASE_1): Likewise.  Use __kernel_cmpxchg2 for release.
+	(__sync_lock_release_4): Adjust operand types.  Use __kernel_cmpxchg
+	for release.
+	(__sync_lock_release_8): Remove.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host (powerpc-*-darwin*,powerpc64-*-darwin*): Revise crt
+	list.
+	* config/rs6000/t-darwin: Build crt3_2 for older systems.  Revise
+	mmacosx-version-min for crts to run across all system versions.
+	* config/rs6000/t-darwin64 (LIB2ADD): Remove.
+	* config/t-darwin: Revise mmacosx-version-min for crts to run across
+	system versions >= 10.4.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host: Add libef_ppc.a to the extra files for powerpc-darwin.
+	* config/rs6000/t-darwin: (PPC_ENDFILE_SRC, PPC_ENDFILE_OBJS): New.
+	Build objects for the out of line save/restore register functions
+	so that they can be used for any supported Darwin version.
+	* config/t-darwin: Default the build Darwin version to Darwin8
+	(MacOS 10.4).
+
+2019-10-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (_dl_read_access_allowed): Change argument to
+	unsigned int.  Adjust callers.
+	(__canonicalize_funcptr_for_compare): Change plabel type to volatile
+	unsigned int *.  Load relocation offset before function pointer.
+	Add barrier to ensure ordering.
+
+2019-10-12  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/lib2funcs.S (__gcc_plt_call): Load branch target to %r21.
+	Load PIC register after branch target.  Fix white space.
+	* config/pa/milli64.S ($$dyncall): Separate LINUX and non LINUX
+	implementations.  Load PIC register after branch target.  Don't
+	clobber function pointer when it points to function descriptor.
+	Use nullification instead of branch in LINUX implementation.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index 91abc84da03..0f15fda3612 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1072,12 +1072,12 @@ powerpc-*-darwin*)
 	  md_unwind_header=rs6000/darwin-unwind.h
 	  ;;
 	esac
-	tmake_file="$tmake_file rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	tmake_file="$tmake_file rs6000/t-ppc64-fp rs6000/t-ibm-ldouble"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc64-*-darwin*)
 	tmake_file="$tmake_file rs6000/t-darwin64 rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc*-*-freebsd*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff rs6000/t-freebsd t-softfp-sfdf t-softfp-excl t-softfp"
diff --git a/libgcc/config/i386/shadow-stack-unwind.h b/libgcc/config/i386/shadow-stack-unwind.h
index c53c3fe5c63..129d6d19c37 100644
--- a/libgcc/config/i386/shadow-stack-unwind.h
+++ b/libgcc/config/i386/shadow-stack-unwind.h
@@ -49,3 +49,46 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 	}					\
     }						\
     while (0)
+
+/* Linux CET kernel places a restore token on shadow stack for signal
+   handler to enhance security.  The restore token is 8 byte and aligned
+   to 8 bytes.  It is usually transparent to user programs since kernel
+   will pop the restore token when signal handler returns.  But when an
+   exception is thrown from a signal handler, now we need to pop the
+   restore token from shadow stack.  For x86-64, we just need to treat
+   the signal frame as normal frame.  For i386, we need to search for
+   the restore token to check if the original shadow stack is 8 byte
+   aligned.  If the original shadow stack is 8 byte aligned, we just
+   need to pop 2 slots, one restore token, from shadow stack.  Otherwise,
+   we need to pop 3 slots, one restore token + 4 byte padding, from
+   shadow stack.  */
+#ifndef __x86_64__
+#undef _Unwind_Frames_Increment
+#define _Unwind_Frames_Increment(context, frames)	\
+  if (_Unwind_IsSignalFrame (context))			\
+    do							\
+      {							\
+	_Unwind_Word ssp, prev_ssp, token;		\
+	ssp = _get_ssp ();				\
+	if (ssp != 0)					\
+	  {						\
+	    /* Align shadow stack pointer to the next	\
+	       8 byte aligned boundary.  */		\
+	    ssp = (ssp + 4) & ~7;			\
+	    do						\
+	      {						\
+		/* Look for a restore token.  */	\
+		token = (*(_Unwind_Word *) (ssp - 8));	\
+		prev_ssp = token & ~7;			\
+		if (prev_ssp == ssp)			\
+		  break;				\
+		ssp += 8;				\
+	      }						\
+	    while (1);					\
+	    frames += (token & 0x4) ? 3 : 2;		\
+	  }						\
+      }							\
+    while (0);						\
+  else							\
+    frames++;
+#endif
diff --git a/libgcc/config/pa/fptr.c b/libgcc/config/pa/fptr.c
index 53440051730..5beb0b832e2 100644
--- a/libgcc/config/pa/fptr.c
+++ b/libgcc/config/pa/fptr.c
@@ -53,7 +53,7 @@ typedef int (*fixup_t) (struct link_map *, unsigned int);
 extern unsigned int _GLOBAL_OFFSET_TABLE_;
 
 static inline int
-_dl_read_access_allowed (unsigned int *addr)
+_dl_read_access_allowed (unsigned int addr)
 {
   int result;
 
@@ -76,7 +76,8 @@ __canonicalize_funcptr_for_compare (fptr_t fptr)
 {
   static unsigned int fixup_plabel[2] __attribute__((used));
   fixup_t fixup;
-  unsigned int *got, *iptr, *plabel;
+  volatile unsigned int *plabel;
+  unsigned int *got, *iptr, reloc_offset;
   int i;
 
   /* -1 and page 0 are special.  -1 is used in crtend to mark the end of
@@ -91,17 +92,20 @@ __canonicalize_funcptr_for_compare (fptr_t fptr)
      to the entry of the PLT stub just before the global offset table.
      The second word in the plabel contains the relocation offset for the
      function.  */
-  plabel = (unsigned int *) ((unsigned int) fptr & ~3);
-  if (!_dl_read_access_allowed (plabel))
+  plabel = (volatile unsigned int *) ((unsigned int) fptr & ~3);
+  if (!_dl_read_access_allowed ((unsigned int)plabel))
     return (unsigned int) fptr;
 
   /* Load first word of candidate descriptor.  It should be a pointer
      with word alignment and point to memory that can be read.  */
   got = (unsigned int *) plabel[0];
   if (((unsigned int) got & 3) != 0
-      || !_dl_read_access_allowed (got))
+      || !_dl_read_access_allowed ((unsigned int)got))
     return (unsigned int) fptr;
 
+  /* We need to load the relocation offset before the function address.  */
+  reloc_offset = plabel[1];
+  __sync_synchronize();
   got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
 
   /* Return the address of the function if the plabel has been resolved.  */
@@ -137,7 +141,7 @@ __canonicalize_funcptr_for_compare (fptr_t fptr)
 
   /* Call fixup to resolve the function address.  got[1] contains the
      link_map pointer and plabel[1] the relocation offset.  */
-  fixup ((struct link_map *) got[1], plabel[1]);
+  fixup ((struct link_map *) got[1], reloc_offset);
 
   return plabel[0];
 }
diff --git a/libgcc/config/pa/lib2funcs.S b/libgcc/config/pa/lib2funcs.S
index b401b6157da..a2db5b3d3ac 100644
--- a/libgcc/config/pa/lib2funcs.S
+++ b/libgcc/config/pa/lib2funcs.S
@@ -55,13 +55,13 @@ __gcc_plt_call
 	; An inline version of dyncall so we don't have to worry
 	; about long calls to millicode, PIC and other complexities.
 	bb,>=,n %r22,30,L$foo
-        depi 0,31,2,%r22
-        ldw 4(%r22),%r19
-        ldw 0(%r22),%r22
+	depi 0,31,2,%r22
+	ldw 0(%r22),%r21
+	ldw 4(%r22),%r19
 L$foo
-        ldsid (%r22),%r1
-        mtsp %r1,%sr0
-        ble 0(%sr0,%r22)
+	ldsid (%r21),%r1
+	mtsp %r1,%sr0
+	ble 0(%sr0,%r21)
 	copy %r31,%r2
 	ldw -8(%r30),%r2
 
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
index 28b41a78e52..4cd69f74cd2 100644
--- a/libgcc/config/pa/linux-atomic.c
+++ b/libgcc/config/pa/linux-atomic.c
@@ -41,7 +41,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 /* Kernel helper for compare-and-exchange a 32-bit value.  */
 static inline long
-__kernel_cmpxchg (int *mem, int oldval, int newval)
+__kernel_cmpxchg (volatile void *mem, int oldval, int newval)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
   register int lws_old asm("r25") = oldval;
@@ -54,20 +54,18 @@ __kernel_cmpxchg (int *mem, int oldval, int newval)
 	: "i" (LWS_CAS), "r" (lws_mem), "r" (lws_old), "r" (lws_new)
 	: "r1", "r20", "r22", "r23", "r29", "r31", "memory"
   );
-  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    __builtin_trap ();
 
   /* If the kernel LWS call succeeded (lws_errno == 0), lws_ret contains
      the old value from memory.  If this value is equal to OLDVAL, the
      new value was written to memory.  If not, return -EBUSY.  */
   if (!lws_errno && lws_ret != oldval)
-    lws_errno = -EBUSY;
+    return -EBUSY;
 
   return lws_errno;
 }
 
 static inline long
-__kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
+__kernel_cmpxchg2 (volatile void *mem, const void *oldval, const void *newval,
 		   int val_size)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
@@ -88,9 +86,6 @@ __kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
   if (__builtin_expect (lws_ret == 0, 1))
     return 0;
 
-  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    __builtin_trap ();
-
   /* If the kernel LWS call fails with no error, return -EBUSY */
   if (__builtin_expect (!lws_errno, 0))
     return -EBUSY;
@@ -108,13 +103,13 @@ __kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
 
 #define FETCH_AND_OP_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
+  __sync_fetch_and_##OP##_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE tmp, newval;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile TYPE *)ptr, __ATOMIC_RELAXED);	\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -122,36 +117,36 @@ __kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
     return tmp;								\
   }
 
-FETCH_AND_OP_2 (add,   , +, long long, 8, 3)
-FETCH_AND_OP_2 (sub,   , -, long long, 8, 3)
-FETCH_AND_OP_2 (or,    , |, long long, 8, 3)
-FETCH_AND_OP_2 (and,   , &, long long, 8, 3)
-FETCH_AND_OP_2 (xor,   , ^, long long, 8, 3)
-FETCH_AND_OP_2 (nand, ~, &, long long, 8, 3)
-
-FETCH_AND_OP_2 (add,   , +, short, 2, 1)
-FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
-FETCH_AND_OP_2 (or,    , |, short, 2, 1)
-FETCH_AND_OP_2 (and,   , &, short, 2, 1)
-FETCH_AND_OP_2 (xor,   , ^, short, 2, 1)
-FETCH_AND_OP_2 (nand, ~, &, short, 2, 1)
-
-FETCH_AND_OP_2 (add,   , +, signed char, 1, 0)
-FETCH_AND_OP_2 (sub,   , -, signed char, 1, 0)
-FETCH_AND_OP_2 (or,    , |, signed char, 1, 0)
-FETCH_AND_OP_2 (and,   , &, signed char, 1, 0)
-FETCH_AND_OP_2 (xor,   , ^, signed char, 1, 0)
-FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
+FETCH_AND_OP_2 (add,   , +, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (or,    , |, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (and,   , &, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, long long unsigned int, 8, 3)
+
+FETCH_AND_OP_2 (add,   , +, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (or,    , |, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (and,   , &, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, short unsigned int, 2, 1)
+
+FETCH_AND_OP_2 (add,   , +, unsigned char, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, unsigned char, 1, 0)
+FETCH_AND_OP_2 (or,    , |, unsigned char, 1, 0)
+FETCH_AND_OP_2 (and,   , &, unsigned char, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, unsigned char, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
 
 #define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
+  __sync_##OP##_and_fetch_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE tmp, newval;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile TYPE *)ptr, __ATOMIC_RELAXED);	\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -159,36 +154,37 @@ FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
     return PFX_OP (tmp INF_OP val);					\
   }
 
-OP_AND_FETCH_2 (add,   , +, long long, 8, 3)
-OP_AND_FETCH_2 (sub,   , -, long long, 8, 3)
-OP_AND_FETCH_2 (or,    , |, long long, 8, 3)
-OP_AND_FETCH_2 (and,   , &, long long, 8, 3)
-OP_AND_FETCH_2 (xor,   , ^, long long, 8, 3)
-OP_AND_FETCH_2 (nand, ~, &, long long, 8, 3)
-
-OP_AND_FETCH_2 (add,   , +, short, 2, 1)
-OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
-OP_AND_FETCH_2 (or,    , |, short, 2, 1)
-OP_AND_FETCH_2 (and,   , &, short, 2, 1)
-OP_AND_FETCH_2 (xor,   , ^, short, 2, 1)
-OP_AND_FETCH_2 (nand, ~, &, short, 2, 1)
-
-OP_AND_FETCH_2 (add,   , +, signed char, 1, 0)
-OP_AND_FETCH_2 (sub,   , -, signed char, 1, 0)
-OP_AND_FETCH_2 (or,    , |, signed char, 1, 0)
-OP_AND_FETCH_2 (and,   , &, signed char, 1, 0)
-OP_AND_FETCH_2 (xor,   , ^, signed char, 1, 0)
-OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)
+OP_AND_FETCH_2 (add,   , +, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (or,    , |, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (and,   , &, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, long long unsigned int, 8, 3)
+
+OP_AND_FETCH_2 (add,   , +, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (or,    , |, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (and,   , &, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, short unsigned int, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, unsigned char, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, unsigned char, 1, 0)
+OP_AND_FETCH_2 (or,    , |, unsigned char, 1, 0)
+OP_AND_FETCH_2 (and,   , &, unsigned char, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, unsigned char, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, unsigned char, 1, 0)
 
 #define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+  unsigned int HIDDEN							\
+  __sync_fetch_and_##OP##_4 (volatile void *ptr, unsigned int val)	\
   {									\
-    int tmp;								\
+    unsigned int tmp;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile unsigned int *)ptr,		\
+			     __ATOMIC_RELAXED);				\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -203,14 +199,15 @@ FETCH_AND_OP_WORD (xor,   , ^)
 FETCH_AND_OP_WORD (nand, ~, &)
 
 #define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
+  unsigned int HIDDEN							\
+  __sync_##OP##_and_fetch_4 (volatile void *ptr, unsigned int val)	\
   {									\
-    int tmp;								\
+    unsigned int tmp;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile unsigned int *)ptr,		\
+			     __ATOMIC_RELAXED);				\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -228,7 +225,7 @@ typedef unsigned char bool;
 
 #define COMPARE_AND_SWAP_2(TYPE, WIDTH, INDEX)				\
   TYPE HIDDEN								\
-  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+  __sync_val_compare_and_swap_##WIDTH (volatile void *ptr, TYPE oldval,	\
 				       TYPE newval)			\
   {									\
     TYPE actual_oldval;							\
@@ -236,7 +233,8 @@ typedef unsigned char bool;
 									\
     while (1)								\
       {									\
-	actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);	\
+	actual_oldval = __atomic_load_n ((volatile TYPE *)ptr,		\
+					 __ATOMIC_RELAXED);		\
 									\
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
@@ -248,27 +246,29 @@ typedef unsigned char bool;
       }									\
   }									\
 									\
-  bool HIDDEN								\
-  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-					TYPE newval)			\
+  _Bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (volatile void *ptr,		\
+					TYPE oldval, TYPE newval)	\
   {									\
     long failure = __kernel_cmpxchg2 (ptr, &oldval, &newval, INDEX);	\
     return (failure == 0);						\
   }
 
-COMPARE_AND_SWAP_2 (long long, 8, 3)
-COMPARE_AND_SWAP_2 (short, 2, 1)
-COMPARE_AND_SWAP_2 (char, 1, 0)
+COMPARE_AND_SWAP_2 (long long unsigned int, 8, 3)
+COMPARE_AND_SWAP_2 (short unsigned int, 2, 1)
+COMPARE_AND_SWAP_2 (unsigned char, 1, 0)
 
-int HIDDEN
-__sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
+unsigned int HIDDEN
+__sync_val_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
+			       unsigned int newval)
 {
   long fail;
-  int actual_oldval;
+  unsigned int actual_oldval;
     
   while (1)
     {
-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
+      actual_oldval = __atomic_load_n ((volatile unsigned int *)ptr,
+				       __ATOMIC_RELAXED);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -280,8 +280,9 @@ __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
     }
 }
 
-bool HIDDEN
-__sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
+_Bool HIDDEN
+__sync_bool_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
+				unsigned int newval)
 {
   long failure = __kernel_cmpxchg (ptr, oldval, newval);
   return (failure == 0);
@@ -289,55 +290,64 @@ __sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
 
 #define SYNC_LOCK_TEST_AND_SET_2(TYPE, WIDTH, INDEX)			\
 TYPE HIDDEN								\
-  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
+  __sync_lock_test_and_set_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE oldval;							\
     long failure;							\
 									\
     do {								\
-      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      oldval = __atomic_load_n ((volatile TYPE *)ptr,			\
+				__ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
     return oldval;							\
   }
 
-SYNC_LOCK_TEST_AND_SET_2 (long long, 8, 3)
-SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
-SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
+SYNC_LOCK_TEST_AND_SET_2 (long long unsigned int, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (short unsigned int, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (unsigned char, 1, 0)
 
-int HIDDEN
-__sync_lock_test_and_set_4 (int *ptr, int val)
+unsigned int HIDDEN
+__sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
 {
   long failure;
-  int oldval;
+  unsigned int oldval;
 
   do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
+    oldval = __atomic_load_n ((volatile unsigned int *)ptr, __ATOMIC_RELAXED);
     failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
   return oldval;
 }
 
-void HIDDEN
-__sync_lock_release_8 (long long *ptr)
-{
-  /* All accesses must be complete before we release the lock.  */
-  __sync_synchronize ();
-  *(double *)ptr = 0;
-}
-
-#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)			\
+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH, INDEX)			\
   void HIDDEN							\
-  __sync_lock_release_##WIDTH (TYPE *ptr)			\
+  __sync_lock_release_##WIDTH (volatile void *ptr)		\
   {								\
-    /* All accesses must be complete before we release		\
-       the lock.  */						\
-    __sync_synchronize ();					\
-    *ptr = 0;							\
+    TYPE oldval, val = 0;					\
+    long failure;						\
+								\
+    do {							\
+      oldval = __atomic_load_n ((volatile TYPE *)ptr,		\
+				__ATOMIC_RELAXED);		\
+      failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);	\
+    } while (failure != 0);					\
   }
 
-SYNC_LOCK_RELEASE_1 (int, 4)
-SYNC_LOCK_RELEASE_1 (short, 2)
-SYNC_LOCK_RELEASE_1 (signed char, 1)
+SYNC_LOCK_RELEASE_1 (long long unsigned int, 8, 3)
+SYNC_LOCK_RELEASE_1 (short unsigned int, 2, 1)
+SYNC_LOCK_RELEASE_1 (unsigned char, 1, 0)
+
+void HIDDEN
+__sync_lock_release_4 (volatile void *ptr)
+{
+  long failure;
+  unsigned int oldval;
+
+  do {
+    oldval = __atomic_load_n ((volatile unsigned int *)ptr, __ATOMIC_RELAXED);
+    failure = __kernel_cmpxchg (ptr, oldval, 0);
+  } while (failure != 0);
+}
diff --git a/libgcc/config/pa/milli64.S b/libgcc/config/pa/milli64.S
index 1e46f5018b9..36040e9e78d 100644
--- a/libgcc/config/pa/milli64.S
+++ b/libgcc/config/pa/milli64.S
@@ -222,19 +222,26 @@ GSYM($$dyncall)
 	.proc
 	.callinfo	millicode
 	.entry
-	bb,>=,n %r22,30,LREF(1)		; branch if not plabel address
-	depi	0,31,2,%r22		; clear the two least significant bits
-	ldw	4(%r22),%r19		; load new LTP value
-	ldw	0(%r22),%r22		; load address of target
-LSYM(1)
 #ifdef LINUX
-	bv	%r0(%r22)		; branch to the real target
+	extru,<>	%r22,30,1,%r0	; nullify if plabel bit set
+	bv,n	%r0(%r22)		; branch to target
+	ldw	-2(%r22),%r21		; load address of target
+	bv	%r0(%r21)		; branch to the real target
+	ldw	2(%r22),%r19		; load new LTP value
 #else
+	bb,>=,n %r22,30,LREF(1)		; branch if not plabel address
+	ldw	-2(%r22),%r21		; load address of target to r21
+	ldsid	(%sr0,%r21),%r1		; get the "space ident" selected by r21
+	ldw	2(%r22),%r19		; load new LTP value
+	mtsp	%r1,%sr0		; move that space identifier into sr0
+	be	0(%sr0,%r21)		; branch to the real target
+	stw	%r2,-24(%r30)		; save return address into frame marker
+LSYM(1)
 	ldsid	(%sr0,%r22),%r1		; get the "space ident" selected by r22
 	mtsp	%r1,%sr0		; move that space identifier into sr0
-	be	0(%sr0,%r22)		; branch to the real target
-#endif
+	be	0(%sr0,%r22)		; branch to the target
 	stw	%r2,-24(%r30)		; save return address into frame marker
+#endif
 	.exit
 	.procend
 #endif
diff --git a/libgcc/config/rs6000/t-darwin b/libgcc/config/rs6000/t-darwin
index 61da0bdf13a..8b513bdb1d7 100644
--- a/libgcc/config/rs6000/t-darwin
+++ b/libgcc/config/rs6000/t-darwin
@@ -1,25 +1,57 @@
-DARWIN_EXTRA_CRT_BUILD_CFLAGS = -mlongcall -mmacosx-version-min=10.4
 
 crt2.o: $(srcdir)/config/rs6000/darwin-crt2.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# The sources for this indicate that there are some parts that
+# don't apply >= 10.4
+crt3_2.o: $(srcdir)/config/darwin-crt3.c
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# The outlined register save/restore functions need to run anywhere, and
+# they must be leaf functions suitable for use in an endfile.
+
+PPC_ENDFILE_SRC = \
+  $(srcdir)/config/rs6000/darwin-gpsave.S \
+  $(srcdir)/config/rs6000/darwin-fpsave.S \
+  $(srcdir)/config/rs6000/darwin-vecsave.S
+
+PPC_ENDFILE_OBJS = \
+ darwin-gpsave.o \
+ darwin-fpsave.o \
+ darwin-vecsave.o
+
+darwin-gpsave.o: $(srcdir)/config/rs6000/darwin-gpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-fpsave.o: $(srcdir)/config/rs6000/darwin-fpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-vecsave.o: $(srcdir)/config/rs6000/darwin-vecsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# We build these into a library, so that they are only linked as needed and not
+# forced into every object.
+
+libef_ppc.a: $(PPC_ENDFILE_OBJS)
+	$(AR_CREATE_FOR_TARGET) $@ $(PPC_ENDFILE_OBJS)
+	$(RANLIB_FOR_TARGET) $@
+
+dw_ppc.o: $(srcdir)/config/rs6000/darwin-world.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
 
 LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
 	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-world.S \
-	  $(srcdir)/config/rs6000/ppc64-fp.c
-
-LIB2ADD_ST = \
-	  $(srcdir)/config/rs6000/darwin-vecsave.S
+	  $(srcdir)/config/rs6000/darwin-world.S
 
 # The .S files above are designed to run on all processors, even though
 # they use AltiVec instructions.
 # -Wa is used because -force_cpusubtype_ALL doesn't work with -dynamiclib.
-# -mmacosx-version-min=10.4 is used to provide compatibility for code from
-# earlier OSX versions.
-HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL -mmacosx-version-min=10.4
 
+HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL
+
+# Although the default for 10.4 is G3, we need the unwinder to be built
+# with vector support so that the "save/rest_world" outlined functions are
+# correctly invoked.
 unwind-dw2_s.o: HOST_LIBGCC2_CFLAGS += -maltivec
 unwind-dw2.o: HOST_LIBGCC2_CFLAGS += -maltivec
 
diff --git a/libgcc/config/rs6000/t-darwin64 b/libgcc/config/rs6000/t-darwin64
index 50f09d6de1a..999679fc3cb 100644
--- a/libgcc/config/rs6000/t-darwin64
+++ b/libgcc/config/rs6000/t-darwin64
@@ -1,7 +1 @@
 LIB2_SIDITI_CONV_FUNCS = yes
-
-LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
-	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S \
-	  $(srcdir)/config/rs6000/darwin-world.S
diff --git a/libgcc/config/t-darwin b/libgcc/config/t-darwin
index 8340ea2bfe4..3b5e3428958 100644
--- a/libgcc/config/t-darwin
+++ b/libgcc/config/t-darwin
@@ -1,21 +1,15 @@
 # Set this as a minimum (unless overriden by arch t-files) since it's a
 # reasonable lowest common denominator that works for all our archs.
-HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.5
+HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.4
 
 crt3.o: $(srcdir)/config/darwin-crt3.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -c $<
 
 crttms.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DSTART -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -DSTART -c $<
 
 crttme.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DEND -c $<
-
-# -pipe because there's an assembler bug, 4077127, which causes
-# it to not properly process the first # directive, causing temporary
-# file names to appear in stabs, causing the bootstrap to fail.  Using -pipe
-# works around this by not having any temporary file names.
-HOST_LIBGCC2_CFLAGS += -pipe
+	$(crt_compile) -mmacosx-version-min=10.4 -DEND -c $<
 
 # Use unwind-dw2-fde-darwin
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/config/unwind-dw2-fde-darwin.c \
@@ -23,4 +17,4 @@ LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/config/unwind-dw2-fde-darwin.c \
 
 # Patch to __Unwind_Find_Enclosing_Function for Darwin10.
 d10-uwfef.o: $(srcdir)/config/darwin10-unwind-find-enc-func.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -mmacosx-version-min=10.6 -c $<
+	$(crt_compile) -mmacosx-version-min=10.6 -c $<
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 48f9886896e..ce75fe80636 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,79 @@
+2020-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/93599
+	* io/async.c (destroy_adv_cond): Do not destroy lock.
+	(async_io): Make sure au->lock is locked for finishing of thread.
+	Do not lock/unlock around signalling emptysignal. Unlock au->lock
+	before return.
+	(init_adv_cond): Do not initialize lock.
+	(enqueue_transfer): Unlock after signal.
+	(enqueue_done_id): Likewise.
+	(enqueue_done): Likewise.
+	(enqueue_close): Likewise.
+	(enqueue_data_transfer): Likewise.
+	(async_wait_id): Do not lock/unlock around signalling au->work.
+	(async_wait): Unlock after signal.
+	* io/async.h (SIGNAL): Add comment about needed au->lock.
+	Remove locking/unlocking of advcond->lock.
+	(WAIT_SIGNAL_MUTEX): Add comment. Remove locking/unlocking of
+	advcond->lock.  Unlock mutex only at the end.  Loop on
+	__ghread_cond_wait returning zero.
+	(REVOKE_SIGNAL): Add comment. Remove locking/unlocking of
+	advcond->lock.
+	(struct adv_cond): Remove mutex from struct.
+
+2020-01-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+        Backport from mainline
+	PR libfortran/93234
+	* io/unit.c (set_internal_unit): Set round and sign flags
+	correctly.
+
+2019-11-26  Jerry DeLisle  <jvdelisle@gcc.ngu.org>
+
+        Backport from mainline
+        PR fortran/92100
+        io/transfer.c (data_transfer_init_worker): Use fbuf_reset
+        instead of fbuf_flush before the seek. Note that fbuf_reset
+        calls fbuf_flush and adjusts fbuf pointers.
+
+2019-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Harald Anlauf <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/92569
+	* io/transfer.c (transfer_array_inner):  If position is
+	at AFTER_ENDFILE in current unit, return from data loop.
+
+2019-11-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-11-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92470
+	* runtime/ISO_Fortran_binding.c (CFI_establish): Set lower_bound to 0
+	also for CFI_attribute_other.
+
+	2019-11-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92470
+	* runtime/ISO_Fortran_binding.c (CFI_address): Handle non-zero
+	lower_bound; update error message.
+	(CFI_allocate): Fix comment typo.
+	(CFI_establish): Fix identation, fix typos, don't check values of 'dv'
+	argument.
+
+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Partial backport from trunk
+	PR fortran/91414
+	* intrinsics/random.c (lcg_parkmiller): Replace with splitmix64.
+	(splitmix64): New function.
+	(getosrandom): Fix return value, simplify.
+	(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64
+	to fill rest of state.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -24,12 +100,12 @@
 2019-05-20  Janne Blomqvist  <jb@gcc.gnu.org>
 
 	Backport from trunk
-        PR libfortran/90038
-        * intrinsics/execute_command_line (sigchld_handler): New function.
-        (execute_command_line): Install handler for SIGCHLD.
-        * configure.ac: Check for presence of sigaction and waitpid.
-        * config.h.in: Regenerated.
-        * configure: Regenerated.
+	PR libfortran/90038
+	* intrinsics/execute_command_line (sigchld_handler): New function.
+	(execute_command_line): Install handler for SIGCHLD.
+	* configure.ac: Check for presence of sigaction and waitpid.
+	* config.h.in: Regenerated.
+	* configure: Regenerated.
 
 2019-05-20  Janne Blomqvist  <jb@gcc.gnu.org>
 
diff --git a/libgfortran/intrinsics/random.c b/libgfortran/intrinsics/random.c
index 7476439647c..5d81bcba74a 100644
--- a/libgfortran/intrinsics/random.c
+++ b/libgfortran/intrinsics/random.c
@@ -275,30 +275,19 @@ jump (xorshift1024star_state* rs)
 }
 
 
-/* Super-simple LCG generator used in getosrandom () if /dev/urandom
-   doesn't exist.  */
+/* Splitmix64 recommended by xorshift author for initializing.  After
+   getting one uint64_t value from the OS, this is used to fill in the
+   rest of the state.  */
 
-#define M 2147483647 /* 2^31 - 1 (A large prime number) */
-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */
-#define Q 127773 /* M / A (To avoid overflow on A * seed) */
-#define R 2836   /* M % A (To avoid overflow on A * seed) */
-
-__attribute__((unused)) static uint32_t
-lcg_parkmiller(uint32_t seed)
+static uint64_t
+splitmix64 (uint64_t x)
 {
-    uint32_t hi = seed / Q;
-    uint32_t lo = seed % Q;
-    int32_t test = A * lo - R * hi;
-    if (test <= 0)
-        test += M;
-    return test;
+  uint64_t z = (x += 0x9e3779b97f4a7c15);
+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
+  return z ^ (z >> 31);
 }
 
-#undef M
-#undef A
-#undef Q
-#undef R
-
 
 /* Get some random bytes from the operating system in order to seed
    the PRNG.  */
@@ -315,7 +304,7 @@ getosrandom (void *buf, size_t buflen)
 #else
 #ifdef HAVE_GETENTROPY
   if (getentropy (buf, buflen) == 0)
-    return 0;
+    return buflen;
 #endif
   int flags = O_RDONLY;
 #ifdef O_CLOEXEC
@@ -328,7 +317,7 @@ getosrandom (void *buf, size_t buflen)
       close (fd);
       return res;
     }
-  uint32_t seed = 1234567890;
+  uint64_t seed = 0x047f7684e9fc949dULL;
   time_t secs;
   long usecs;
   if (gf_gettime (&secs, &usecs) == 0)
@@ -340,13 +329,9 @@ getosrandom (void *buf, size_t buflen)
   pid_t pid = getpid();
   seed ^= pid;
 #endif
-  uint32_t* ub = buf;
-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)
-    {
-      ub[i] = seed;
-      seed = lcg_parkmiller (seed);
-    }
-  return buflen;
+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);
+  memcpy (buf, &seed, size);
+  return size;
 #endif /* __MINGW64_VERSION_MAJOR  */
 }
 
@@ -361,7 +346,13 @@ init_rand_state (xorshift1024star_state* rs, const bool locked)
     __gthread_mutex_lock (&random_lock);
   if (!master_init)
     {
-      getosrandom (master_state, sizeof (master_state));
+      uint64_t os_seed;
+      getosrandom (&os_seed, sizeof (os_seed));
+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)
+	{
+	  os_seed = splitmix64 (os_seed);
+	  master_state[i] = os_seed;
+	}
       njumps = 0;
       master_init = true;
     }
diff --git a/libgfortran/io/async.c b/libgfortran/io/async.c
index e3d1d01122e..28b84f6613a 100644
--- a/libgfortran/io/async.c
+++ b/libgfortran/io/async.c
@@ -80,7 +80,6 @@ update_pdt (st_parameter_dt **old, st_parameter_dt *new) {
 static void
 destroy_adv_cond (struct adv_cond *ac)
 {
-  T_ERROR (__gthread_mutex_destroy, &ac->lock);
   T_ERROR (__gthread_cond_destroy, &ac->signal);
 }
 
@@ -156,6 +155,7 @@ async_io (void *arg)
 
 		case AIO_CLOSE:
 		  NOTE ("Received AIO_CLOSE");
+		  LOCK (&au->lock);
 		  goto finish_thread;
 
 		default:
@@ -175,7 +175,6 @@ async_io (void *arg)
 	      else if (ctq->type == AIO_CLOSE)
 		{
 		  NOTE ("Received AIO_CLOSE during error condition");
-		  UNLOCK (&au->lock);
 		  goto finish_thread;
 		}
 	    }
@@ -189,9 +188,7 @@ async_io (void *arg)
       au->tail = NULL;
       au->head = NULL;
       au->empty = 1;
-      UNLOCK (&au->lock);
       SIGNAL (&au->emptysignal);
-      LOCK (&au->lock);
     }
  finish_thread:
   au->tail = NULL;
@@ -199,6 +196,7 @@ async_io (void *arg)
   au->empty = 1;
   SIGNAL (&au->emptysignal);
   free (ctq);
+  UNLOCK (&au->lock);
   return NULL;
 }
 
@@ -223,7 +221,6 @@ static void
 init_adv_cond (struct adv_cond *ac)
 {
   ac->pending = 0;
-  __GTHREAD_MUTEX_INIT_FUNCTION (&ac->lock);
   __GTHREAD_COND_INIT_FUNCTION (&ac->signal);
 }
 
@@ -279,8 +276,8 @@ enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)
   au->tail = tq;
   REVOKE_SIGNAL (&(au->emptysignal));
   au->empty = false;
-  UNLOCK (&au->lock);
   SIGNAL (&au->work);
+  UNLOCK (&au->lock);
 }
 
 /* Enqueue an st_write_done or st_read_done which contains an ID.  */
@@ -303,8 +300,8 @@ enqueue_done_id (async_unit *au, enum aio_do type)
   au->empty = false;
   ret = au->id.high++;
   NOTE ("Enqueue id: %d", ret);
-  UNLOCK (&au->lock);
   SIGNAL (&au->work);
+  UNLOCK (&au->lock);
   return ret;
 }
 
@@ -324,8 +321,8 @@ enqueue_done (async_unit *au, enum aio_do type)
   au->tail = tq;
   REVOKE_SIGNAL (&(au->emptysignal));
   au->empty = false;
-  UNLOCK (&au->lock);
   SIGNAL (&au->work);
+  UNLOCK (&au->lock);
 }
 
 /* Enqueue a CLOSE statement.  */
@@ -344,8 +341,8 @@ enqueue_close (async_unit *au)
   au->tail = tq;
   REVOKE_SIGNAL (&(au->emptysignal));
   au->empty = false;
-  UNLOCK (&au->lock);
   SIGNAL (&au->work);
+  UNLOCK (&au->lock);
 }
 
 /* The asynchronous unit keeps the currently active PDT around.
@@ -374,9 +371,9 @@ enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)
     au->tail->next = tq;
   au->tail = tq;
   REVOKE_SIGNAL (&(au->emptysignal));
-  au->empty = 0;
-  UNLOCK (&au->lock);
+  au->empty = false;
   SIGNAL (&au->work);
+  UNLOCK (&au->lock);
 }
 
 /* Collect the errors that may have happened asynchronously.  Return true if
@@ -430,9 +427,7 @@ async_wait_id (st_parameter_common *cmp, async_unit *au, int i)
   NOTE ("Waiting for id %d", i);
   if (au->id.waiting < i)
     au->id.waiting = i;
-  UNLOCK (&au->lock);
   SIGNAL (&(au->work));
-  LOCK (&au->lock);
   WAIT_SIGNAL_MUTEX (&(au->id.done),
 		     (au->id.low >= au->id.waiting || au->empty), &au->lock);
   LOCK (&au->lock);
@@ -454,8 +449,8 @@ async_wait (st_parameter_common *cmp, async_unit *au)
   if (cmp == NULL)
     cmp = au->error.cmp;
 
-  SIGNAL (&(au->work));
   LOCK (&(au->lock));
+  SIGNAL (&(au->work));
 
   if (au->empty)
     {
diff --git a/libgfortran/io/async.h b/libgfortran/io/async.h
index 3ac51772502..0fe407945c3 100644
--- a/libgfortran/io/async.h
+++ b/libgfortran/io/async.h
@@ -229,44 +229,44 @@
 
 #if ASYNC_IO
 
+/* au->lock has to be held when calling this macro.  */
+
 #define SIGNAL(advcond) do{						\
-    INTERN_LOCK (&(advcond)->lock);					\
     (advcond)->pending = 1;						\
     DEBUG_PRINTF ("%s%-75s %20s():%-5d %18p\n", aio_prefix, DEBUG_ORANGE "SIGNAL: " DEBUG_NORM \
 		 #advcond, __FUNCTION__, __LINE__, (void *) advcond);	\
-    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);		\
-    INTERN_UNLOCK (&(advcond)->lock);					\
+    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);			\
   } while (0)
 
+/* Has to be entered with mutex locked.  */
+
 #define WAIT_SIGNAL_MUTEX(advcond, condition, mutex) do{		\
     __label__ finish;		       					\
-    INTERN_LOCK (&((advcond)->lock));					\
     DEBUG_PRINTF ("%s%-75s %20s():%-5d %18p\n", aio_prefix, DEBUG_BLUE "WAITING: " DEBUG_NORM \
 		 #advcond, __FUNCTION__, __LINE__, (void *) advcond);	\
-    if ((advcond)->pending || (condition)){				\
-      UNLOCK (mutex);							\
+    if ((advcond)->pending || (condition))				\
       goto finish;							\
-    }									\
-    UNLOCK (mutex);							\
-     while (!__gthread_cond_wait(&(advcond)->signal, &(advcond)->lock)) {	\
-       { int cond;							\
-	 LOCK (mutex); cond = condition; UNLOCK (mutex);	\
-	   if (cond){							\
-	     DEBUG_PRINTF ("%s%-75s %20s():%-5d %18p\n", aio_prefix, DEBUG_ORANGE "REC: " DEBUG_NORM \
-		  #advcond,  __FUNCTION__, __LINE__, (void *)advcond);	\
-	   break;				      			\
-        }							\
+    while (1)								\
+      {									\
+	int err_ret = __gthread_cond_wait(&(advcond)->signal, mutex);	\
+	if (err_ret) internal_error (NULL, "WAIT_SIGNAL_MUTEX failed");	\
+	if (condition)							\
+	  {								\
+	    DEBUG_PRINTF ("%s%-75s %20s():%-5d %18p\n", aio_prefix, DEBUG_ORANGE \
+			  "REC: " DEBUG_NORM				\
+			  #advcond,  __FUNCTION__, __LINE__, (void *)advcond); \
+	    break;				      			\
+	  }								\
       }									\
-    }									\
   finish:								\
-		 (advcond)->pending = 0;				\
-		 INTERN_UNLOCK (&((advcond)->lock));			\
-		 } while (0)
+    (advcond)->pending = 0;						\
+    UNLOCK (mutex);							\
+  } while (0)
+
+/* au->lock has to be held when calling this macro.  */
 
 #define REVOKE_SIGNAL(advcond) do{		\
-    INTERN_LOCK (&(advcond)->lock);		\
     (advcond)->pending = 0;			\
-    INTERN_UNLOCK (&(advcond)->lock);		\
   } while (0)
 
 #else
@@ -330,7 +330,6 @@ struct adv_cond
 {
 #if ASYNC_IO
   int pending;
-  __gthread_mutex_t lock;
   __gthread_cond_t signal;
 #endif
 };
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index c43360f6332..28e403fedf2 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -2529,26 +2529,62 @@ transfer_array_inner (st_parameter_dt *dtp, gfc_array_char *desc, int kind,
 
   data = GFC_DESCRIPTOR_DATA (desc);
 
-  while (data)
+  /* When reading, we need to check endfile conditions so we do not miss
+     an END=label.  Make this separate so we do not have an extra test
+     in a tight loop when it is not needed.  */
+
+  if (dtp->u.p.current_unit && dtp->u.p.mode == READING)
     {
-      dtp->u.p.transfer (dtp, iotype, data, kind, size, tsize);
-      data += stride0 * tsize;
-      count[0] += tsize;
-      n = 0;
-      while (count[n] == extent[n])
+      while (data)
 	{
-	  count[n] = 0;
-	  data -= stride[n] * extent[n];
-	  n++;
-	  if (n == rank)
+	  if (unlikely (dtp->u.p.current_unit->endfile == AFTER_ENDFILE))
+	    return;
+
+	  dtp->u.p.transfer (dtp, iotype, data, kind, size, tsize);
+	  data += stride0 * tsize;
+	  count[0] += tsize;
+	  n = 0;
+	  while (count[n] == extent[n])
 	    {
-	      data = NULL;
-	      break;
+	      count[n] = 0;
+	      data -= stride[n] * extent[n];
+	      n++;
+	      if (n == rank)
+		{
+		  data = NULL;
+		  break;
+		}
+	      else
+		{
+		  count[n]++;
+		  data += stride[n];
+		}
 	    }
-	  else
+	}
+    }
+  else
+    {
+      while (data)
+	{
+	  dtp->u.p.transfer (dtp, iotype, data, kind, size, tsize);
+	  data += stride0 * tsize;
+	  count[0] += tsize;
+	  n = 0;
+	  while (count[n] == extent[n])
 	    {
-	      count[n]++;
-	      data += stride[n];
+	      count[n] = 0;
+	      data -= stride[n] * extent[n];
+	      n++;
+	      if (n == rank)
+		{
+		  data = NULL;
+		  break;
+		}
+	      else
+		{
+		  count[n]++;
+		  data += stride[n];
+		}
 	    }
 	}
     }
@@ -3258,8 +3294,9 @@ data_transfer_init_worker (st_parameter_dt *dtp, int read_flag)
 
           if (dtp->pos != dtp->u.p.current_unit->strm_pos)
             {
-              fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
-              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1, SEEK_SET) < 0)
+              fbuf_reset (dtp->u.p.current_unit);
+              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1,
+		  SEEK_SET) < 0)
                 {
                   generate_error (&dtp->common, LIBERROR_OS, NULL);
                   return;
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index c0dbfad2c78..87e01fe0442 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -514,12 +514,12 @@ set_internal_unit (st_parameter_dt *dtp, gfc_unit *iunit, int kind)
   iunit->flags.form = FORM_FORMATTED;
   iunit->flags.pad = PAD_YES;
   iunit->flags.status = STATUS_UNSPECIFIED;
-  iunit->flags.sign = SIGN_UNSPECIFIED;
+  iunit->flags.sign = SIGN_PROCDEFINED;
   iunit->flags.decimal = DECIMAL_POINT;
   iunit->flags.delim = DELIM_UNSPECIFIED;
   iunit->flags.encoding = ENCODING_DEFAULT;
   iunit->flags.async = ASYNC_NO;
-  iunit->flags.round = ROUND_UNSPECIFIED;
+  iunit->flags.round = ROUND_PROCDEFINED;
 
   /* Initialize the data transfer parameters.  */
 
@@ -627,12 +627,12 @@ init_units (void)
       u->flags.blank = BLANK_NULL;
       u->flags.pad = PAD_YES;
       u->flags.position = POSITION_ASIS;
-      u->flags.sign = SIGN_UNSPECIFIED;
+      u->flags.sign = SIGN_PROCDEFINED;
       u->flags.decimal = DECIMAL_POINT;
       u->flags.delim = DELIM_UNSPECIFIED;
       u->flags.encoding = ENCODING_DEFAULT;
       u->flags.async = ASYNC_NO;
-      u->flags.round = ROUND_UNSPECIFIED;
+      u->flags.round = ROUND_PROCDEFINED;
       u->flags.share = SHARE_UNSPECIFIED;
       u->flags.cc = CC_LIST;
 
@@ -658,12 +658,12 @@ init_units (void)
       u->flags.status = STATUS_OLD;
       u->flags.blank = BLANK_NULL;
       u->flags.position = POSITION_ASIS;
-      u->flags.sign = SIGN_UNSPECIFIED;
+      u->flags.sign = SIGN_PROCDEFINED;
       u->flags.decimal = DECIMAL_POINT;
       u->flags.delim = DELIM_UNSPECIFIED;
       u->flags.encoding = ENCODING_DEFAULT;
       u->flags.async = ASYNC_NO;
-      u->flags.round = ROUND_UNSPECIFIED;
+      u->flags.round = ROUND_PROCDEFINED;
       u->flags.share = SHARE_UNSPECIFIED;
       u->flags.cc = CC_LIST;
 
@@ -689,11 +689,11 @@ init_units (void)
       u->flags.status = STATUS_OLD;
       u->flags.blank = BLANK_NULL;
       u->flags.position = POSITION_ASIS;
-      u->flags.sign = SIGN_UNSPECIFIED;
+      u->flags.sign = SIGN_PROCDEFINED;
       u->flags.decimal = DECIMAL_POINT;
       u->flags.encoding = ENCODING_DEFAULT;
       u->flags.async = ASYNC_NO;
-      u->flags.round = ROUND_UNSPECIFIED;
+      u->flags.round = ROUND_PROCDEFINED;
       u->flags.share = SHARE_UNSPECIFIED;
       u->flags.cc = CC_LIST;
 
diff --git a/libgfortran/runtime/ISO_Fortran_binding.c b/libgfortran/runtime/ISO_Fortran_binding.c
index 695ef57ac32..0aec06b5eed 100644
--- a/libgfortran/runtime/ISO_Fortran_binding.c
+++ b/libgfortran/runtime/ISO_Fortran_binding.c
@@ -119,24 +119,25 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)
     d->type = (CFI_type_t)(d->type
 		+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));
 
-  /* Full pointer or allocatable arrays retain their lower_bounds.  */
-  for (n = 0; n < GFC_DESCRIPTOR_RANK (s); n++)
-    {
-      if (d->attribute != CFI_attribute_other)
-	d->dim[n].lower_bound = (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n);
-      else
-	d->dim[n].lower_bound = 0;
-
-      /* Assumed size arrays have gfc ubound == 0 and CFI extent = -1.  */
-      if ((n == GFC_DESCRIPTOR_RANK (s) - 1)
-	  && GFC_DESCRIPTOR_LBOUND(s, n) == 1
-	  && GFC_DESCRIPTOR_UBOUND(s, n) == 0)
-	d->dim[n].extent = -1;
-      else
-	d->dim[n].extent = (CFI_index_t)GFC_DESCRIPTOR_UBOUND(s, n)
-			    - (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n) + 1;
-      d->dim[n].sm = (CFI_index_t)(GFC_DESCRIPTOR_STRIDE(s, n) * s->span);
-    }
+  if (d->base_addr)
+    /* Full pointer or allocatable arrays retain their lower_bounds.  */
+    for (n = 0; n < GFC_DESCRIPTOR_RANK (s); n++)
+      {
+	if (d->attribute != CFI_attribute_other)
+	  d->dim[n].lower_bound = (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n);
+	else
+	  d->dim[n].lower_bound = 0;
+
+	/* Assumed size arrays have gfc ubound == 0 and CFI extent = -1.  */
+	if (n == GFC_DESCRIPTOR_RANK (s) - 1
+	    && GFC_DESCRIPTOR_LBOUND(s, n) == 1
+	    && GFC_DESCRIPTOR_UBOUND(s, n) == 0)
+	  d->dim[n].extent = -1;
+	else
+	  d->dim[n].extent = (CFI_index_t)GFC_DESCRIPTOR_UBOUND(s, n)
+			     - (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n) + 1;
+	d->dim[n].sm = (CFI_index_t)(GFC_DESCRIPTOR_STRIDE(s, n) * s->span);
+      }
 
   if (*d_ptr == NULL)
     *d_ptr = d;
@@ -176,19 +177,21 @@ void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])
 	 specified by subscripts. */
       for (i = 0; i < dv->rank; i++)
 	{
+	  CFI_index_t idx = subscripts[i] - dv->dim[i].lower_bound;
 	  if (unlikely (compile_options.bounds_check)
-	      && ((dv->dim[i].extent != -1
-		   && subscripts[i] >= dv->dim[i].extent)
-		  || subscripts[i] < 0))
+	      && ((dv->dim[i].extent != -1 && idx >= dv->dim[i].extent)
+		  || idx < 0))
 	    {
-	      fprintf (stderr, "CFI_address: subscripts[%d], is out of "
-		       "bounds. dv->dim[%d].extent = %d subscripts[%d] "
-		       "= %d.\n", i, i, (int)dv->dim[i].extent, i,
-		       (int)subscripts[i]);
+	      fprintf (stderr, "CFI_address: subscripts[%d] is out of "
+		       "bounds. For dimension = %d, subscripts = %d, "
+		       "lower_bound = %d, upper bound = %d, extend = %d\n",
+		       i, i, (int)subscripts[i], (int)dv->dim[i].lower_bound,
+		       (int)(dv->dim[i].extent - dv->dim[i].lower_bound),
+		       (int)dv->dim[i].extent);
               return NULL;
             }
 
-	  base_addr = base_addr + (CFI_index_t)(subscripts[i] * dv->dim[i].sm);
+	  base_addr = base_addr + (CFI_index_t)(idx * dv->dim[i].sm);
 	}
     }
 
@@ -227,7 +230,7 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],
     }
 
   /* If the type is a character, the descriptor's element length is replaced
-   * by the elem_len argument. */
+     by the elem_len argument. */
   if (dv->type == CFI_type_char || dv->type == CFI_type_ucs4_char ||
       dv->type == CFI_type_signed_char)
     dv->elem_len = elem_len;
@@ -236,7 +239,7 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],
   size_t arr_len = 1;
 
   /* If rank is greater than 0, lower_bounds and upper_bounds are used. They're
-   * ignored otherwhise. */
+     ignored otherwise. */
   if (dv->rank > 0)
     {
       if (unlikely (compile_options.bounds_check)
@@ -324,20 +327,10 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
 	{
 	  fprintf (stderr, "CFI_establish: Rank must be between 0 and %d, "
 		   "0 < rank (0 !< %d).\n", CFI_MAX_RANK, (int)rank);
-      return CFI_INVALID_RANK;
-    }
-
-      /* C Descriptor must not be an allocated allocatable. */
-      if (dv->attribute == CFI_attribute_allocatable && dv->base_addr != NULL)
-	{
-	  fprintf (stderr, "CFI_establish: If the C Descriptor represents an "
-		   "allocatable variable (dv->attribute = %d), its base "
-		   "address must be NULL (dv->base_addr = NULL).\n",
-		   CFI_attribute_allocatable);
-	  return CFI_INVALID_DESCRIPTOR;
+	  return CFI_INVALID_RANK;
 	}
 
-       /* If base address is not NULL, the established C Descriptor is for a
+      /* If base address is not NULL, the established C Descriptor is for a
 	  nonallocatable entity. */
       if (attribute == CFI_attribute_allocatable && base_addr != NULL)
 	{
@@ -381,26 +374,20 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
   dv->type = type;
 
   /* Extents must not be NULL if rank is greater than zero and base_addr is not
-   * NULL */
+     NULL */
   if (rank > 0 && base_addr != NULL)
     {
       if (unlikely (compile_options.bounds_check) && extents == NULL)
         {
 	  fprintf (stderr, "CFI_establish: Extents must not be NULL "
-		   "(extents != NULL) if rank (= %d) > 0 nd base address"
+		   "(extents != NULL) if rank (= %d) > 0 and base address "
 		   "is not NULL (base_addr != NULL).\n", (int)rank);
 	  return CFI_INVALID_EXTENT;
 	}
 
       for (int i = 0; i < rank; i++)
 	{
-	  /* If the C Descriptor is for a pointer then the lower bounds of every
-	   * dimension are set to zero. */
-	  if (attribute == CFI_attribute_pointer)
-	    dv->dim[i].lower_bound = 0;
-	  else
-	    dv->dim[i].lower_bound = 1;
-
+	  dv->dim[i].lower_bound = 0;
 	  dv->dim[i].extent = extents[i];
 	  if (i == 0)
 	    dv->dim[i].sm = dv->elem_len;
diff --git a/libgo/go/go/internal/gccgoimporter/importer_test.go b/libgo/go/go/internal/gccgoimporter/importer_test.go
index 58fa8c8cf5c..eb070c137ff 100644
--- a/libgo/go/go/internal/gccgoimporter/importer_test.go
+++ b/libgo/go/go/internal/gccgoimporter/importer_test.go
@@ -91,6 +91,7 @@ var importerTests = [...]importerTest{
 	{pkgpath: "v1reflect", name: "Type", want: "type Type interface{Align() int; AssignableTo(u Type) bool; Bits() int; ChanDir() ChanDir; Elem() Type; Field(i int) StructField; FieldAlign() int; FieldByIndex(index []int) StructField; FieldByName(name string) (StructField, bool); FieldByNameFunc(match func(string) bool) (StructField, bool); Implements(u Type) bool; In(i int) Type; IsVariadic() bool; Key() Type; Kind() Kind; Len() int; Method(int) Method; MethodByName(string) (Method, bool); Name() string; NumField() int; NumIn() int; NumMethod() int; NumOut() int; Out(i int) Type; PkgPath() string; Size() uintptr; String() string; common() *commonType; rawString() string; runtimeType() *runtimeType; uncommon() *uncommonType}"},
 	{pkgpath: "nointerface", name: "I", want: "type I int"},
 	{pkgpath: "issue29198", name: "FooServer", want: "type FooServer struct{FooServer *FooServer; user string; ctx context.Context}"},
+	{pkgpath: "issue34182", name: "T1", want: "type T1 struct{f *T2}"},
 }
 
 func TestGoxImporter(t *testing.T) {
diff --git a/libgo/go/go/internal/gccgoimporter/parser.go b/libgo/go/go/internal/gccgoimporter/parser.go
index 42f43a19fb7..ab731cbbfc4 100644
--- a/libgo/go/go/internal/gccgoimporter/parser.go
+++ b/libgo/go/go/internal/gccgoimporter/parser.go
@@ -248,7 +248,7 @@ func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string) {
 		case *types.Named:
 			name = typ.Obj().Name()
 		default:
-			p.error("anonymous field expected")
+			p.error("embedded field expected")
 		}
 	}
 	field = types.NewField(token.NoPos, pkg, name, typ, anon)
@@ -451,8 +451,12 @@ func (p *parser) reserve(n int) {
 	}
 }
 
-// update sets the type map entries for the given type numbers nlist to t.
-func (p *parser) update(t types.Type, nlist []int) {
+// update sets the type map entries for the entries in nlist to t.
+// An entry in nlist can be a type number in p.typeList,
+// used to resolve named types, or it can be a *types.Pointer,
+// used to resolve pointers to named types in case they are referenced
+// by embedded fields.
+func (p *parser) update(t types.Type, nlist []interface{}) {
 	if len(nlist) != 0 {
 		if t == reserved {
 			p.errorf("internal error: update(%v) invoked on reserved", nlist)
@@ -462,20 +466,34 @@ func (p *parser) update(t types.Type, nlist []int) {
 		}
 	}
 	for _, n := range nlist {
-		if p.typeList[n] == t {
-			continue
-		}
-		if p.typeList[n] != reserved {
-			p.errorf("internal error: update(%v): %d not reserved", nlist, n)
+		switch n := n.(type) {
+		case int:
+			if p.typeList[n] == t {
+				continue
+			}
+			if p.typeList[n] != reserved {
+				p.errorf("internal error: update(%v): %d not reserved", nlist, n)
+			}
+			p.typeList[n] = t
+		case *types.Pointer:
+			if *n != (types.Pointer{}) {
+				elem := n.Elem()
+				if elem == t {
+					continue
+				}
+				p.errorf("internal error: update: pointer already set to %v, expected %v", elem, t)
+			}
+			*n = *types.NewPointer(t)
+		default:
+			p.errorf("internal error: %T on nlist", n)
 		}
-		p.typeList[n] = t
 	}
 }
 
 // NamedType = TypeName [ "=" ] Type { Method } .
 // TypeName  = ExportedName .
 // Method    = "func" "(" Param ")" Name ParamList ResultList [InlineBody] ";" .
-func (p *parser) parseNamedType(nlist []int) types.Type {
+func (p *parser) parseNamedType(nlist []interface{}) types.Type {
 	pkg, name := p.parseExportedName()
 	scope := pkg.Scope()
 	obj := scope.Lookup(name)
@@ -582,7 +600,7 @@ func (p *parser) parseInt() int {
 }
 
 // ArrayOrSliceType = "[" [ int ] "]" Type .
-func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expect('[')
 	if p.tok == ']' {
 		p.next()
@@ -605,7 +623,7 @@ func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []int) types.Ty
 }
 
 // MapType = "map" "[" Type "]" Type .
-func (p *parser) parseMapType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseMapType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expectKeyword("map")
 
 	t := new(types.Map)
@@ -621,7 +639,7 @@ func (p *parser) parseMapType(pkg *types.Package, nlist []int) types.Type {
 }
 
 // ChanType = "chan" ["<-" | "-<"] Type .
-func (p *parser) parseChanType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseChanType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expectKeyword("chan")
 
 	t := new(types.Chan)
@@ -648,7 +666,7 @@ func (p *parser) parseChanType(pkg *types.Package, nlist []int) types.Type {
 }
 
 // StructType = "struct" "{" { Field } "}" .
-func (p *parser) parseStructType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseStructType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expectKeyword("struct")
 
 	t := new(types.Struct)
@@ -714,7 +732,7 @@ func (p *parser) parseResultList(pkg *types.Package) *types.Tuple {
 }
 
 // FunctionType = ParamList ResultList .
-func (p *parser) parseFunctionType(pkg *types.Package, nlist []int) *types.Signature {
+func (p *parser) parseFunctionType(pkg *types.Package, nlist []interface{}) *types.Signature {
 	t := new(types.Signature)
 	p.update(t, nlist)
 
@@ -740,7 +758,7 @@ func (p *parser) parseFunc(pkg *types.Package) *types.Func {
 }
 
 // InterfaceType = "interface" "{" { ("?" Type | Func) ";" } "}" .
-func (p *parser) parseInterfaceType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseInterfaceType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expectKeyword("interface")
 
 	t := new(types.Interface)
@@ -767,7 +785,7 @@ func (p *parser) parseInterfaceType(pkg *types.Package, nlist []int) types.Type
 }
 
 // PointerType = "*" ("any" | Type) .
-func (p *parser) parsePointerType(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parsePointerType(pkg *types.Package, nlist []interface{}) types.Type {
 	p.expect('*')
 	if p.tok == scanner.Ident {
 		p.expectKeyword("any")
@@ -779,13 +797,13 @@ func (p *parser) parsePointerType(pkg *types.Package, nlist []int) types.Type {
 	t := new(types.Pointer)
 	p.update(t, nlist)
 
-	*t = *types.NewPointer(p.parseType(pkg))
+	*t = *types.NewPointer(p.parseType(pkg, t))
 
 	return t
 }
 
 // TypeSpec = NamedType | MapType | ChanType | StructType | InterfaceType | PointerType | ArrayOrSliceType | FunctionType .
-func (p *parser) parseTypeSpec(pkg *types.Package, nlist []int) types.Type {
+func (p *parser) parseTypeSpec(pkg *types.Package, nlist []interface{}) types.Type {
 	switch p.tok {
 	case scanner.String:
 		return p.parseNamedType(nlist)
@@ -874,13 +892,13 @@ func lookupBuiltinType(typ int) types.Type {
 //
 // parseType updates the type map to t for all type numbers n.
 //
-func (p *parser) parseType(pkg *types.Package, n ...int) types.Type {
+func (p *parser) parseType(pkg *types.Package, n ...interface{}) types.Type {
 	p.expect('<')
 	return p.parseTypeAfterAngle(pkg, n...)
 }
 
 // (*parser).Type after reading the "<".
-func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...int) (t types.Type) {
+func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...interface{}) (t types.Type) {
 	p.expectKeyword("type")
 
 	switch p.tok {
@@ -995,12 +1013,12 @@ func (p *parser) parseTypes(pkg *types.Package) {
 	}
 
 	for i := 1; i < int(exportedp1); i++ {
-		p.parseSavedType(pkg, i, []int{})
+		p.parseSavedType(pkg, i, nil)
 	}
 }
 
 // parseSavedType parses one saved type definition.
-func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []int) {
+func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []interface{}) {
 	defer func(s *scanner.Scanner, tok rune, lit string) {
 		p.scanner = s
 		p.tok = tok
diff --git a/libgo/go/go/internal/gccgoimporter/testdata/issue34182.go b/libgo/go/go/internal/gccgoimporter/testdata/issue34182.go
new file mode 100644
index 00000000000..2a5c333a057
--- /dev/null
+++ b/libgo/go/go/internal/gccgoimporter/testdata/issue34182.go
@@ -0,0 +1,17 @@
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package issue34182
+
+type T1 struct {
+	f *T2
+}
+
+type T2 struct {
+	f T3
+}
+
+type T3 struct {
+	*T2
+}
diff --git a/libgo/go/go/internal/gccgoimporter/testdata/issue34182.gox b/libgo/go/go/internal/gccgoimporter/testdata/issue34182.gox
new file mode 100644
index 00000000000..671a7d62d6f
--- /dev/null
+++ b/libgo/go/go/internal/gccgoimporter/testdata/issue34182.gox
@@ -0,0 +1,13 @@
+v3;
+package issue34182
+pkgpath issue34182
+init issue34182 ~go.issue34182
+types 8 4 21 21 21 17 30 45 45
+type 1 "T1" <type 6>
+type 2 "T2" <type 7>
+type 3 "T3" <type 5>
+type 4 *<type 2>
+type 5 struct { ? <type 4>; }
+type 6 struct { .go.issue34182.f <type 4>; }
+type 7 struct { .go.issue34182.f <type 3>; }
+checksum FF02C49BAF44B06C087ED4E573F7CC880C79C208
diff --git a/libgo/mksysinfo.sh b/libgo/mksysinfo.sh
index c9dd8d494a9..f086c507e07 100755
--- a/libgo/mksysinfo.sh
+++ b/libgo/mksysinfo.sh
@@ -1127,7 +1127,7 @@ grep '^const _FALLOC_' gen-sysinfo.go |
 # Prefer largefile variant if available.
 # CentOS 5 does not have f_flags, so pull from f_spare.
 statfs=`grep '^type _statfs64 ' gen-sysinfo.go || true`
-if test "$statfs" == ""; then
+if test "$statfs" = ""; then
   statfs=`grep '^type _statfs ' gen-sysinfo.go || true`
 fi
 if ! echo "$statfs" | grep f_flags; then
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index 958572a54c0..b90fddf3ee2 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,61 @@
+2020-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/93515
+	* testsuite/libgomp.c-c++-common/pr93515.c: New test.
+
+2020-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-01-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/93219
+	* libgomp.h (gomp_print_string): Change return type from void to int.
+	* affinity-fmt.c (gomp_print_string): Likewise.  Return true if
+	not all characters have been written.
+
+	2019-12-31  Ayush Mittal  <ayush.m@samsung.com>
+
+	PR libgomp/93065
+	* oacc-init.c (goacc_runtime_deinitialize): New function.
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92899
+	* testsuite/libgomp.fortran/atomic1.f90: New test.
+
+	2019-11-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60228
+	* testsuite/libgomp.c++/udr-20.C: New test.
+	* testsuite/libgomp.c++/udr-21.C: New test.
+
+2019-12-11  Thomas Schwinge  <thomas@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+
+	* target.c (gomp_load_image_to_device, omp_target_associate_ptr):
+	Initialize 'dynamic_refcount' whenever we initialize 'refcount'.
+
+2019-12-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from mainline
+	2019-12-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	* omp_lib.h.in: Fix spelling of function declaration
+	omp_get_cancell(l)ation.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91422
+	* testsuite/libgomp.oacc-fortran/routine-7.f90: Correct array
+	dimension.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libgomp/affinity-fmt.c b/libgomp/affinity-fmt.c
index d9c6e181233..61417c9e5ae 100644
--- a/libgomp/affinity-fmt.c
+++ b/libgomp/affinity-fmt.c
@@ -37,10 +37,10 @@
 #include <sys/utsname.h>
 #endif
 
-void
+bool
 gomp_print_string (const char *str, size_t len)
 {
-  fwrite (str, 1, len, stderr);
+  return fwrite (str, 1, len, stderr) != len;
 }
 
 void
diff --git a/libgomp/libgomp.h b/libgomp/libgomp.h
index afea659445d..c98c1452bd4 100644
--- a/libgomp/libgomp.h
+++ b/libgomp/libgomp.h
@@ -751,7 +751,7 @@ extern void gomp_display_affinity_place (char *, size_t, size_t *, int);
 
 /* affinity-fmt.c */
 
-extern void gomp_print_string (const char *str, size_t len);
+extern bool gomp_print_string (const char *str, size_t len);
 extern void gomp_set_affinity_format (const char *, size_t);
 extern void gomp_display_string (char *, size_t, size_t *, const char *,
 				 size_t);
diff --git a/libgomp/oacc-init.c b/libgomp/oacc-init.c
index f30cf2f81d8..033fac463c6 100644
--- a/libgomp/oacc-init.c
+++ b/libgomp/oacc-init.c
@@ -657,6 +657,15 @@ goacc_runtime_initialize (void)
   goacc_host_init ();
 }
 
+static void __attribute__((destructor))
+goacc_runtime_deinitialize (void)
+{
+#if !(defined HAVE_TLS || defined USE_EMUTLS)
+  pthread_key_delete (goacc_tls_key);
+#endif
+  pthread_key_delete (goacc_cleanup_key);
+}
+
 /* Compiler helper functions */
 
 attribute_hidden void
diff --git a/libgomp/omp_lib.h.in b/libgomp/omp_lib.h.in
index a0fc04cc724..2c33ce8ea76 100644
--- a/libgomp/omp_lib.h.in
+++ b/libgomp/omp_lib.h.in
@@ -102,8 +102,8 @@
       external omp_in_final
       logical(4) omp_in_final
 
-      external omp_get_cancelllation
-      logical(4) omp_get_cancelllation
+      external omp_get_cancellation
+      logical(4) omp_get_cancellation
 
       external omp_get_proc_bind
       integer(omp_proc_bind_kind) omp_get_proc_bind
diff --git a/libgomp/target.c b/libgomp/target.c
index 31148003d0a..97fc1ee2ddc 100644
--- a/libgomp/target.c
+++ b/libgomp/target.c
@@ -1214,6 +1214,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,
       k->tgt = tgt;
       k->tgt_offset = target_table[i].start;
       k->refcount = REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       k->link_key = NULL;
       array->left = NULL;
       array->right = NULL;
@@ -1246,6 +1247,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,
       k->tgt = tgt;
       k->tgt_offset = target_var->start;
       k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       k->link_key = NULL;
       array->left = NULL;
       array->right = NULL;
@@ -2501,6 +2503,7 @@ omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,
       k->tgt = tgt;
       k->tgt_offset = (uintptr_t) device_ptr + device_offset;
       k->refcount = REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       array->left = NULL;
       array->right = NULL;
       splay_tree_insert (&devicep->mem_map, array);
diff --git a/libgomp/testsuite/libgomp.c++/udr-20.C b/libgomp/testsuite/libgomp.c++/udr-20.C
new file mode 100644
index 00000000000..83388758edd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/udr-20.C
@@ -0,0 +1,54 @@
+// PR c++/60228
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct A
+{
+  typedef int T;
+  #pragma omp declare reduction (x : T : omp_out += omp_in + [](){ return 0; }()) initializer (omp_priv = [](){ return 0; }())
+  static void foo ();
+};
+
+template <typename T>
+struct B
+{
+  #pragma omp declare reduction (x : T : omp_out += omp_in + [](){ return T (0); }()) initializer (omp_priv = [](){ return T (0); }())
+  static void foo ();
+};
+
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+  #pragma omp parallel for reduction (x : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+template <typename T>
+void
+B<T>::foo ()
+{
+  T r = 0, s = 0;
+  #pragma omp parallel for reduction (x : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+int
+main ()
+{
+  A::foo ();
+  B<long>::foo ();
+}
diff --git a/libgomp/testsuite/libgomp.c++/udr-21.C b/libgomp/testsuite/libgomp.c++/udr-21.C
new file mode 100644
index 00000000000..9ec655718fd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/udr-21.C
@@ -0,0 +1,54 @@
+// PR c++/60228
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct A
+{
+  typedef int T;
+  #pragma omp declare reduction (y : T : [&omp_out, &omp_in]() { omp_out += omp_in; return 0; }()) initializer (omp_priv = [omp_orig]() { return omp_orig; }())
+  static void foo ();
+};
+
+template <typename T>
+struct B
+{
+  #pragma omp declare reduction (y : T : [&omp_out, &omp_in]() { omp_out += omp_in; return 0; }()) initializer (omp_priv = [omp_orig]() { return omp_orig; }())
+  static void foo ();
+};
+
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+  #pragma omp parallel for reduction (y : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+template <typename T>
+void
+B<T>::foo ()
+{
+  T r = 0, s = 0;
+  #pragma omp parallel for reduction (y : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+int
+main ()
+{
+  A::foo ();
+  B<short>::foo ();
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/pr93515.c b/libgomp/testsuite/libgomp.c-c++-common/pr93515.c
new file mode 100644
index 00000000000..8a69088ccec
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/pr93515.c
@@ -0,0 +1,36 @@
+/* PR libgomp/93515 */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int
+main ()
+{
+  int i;
+  int a = 42;
+#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)
+  for (i = 0; i < 64; ++i)
+    if (omp_get_team_num () == 0)
+      if (omp_get_thread_num () == 0)
+	a = 142;
+  if (a != 142)
+    __builtin_abort ();
+  a = 42;
+#pragma omp target parallel for defaultmap(tofrom: scalar)
+  for (i = 0; i < 64; ++i)
+    if (omp_get_thread_num () == 0)
+      a = 143;
+  if (a != 143)
+    __builtin_abort ();
+  a = 42;
+#pragma omp target firstprivate(a)
+  {
+    #pragma omp parallel for
+    for (i = 0; i < 64; ++i)
+      if (omp_get_thread_num () == 0)
+	a = 144;
+    if (a != 144)
+      abort ();
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.fortran/atomic1.f90 b/libgomp/testsuite/libgomp.fortran/atomic1.f90
new file mode 100644
index 00000000000..e0c13536f94
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/atomic1.f90
@@ -0,0 +1,46 @@
+! PR fortran/92899
+
+program pr92899
+  real :: x = 1.0
+  double precision :: y
+  integer(kind=4) :: z = 4
+  integer(kind=8) :: w
+  !$omp atomic capture
+  y = x
+  x = 2.0
+  !$omp end atomic
+  if (y /= 1.0 .or. x /= 2.0) stop 1
+  !$omp atomic capture
+  x = y
+  y = 3.0
+  !$omp end atomic
+  if (x /= 1.0 .or. y /= 3.0) stop 2
+  !$omp atomic capture
+  w = z
+  z = 5
+  !$omp end atomic
+  if (w /= 4 .or. z /= 5) stop 3
+  !$omp atomic capture
+  z = w
+  w = 6
+  !$omp end atomic
+  if (z /= 4 .or. w /= 6) stop 4
+  !$omp atomic write
+  x = y
+  !$omp end atomic
+  if (x /= 3.0 .or. y /= 3.0) stop 5
+  x = 7.0
+  !$omp atomic write
+  y = x
+  !$omp end atomic
+  if (x /= 7.0 .or. y /= 7.0) stop 6
+  !$omp atomic write
+  z = w
+  !$omp end atomic
+  if (z /= 6 .or. w /= 6) stop 7
+  z = 8
+  !$omp atomic write
+  w = z
+  !$omp end atomic
+  if (z /= 8 .or. w /= 8) stop 8
+end
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90 b/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
index f58a95fe670..1009f4a81e5 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
@@ -109,7 +109,7 @@ end subroutine gang
 
 subroutine seq (a)
   !$acc routine seq
-  integer, intent (inout) :: a(M)
+  integer, intent (inout) :: a(N)
   integer :: i
 
   do i = 1, N
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index 7bbc0dec6c8..0be41b24d13 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,12 @@
+2020-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR lto/93966
+	* simple-object.c (handle_lto_debug_sections): Also copy
+	.note.gnu.property section.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libiberty/simple-object.c b/libiberty/simple-object.c
index b00c265128c..7fdb30f3416 100644
--- a/libiberty/simple-object.c
+++ b/libiberty/simple-object.c
@@ -293,6 +293,9 @@ handle_lto_debug_sections (const char *name, int rename)
   /* Copy over .note.GNU-stack section under the same name if present.  */
   else if (strcmp (name, ".note.GNU-stack") == 0)
     return strcpy (newname, name);
+  /* Copy over .note.gnu.property section under the same name if present.  */
+  else if (strcmp (name, ".note.gnu.property") == 0)
+    return strcpy (newname, name);
   /* Copy over .comment section under the same name if present.  Solaris
      ld uses them to relax its checking of ELF gABI access rules for
      COMDAT sections in objects produced by GCC.  */
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 24de0ab9bd8..becd8b1ec86 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,12 @@
+2019-10-30  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+
+	2019-09-03  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* testsuite/lib/libphobos.exp (libphobos_init): Add multi-lib libgcc
+	dirs to the ld_library_path var.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libphobos/testsuite/lib/libphobos.exp b/libphobos/testsuite/lib/libphobos.exp
index d3fe75358c8..056e8f1d444 100644
--- a/libphobos/testsuite/lib/libphobos.exp
+++ b/libphobos/testsuite/lib/libphobos.exp
@@ -170,6 +170,25 @@ proc libphobos_init { args } {
 	append ld_library_path ":${blddir}/src/.libs"
     }
 
+    # Compute what needs to be added to the existing LD_LIBRARY_PATH.
+    if {$gccdir != ""} {
+	set compiler ${gccdir}/gdc
+
+	if { [is_remote host] == 0 && [which $compiler] != 0 } {
+	  foreach i "[exec $compiler --print-multi-lib]" {
+	    set mldir ""
+	    regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
+	    set mldir [string trimright $mldir "\;@"]
+	    if { "$mldir" == "." } {
+	      continue
+	    }
+	    if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] >= 1 } {
+	      append ld_library_path ":${gccdir}/${mldir}"
+	    }
+	  }
+	}
+    }
+
     set_ld_library_path_env_vars
 
     libphobos_maybe_build_wrapper "${objdir}/testglue.o"
diff --git a/libquadmath/ChangeLog b/libquadmath/ChangeLog
index 15f371b36f0..b8f71d6520b 100644
--- a/libquadmath/ChangeLog
+++ b/libquadmath/ChangeLog
@@ -1,3 +1,12 @@
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-08-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* quadmath.h (M_Eq, M_LOG2Eq, M_LOG10Eq, M_LN2q, M_LN10q, M_PIq,
+	M_PI_2q, M_PI_4q, M_1_PIq, M_2_PIq, M_2_SQRTPIq, M_SQRT2q,
+	M_SQRT1_2q): Use two more decimal places.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libquadmath/quadmath.h b/libquadmath/quadmath.h
index 76275b51b62..81eb957d2fa 100644
--- a/libquadmath/quadmath.h
+++ b/libquadmath/quadmath.h
@@ -1,5 +1,5 @@
 /* GCC Quad-Precision Math Library
-   Copyright (C) 2010, 2011 Free Software Foundation, Inc.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
    Written by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
 
 This file is part of the libquadmath library.
@@ -165,19 +165,19 @@ extern int quadmath_snprintf (char *str, size_t size,
    (floating constant exceeds range of ‘__float128’)  */
 /* #define HUGE_VALQ (__extension__ 0x1.0p32767Q) */
 
-#define M_Eq		2.7182818284590452353602874713526625Q  /* e */
-#define M_LOG2Eq	1.4426950408889634073599246810018921Q  /* log_2 e */
-#define M_LOG10Eq	0.4342944819032518276511289189166051Q  /* log_10 e */
-#define M_LN2q		0.6931471805599453094172321214581766Q  /* log_e 2 */
-#define M_LN10q		2.3025850929940456840179914546843642Q  /* log_e 10 */
-#define M_PIq		3.1415926535897932384626433832795029Q  /* pi */
-#define M_PI_2q		1.5707963267948966192313216916397514Q  /* pi/2 */
-#define M_PI_4q		0.7853981633974483096156608458198757Q  /* pi/4 */
-#define M_1_PIq		0.3183098861837906715377675267450287Q  /* 1/pi */
-#define M_2_PIq		0.6366197723675813430755350534900574Q  /* 2/pi */
-#define M_2_SQRTPIq	1.1283791670955125738961589031215452Q  /* 2/sqrt(pi) */
-#define M_SQRT2q	1.4142135623730950488016887242096981Q  /* sqrt(2) */
-#define M_SQRT1_2q	0.7071067811865475244008443621048490Q  /* 1/sqrt(2) */
+#define M_Eq		2.718281828459045235360287471352662498Q  /* e */
+#define M_LOG2Eq	1.442695040888963407359924681001892137Q  /* log_2 e */
+#define M_LOG10Eq	0.434294481903251827651128918916605082Q  /* log_10 e */
+#define M_LN2q		0.693147180559945309417232121458176568Q  /* log_e 2 */
+#define M_LN10q		2.302585092994045684017991454684364208Q  /* log_e 10 */
+#define M_PIq		3.141592653589793238462643383279502884Q  /* pi */
+#define M_PI_2q		1.570796326794896619231321691639751442Q  /* pi/2 */
+#define M_PI_4q		0.785398163397448309615660845819875721Q  /* pi/4 */
+#define M_1_PIq		0.318309886183790671537767526745028724Q  /* 1/pi */
+#define M_2_PIq		0.636619772367581343075535053490057448Q  /* 2/pi */
+#define M_2_SQRTPIq	1.128379167095512573896158903121545172Q  /* 2/sqrt(pi) */
+#define M_SQRT2q	1.414213562373095048801688724209698079Q  /* sqrt(2) */
+#define M_SQRT1_2q	0.707106781186547524400844362104849039Q  /* 1/sqrt(2) */
 
 #define __quadmath_extern_inline \
   extern inline __attribute__ ((__gnu_inline__))
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index c7d3cf4f562..53b8343a189 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,40 @@
+2020-03-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* configure.tgt (x86_64-*-darwin*, i?86-*-darwin*): Enable by
+	default only for Darwin versions greater than equal to 11
+	(macOS 10.7).
+
+2019-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-11-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/92154
+	* sanitizer_common/sanitizer_platform_limits_posix.h: Cherry-pick
+	llvm-project revision 947f9692440836dcb8d88b74b69dd379d85974ce.
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Likewise.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-22  Tamar Christina  <tamar.christina@arm.com>
+
+	PR sanitizer/92154
+	* sanitizer_common/sanitizer_platform_limits_posix.cc:
+	Cherry-pick compiler-rt revision r375220.
+
+2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libsanitizer/87880
+	* asan/asan_interceptors.h:
+	(ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION): New.
+	* asan/Makefile.am (DEFS): Add (for Darwin only)
+	ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION, defined to 0.
+	* asan/Makefile.in: Regenerated.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libsanitizer/asan/Makefile.am b/libsanitizer/asan/Makefile.am
index 867240d2445..6efbc1df7f8 100644
--- a/libsanitizer/asan/Makefile.am
+++ b/libsanitizer/asan/Makefile.am
@@ -5,7 +5,7 @@ gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)
 
 DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_NEEDS_SEGV=1 -DCAN_SANITIZE_UB=0
 if USING_MAC_INTERPOSE
-DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT
+DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT -DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0
 endif
 AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -fno-ipa-icf
 AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)
diff --git a/libsanitizer/asan/Makefile.in b/libsanitizer/asan/Makefile.in
index 926ff7d7491..8dfd93a6fd3 100644
--- a/libsanitizer/asan/Makefile.in
+++ b/libsanitizer/asan/Makefile.in
@@ -90,7 +90,7 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@USING_MAC_INTERPOSE_TRUE@am__append_1 = -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT
+@USING_MAC_INTERPOSE_TRUE@am__append_1 = -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT -DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0
 @USING_MAC_INTERPOSE_FALSE@am__append_2 = $(top_builddir)/interception/libinterception.la
 @LIBBACKTRACE_SUPPORTED_TRUE@am__append_3 = $(top_builddir)/libbacktrace/libsanitizer_libbacktrace.la
 subdir = asan
diff --git a/libsanitizer/asan/asan_interceptors.h b/libsanitizer/asan/asan_interceptors.h
index b599ebb0ba9..beb1dc9532b 100644
--- a/libsanitizer/asan/asan_interceptors.h
+++ b/libsanitizer/asan/asan_interceptors.h
@@ -79,7 +79,12 @@ void InitializePlatformInterceptors();
 #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \
     !SANITIZER_NETBSD
 # define ASAN_INTERCEPT___CXA_THROW 1
-# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1
+# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \
+     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION
+#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1
+# else
+#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0
+# endif
 # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))
 #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1
 # else
diff --git a/libsanitizer/configure.tgt b/libsanitizer/configure.tgt
index b241ddbfec4..424fb17a45c 100644
--- a/libsanitizer/configure.tgt
+++ b/libsanitizer/configure.tgt
@@ -60,7 +60,7 @@ case "${target}" in
 		TSAN_TARGET_DEPENDENT_OBJECTS=tsan_rtl_aarch64.lo
 	fi
 	;;
-  x86_64-*-darwin[1]* | i?86-*-darwin[1]*)
+  x86_64-*-darwin1[1-9]* | i?86-*-darwin1[1-9]*)
 	TSAN_SUPPORTED=no
 	;;
   x86_64-*-solaris2.11* | i?86-*-solaris2.11*)
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
index 6cd4a5bac8b..d823a12190c 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
@@ -1156,8 +1156,9 @@ CHECK_SIZE_AND_OFFSET(ipc_perm, uid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, gid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);
-#if !defined(__aarch64__) || !SANITIZER_LINUX || __GLIBC_PREREQ (2, 21)
-/* On aarch64 glibc 2.20 and earlier provided incorrect mode field.  */
+#if !SANITIZER_LINUX || __GLIBC_PREREQ (2, 31)
+/* glibc 2.30 and earlier provided 16-bit mode field instead of 32-bit
+   on many architectures.  */
 CHECK_SIZE_AND_OFFSET(ipc_perm, mode);
 #endif
 
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
index 73af92af1e8..6a673a7c995 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
@@ -211,26 +211,13 @@ namespace __sanitizer {
     u64 __unused1;
     u64 __unused2;
 #elif defined(__sparc__)
-#if defined(__arch64__)
     unsigned mode;
-    unsigned short __pad1;
-#else
-    unsigned short __pad1;
-    unsigned short mode;
     unsigned short __pad2;
-#endif
     unsigned short __seq;
     unsigned long long __unused1;
     unsigned long long __unused2;
-#elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)
-    unsigned int mode;
-    unsigned short __seq;
-    unsigned short __pad1;
-    unsigned long __unused1;
-    unsigned long __unused2;
 #else
-    unsigned short mode;
-    unsigned short __pad1;
+    unsigned int mode;
     unsigned short __seq;
     unsigned short __pad2;
 #if defined(__x86_64__) && !defined(_LP64)
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 8ac50251005..2f36d845098 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,561 @@
+2020-03-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-03-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/all.cc: Mark unused variable.
+	* testsuite/27_io/filesystem/operations/copy.cc: Fix typo.
+	* testsuite/experimental/filesystem/operations/copy.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/file_size.cc: Use correct type
+	for return value, and in comparison.
+	* testsuite/experimental/filesystem/operations/file_size.cc: Likewise.
+
+	Backport from mainline
+	2019-09-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91910
+	* src/c++11/debug.cc (_Safe_iterator_base::_M_detach()): Load pointer
+	atomically and lock the mutex before accessing the sequence.
+	(_Safe_local_iterator_base::_M_detach()): Likewise.
+	(_Safe_iterator_base::_M_reset()): Clear _M_sequence atomically.
+
+	Backport from mainline
+	2019-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/c_global/cmath (__lerp, lerp): Add noexcept (LWG 3201).
+
+	Backport from mainline
+	2019-11-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_algo.h (for_each_n): Handle negative count.
+	* testsuite/25_algorithms/for_each/for_each_n_debug.cc: New test.
+
+	Backport from mainline
+	2020-01-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93470
+	* include/bits/refwrap.h (reference_wrapper::operator()): Restrict
+	static assertion to object types.
+
+2020-01-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93325
+	* acinclude.m4 (GLIBCXX_ENABLE_LIBSTDCXX_TIME): Use AC_SEARCH_LIBS for
+	clock_gettime instead of explicit glibc version check.
+	* configure: Regenerate.
+
+2020-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt: Updated.
+
+2020-02-29  John David Anglin  <danglin@gcc.gnu.org>
+
+	* testsuite/17_intro/headers/c++1998/charset.cc: Skip on *-*-hpux*.
+	* testsuite/17_intro/headers/c++2011/charset.cc: Likewise.
+	* testsuite/17_intro/headers/c++2014/charset.cc: Likewise.
+	* testsuite/17_intro/headers/c++2017/charset.cc: Likewise.
+	* testsuite/17_intro/headers/c++2020/charset.cc: Likewise.
+
+2020-02-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93205
+	* include/bits/random.h (operator>>): Check stream operation succeeds.
+	* include/bits/random.tcc (operator>>): Likewise.
+	(__extract_params): New function to fill a vector from a stream.
+	* testsuite/26_numerics/random/pr60037-neg.cc: Adjust dg-error line.
+
+	Backport from mainline
+	2019-12-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92886
+	* include/bits/ios_base.h (std::ios_base::trunc): Fix comment.
+
+	Backport from mainline
+	2020-01-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93325
+	* acinclude.m4 (GLIBCXX_ENABLE_LIBSTDCXX_TIME): Use AC_SEARCH_LIBS for
+	clock_gettime instead of explicit glibc version check.
+	* configure: Regenerate.
+
+	Backport from mainline
+	2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93562
+	* include/bits/unique_ptr.h (__uniq_ptr_impl::swap): Define.
+	(unique_ptr::swap, unique_ptr<T[], D>::swap): Call it.
+	* testsuite/20_util/unique_ptr/modifiers/93562.cc: New test.
+
+	Backport from mainline
+	2020-01-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92376
+	* include/bits/c++config: Only do PSTL config when the header is
+	present, to fix freestanding.
+	* libsupc++/new_opa.cc [!_GLIBCXX_HOSTED]: Declare allocation
+	functions if they were detected by configure.
+
+	Backport from mainline
+	2019-10-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/78552
+	* src/c++98/locale_init.cc (locale::classic()): Do not construct a new
+	locale object for every call.
+	(locale::_S_initialize_once()): Construct C locale here.
+
+2020-01-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-01-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91947
+	* include/Makefile.am (${host_builddir}/largefile-config.h): Simplify
+	rule.
+	* include/Makefile.in: Regenerate.
+
+	Backport from mainline
+	2020-01-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Fix grammar.
+	* doc/xml/manual/appendix_contributing.xml: Improve instructions.
+	* doc/xml/manual/spine.xml: Update copyright years.
+	* doc/html/*: Regenerate.
+
+2020-01-19  Eric S. Raymond <esr@thyrsus.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	Partial backport from mainline:
+
+	2020-01-19  Eric S. Raymond <esr@thyrsus.com>
+	* doc/xml/faq.xml: Update for SVN -> Git transition.
+	* doc/xml/manual/appendix_contributing.xml: Likewise.
+
+2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainlne
+	2019-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81091
+	PR libstdc++/91947
+	* configure.ac: Use AC_SYS_LARGEFILE to enable 64-bit file APIs.
+	* config.h.in: Regenerate:
+	* configure: Regenerate:
+	* include/Makefile.am (${host_builddir}/largefile-config.h): New
+	target to generate config header for filesystem library.
+	(${host_builddir}/c++config.h): Rename macros for large file support.
+	* include/Makefile.in: Regenerate.
+	* src/c++17/fs_dir.cc: Include new config header.
+	* src/c++17/fs_ops.cc: Likewise.
+	(filesystem::file_size): Use uintmax_t for size.
+	* src/filesystem/dir.cc: Include new config header.
+	* src/filesystem/ops.cc: Likewise.
+	(experimental::filesystem::file_size): Use uintmax_t for size.
+
+	* doc/xml/manual/status_cxx1998.xml: Replace incorrect statement
+	about documenting mainline.
+	* doc/xml/manual/status_cxx2011.xml: Likewise.
+	* doc/xml/manual/status_cxx2014.xml: Likewise.
+	* doc/xml/manual/status_cxx2017.xml: Likewise.
+	* doc/xml/manual/status_cxx2020.xml: Likewise.
+	* doc/xml/manual/status_cxxtr1.xml: Likewise.
+	* doc/xml/manual/status_cxxtr24733.xml: Likewise.
+	* doc/html/*: Regenerate.
+
+2020-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93208
+	* config/abi/pre/gnu.ver: Add new exports.
+	* include/std/memory_resource (memory_resource::~memory_resource()):
+	Do not define inline.
+	(monotonic_buffer_resource::~monotonic_buffer_resource()): Likewise.
+	* src/c++17/memory_resource.cc (memory_resource::~memory_resource()):
+	Define.
+	(monotonic_buffer_resource::~monotonic_buffer_resource()): Define.
+	* testsuite/20_util/monotonic_buffer_resource/93208.cc: New test.
+
+2020-01-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93201
+	* src/c++17/fs_ops.cc (remove_all(const path&, error_code&)): Check
+	result of recursive call before incrementing iterator.
+	* src/filesystem/ops.cc (remove_all(const path&, error_code&)):
+	Likewise.
+	* testsuite/27_io/filesystem/operations/remove_all.cc: Check errors
+	are reported correctly.
+	* testsuite/experimental/filesystem/operations/remove_all.cc: Likewise.
+
+2019-12-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-11-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91786
+	* include/bits/fs_path.h (filesystem_error): Move definition before
+	the use in u8path.
+
+2019-12-10  Thomas Rodgers  <trodgers@redhat.com>
+
+	Backport from mainline
+	2019-12-10  Thomas Rodgers  <trodgers@redhat.com>
+
+	* include/pstl/glue_numeric_defs.h: Restore enable_if lost during
+	original import of pstl.
+	* include/pstl/glue_numeric_impl.h: Likewise.
+
+2019-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92853
+	* src/c++17/fs_path.cc (filesystem::path::operator+=(const path&)):
+	Do not process a trailing directory separator twice.
+	* testsuite/27_io/filesystem/path/concat/92853.cc: New test.
+	* testsuite/27_io/filesystem/path/concat/path.cc: Test more cases.
+	* testsuite/27_io/filesystem/path/concat/strings.cc: Test more cases.
+
+2019-11-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-10-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92267
+	* include/bits/stl_deque.h (_Deque_iterator(const _Deque_iterator&)):
+	Do not define as defaulted.
+	* testsuite/23_containers/deque/types/92267.cc: New test.
+
+2019-10-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/abi/post/hppa-linux-gnu/baseline_symbols.txt: Update.
+
+2019-10-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90682
+	* libsupc++/eh_term_handler.cc: Include eh_term_handler.h to get
+	definition of _GLIBCXX_DEFAULT_TERM_HANDLER.
+	* libsupc++/eh_term_handler.h: New header defining
+	_GLIBCXX_DEFAULT_TERM_HANDLER.
+	* libsupc++/eh_terminate.cc: Include eh_term_handler.h.
+	(set_terminate): Restore default handler when argument is null.
+	(set_unexpected): Likewise.
+	* testsuite/18_support/set_terminate.cc: New test.
+	* testsuite/18_support/set_unexpected.cc: New test.
+
+	Backport from mainline
+	2019-05-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61761
+	* include/std/complex (__complex_proj): Return parameter unchanged.
+	[_GLIBCXX_USE_C99_COMPLEX] (__complex_proj): Change overloads for
+	floating-point types to take std::complex arguments.
+	[_GLIBCXX_USE_C99_MATH_TR1] (__complex_proj): Add overloads for
+	floating-point types.
+	* testsuite/26_numerics/complex/proj.cc: New test.
+
+	Backport from mainline
+	2019-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/deque/requirements/dr438/assign_neg.cc: Add
+	dg-prune-output for different C++98 diagnostic.
+	* testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc:
+	Likewise.
+	* testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc:
+	Likewise.
+	* testsuite/23_containers/deque/requirements/dr438/insert_neg.cc:
+	Likewise.
+	* testsuite/23_containers/list/requirements/dr438/assign_neg.cc:
+	Likewise.
+	* testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc:
+	Likewise.
+	* testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc:
+	Likewise.
+	* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:
+	Likewise.
+	* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:
+	Likewise.
+	* testsuite/23_containers/vector/requirements/dr438/
+	constructor_1_neg.cc: Likewise.
+	* testsuite/23_containers/vector/requirements/dr438/
+	constructor_2_neg.cc: Likewise.
+	* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:
+	Likewise.
+	* testsuite/libstdc++-prettyprinters/compat.cc: Do not run for C++98.
+
+	Backport from mainline
+	2019-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/is_nothrow_invocable/value.cc: Test converting to
+	void.
+	* testsuite/experimental/names.cc: Do not run for C++98 mode. Do not
+	include Library Fundamentals or Networking headers in C++11 mode.
+	* testsuite/ext/char8_t/atomic-1.cc: Do not run for C++98 mode.
+
+	Backport from mainline
+	2019-05-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/util/testsuite_allocator.h (memory_resource)
+	(default_resource_mgr): Fix indentation.
+
+	Backport from mainline
+	2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89164
+	* include/bits/stl_algobase.h (__copy_move): Give descriptive names
+	to template parameters.
+	* include/bits/stl_uninitialized.h (uninitialized_copy)
+	(uninitialized_fill, uninitialized_fill_n): Add static assertions to
+	diagnose invalid uses.
+	* testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc:
+	Adjust expected error.
+	* testsuite/20_util/specialized_algorithms/uninitialized_copy/89164.cc:
+	New test.
+	* testsuite/20_util/specialized_algorithms/uninitialized_copy_n/
+	89164.cc: New test.
+	* testsuite/20_util/specialized_algorithms/uninitialized_fill/89164.cc:
+	New test.
+	* testsuite/20_util/specialized_algorithms/uninitialized_fill_n/
+	89164.cc: New test.
+	* testsuite/23_containers/vector/cons/89164.cc: New test.
+	* testsuite/23_containers/vector/cons/89164_c++17.cc: New test.
+
+	Backport from mainline
+	2019-10-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/memoryfwd.h (uses_allocator): Do not declare for C++98.
+	* testsuite/17_intro/names.cc: Check uses_allocator in C++98.
+
+	Backport from mainline
+	2019-10-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92143
+	* libsupc++/new_opa.cc (operator new) [__APPLE__]: Increase alignment
+	to at least sizeof(void*).
+
+	Backport from mainline
+	2019-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/unordered_map/requirements/debug_container.cc:
+	Do not test allocator rebinding extension for C++2a.
+	* testsuite/23_containers/unordered_set/allocator/ext_ptr.cc: Change
+	dg-do directive for C++17 and C++2a.
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/function_objects/invoke/1.cc: Add more tests.
+	Move C++17-specific tests to ...
+	* testsuite/20_util/function_objects/invoke/3.cc: New test.
+	* testsuite/23_containers/unordered_set/allocator/ext_ptr.cc: Change
+	"compile" test to "run".
+
+	Backport from mainline
+	2019-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/Makefile.am (doc-html-docbook-regenerate): New target.
+	(${docbook_outdir}/html): Do not create unused 'html/ext' directory.
+	* doc/Makefile.in: Regenerate.
+	* doc/xml/manual/documentation_hacking.xml: Document new target.
+	* doc/html/*: Regenerate.
+
+	* doc/xml/manual/allocator.xml: Use archived copy of CUJ article.
+
+	Backport from mainline
+	2019-05-31  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/xml/manual/allocator.xml: Move hoard.org back to http.
+
+	Backport from mainline
+	2019-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91456
+	* include/bits/std_function.h (__check_func_return_type): Remove.
+	(function::_Callable): Use std::__is_invocable_impl instead of
+	__check_func_return_type.
+	* include/std/type_traits (__is_invocable_impl): Add another defaulted
+	template parameter. Define a separate partial specialization for
+	INVOKE and INVOKE<void>. For INVOKE<R> replace is_convertible check
+	with a check that models delayed temporary materialization.
+	* testsuite/20_util/function/91456.cc: New test.
+	* testsuite/20_util/is_invocable/91456.cc: New test.
+
+	Backport from mainline
+	2019-09-30  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* include/experimental/internet: Include netinet/in.h if we have
+	_GLIBCXX_HAVE_NETINET_IN_H defined.
+
+	Backport from mainline
+	2019-09-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/internet (operator==, operator<): Fix loop
+	condition to avoid reading past the end of the array.
+
+	Backport from mainline
+	2019-08-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	P1651R0 bind_front should not unwrap reference_wrapper
+	* include/std/functional (bind_front): Don't unwrap reference_wrapper.
+	* include/std/version (__cpp_lib_bind_front): Update value.
+	* testsuite/20_util/function_objects/bind_front/1.cc: Fix test for
+	feature test macro.
+	* testsuite/20_util/function_objects/bind_front/2.cc: New test.
+
+	Backport from mainline
+	2019-10-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92059
+	* include/tr2/dynamic_bitset (__dynamic_bitset_base): Define all
+	special member functions as defaulted. Add noexcept to most members.
+	(__dynamic_bitset_base(size_t, unsigned long long, const _Alloc&)):
+	Mask off unwanted bits in the __val parameter. Avoid undefined left
+	shifts.
+	(__dynamic_bitset_base::_M_assign): Remove.
+	(__dynamic_bitset_base::_M_do_reset): Use std::fill.
+	(__dynamic_bitset_base::_M_are_all_aux): Avoid integer promotion when
+	block_type has lower rank than int.
+	(dynamic_bitset): Add noexcept to most members. Use injected-class-name
+	in return types and parameter types.
+	(dynamic_bitset::_M_Nb): Add default member initializer.
+	(dynamic_bitset(), dynamic_bitset(const dynamic_bitset&)): Define as
+	defaulted.
+	(dynamic_bitset(dynamic_bitset&&)): Clear source object after move.
+	(dynamic_bitset::operator=(const dynamic_bitset&)): Define as
+	defaulted.
+	(dynamic_bitset::operator=(dynamic_bitset&&)): Add noexcept-specifier.
+	Define without using swap, to propagate allocator correctly.
+	(dynamic_bitset(const char*, const _Alloc&)): Use strlen.
+	(dynamic_bitset::_M_do_sanitize, dynamic_bitset::_M_do_fill): Use
+	casts to avoid unwanted integer promotions.
+	(dynamic_bitset::_M_copy_from_ptr): Rearrange template parameters and
+	add default template arguments and default argument to simplify usage.
+	(dynamic_bitset::_M_copy_from_string): Adjust call to _M_copy_from_ptr.
+	(operator==(const dynamic_bitset&, const dynamic_bitset&))
+	(operator<(const dynamic_bitset&, const dynamic_bitset&)): Use _M_Nb.
+	* include/tr2/dynamic_bitset.tcc (dynamic_bitset::_M_copy_from_ptr):
+	Adjust template parameters to match declaration.
+	* testsuite/tr2/dynamic_bitset/cmp.cc: New test.
+	* testsuite/tr2/dynamic_bitset/cons.cc: New test.
+	* testsuite/tr2/dynamic_bitset/copy.cc: New test.
+	* testsuite/tr2/dynamic_bitset/move.cc: New test.
+	* testsuite/tr2/dynamic_bitset/pr92059.cc: New test.
+
+2019-09-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91748
+	* include/bits/stl_algo.h (for_each_n): Fix random access iterator
+	case.
+	* testsuite/25_algorithms/for_each/for_each_n.cc: Test with random
+	access iterators.
+
+2019-09-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/xmethods.py (SharedPtrUseCountWorker.__call__):
+	Fix syntax error.
+
+2019-09-09  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	Update docs for p858 - Constexpr iterator changes available since 9.1.
+	* doc/xml/manual/status_cxx2020.xml: Update p0858r0 status.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/abi.xml: Document 9.x library versions.
+	* doc/html/*: Regenerate.
+
+2019-09-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/abi/post/i386-solaris2.10/baseline_symbols.txt: Regenerate.
+	* config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt: Likewise.
+	* config/abi/post/i386-solaris2.11/baseline_symbols.txt: Likewise.
+	* config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt: Likewise.
+	* config/abi/post/sparc-solaris2.10/baseline_symbols.txt: Likewise.
+	* config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt:
+	Likewise.
+	* config/abi/post/sparc-solaris2.11/baseline_symbols.txt: Likewise.
+	* config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt:
+	Likewise.
+
+2019-08-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91067
+	* acinclude.m4 (libtool_VERSION): Bump to 6:28:0.
+	* configure: Regenerate.
+	* config/abi/pre/gnu.ver (GLIBCXX_3.4.28): Add new version. Export
+	missing symbols.
+	* testsuite/27_io/filesystem/iterators/91067.cc: Test move
+	constructors.
+	* testsuite/util/testsuite_abi.cc: Add new symbol version.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com
+
+	* config/abi/post/aarch64-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/s390x-linux-gnu/baseline_symbols.txt: Update.
+
+2019-08-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* config/abi/post/i386-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/i486-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/powerpc-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt: Update.
+	* config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt: Update.
+	* config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
+
+2019-08-23  Joseph Myers  <joseph@codesourcery.com>
+
+	* src/filesystem/ops-common.h [_GLIBCXX_FILESYSTEM_IS_WINDOWS]
+	(std::filesystem::__gnu_posix::lstat): Add return type.
+
+2019-08-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/numeric (reduce): Fix Doxygen markup.
+
+	Backport from mainline
+	2019-06-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/numeric (reduce(Iter, Iter, T, BinOp)): Fix value
+	category used in invocable check.
+	(reduce(Iter, Iter, T)): Pass initial value as rvalue.
+	* testsuite/26_numerics/reduce/2.cc: New test.
+
+	Backport from mainline
+	2019-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/algorithmfwd.h: Change title of doc group.
+	* include/bits/stl_algo.h (for_each_n): Add new C++17 algorithm from
+	P0024R2.
+	* include/bits/stl_numeric.h: Define doc group and add algos to it.
+	* include/std/numeric (__is_random_access_iter): New internal trait.
+	(reduce, transform_reduce, exclusive_scan, inclusive_scan)
+	(transform_exclusive_scan, transform_inclusive_scan): Likewise.
+	* testsuite/25_algorithms/for_each/for_each_n.cc: New test.
+	* testsuite/26_numerics/exclusive_scan/1.cc: New test.
+	* testsuite/26_numerics/inclusive_scan/1.cc: New test.
+	* testsuite/26_numerics/reduce/1.cc: New test.
+	* testsuite/26_numerics/transform_exclusive_scan/1.cc: New test.
+	* testsuite/26_numerics/transform_inclusive_scan/1.cc: New test.
+	* testsuite/26_numerics/transform_reduce/1.cc: New test.
+	* testsuite/util/testsuite_iterators.h (test_container::size()): New
+	member function.
+
+2019-08-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/abi/post/alpha-linux-gnu/baseline_symbols.txt: Update.
+
+2019-08-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90361
+	* src/c++17/string-inst.cc: Use _GLIBCXX_USE_CXX11_ABI=1 by default.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 0112d645aa4..d22e30230b3 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -1405,20 +1405,14 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [
         ac_has_sched_yield=yes
         ;;
       gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
-        AC_MSG_CHECKING([for at least GNU libc 2.17])
-        AC_TRY_COMPILE(
-          [#include <features.h>],
-          [
-          #if ! __GLIBC_PREREQ(2, 17)
-          #error 
-          #endif
-          ],
-          [glibcxx_glibc217=yes], [glibcxx_glibc217=no])
-        AC_MSG_RESULT($glibcxx_glibc217)
-
-        if test x"$glibcxx_glibc217" = x"yes"; then
-          ac_has_clock_monotonic=yes
-          ac_has_clock_realtime=yes
+        # Don't use link test for freestanding library, in case gcc_no_link=yes
+        if test x"$is_hosted" = xyes; then
+          # Versions of glibc before 2.17 needed -lrt for clock_gettime.
+          AC_SEARCH_LIBS(clock_gettime, [rt])
+          if test x"$ac_cv_search_clock_gettime" = x"none required"; then
+            ac_has_clock_monotonic=yes
+            ac_has_clock_realtime=yes
+          fi
         fi
         ac_has_nanosleep=yes
         ac_has_sched_yield=yes
@@ -3820,7 +3814,7 @@ changequote([,])dnl
 fi
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:27:0
+libtool_VERSION=6:28:0
 
 # Everything parsed; figure out what files and settings to use.
 case $enable_symvers in
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 3a6f180c06d..1252e0c6f60 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -803,6 +803,14 @@
 /* Version number of package */
 #undef VERSION
 
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
 /* Define if C99 functions in <complex.h> should be used in <complex> for
    C++11. Using compiler builtins for these functions requires corresponding
    C99 library functions to be present. */
@@ -1041,6 +1049,9 @@
 /* Define to 1 if mutex_timedlock is available. */
 #undef _GTHREAD_USE_MUTEX_TIMEDLOCK
 
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
 /* Define if all C++11 floating point overloads are available in <math.h>.  */
 #if __cplusplus >= 201103L
 #undef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
diff --git a/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
index 17114e84ee9..53c87f115e0 100644
--- a/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4401,6 +4407,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/alpha-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/alpha-linux-gnu/baseline_symbols.txt
index 9d070517326..65ee06d5c2a 100644
--- a/libstdc++-v3/config/abi/post/alpha-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/alpha-linux-gnu/baseline_symbols.txt
@@ -112,6 +112,7 @@ FUNC:_ZN11__gnu_debug19_Safe_sequence_base13_M_detach_allEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base18_M_detach_singularEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base22_M_revalidate_singularEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_@@GLIBCXX_3.4
+FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base16_M_attach_singleEPNS_19_Safe_sequence_baseEb@@GLIBCXX_3.4.26
 FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base9_M_attachEPNS_19_Safe_sequence_baseEb@@GLIBCXX_3.4.17
 FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base9_M_detachEv@@GLIBCXX_3.4.17
 FUNC:_ZN11__gnu_debug30_Safe_unordered_container_base13_M_detach_allEv@@GLIBCXX_3.4.17
@@ -261,6 +262,7 @@ FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8_M_limitEmm@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8capacityEv@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8max_sizeEv@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE9_M_ibeginEv@@GLIBCXX_3.4
+FUNC:_ZNKSbIwSt11char_traitsIwESaIwEEcvSt17basic_string_viewIwS0_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEEixEm@@GLIBCXX_3.4
 FUNC:_ZNKSi6gcountEv@@GLIBCXX_3.4
 FUNC:_ZNKSi6sentrycvbEv@@GLIBCXX_3.4
@@ -328,9 +330,66 @@ FUNC:_ZNKSs8_M_limitEmm@@GLIBCXX_3.4
 FUNC:_ZNKSs8capacityEv@@GLIBCXX_3.4
 FUNC:_ZNKSs8max_sizeEv@@GLIBCXX_3.4
 FUNC:_ZNKSs9_M_ibeginEv@@GLIBCXX_3.4
+FUNC:_ZNKSscvSt17basic_string_viewIcSt11char_traitsIcEEEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSsixEm@@GLIBCXX_3.4
 FUNC:_ZNKSt10bad_typeid4whatEv@@GLIBCXX_3.4.9
 FUNC:_ZNKSt10error_code23default_error_conditionEv@@GLIBCXX_3.4.11
+FUNC:_ZNKSt10filesystem16filesystem_error4whatEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem16filesystem_error5path1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem16filesystem_error5path2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem18directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path11parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path12has_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13has_root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13has_root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path14root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path15has_parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path16lexically_normalEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path17_M_find_extensionEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path17has_relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path18has_root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path18lexically_relativeERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path19lexically_proximateERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List13_Impl_deleterclEPNS1_5_ImplE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List3endEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List5beginEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path7compareERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path7compareESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path9root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path9root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error4whatEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1118directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path11parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path12has_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13has_root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13has_root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path14root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path15has_parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path16lexically_normalEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path17_M_find_extensionEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path17has_relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path18has_root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path18lexically_relativeERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path19lexically_proximateERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List13_Impl_deleterclEPNS2_5_ImplE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List3endEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List5beginEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path7compareERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path7compareESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path9root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path9root_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10istrstream5rdbufEv@@GLIBCXX_3.4
 FUNC:_ZNKSt10lock_error4whatEv@@GLIBCXX_3.4.11
 FUNC:_ZNKSt10moneypunctIcLb0EE10neg_formatEv@@GLIBCXX_3.4
@@ -876,6 +935,7 @@ FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_checkEmPKc@@GLIBC
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_limitEmm@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8capacityEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8max_sizeEv@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEcvSt17basic_string_viewIcS2_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEixEm@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE11_M_disjunctEPKw@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE11_M_is_localEv@@GLIBCXX_3.4.21
@@ -936,6 +996,7 @@ FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8_M_checkEmPKc@@GLIBC
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8_M_limitEmm@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8capacityEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8max_sizeEv@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEcvSt17basic_string_viewIwS2_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEixEm@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEE3strEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEE3strEv@@GLIBCXX_3.4.21
@@ -1067,6 +1128,13 @@ FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES4_bRSt8ios_basewg@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb0EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE6do_outERS0_PKDiS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE9do_lengthERS0_PKDuS4_m@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -1074,6 +1142,13 @@ FUNC:_ZNKSt7codecvtIDic11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE5do_inERS0_PKcS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE6do_outERS0_PKDiS4_RS4_PcS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE9do_lengthERS0_PKcS4_m@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDsS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE6do_outERS0_PKDsS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE9do_lengthERS0_PKDuS4_m@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -1276,6 +1351,7 @@ FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE16do_get_mont
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE21_M_extract_via_formatES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKc@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE24_M_extract_wday_or_monthES3_S3_RiPPKcmRSt8ios_baseRSt12_Ios_Iostate@@GLIBCXX_3.4.14
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKcSC_@@GLIBCXX_3.4.21
+FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.26
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.21
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE8get_dateES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE8get_timeES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
@@ -1294,6 +1370,7 @@ FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE16do_get_mont
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE21_M_extract_via_formatES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKw@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE24_M_extract_wday_or_monthES3_S3_RiPPKwmRSt8ios_baseRSt12_Ios_Iostate@@GLIBCXX_3.4.14
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKwSC_@@GLIBCXX_3.4.21
+FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.26
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.21
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE8get_dateES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE8get_timeES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
@@ -1386,6 +1463,8 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIN9__gnu_cxx17__normal_iterato
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIPKwEEPwT_S7_RKS1_St20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIPwEES4_T_S5_RKS1_St20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_empty_repEv@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12__sv_wrapperC1ESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12__sv_wrapperC2ESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIPKwS2_EES8_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIS3_S2_EES6_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwPKwS5_@@GLIBCXX_3.4
@@ -1393,6 +1472,7 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwS3_S3_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13shrink_to_fitEv@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE14_M_replace_auxEmmmw@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE15_M_replace_safeEmmPKwm@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE17_S_to_string_viewESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE18_S_construct_aux_2EmwRKS1_@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE2atEm@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE3endEv@@GLIBCXX_3.4
@@ -1409,6 +1489,7 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep7_M_grabERKS1_S5_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep8_M_cloneERKS1_m@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep9_S_createEmmRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4backEv@@GLIBCXX_3.4.15
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4rendEv@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4swapERS2_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE5beginEv@@GLIBCXX_3.4
@@ -1467,11 +1548,14 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwmw@@GLIBCXX_3.4.5
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwmw@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_mutateEmmm@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ENS2_12__sv_wrapperERKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EOS2_@@GLIBCXX_3.4.14
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EOS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwmRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_mRKS1_@@GLIBCXX_3.4.23
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_mm@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_mmRKS1_@@GLIBCXX_3.4
@@ -1481,11 +1565,14 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IN9__gnu_cxx17__normal_iteratorIPwS2_EEEET_S8_RKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IPKwEET_S6_RKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IPwEET_S5_RKS1_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ENS2_12__sv_wrapperERKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EOS2_@@GLIBCXX_3.4.15
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EOS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EPKwRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EPKwmRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_mRKS1_@@GLIBCXX_3.4.23
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_mm@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_mmRKS1_@@GLIBCXX_3.4
@@ -1616,6 +1703,7 @@ FUNC:_ZNSoD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSoD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSoD2Ev@@GLIBCXX_3.4
 FUNC:_ZNSoaSEOSo@@GLIBCXX_3.4.21
+FUNC:_ZNSolsEDn@@GLIBCXX_3.4.26
 FUNC:_ZNSolsEPFRSoS_E@@GLIBCXX_3.4
 FUNC:_ZNSolsEPFRSt8ios_baseS0_E@@GLIBCXX_3.4
 FUNC:_ZNSolsEPFRSt9basic_iosIcSt11char_traitsIcEES3_E@@GLIBCXX_3.4
@@ -1643,6 +1731,8 @@ FUNC:_ZNSs12_S_constructIN9__gnu_cxx17__normal_iteratorIPcSsEEEES2_T_S4_RKSaIcES
 FUNC:_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSs12_S_constructIPcEES0_T_S1_RKSaIcESt20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSs12_S_empty_repEv@@GLIBCXX_3.4
+FUNC:_ZNSs12__sv_wrapperC1ESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSs12__sv_wrapperC2ESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
 FUNC:_ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcSsEES4_@@GLIBCXX_3.4
 FUNC:_ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIS_SsEES2_@@GLIBCXX_3.4
 FUNC:_ZNSs13_S_copy_charsEPcPKcS1_@@GLIBCXX_3.4
@@ -1650,6 +1740,7 @@ FUNC:_ZNSs13_S_copy_charsEPcS_S_@@GLIBCXX_3.4
 FUNC:_ZNSs13shrink_to_fitEv@@GLIBCXX_3.4.14
 FUNC:_ZNSs14_M_replace_auxEmmmc@@GLIBCXX_3.4
 FUNC:_ZNSs15_M_replace_safeEmmPKcm@@GLIBCXX_3.4
+FUNC:_ZNSs17_S_to_string_viewESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
 FUNC:_ZNSs18_S_construct_aux_2EmcRKSaIcE@@GLIBCXX_3.4.14
 FUNC:_ZNSs2atEm@@GLIBCXX_3.4
 FUNC:_ZNSs3endEv@@GLIBCXX_3.4
@@ -1666,6 +1757,7 @@ FUNC:_ZNSs4_Rep7_M_grabERKSaIcES2_@@GLIBCXX_3.4
 FUNC:_ZNSs4_Rep8_M_cloneERKSaIcEm@@GLIBCXX_3.4
 FUNC:_ZNSs4_Rep9_S_createEmmRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSs4backEv@@GLIBCXX_3.4.15
+FUNC:_ZNSs4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSs4rendEv@@GLIBCXX_3.4
 FUNC:_ZNSs4swapERSs@@GLIBCXX_3.4
 FUNC:_ZNSs5beginEv@@GLIBCXX_3.4
@@ -1724,11 +1816,14 @@ FUNC:_ZNSs9_M_assignEPcmc@@GLIBCXX_3.4.5
 FUNC:_ZNSs9_M_assignEPcmc@GLIBCXX_3.4
 FUNC:_ZNSs9_M_mutateEmmm@@GLIBCXX_3.4
 FUNC:_ZNSs9push_backEc@@GLIBCXX_3.4
+FUNC:_ZNSsC1ENSs12__sv_wrapperERKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1EOSs@@GLIBCXX_3.4.14
+FUNC:_ZNSsC1EOSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1EPKcRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1EPKcmRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSsC1ERKSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1ERKSsmRKSaIcE@@GLIBCXX_3.4.23
 FUNC:_ZNSsC1ERKSsmm@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSsmmRKSaIcE@@GLIBCXX_3.4
@@ -1738,11 +1833,14 @@ FUNC:_ZNSsC1Ev@@GLIBCXX_3.4
 FUNC:_ZNSsC1IN9__gnu_cxx17__normal_iteratorIPcSsEEEET_S4_RKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1IPKcEET_S2_RKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1IPcEET_S1_RKSaIcE@@GLIBCXX_3.4
+FUNC:_ZNSsC2ENSs12__sv_wrapperERKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2EOSs@@GLIBCXX_3.4.15
+FUNC:_ZNSsC2EOSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2EPKcRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2EPKcmRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSsC2ERKSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2ERKSsmRKSaIcE@@GLIBCXX_3.4.23
 FUNC:_ZNSsC2ERKSsmm@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSsmmRKSaIcE@@GLIBCXX_3.4
@@ -1774,6 +1872,208 @@ FUNC:_ZNSt10__num_base15_S_format_floatERKSt8ios_basePcc@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt10filesystem10equivalentERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10hash_valueERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_4pathENS_5permsENS_12perm_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_4pathENS_5permsENS_12perm_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_7__cxx114pathENS_5permsENS_12perm_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_7__cxx114pathENS_5permsENS_12perm_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_4pathEm@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_4pathEmRSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_7__cxx114pathEm@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_7__cxx114pathEmRSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathB5cxx11ERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathB5cxx11Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathENSt6chrono10time_pointINS_12__file_clockENS3_8durationIlSt5ratioILl1ELl1000000000EEEEEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathENSt6chrono10time_pointINS_12__file_clockENS3_8durationIlSt5ratioILl1ELl1000000000EEEEEERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathENSt6chrono10time_pointINS_12__file_clockENS4_8durationIlSt5ratioILl1ELl1000000000EEEEEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathENSt6chrono10time_pointINS_12__file_clockENS4_8durationIlSt5ratioILl1ELl1000000000EEEEEERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsRKNS_4pathES5_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsRKNS_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsRKNS_4pathES5_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsRKNS_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathB5cxx11ERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathB5cxx11Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_7__cxx114pathES3_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_7__cxx114pathES3_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path14_M_split_cmptsEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path14_S_convert_locEPKcS2_RKSt6locale@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path15remove_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path16replace_filenameERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path17replace_extensionERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path5_ListC1ERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path5_ListC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path9_M_appendESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path9_M_concatESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathaSERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathdVERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathpLERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1110hash_valueERKNS0_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESC_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESC_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path15remove_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path16replace_filenameERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path17replace_extensionERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path5_ListC1ERKS2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path5_ListC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path9_M_appendESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path9_M_concatESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathaSERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathdVERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathpLERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_7__cxx114pathES3_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_7__cxx114pathES3_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10istrstream3strEv@@GLIBCXX_3.4
 FUNC:_ZNSt10istrstreamC1EPKc@@GLIBCXX_3.4
 FUNC:_ZNSt10istrstreamC1EPKcl@@GLIBCXX_3.4
@@ -1860,10 +2160,12 @@ FUNC:_ZNSt11char_traitsIcE2eqERKcS2_@@GLIBCXX_3.4.5
 FUNC:_ZNSt11char_traitsIcE2eqERKcS2_@GLIBCXX_3.4
 FUNC:_ZNSt11char_traitsIwE2eqERKwS2_@@GLIBCXX_3.4.5
 FUNC:_ZNSt11char_traitsIwE2eqERKwS2_@GLIBCXX_3.4
+FUNC:_ZNSt11logic_errorC1EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSt11logic_errorC2EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_errorC2EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC2ERKS_@@GLIBCXX_3.4.21
@@ -1871,6 +2173,7 @@ FUNC:_ZNSt11logic_errorC2ERKSs@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt11logic_erroraSEOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_erroraSERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt11range_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
@@ -1903,6 +2206,20 @@ FUNC:_ZNSt12__basic_fileIcEC1EP15pthread_mutex_t@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcEC2EP15pthread_mutex_t@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD2Ev@@GLIBCXX_3.4.15
@@ -2206,6 +2523,7 @@ FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEEaSEOS2_@@GLIBCXX_3.4.21
+FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEDn@@GLIBCXX_3.4.26
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRSt8ios_baseS4_E@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRSt9basic_iosIwS1_ES5_E@@GLIBCXX_3.4
@@ -2231,10 +2549,12 @@ FUNC:_ZNSt13random_device7_M_finiEv@@GLIBCXX_3.4.18
 FUNC:_ZNSt13random_device7_M_initERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13random_device7_M_initERKSs@@GLIBCXX_3.4.18
 FUNC:_ZNSt13random_device9_M_getvalEv@@GLIBCXX_3.4.18
+FUNC:_ZNSt13runtime_errorC1EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSt13runtime_errorC2EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_errorC2EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC2ERKS_@@GLIBCXX_3.4.21
@@ -2242,6 +2562,7 @@ FUNC:_ZNSt13runtime_errorC2ERKSs@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt13runtime_erroraSEOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_erroraSERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openERKNSt7__cxx1112basic_stringIcS1_SaIcEEESt13_Ios_Openmode@@GLIBCXX_3.4.21
@@ -2353,12 +2674,16 @@ FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcEC1EPKcm@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIcEC1ERKSsm@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIcEC2EPKcm@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIcEC2ERKSsm@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIcED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwEC1EPKcm@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIwEC1ERKSsm@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIwEC2EPKcm@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIwEC2ERKSsm@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIwED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwED2Ev@@GLIBCXX_3.4
@@ -2498,9 +2823,11 @@ FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE9underflowEv@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEaSEOS3_@@GLIBCXX_3.4.21
@@ -2520,9 +2847,11 @@ FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE9underflowEv@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEaSEOS3_@@GLIBCXX_3.4.21
@@ -2730,9 +3059,11 @@ FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4.
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2742,9 +3073,11 @@ FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4.
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2756,6 +3089,7 @@ FUNC:_ZNSt18condition_variableC1Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableC2Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableD1Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableD2Ev@@GLIBCXX_3.4.11
+FUNC:_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info@@GLIBCXX_3.4.26
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED2Ev@@GLIBCXX_3.4.21
@@ -2770,9 +3104,11 @@ FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2782,9 +3118,11 @@ FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2794,9 +3132,11 @@ FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2806,9 +3146,11 @@ FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2849,6 +3191,26 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceC1ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceC2ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceC1ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceC2ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt5ctypeIcE13classic_tableEv@@GLIBCXX_3.4
 FUNC:_ZNSt5ctypeIcEC1EP15__locale_structPKtbm@@GLIBCXX_3.4
 FUNC:_ZNSt5ctypeIcEC1EPKtbm@@GLIBCXX_3.4
@@ -2982,6 +3344,8 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIN9__gnu
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIN9__gnu_cxx17__normal_iteratorIPcS4_EEEEvT_SA_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12__sv_wrapperC1ESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12__sv_wrapperC2ESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_M_local_dataEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_M_set_lengthEm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcS4_EESA_@@GLIBCXX_3.4.21
@@ -2991,10 +3355,12 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcS5_S
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13shrink_to_fitEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEmmmc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE16_M_get_allocatorEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE17_S_to_string_viewESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE18_M_construct_aux_2Emc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE2atEm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE3endEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4backEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4rendEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4swapERS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5beginEv@@GLIBCXX_3.4.21
@@ -3018,6 +3384,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignERKS4_@@GLIBCXX
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignERKS4_mm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignESt16initializer_listIcE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignEmc@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EESt16initializer_listIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEmc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPcS4_EESt16initializer_listIcE@@GLIBCXX_3.4.21
@@ -3067,6 +3434,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_lengthEm@@GLIBCXX_
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEmmPKcm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcmc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_@@GLIBCXX_3.4.21
@@ -3083,6 +3451,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IN9__gnu_cxx17__normal_iteratorIPcS4_EEvEET_SA_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IPKcvEET_S8_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IPcvEET_S7_RKS3_@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EPKcRKS3_@@GLIBCXX_3.4.21
@@ -3125,6 +3494,8 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIN9__gnu
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIN9__gnu_cxx17__normal_iteratorIPwS4_EEEEvT_SA_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIPKwEEvT_S8_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIPwEEvT_S7_St20forward_iterator_tag@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12__sv_wrapperC1ESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12__sv_wrapperC2ESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_M_local_dataEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_M_set_lengthEm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIPKwS4_EESA_@@GLIBCXX_3.4.21
@@ -3134,10 +3505,12 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwS5_S
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13shrink_to_fitEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE14_M_replace_auxEmmmw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE16_M_get_allocatorEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE17_S_to_string_viewESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE18_M_construct_aux_2Emw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE2atEm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE3endEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4backEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4rendEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4swapERS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE5beginEv@@GLIBCXX_3.4.21
@@ -3161,6 +3534,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignERKS4_@@GLIBCXX
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignERKS4_mm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignESt16initializer_listIwE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignEmw@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EESt16initializer_listIwE@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EEmw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EEw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS4_EESt16initializer_listIwE@@GLIBCXX_3.4.21
@@ -3210,6 +3584,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_M_lengthEm@@GLIBCXX_
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_M_mutateEmmPKwm@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_S_assignEPwmw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9push_backEw@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EPKwRKS3_@@GLIBCXX_3.4.21
@@ -3226,6 +3601,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IN9__gnu_cxx17__normal_iteratorIPwS4_EEvEET_SA_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IPKwvEET_S8_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IPwvEET_S7_RKS3_@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EPKwRKS3_@@GLIBCXX_3.4.21
@@ -3289,10 +3665,12 @@ FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3318,10 +3696,12 @@ FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3401,9 +3781,11 @@ FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLIB
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3413,9 +3795,11 @@ FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLIB
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3425,9 +3809,11 @@ FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3437,9 +3823,11 @@ FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3449,9 +3837,11 @@ FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3461,9 +3851,11 @@ FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3546,9 +3938,15 @@ FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEC2Em@
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED2Ev@@GLIBCXX_3.4.21
@@ -3831,6 +4229,7 @@ FUNC:_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base@@GLIBCXX_3.4
 FUNC:_ZSt18__throw_bad_typeidv@@GLIBCXX_3.4
 FUNC:_ZSt18uncaught_exceptionv@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_ios_failurePKc@@GLIBCXX_3.4
+FUNC:_ZSt19__throw_ios_failurePKci@@GLIBCXX_3.4.26
 FUNC:_ZSt19__throw_logic_errorPKc@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_range_errorPKc@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_regex_errorNSt15regex_constants10error_typeE@@GLIBCXX_3.4.15
@@ -4211,6 +4610,7 @@ OBJECT:0:CXXABI_1.3
 OBJECT:0:CXXABI_1.3.1
 OBJECT:0:CXXABI_1.3.10
 OBJECT:0:CXXABI_1.3.11
+OBJECT:0:CXXABI_1.3.12
 OBJECT:0:CXXABI_1.3.2
 OBJECT:0:CXXABI_1.3.3
 OBJECT:0:CXXABI_1.3.4
@@ -4240,6 +4640,8 @@ OBJECT:0:GLIBCXX_3.4.22
 OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
+OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4326,6 +4728,7 @@ OBJECT:16:_ZTIDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIN10__cxxabiv115__forced_unwindE@@CXXABI_1.3.2
 OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
@@ -4447,6 +4850,19 @@ OBJECT:1:_ZNSt14numeric_limitsIDsE8is_exactE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_iec559E@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_moduloE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_signedE@@GLIBCXX_3.4.11
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_boundedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_integerE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE12has_infinityE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE13has_quiet_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE14is_specializedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15has_denorm_lossE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15tinyness_beforeE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE17has_signaling_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE5trapsE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE8is_exactE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_iec559E@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_moduloE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_signedE@@GLIBCXX_3.4.26
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_boundedE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_integerE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE12has_infinityE@@GLIBCXX_3.4
@@ -4758,6 +5174,8 @@ OBJECT:24:_ZTIN9__gnu_cxx13stdio_filebufIcSt11char_traitsIcEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTIN9__gnu_cxx13stdio_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
+OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
+OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1287num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1287num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
@@ -4767,6 +5185,8 @@ OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIcSt19istreambuf_iteratorIcSt11cha
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
+OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
+OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTINSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
@@ -4865,7 +5285,9 @@ OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt5ctypeIwE@@GLIBCXX_3.4
+OBJECT:24:_ZTISt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTISt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:24:_ZTISt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTISt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:24:_ZTISt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -4952,6 +5374,8 @@ OBJECT:2:_ZTSv@@CXXABI_1.3
 OBJECT:2:_ZTSw@@CXXABI_1.3
 OBJECT:2:_ZTSx@@CXXABI_1.3
 OBJECT:2:_ZTSy@@CXXABI_1.3
+OBJECT:30:_ZTSSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
+OBJECT:30:_ZTSSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:32:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
 OBJECT:32:_ZNSs4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
 OBJECT:32:_ZTIPDd@@CXXABI_1.3.4
@@ -4960,12 +5384,14 @@ OBJECT:32:_ZTIPDf@@CXXABI_1.3.4
 OBJECT:32:_ZTIPDi@@CXXABI_1.3.3
 OBJECT:32:_ZTIPDn@@CXXABI_1.3.5
 OBJECT:32:_ZTIPDs@@CXXABI_1.3.3
+OBJECT:32:_ZTIPDu@@CXXABI_1.3.12
 OBJECT:32:_ZTIPKDd@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDe@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDf@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDi@@CXXABI_1.3.3
 OBJECT:32:_ZTIPKDn@@CXXABI_1.3.5
 OBJECT:32:_ZTIPKDs@@CXXABI_1.3.3
+OBJECT:32:_ZTIPKDu@@CXXABI_1.3.12
 OBJECT:32:_ZTIPKa@@CXXABI_1.3
 OBJECT:32:_ZTIPKb@@CXXABI_1.3
 OBJECT:32:_ZTIPKc@@CXXABI_1.3
@@ -5095,6 +5521,8 @@ OBJECT:40:_ZTSSt14basic_ifstreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:40:_ZTSSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:40:_ZTSSt14basic_ofstreamIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:40:_ZTSSt14basic_ofstreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:40:_ZTVNSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
+OBJECT:40:_ZTVNSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:40:_ZTVNSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:40:_ZTVNSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:40:_ZTVNSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
@@ -5169,6 +5597,15 @@ OBJECT:4:_ZNSt14numeric_limitsIDsE14min_exponent10E@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE5radixE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE6digitsE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE8digits10E@@GLIBCXX_3.4.11
+OBJECT:4:_ZNSt14numeric_limitsIDuE10has_denormE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE11round_styleE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12max_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12min_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14max_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14min_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE5radixE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE6digitsE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE8digits10E@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt14numeric_limitsIaE10has_denormE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE11round_styleE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE12max_digits10E@@GLIBCXX_3.4.14
@@ -5585,7 +6022,9 @@ OBJECT:88:_ZTVSt23__codecvt_abstract_baseIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
+OBJECT:88:_ZTVSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:88:_ZTVSt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:88:_ZTVSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:88:_ZTVSt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:88:_ZTVSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -5679,7 +6118,9 @@ OBJECT:8:_ZNSt7__cxx119money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2
 OBJECT:8:_ZNSt7__cxx119money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7__cxx119money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
+OBJECT:8:_ZNSt7codecvtIDiDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:8:_ZNSt7codecvtIDic11__mbstate_tE2idE@@GLIBCXX_3.4.21
+OBJECT:8:_ZNSt7codecvtIDsDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:8:_ZNSt7codecvtIDsc11__mbstate_tE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7codecvtIcc11__mbstate_tE2idE@@GLIBCXX_3.4
 OBJECT:8:_ZNSt7codecvtIwc11__mbstate_tE2idE@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/hppa-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/hppa-linux-gnu/baseline_symbols.txt
index 18879a8a0be..159e0100b5f 100644
--- a/libstdc++-v3/config/abi/post/hppa-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/hppa-linux-gnu/baseline_symbols.txt
@@ -112,6 +112,7 @@ FUNC:_ZN11__gnu_debug19_Safe_sequence_base13_M_detach_allEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base18_M_detach_singularEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base22_M_revalidate_singularEv@@GLIBCXX_3.4
 FUNC:_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_@@GLIBCXX_3.4
+FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base16_M_attach_singleEPNS_19_Safe_sequence_baseEb@@GLIBCXX_3.4.26
 FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base9_M_attachEPNS_19_Safe_sequence_baseEb@@GLIBCXX_3.4.17
 FUNC:_ZN11__gnu_debug25_Safe_local_iterator_base9_M_detachEv@@GLIBCXX_3.4.17
 FUNC:_ZN11__gnu_debug30_Safe_unordered_container_base13_M_detach_allEv@@GLIBCXX_3.4.17
@@ -261,6 +262,7 @@ FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8_M_limitEjj@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8capacityEv@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE8max_sizeEv@@GLIBCXX_3.4
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEE9_M_ibeginEv@@GLIBCXX_3.4
+FUNC:_ZNKSbIwSt11char_traitsIwESaIwEEcvSt17basic_string_viewIwS0_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSbIwSt11char_traitsIwESaIwEEixEj@@GLIBCXX_3.4
 FUNC:_ZNKSi6gcountEv@@GLIBCXX_3.4
 FUNC:_ZNKSi6sentrycvbEv@@GLIBCXX_3.4
@@ -328,9 +330,66 @@ FUNC:_ZNKSs8_M_limitEjj@@GLIBCXX_3.4
 FUNC:_ZNKSs8capacityEv@@GLIBCXX_3.4
 FUNC:_ZNKSs8max_sizeEv@@GLIBCXX_3.4
 FUNC:_ZNKSs9_M_ibeginEv@@GLIBCXX_3.4
+FUNC:_ZNKSscvSt17basic_string_viewIcSt11char_traitsIcEEEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSsixEj@@GLIBCXX_3.4
 FUNC:_ZNKSt10bad_typeid4whatEv@@GLIBCXX_3.4.9
 FUNC:_ZNKSt10error_code23default_error_conditionEv@@GLIBCXX_3.4.11
+FUNC:_ZNKSt10filesystem16filesystem_error4whatEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem16filesystem_error5path1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem16filesystem_error5path2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem18directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path11parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path12has_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13has_root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13has_root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path13relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path14root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path15has_parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path16lexically_normalEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path17_M_find_extensionEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path17has_relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path18has_root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path18lexically_relativeERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path19lexically_proximateERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List13_Impl_deleterclEPNS1_5_ImplE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List3endEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path5_List5beginEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path7compareERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path7compareESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path9root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem4path9root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error4whatEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1118directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path11parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path12has_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13has_root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13has_root_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path13relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path14root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path15has_parent_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path16lexically_normalEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path17_M_find_extensionEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path17has_relative_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path18has_root_directoryEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path18lexically_relativeERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path19lexically_proximateERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List13_Impl_deleterclEPNS2_5_ImplE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List3endEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path5_List5beginEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path7compareERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path7compareESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path9root_nameEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx114path9root_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10istrstream5rdbufEv@@GLIBCXX_3.4
 FUNC:_ZNKSt10lock_error4whatEv@@GLIBCXX_3.4.11
 FUNC:_ZNKSt10moneypunctIcLb0EE10neg_formatEv@@GLIBCXX_3.4
@@ -734,6 +793,7 @@ FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_checkEjPKc@@GLIBC
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8_M_limitEjj@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8capacityEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8max_sizeEv@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEcvSt17basic_string_viewIcS2_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEixEj@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE11_M_disjunctEPKw@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE11_M_is_localEv@@GLIBCXX_3.4.21
@@ -794,6 +854,7 @@ FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8_M_checkEjPKc@@GLIBC
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8_M_limitEjj@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8capacityEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE8max_sizeEv@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEcvSt17basic_string_viewIwS2_EEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEixEj@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEE3strEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEE3strEv@@GLIBCXX_3.4.21
@@ -925,6 +986,13 @@ FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES4_bRSt8ios_basewe@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb0EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE6do_outERS0_PKDiS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE9do_lengthERS0_PKDuS4_j@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -932,6 +1000,13 @@ FUNC:_ZNKSt7codecvtIDic11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE5do_inERS0_PKcS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE6do_outERS0_PKDiS4_RS4_PcS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE9do_lengthERS0_PKcS4_j@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDsS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE6do_outERS0_PKDsS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE9do_lengthERS0_PKDuS4_j@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -1134,6 +1209,7 @@ FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE16do_get_mont
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE21_M_extract_via_formatES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKc@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE24_M_extract_wday_or_monthES3_S3_RiPPKcjRSt8ios_baseRSt12_Ios_Iostate@@GLIBCXX_3.4.14
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKcSC_@@GLIBCXX_3.4.21
+FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.26
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.21
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE8get_dateES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE8get_timeES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
@@ -1152,6 +1228,7 @@ FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE16do_get_mont
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE21_M_extract_via_formatES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKw@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE24_M_extract_wday_or_monthES3_S3_RiPPKwjRSt8ios_baseRSt12_Ios_Iostate@@GLIBCXX_3.4.14
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmPKwSC_@@GLIBCXX_3.4.21
+FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.26
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tmcc@@GLIBCXX_3.4.21
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE8get_dateES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
 FUNC:_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE8get_timeES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm@@GLIBCXX_3.4
@@ -1244,6 +1321,8 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIN9__gnu_cxx17__normal_iterato
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIPKwEEPwT_S7_RKS1_St20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_constructIPwEES4_T_S5_RKS1_St20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12_S_empty_repEv@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12__sv_wrapperC1ESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE12__sv_wrapperC2ESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIPKwS2_EES8_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIS3_S2_EES6_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwPKwS5_@@GLIBCXX_3.4
@@ -1251,6 +1330,7 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwS3_S3_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE13shrink_to_fitEv@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE14_M_replace_auxEjjjw@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE15_M_replace_safeEjjPKwj@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE17_S_to_string_viewESt17basic_string_viewIwS0_E@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE18_S_construct_aux_2EjwRKS1_@@GLIBCXX_3.4.14
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE2atEj@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE3endEv@@GLIBCXX_3.4
@@ -1267,6 +1347,7 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep7_M_grabERKS1_S5_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep8_M_cloneERKS1_j@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep9_S_createEjjRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4backEv@@GLIBCXX_3.4.15
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4rendEv@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE4swapERS2_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE5beginEv@@GLIBCXX_3.4
@@ -1325,11 +1406,14 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwjw@@GLIBCXX_3.4.5
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwjw@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9_M_mutateEjjj@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ENS2_12__sv_wrapperERKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EOS2_@@GLIBCXX_3.4.14
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EOS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwjRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jRKS1_@@GLIBCXX_3.4.24
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jj@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_@@GLIBCXX_3.4
@@ -1339,11 +1423,14 @@ FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IN9__gnu_cxx17__normal_iteratorIPwS2_EEEET_S8_RKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IPKwEET_S6_RKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC1IPwEET_S5_RKS1_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ENS2_12__sv_wrapperERKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EOS2_@@GLIBCXX_3.4.15
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EOS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EPKwRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2EPKwjRKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS1_@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_@@GLIBCXX_3.4
+FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_RKS1_@@GLIBCXX_3.4.26
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_jRKS1_@@GLIBCXX_3.4.24
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_jj@@GLIBCXX_3.4
 FUNC:_ZNSbIwSt11char_traitsIwESaIwEEC2ERKS2_jjRKS1_@@GLIBCXX_3.4
@@ -1471,6 +1558,7 @@ FUNC:_ZNSoD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSoD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSoD2Ev@@GLIBCXX_3.4
 FUNC:_ZNSoaSEOSo@@GLIBCXX_3.4.21
+FUNC:_ZNSolsEDn@@GLIBCXX_3.4.26
 FUNC:_ZNSolsEPFRSoS_E@@GLIBCXX_3.4
 FUNC:_ZNSolsEPFRSt8ios_baseS0_E@@GLIBCXX_3.4
 FUNC:_ZNSolsEPFRSt9basic_iosIcSt11char_traitsIcEES3_E@@GLIBCXX_3.4
@@ -1497,6 +1585,8 @@ FUNC:_ZNSs12_S_constructIN9__gnu_cxx17__normal_iteratorIPcSsEEEES2_T_S4_RKSaIcES
 FUNC:_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSs12_S_constructIPcEES0_T_S1_RKSaIcESt20forward_iterator_tag@@GLIBCXX_3.4.14
 FUNC:_ZNSs12_S_empty_repEv@@GLIBCXX_3.4
+FUNC:_ZNSs12__sv_wrapperC1ESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSs12__sv_wrapperC2ESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
 FUNC:_ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcSsEES4_@@GLIBCXX_3.4
 FUNC:_ZNSs13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIS_SsEES2_@@GLIBCXX_3.4
 FUNC:_ZNSs13_S_copy_charsEPcPKcS1_@@GLIBCXX_3.4
@@ -1504,6 +1594,7 @@ FUNC:_ZNSs13_S_copy_charsEPcS_S_@@GLIBCXX_3.4
 FUNC:_ZNSs13shrink_to_fitEv@@GLIBCXX_3.4.14
 FUNC:_ZNSs14_M_replace_auxEjjjc@@GLIBCXX_3.4
 FUNC:_ZNSs15_M_replace_safeEjjPKcj@@GLIBCXX_3.4
+FUNC:_ZNSs17_S_to_string_viewESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
 FUNC:_ZNSs18_S_construct_aux_2EjcRKSaIcE@@GLIBCXX_3.4.14
 FUNC:_ZNSs2atEj@@GLIBCXX_3.4
 FUNC:_ZNSs3endEv@@GLIBCXX_3.4
@@ -1520,6 +1611,7 @@ FUNC:_ZNSs4_Rep7_M_grabERKSaIcES2_@@GLIBCXX_3.4
 FUNC:_ZNSs4_Rep8_M_cloneERKSaIcEj@@GLIBCXX_3.4
 FUNC:_ZNSs4_Rep9_S_createEjjRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSs4backEv@@GLIBCXX_3.4.15
+FUNC:_ZNSs4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSs4rendEv@@GLIBCXX_3.4
 FUNC:_ZNSs4swapERSs@@GLIBCXX_3.4
 FUNC:_ZNSs5beginEv@@GLIBCXX_3.4
@@ -1578,11 +1670,14 @@ FUNC:_ZNSs9_M_assignEPcjc@@GLIBCXX_3.4.5
 FUNC:_ZNSs9_M_assignEPcjc@GLIBCXX_3.4
 FUNC:_ZNSs9_M_mutateEjjj@@GLIBCXX_3.4
 FUNC:_ZNSs9push_backEc@@GLIBCXX_3.4
+FUNC:_ZNSsC1ENSs12__sv_wrapperERKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1EOSs@@GLIBCXX_3.4.14
+FUNC:_ZNSsC1EOSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1EPKcRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1EPKcjRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSsC1ERKSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC1ERKSsjRKSaIcE@@GLIBCXX_3.4.23
 FUNC:_ZNSsC1ERKSsjj@@GLIBCXX_3.4
 FUNC:_ZNSsC1ERKSsjjRKSaIcE@@GLIBCXX_3.4
@@ -1592,11 +1687,14 @@ FUNC:_ZNSsC1Ev@@GLIBCXX_3.4
 FUNC:_ZNSsC1IN9__gnu_cxx17__normal_iteratorIPcSsEEEET_S4_RKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1IPKcEET_S2_RKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC1IPcEET_S1_RKSaIcE@@GLIBCXX_3.4
+FUNC:_ZNSsC2ENSs12__sv_wrapperERKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2EOSs@@GLIBCXX_3.4.15
+FUNC:_ZNSsC2EOSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2EPKcRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2EPKcjRKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSaIcE@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSsC2ERKSsRKSaIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSsC2ERKSsjRKSaIcE@@GLIBCXX_3.4.23
 FUNC:_ZNSsC2ERKSsjj@@GLIBCXX_3.4
 FUNC:_ZNSsC2ERKSsjjRKSaIcE@@GLIBCXX_3.4
@@ -1628,6 +1726,208 @@ FUNC:_ZNSt10__num_base15_S_format_floatERKSt8ios_basePcc@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt10bad_typeidD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt10filesystem10equivalentERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10equivalentERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10hash_valueERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem10remove_allERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_4pathENS_5permsENS_12perm_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_4pathENS_5permsENS_12perm_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_7__cxx114pathENS_5permsENS_12perm_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11permissionsERKNS_7__cxx114pathENS_5permsENS_12perm_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_4pathEy@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_4pathEyRSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_7__cxx114pathEy@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem11resize_fileERKNS_7__cxx114pathEyRSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12copy_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathB5cxx11ERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathB5cxx11Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12current_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem12read_symlinkERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14create_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem14symlink_statusERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15hard_link_countERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathENSt6chrono10time_pointINS_12__file_clockENS3_8durationIxSt5ratioILx1ELx1000000000EEEEEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathENSt6chrono10time_pointINS_12__file_clockENS3_8durationIxSt5ratioILx1ELx1000000000EEEEEERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathENSt6chrono10time_pointINS_12__file_clockENS4_8durationIxSt5ratioILx1ELx1000000000EEEEEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathENSt6chrono10time_pointINS_12__file_clockENS4_8durationIxSt5ratioILx1ELx1000000000EEEEEERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem15last_write_timeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_directoryERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16create_hard_linkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsRKNS_4pathES5_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsRKNS_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC1ERKSsSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsRKNS_4pathES5_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsRKNS_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorC2ERKSsSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem16weakly_canonicalERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathB5cxx11ERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathB5cxx11Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem19temp_directory_pathEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
+FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_7__cxx114pathES3_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4copyERKNS_7__cxx114pathES3_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path14_M_split_cmptsEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path14_S_convert_locEPKcS2_RKSt6locale@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path15remove_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path16replace_filenameERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path17replace_extensionERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path5_ListC1ERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path5_ListC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path9_M_appendESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4path9_M_concatESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathaSERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathdVERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem4pathpLERKS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem5spaceERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6removeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6renameERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem6statusERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1110hash_valueERKNS0_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESC_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESC_St10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_4pathESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path15remove_filenameEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path16replace_filenameERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path17replace_extensionERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path5_ListC1ERKS2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path5_ListC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path9_M_appendESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114path9_M_concatESt17basic_string_viewIcSt11char_traitsIcEE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathaSERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathdVERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx114pathpLERKS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8absoluteERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8is_emptyERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem8relativeERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9canonicalERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_7__cxx114pathES3_NS_12copy_optionsE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9copy_fileERKNS_7__cxx114pathES3_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_4pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9file_sizeERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_4pathES2_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem9proximateERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10istrstream3strEv@@GLIBCXX_3.4
 FUNC:_ZNSt10istrstreamC1EPKc@@GLIBCXX_3.4
 FUNC:_ZNSt10istrstreamC1EPKci@@GLIBCXX_3.4
@@ -1714,10 +2014,12 @@ FUNC:_ZNSt11char_traitsIcE2eqERKcS2_@@GLIBCXX_3.4.5
 FUNC:_ZNSt11char_traitsIcE2eqERKcS2_@GLIBCXX_3.4
 FUNC:_ZNSt11char_traitsIwE2eqERKwS2_@@GLIBCXX_3.4.5
 FUNC:_ZNSt11char_traitsIwE2eqERKwS2_@GLIBCXX_3.4
+FUNC:_ZNSt11logic_errorC1EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSt11logic_errorC2EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_errorC2EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt11logic_errorC2ERKS_@@GLIBCXX_3.4.21
@@ -1725,6 +2027,7 @@ FUNC:_ZNSt11logic_errorC2ERKSs@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt11logic_errorD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt11logic_erroraSEOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt11logic_erroraSERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt11range_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
@@ -1757,6 +2060,24 @@ FUNC:_ZNSt12__basic_fileIcEC1EP15pthread_mutex_t@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcEC2EP15pthread_mutex_t@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD2Ev@@GLIBCXX_3.4.15
@@ -2057,6 +2378,7 @@ FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEEaSEOS2_@@GLIBCXX_3.4.21
+FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEDn@@GLIBCXX_3.4.26
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRSt8ios_baseS4_E@@GLIBCXX_3.4
 FUNC:_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRSt9basic_iosIwS1_ES5_E@@GLIBCXX_3.4
@@ -2081,10 +2403,12 @@ FUNC:_ZNSt13random_device7_M_finiEv@@GLIBCXX_3.4.18
 FUNC:_ZNSt13random_device7_M_initERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13random_device7_M_initERKSs@@GLIBCXX_3.4.18
 FUNC:_ZNSt13random_device9_M_getvalEv@@GLIBCXX_3.4.18
+FUNC:_ZNSt13runtime_errorC1EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_errorC1EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC1ERKSs@@GLIBCXX_3.4
+FUNC:_ZNSt13runtime_errorC2EOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_errorC2EPKc@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
 FUNC:_ZNSt13runtime_errorC2ERKS_@@GLIBCXX_3.4.21
@@ -2092,6 +2416,7 @@ FUNC:_ZNSt13runtime_errorC2ERKSs@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt13runtime_errorD2Ev@@GLIBCXX_3.4
+FUNC:_ZNSt13runtime_erroraSEOS_@@GLIBCXX_3.4.26
 FUNC:_ZNSt13runtime_erroraSERKS_@@GLIBCXX_3.4.21
 FUNC:_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openERKNSt7__cxx1112basic_stringIcS1_SaIcEEESt13_Ios_Openmode@@GLIBCXX_3.4.21
@@ -2203,12 +2528,16 @@ FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14codecvt_bynameIwc11__mbstate_tED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcEC1EPKcj@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIcEC1ERKSsj@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIcEC2EPKcj@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIcEC2ERKSsj@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIcED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwEC1EPKcj@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIwEC1ERKSsj@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIwEC2EPKcj@@GLIBCXX_3.4
+FUNC:_ZNSt14collate_bynameIwEC2ERKSsj@@GLIBCXX_3.4.26
 FUNC:_ZNSt14collate_bynameIwED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt14collate_bynameIwED2Ev@@GLIBCXX_3.4
@@ -2348,9 +2677,11 @@ FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE9underflowEv@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEaSEOS3_@@GLIBCXX_3.4.21
@@ -2370,9 +2701,11 @@ FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE9underflowEv@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEEaSEOS3_@@GLIBCXX_3.4.21
@@ -2540,9 +2873,11 @@ FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4.
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2552,9 +2887,11 @@ FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4.
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2566,6 +2903,7 @@ FUNC:_ZNSt18condition_variableC1Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableC2Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableD1Ev@@GLIBCXX_3.4.11
 FUNC:_ZNSt18condition_variableD2Ev@@GLIBCXX_3.4.11
+FUNC:_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info@@GLIBCXX_3.4.26
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt19__codecvt_utf8_baseIDiED2Ev@@GLIBCXX_3.4.21
@@ -2580,9 +2918,11 @@ FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2592,9 +2932,11 @@ FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_istringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2604,9 +2946,11 @@ FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ERKSsSt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4
@@ -2616,9 +2960,11 @@ FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEE4swapERS3_@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2EOS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ERKSbIwS1_S2_ESt13_Ios_Openmode@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4
+FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4
@@ -2659,6 +3005,26 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceC1ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceC2ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr26synchronized_pool_resourceD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceC1ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceC2ERKNS_12pool_optionsEPNS_15memory_resourceE@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceD1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr28unsynchronized_pool_resourceD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt5ctypeIcE13classic_tableEv@@GLIBCXX_3.4
 FUNC:_ZNSt5ctypeIcEC1EP15__locale_structPKtbj@@GLIBCXX_3.4
 FUNC:_ZNSt5ctypeIcEC1EPKtbj@@GLIBCXX_3.4
@@ -2792,6 +3158,8 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIN9__gnu
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIN9__gnu_cxx17__normal_iteratorIPcS4_EEEEvT_SA_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12__sv_wrapperC1ESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12__sv_wrapperC2ESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_M_local_dataEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_M_set_lengthEj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcN9__gnu_cxx17__normal_iteratorIPKcS4_EESA_@@GLIBCXX_3.4.21
@@ -2801,10 +3169,12 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13_S_copy_charsEPcS5_S
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE13shrink_to_fitEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE14_M_replace_auxEjjjc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE16_M_get_allocatorEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE17_S_to_string_viewESt17basic_string_viewIcS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE18_M_construct_aux_2Ejc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE2atEj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE3endEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4backEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4rendEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4swapERS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5beginEv@@GLIBCXX_3.4.21
@@ -2828,6 +3198,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignERKS4_@@GLIBCXX
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignERKS4_jj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignESt16initializer_listIcE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6assignEjc@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EESt16initializer_listIcE@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPKcS4_EEjc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6insertEN9__gnu_cxx17__normal_iteratorIPcS4_EESt16initializer_listIcE@@GLIBCXX_3.4.21
@@ -2877,6 +3248,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_lengthEj@@GLIBCXX_
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_S_assignEPcjc@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9push_backEc@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EPKcRKS3_@@GLIBCXX_3.4.21
@@ -2893,6 +3265,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IN9__gnu_cxx17__normal_iteratorIPcS4_EEvEET_SA_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IPKcvEET_S8_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IPcvEET_S7_RKS3_@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2EPKcRKS3_@@GLIBCXX_3.4.21
@@ -2935,6 +3308,8 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIN9__gnu
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIN9__gnu_cxx17__normal_iteratorIPwS4_EEEEvT_SA_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIPKwEEvT_S8_St20forward_iterator_tag@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12_M_constructIPwEEvT_S7_St20forward_iterator_tag@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12__sv_wrapperC1ESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE12__sv_wrapperC2ESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_M_local_dataEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_M_set_lengthEj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwN9__gnu_cxx17__normal_iteratorIPKwS4_EESA_@@GLIBCXX_3.4.21
@@ -2944,10 +3319,12 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13_S_copy_charsEPwS5_S
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE13shrink_to_fitEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE14_M_replace_auxEjjjw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE16_M_get_allocatorEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE17_S_to_string_viewESt17basic_string_viewIwS2_E@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE18_M_construct_aux_2Ejw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE2atEj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE3endEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4backEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4dataEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4rendEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE4swapERS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE5beginEv@@GLIBCXX_3.4.21
@@ -2971,6 +3348,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignERKS4_@@GLIBCXX
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignERKS4_jj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignESt16initializer_listIwE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6assignEjw@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EESt16initializer_listIwE@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EEjw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPKwS4_EEw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS4_EESt16initializer_listIwE@@GLIBCXX_3.4.21
@@ -3020,6 +3398,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_M_lengthEj@@GLIBCXX_
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_M_mutateEjjPKwj@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9_S_assignEPwjw@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEE9push_backEw@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1EPKwRKS3_@@GLIBCXX_3.4.21
@@ -3036,6 +3415,7 @@ FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IN9__gnu_cxx17__normal_iteratorIPwS4_EEvEET_SA_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IPKwvEET_S8_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC1IPwvEET_S7_RKS3_@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2ENS4_12__sv_wrapperERKS3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EOS4_RKS3_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEC2EPKwRKS3_@@GLIBCXX_3.4.21
@@ -3099,10 +3479,12 @@ FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3128,10 +3510,12 @@ FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2EOS4_ONS4_14__xfer_bufptrsE@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3211,9 +3595,11 @@ FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLIB
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3223,9 +3609,11 @@ FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLIB
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1118basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3235,9 +3623,11 @@ FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3247,9 +3637,11 @@ FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_istringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3259,9 +3651,11 @@ FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ERKNS_12basic_stringIcS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIcSt11char_traitsIcESaIcEED2Ev@@GLIBCXX_3.4.21
@@ -3271,9 +3665,11 @@ FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEE4swapERS4_@@GLI
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2EOS4_@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ERKNS_12basic_stringIwS2_S3_EESt13_Ios_Openmode@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2ESt13_Ios_Openmode@@GLIBCXX_3.4.21
+FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEEC2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx1119basic_ostringstreamIwSt11char_traitsIwESaIwEED2Ev@@GLIBCXX_3.4.21
@@ -3356,9 +3752,15 @@ FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEC2Ej@
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED2Ev@@GLIBCXX_3.4.21
@@ -3640,6 +4042,7 @@ FUNC:_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base@@GLIBCXX_3.4
 FUNC:_ZSt18__throw_bad_typeidv@@GLIBCXX_3.4
 FUNC:_ZSt18uncaught_exceptionv@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_ios_failurePKc@@GLIBCXX_3.4
+FUNC:_ZSt19__throw_ios_failurePKci@@GLIBCXX_3.4.26
 FUNC:_ZSt19__throw_logic_errorPKc@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_range_errorPKc@@GLIBCXX_3.4
 FUNC:_ZSt19__throw_regex_errorNSt15regex_constants10error_typeE@@GLIBCXX_3.4.15
@@ -4000,6 +4403,7 @@ OBJECT:0:CXXABI_1.3
 OBJECT:0:CXXABI_1.3.1
 OBJECT:0:CXXABI_1.3.10
 OBJECT:0:CXXABI_1.3.11
+OBJECT:0:CXXABI_1.3.12
 OBJECT:0:CXXABI_1.3.2
 OBJECT:0:CXXABI_1.3.3
 OBJECT:0:CXXABI_1.3.4
@@ -4028,6 +4432,9 @@ OBJECT:0:GLIBCXX_3.4.22
 OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
+OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4051,7 +4458,11 @@ OBJECT:12:_ZTIN9__gnu_cxx13stdio_filebufIcSt11char_traitsIcEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTIN9__gnu_cxx13stdio_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
+OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
+OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
+OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTINSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3.4.21
@@ -4150,7 +4561,9 @@ OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt5ctypeIwE@@GLIBCXX_3.4
+OBJECT:12:_ZTISt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTISt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:12:_ZTISt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTISt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:12:_ZTISt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -4210,12 +4623,14 @@ OBJECT:16:_ZTIPDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIPDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIPDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIPDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIPDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIPKDd@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDe@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIPKDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIPKDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIPKDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIPKa@@CXXABI_1.3
 OBJECT:16:_ZTIPKb@@CXXABI_1.3
 OBJECT:16:_ZTIPKc@@CXXABI_1.3
@@ -4349,6 +4764,19 @@ OBJECT:1:_ZNSt14numeric_limitsIDsE8is_exactE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_iec559E@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_moduloE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_signedE@@GLIBCXX_3.4.11
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_boundedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_integerE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE12has_infinityE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE13has_quiet_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE14is_specializedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15has_denorm_lossE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15tinyness_beforeE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE17has_signaling_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE5trapsE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE8is_exactE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_iec559E@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_moduloE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_signedE@@GLIBCXX_3.4.26
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_boundedE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_integerE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE12has_infinityE@@GLIBCXX_3.4
@@ -4592,6 +5020,8 @@ OBJECT:1:_ZSt7nothrow@@GLIBCXX_3.4
 OBJECT:20:_ZTSSt12ctype_bynameIcE@@GLIBCXX_3.4
 OBJECT:20:_ZTSSt12ctype_bynameIwE@@GLIBCXX_3.4
 OBJECT:20:_ZTSSt15underflow_error@@GLIBCXX_3.4
+OBJECT:20:_ZTVNSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
+OBJECT:20:_ZTVNSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:20:_ZTVNSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:20:_ZTVNSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:20:_ZTVNSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
@@ -4720,6 +5150,8 @@ OBJECT:2:_ZTSv@@CXXABI_1.3
 OBJECT:2:_ZTSw@@CXXABI_1.3
 OBJECT:2:_ZTSx@@CXXABI_1.3
 OBJECT:2:_ZTSy@@CXXABI_1.3
+OBJECT:30:_ZTSSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
+OBJECT:30:_ZTSSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIcLb0EEE@@GLIBCXX_3.4.21
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIcLb1EEE@@GLIBCXX_3.4.21
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIwLb0EEE@@GLIBCXX_3.4.21
@@ -4874,7 +5306,9 @@ OBJECT:44:_ZTVSt23__codecvt_abstract_baseIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
+OBJECT:44:_ZTVSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:44:_ZTVSt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:44:_ZTVSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:44:_ZTVSt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:44:_ZTVSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -4926,6 +5360,15 @@ OBJECT:4:_ZNSt14numeric_limitsIDsE14min_exponent10E@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE5radixE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE6digitsE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE8digits10E@@GLIBCXX_3.4.11
+OBJECT:4:_ZNSt14numeric_limitsIDuE10has_denormE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE11round_styleE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12max_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12min_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14max_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14min_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE5radixE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE6digitsE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE8digits10E@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt14numeric_limitsIaE10has_denormE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE11round_styleE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE12max_digits10E@@GLIBCXX_3.4.14
@@ -5125,7 +5568,9 @@ OBJECT:4:_ZNSt7__cxx119money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2
 OBJECT:4:_ZNSt7__cxx119money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7__cxx119money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
+OBJECT:4:_ZNSt7codecvtIDiDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt7codecvtIDic11__mbstate_tE2idE@@GLIBCXX_3.4.21
+OBJECT:4:_ZNSt7codecvtIDsDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt7codecvtIDsc11__mbstate_tE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7codecvtIcc11__mbstate_tE2idE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt7codecvtIwc11__mbstate_tE2idE@@GLIBCXX_3.4
@@ -5324,6 +5769,7 @@ OBJECT:8:_ZTIDf@@CXXABI_1.3.4
 OBJECT:8:_ZTIDi@@CXXABI_1.3.3
 OBJECT:8:_ZTIDn@@CXXABI_1.3.5
 OBJECT:8:_ZTIDs@@CXXABI_1.3.3
+OBJECT:8:_ZTIDu@@CXXABI_1.3.12
 OBJECT:8:_ZTIN10__cxxabiv115__forced_unwindE@@CXXABI_1.3.2
 OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
diff --git a/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
index dcc61af7410..e488ada5c72 100644
--- a/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4402,6 +4408,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
index 7edc3395008..dc1a34fa9f5 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4361,6 +4371,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
index 963b2d4abf1..c097965d4b2 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4361,6 +4371,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
index d865017cba6..2a8f88bac7b 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4363,6 +4373,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
index d6080893ea2..85796b3689b 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4363,6 +4373,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
index dcc61af7410..e488ada5c72 100644
--- a/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4402,6 +4408,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/powerpc-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/powerpc-linux-gnu/baseline_symbols.txt
index 9d46d94a457..5cb72bbfcb4 100644
--- a/libstdc++-v3/config/abi/post/powerpc-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/powerpc-linux-gnu/baseline_symbols.txt
@@ -1975,6 +1975,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -2031,6 +2032,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2206,13 +2208,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4635,6 +4641,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt
index 9d46d94a457..5cb72bbfcb4 100644
--- a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt
@@ -1975,6 +1975,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -2031,6 +2032,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2206,13 +2208,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4635,6 +4641,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
index c58d963cc65..65ee06d5c2a 100644
--- a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
@@ -1975,6 +1975,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -2031,6 +2032,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2206,13 +2208,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4635,6 +4641,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
index c58d963cc65..65ee06d5c2a 100644
--- a/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
@@ -1975,6 +1975,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -2031,6 +2032,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2206,13 +2208,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4635,6 +4641,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
index 0a49a0b0e91..b4b39e3fbae 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4360,6 +4370,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
index 6df91465a9d..769d83c53bb 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4360,6 +4370,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
index da16a61f472..ceb8f02d402 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4362,6 +4372,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
index 1dacb5ae9aa..b8a89bb1ef4 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
@@ -1804,6 +1804,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1860,6 +1861,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2031,13 +2033,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4362,6 +4372,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
index dcc61af7410..e488ada5c72 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4402,6 +4408,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
index 871afd61294..a403f4b660a 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4402,6 +4408,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
index 7bea5e94608..990abf00d70 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt
@@ -1829,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1885,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2060,13 +2062,17 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -4402,6 +4408,7 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/config/abi/pre/gnu.ver b/libstdc++-v3/config/abi/pre/gnu.ver
index ff4b74cb971..ff1cc32614d 100644
--- a/libstdc++-v3/config/abi/pre/gnu.ver
+++ b/libstdc++-v3/config/abi/pre/gnu.ver
@@ -2268,11 +2268,11 @@ GLIBCXX_3.4.26 {
 
 GLIBCXX_3.4.27 {
 
-    # __shared_ptr<_Dir>::__shared_ptr()
+    # __shared_ptr<_Dir>::__shared_ptr() (base object ctor)
     _ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE[012]EEC2Ev;
     _ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE[012]EEC2Ev;
 
-    # __shared_ptr<recursive_directory_iterator::_Dir_stack>::__shared_ptr()
+    # __shared_ptr<recursive_directory_iterator::_Dir_stack>::__shared_ptr() (base object ctor)
     _ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE[012]EEC2Ev;
     _ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE[012]EEC2Ev;
 
@@ -2282,6 +2282,24 @@ GLIBCXX_3.4.27 {
 
 } GLIBCXX_3.4.26;
 
+GLIBCXX_3.4.28 {
+
+    # __shared_ptr<_Dir>::__shared_ptr(__shared_ptr&&) (base object ctor)
+    _ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE[012]EEC2EOS4_;
+    _ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE[012]EEC2EOS5_;
+
+    # __shared_ptr<recursive_directory_iterator::_Dir_stack>::__shared_ptr(__shared_ptr&&) (base object ctor)
+    _ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE[012]EEC2EOS5_;
+    _ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE[012]EEC2EOS6_;
+
+    # key functions, vtables and rtti for memory resources
+    _ZNSt3pmr15memory_resourceD[0125]Ev;
+    _ZT[ISV]NSt3pmr15memory_resourceE;
+    _ZNSt3pmr25monotonic_buffer_resourceD[0125]Ev;
+    _ZT[ISV]NSt3pmr25monotonic_buffer_resourceE;
+
+} GLIBCXX_3.4.27;
+
 # Symbols in the support library (libsupc++) have their own tag.
 CXXABI_1.3 {
 
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 5acf79cba54..1225edc596b 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -895,6 +895,7 @@ ac_user_opts='
 enable_option_checking
 enable_multilib
 enable_silent_rules
+enable_largefile
 with_target_subdir
 with_cross_host
 with_newlib
@@ -1579,6 +1580,7 @@ Optional Features:
   --enable-multilib       build many library versions (default)
   --enable-silent-rules   less verbose build output (undo: "make V=1")
   --disable-silent-rules  verbose build output (undo: "make V=0")
+  --disable-largefile     omit support for large files
   --enable-maintainer-mode
                           enable make rules and dependencies not useful (and
                           sometimes confusing) to the casual installer
@@ -4928,9 +4930,210 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 CXXFLAGS="$save_CXXFLAGS"
 
+
+# Check whether --enable-largefile was given.
+if test "${enable_largefile+set}" = set; then :
+  enableval=$enable_largefile;
+fi
+
+if test "$enable_largefile" != no; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
+$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
+if ${ac_cv_sys_largefile_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_sys_largefile_CC=no
+     if test "$GCC" != yes; then
+       ac_save_CC=$CC
+       while :; do
+	 # IRIX 6.2 and later do not support large files by default,
+	 # so use the C compiler's -n32 option if that helps.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 CC="$CC -n32"
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_largefile_CC=' -n32'; break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 break
+       done
+       CC=$ac_save_CC
+       rm -f conftest.$ac_ext
+    fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
+$as_echo "$ac_cv_sys_largefile_CC" >&6; }
+  if test "$ac_cv_sys_largefile_CC" != no; then
+    CC=$CC$ac_cv_sys_largefile_CC
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
+if ${ac_cv_sys_file_offset_bits+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=64; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_file_offset_bits=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
+$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
+case $ac_cv_sys_file_offset_bits in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  if test $ac_cv_sys_file_offset_bits = unknown; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
+$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
+if ${ac_cv_sys_large_files+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _LARGE_FILES 1
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=1; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_large_files=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
+$as_echo "$ac_cv_sys_large_files" >&6; }
+case $ac_cv_sys_large_files in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGE_FILES $ac_cv_sys_large_files
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  fi
+
+
+fi
+
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
-
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -11845,7 +12048,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11848 "configure"
+#line 12051 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11951,7 +12154,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11954 "configure"
+#line 12157 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15637,7 +15840,7 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15640 "configure"
+#line 15843 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15672,7 +15875,7 @@ $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15675 "configure"
+#line 15878 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15707,7 +15910,7 @@ $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15710 "configure"
+#line 15913 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15743,7 +15946,7 @@ $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15746 "configure"
+#line 15949 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15896,7 +16099,7 @@ $as_echo "mutex" >&6; }
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15899 "configure"
+#line 16102 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15938,7 +16141,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15941 "configure"
+#line 16144 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15972,7 +16175,7 @@ $as_echo "$enable_int128" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15975 "configure"
+#line 16178 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -20835,35 +21038,72 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
         ac_has_sched_yield=yes
         ;;
       gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for at least GNU libc 2.17" >&5
-$as_echo_n "checking for at least GNU libc 2.17... " >&6; }
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+        # Don't use link test for freestanding library, in case gcc_no_link=yes
+        if test x"$is_hosted" = xyes; then
+          # Versions of glibc before 2.17 needed -lrt for clock_gettime.
+          { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+$as_echo_n "checking for library containing clock_gettime... " >&6; }
+if ${ac_cv_search_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <features.h>
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
 int
 main ()
 {
-
-          #if ! __GLIBC_PREREQ(2, 17)
-          #error
-          #endif
-
+return clock_gettime ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  glibcxx_glibc217=yes
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if test x$gcc_no_link = xyes; then
+  as_fn_error $? "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_search_clock_gettime=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_clock_gettime+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_clock_gettime+:} false; then :
+
 else
-  glibcxx_glibc217=no
+  ac_cv_search_clock_gettime=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
+$as_echo "$ac_cv_search_clock_gettime" >&6; }
+ac_res=$ac_cv_search_clock_gettime
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_glibc217" >&5
-$as_echo "$glibcxx_glibc217" >&6; }
 
-        if test x"$glibcxx_glibc217" = x"yes"; then
-          ac_has_clock_monotonic=yes
-          ac_has_clock_realtime=yes
+          if test x"$ac_cv_search_clock_gettime" = x"none required"; then
+            ac_has_clock_monotonic=yes
+            ac_has_clock_realtime=yes
+          fi
         fi
         ac_has_nanosleep=yes
         ac_has_sched_yield=yes
@@ -79469,7 +79709,7 @@ $as_echo "$as_me: WARNING: === Symbol versioning will be disabled." >&2;}
 fi
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:27:0
+libtool_VERSION=6:28:0
 
 # Everything parsed; figure out what files and settings to use.
 case $enable_symvers in
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index dadd8827b49..d8455e41574 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -83,6 +83,8 @@ AC_PROG_CC
 AC_PROG_CXX
 CXXFLAGS="$save_CXXFLAGS"
 
+AC_SYS_LARGEFILE
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
 GLIBCXX_CONFIGURE
diff --git a/libstdc++-v3/doc/Makefile.am b/libstdc++-v3/doc/Makefile.am
index eb8251d10e3..4427e5da6ad 100644
--- a/libstdc++-v3/doc/Makefile.am
+++ b/libstdc++-v3/doc/Makefile.am
@@ -477,7 +477,6 @@ ${docbook_outdir}/fo:
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -546,6 +545,12 @@ stamp-html-docbook: $(xml_sources) ${docbook_outdir}/html
 
 doc-html-docbook: stamp-html-docbook-data
 
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
+
 # HTML, all one page
 # NB: Have to generate customization XSL for UTF-8 output.
 manual_html = ${docbook_outdir}/html/libstdc++-manual-single.html
diff --git a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
index 12be1f7e254..1058d5c3cc8 100644
--- a/libstdc++-v3/doc/Makefile.in
+++ b/libstdc++-v3/doc/Makefile.in
@@ -978,7 +978,6 @@ ${docbook_outdir}/fo:
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -1030,6 +1029,12 @@ stamp-html-docbook: $(xml_sources) ${docbook_outdir}/html
 	$(STAMP) stamp-html-docbook
 
 doc-html-docbook: stamp-html-docbook-data
+
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
 stamp-html-single-docbook: $(xml_sources) ${docbook_outdir}/html
 	@echo "Generating html single file..."
 	$(XSLTPROC) $(XSLT_PARAM) $(XSLT_FLAGS) -o ${manual_html} \
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
index 1f6934ef4c8..ac99835acf2 100644
--- a/libstdc++-v3/doc/html/faq.html
+++ b/libstdc++-v3/doc/html/faq.html
@@ -113,9 +113,8 @@
      clauses 20 through 33 and annex D (prior to the 2017 standard
      the library clauses started with 17).  For those who want to see
      exactly how far the project has come, or just want the latest
-     bleeding-edge code, the up-to-date source is available over
-     anonymous SVN, and can be browsed over the
-     <a class="link" href="https://gcc.gnu.org/svn.html" target="_top">web</a>.
+     bleeding-edge code, the up-to-date source can be cloned via
+     <a class="link" href="https://gcc.gnu.org/git.html" target="_top">Git</a>.
     </p><p>
     N.B. The library is called libstdc++ <span class="emphasis"><em>not</em></span> stdlibc++.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.why"></a><a id="q-why"></a><p><strong>1.2.</strong></p></td><td align="left" valign="top"><p>
@@ -260,24 +259,11 @@
     mirrors. A full <a class="link" href="https://gcc.gnu.org/mirrors.html" target="_top">list of
     download sites</a> is provided on the main GCC site.
     </p><p>
-    Current libstdc++ sources can always be checked out of the main
-    GCC source repository using the appropriate version control
-    tool. At this time, that tool
-    is <span class="application">Subversion</span>.
-    </p><p>
-    <span class="application">Subversion</span>, or <acronym class="acronym">SVN</acronym>, is
-    one of several revision control packages.  It was selected for GNU
-    projects because it's free (speech), free (beer), and very high
-    quality.  The <a class="link" href="http://subversion.tigris.org" target="_top"> Subversion
-    home page</a> has a better description.
-    </p><p>
-    The <span class="quote">“<span class="quote">anonymous client checkout</span>”</span> feature of SVN is
-    similar to anonymous FTP in that it allows anyone to retrieve
-    the latest libstdc++ sources.
-    </p><p>
-    For more information
-    see <a class="link" href="https://gcc.gnu.org/svn.html" target="_top"><acronym class="acronym">SVN</acronym>
-    details</a>.
+    Current libstdc++ sources can always be found in the main GCC source
+    repository, available using the appropriate version control tool.
+    At this time, that tool is <span class="application">Git</span>.
+    For more details see the documentation on
+    <a class="link" href="https://gcc.gnu.org/git.html" target="_top">using the Git repository</a>.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.how_to_test"></a><a id="q-how_to_test"></a><p><strong>3.3.</strong></p></td><td align="left" valign="top"><p>How do I know if it works?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-how_to_test"></a></td><td align="left" valign="top"><p>
     Libstdc++ comes with its own validation testsuite, which includes
diff --git a/libstdc++-v3/doc/html/manual/abi.html b/libstdc++-v3/doc/html/manual/abi.html
index 2d6d8f6c984..96383c33112 100644
--- a/libstdc++-v3/doc/html/manual/abi.html
+++ b/libstdc++-v3/doc/html/manual/abi.html
@@ -110,7 +110,7 @@ compatible.
 	has the same filename and <code class="constant">DT_SONAME</code> as the
 	preceding release.
       </p><p>It is versioned as follows:
-    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: libstdc++.so.3.0.0</p></li><li class="listitem"><p>GCC 3.0.1: libstdc++.so.3.0.1</p></li><li class="listitem"><p>GCC 3.0.2: libstdc++.so.3.0.2</p></li><li class="listitem"><p>GCC 3.0.3: libstdc++.so.3.0.2 (See Note 1)</p></li><li class="listitem"><p>GCC 3.0.4: libstdc++.so.3.0.4</p></li><li class="listitem"><p>GCC 3.1.0: libstdc++.so.4.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.1.1: libstdc++.so.4.0.1</p></li><li class="listitem"><p>GCC 3.2.0: libstdc++.so.5.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.2.1: libstdc++.so.5.0.1</p></li><li class="listitem"><p>GCC 3.2.2: libstdc++.so.5.0.2</p></li><li class="listitem"><p>GCC 3.2.3: libstdc++.so.5.0.3 (See Note 2)</p></li><li class="listitem"><p>GCC 3.3.0: libstdc++.so.5.0.4</p></li><li class="listitem"><p>GCC 3.3.1: libstdc++.so.5.0.5</p></li><li class="listitem"><p>GCC 3.4.0: libstdc++.so.6.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.4.1: libstdc++.so.6.0.1</p></li><li class="listitem"><p>GCC 3.4.2: libstdc++.so.6.0.2</p></li><li class="listitem"><p>GCC 3.4.3: libstdc++.so.6.0.3</p></li><li class="listitem"><p>GCC 4.0.0: libstdc++.so.6.0.4</p></li><li class="listitem"><p>GCC 4.0.1: libstdc++.so.6.0.5</p></li><li class="listitem"><p>GCC 4.0.2: libstdc++.so.6.0.6</p></li><li class="listitem"><p>GCC 4.0.3: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.0: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.1: libstdc++.so.6.0.8</p></li><li class="listitem"><p>GCC 4.2.0: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.2.1: libstdc++.so.6.0.9 (See Note 3)</p></li><li class="listitem"><p>GCC 4.2.2: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.3.0: libstdc++.so.6.0.10</p></li><li class="listitem"><p>GCC 4.4.0: libstdc++.so.6.0.11</p></li><li class="listitem"><p>GCC 4.4.1: libstdc++.so.6.0.12</p></li><li class="listitem"><p>GCC 4.4.2: libstdc++.so.6.0.13</p></li><li class="listitem"><p>GCC 4.5.0: libstdc++.so.6.0.14</p></li><li class="listitem"><p>GCC 4.6.0: libstdc++.so.6.0.15</p></li><li class="listitem"><p>GCC 4.6.1: libstdc++.so.6.0.16</p></li><li class="listitem"><p>GCC 4.7.0: libstdc++.so.6.0.17</p></li><li class="listitem"><p>GCC 4.8.0: libstdc++.so.6.0.18</p></li><li class="listitem"><p>GCC 4.8.3: libstdc++.so.6.0.19</p></li><li class="listitem"><p>GCC 4.9.0: libstdc++.so.6.0.20</p></li><li class="listitem"><p>GCC 5.1.0: libstdc++.so.6.0.21</p></li><li class="listitem"><p>GCC 6.1.0: libstdc++.so.6.0.22</p></li><li class="listitem"><p>GCC 7.1.0: libstdc++.so.6.0.23</p></li><li class="listitem"><p>GCC 7.2.0: libstdc++.so.6.0.24</p></li><li class="listitem"><p>GCC 8.0.0: libstdc++.so.6.0.25</p></li><li class="listitem"><p>GCC 9.0.0: libstdc++.so.6.0.26</p></li></ul></div><p>
+    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: libstdc++.so.3.0.0</p></li><li class="listitem"><p>GCC 3.0.1: libstdc++.so.3.0.1</p></li><li class="listitem"><p>GCC 3.0.2: libstdc++.so.3.0.2</p></li><li class="listitem"><p>GCC 3.0.3: libstdc++.so.3.0.2 (See Note 1)</p></li><li class="listitem"><p>GCC 3.0.4: libstdc++.so.3.0.4</p></li><li class="listitem"><p>GCC 3.1.0: libstdc++.so.4.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.1.1: libstdc++.so.4.0.1</p></li><li class="listitem"><p>GCC 3.2.0: libstdc++.so.5.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.2.1: libstdc++.so.5.0.1</p></li><li class="listitem"><p>GCC 3.2.2: libstdc++.so.5.0.2</p></li><li class="listitem"><p>GCC 3.2.3: libstdc++.so.5.0.3 (See Note 2)</p></li><li class="listitem"><p>GCC 3.3.0: libstdc++.so.5.0.4</p></li><li class="listitem"><p>GCC 3.3.1: libstdc++.so.5.0.5</p></li><li class="listitem"><p>GCC 3.4.0: libstdc++.so.6.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.4.1: libstdc++.so.6.0.1</p></li><li class="listitem"><p>GCC 3.4.2: libstdc++.so.6.0.2</p></li><li class="listitem"><p>GCC 3.4.3: libstdc++.so.6.0.3</p></li><li class="listitem"><p>GCC 4.0.0: libstdc++.so.6.0.4</p></li><li class="listitem"><p>GCC 4.0.1: libstdc++.so.6.0.5</p></li><li class="listitem"><p>GCC 4.0.2: libstdc++.so.6.0.6</p></li><li class="listitem"><p>GCC 4.0.3: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.0: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.1: libstdc++.so.6.0.8</p></li><li class="listitem"><p>GCC 4.2.0: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.2.1: libstdc++.so.6.0.9 (See Note 3)</p></li><li class="listitem"><p>GCC 4.2.2: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.3.0: libstdc++.so.6.0.10</p></li><li class="listitem"><p>GCC 4.4.0: libstdc++.so.6.0.11</p></li><li class="listitem"><p>GCC 4.4.1: libstdc++.so.6.0.12</p></li><li class="listitem"><p>GCC 4.4.2: libstdc++.so.6.0.13</p></li><li class="listitem"><p>GCC 4.5.0: libstdc++.so.6.0.14</p></li><li class="listitem"><p>GCC 4.6.0: libstdc++.so.6.0.15</p></li><li class="listitem"><p>GCC 4.6.1: libstdc++.so.6.0.16</p></li><li class="listitem"><p>GCC 4.7.0: libstdc++.so.6.0.17</p></li><li class="listitem"><p>GCC 4.8.0: libstdc++.so.6.0.18</p></li><li class="listitem"><p>GCC 4.8.3: libstdc++.so.6.0.19</p></li><li class="listitem"><p>GCC 4.9.0: libstdc++.so.6.0.20</p></li><li class="listitem"><p>GCC 5.1.0: libstdc++.so.6.0.21</p></li><li class="listitem"><p>GCC 6.1.0: libstdc++.so.6.0.22</p></li><li class="listitem"><p>GCC 7.1.0: libstdc++.so.6.0.23</p></li><li class="listitem"><p>GCC 7.2.0: libstdc++.so.6.0.24</p></li><li class="listitem"><p>GCC 8.0.0: libstdc++.so.6.0.25</p></li><li class="listitem"><p>GCC 9.1.0: libstdc++.so.6.0.26</p></li><li class="listitem"><p>GCC 9.2.0: libstdc++.so.6.0.27</p></li><li class="listitem"><p>GCC 9.3.0: libstdc++.so.6.0.28</p></li></ul></div><p>
       Note 1: Error should be libstdc++.so.3.0.3.
     </p><p>
       Note 2: Not strictly required.
diff --git a/libstdc++-v3/doc/html/manual/appendix_contributing.html b/libstdc++-v3/doc/html/manual/appendix_contributing.html
index ca8ae873b9e..2f384a64afa 100644
--- a/libstdc++-v3/doc/html/manual/appendix_contributing.html
+++ b/libstdc++-v3/doc/html/manual/appendix_contributing.html
@@ -90,14 +90,12 @@
 	  easily and simply show the existing error or test new
 	  functionality.
 	</p></li><li class="listitem"><p>
-	  The patch itself. If you are accessing the SVN
-	  repository use <span class="command"><strong>svn update; svn diff NEW</strong></span>;
-	  else, use <span class="command"><strong>diff -cp OLD NEW</strong></span> ... If your
+	  The patch itself. If you are using the Git repository use
+	  <span class="command"><strong>git diff</strong></span> or <span class="command"><strong>git format-patch</strong></span>
+	  to produce a patch;
+	  otherwise, use <span class="command"><strong>diff -cp OLD NEW</strong></span>. If your
 	  version of diff does not support these options, then get the
-	  latest version of GNU
-	  diff. The <a class="link" href="http://gcc.gnu.org/wiki/SvnTricks" target="_top">SVN
-	  Tricks</a> wiki page has information on customising the
-	  output of <code class="code">svn diff</code>.
+	  latest version of GNU diff.
 	</p></li><li class="listitem"><p>
 	  When you have all these pieces, bundle them up in a
 	  mail message and send it to libstdc++@gcc.gnu.org. All
diff --git a/libstdc++-v3/doc/html/manual/documentation_hacking.html b/libstdc++-v3/doc/html/manual/documentation_hacking.html
index fcd7f1e60c5..045556a337b 100644
--- a/libstdc++-v3/doc/html/manual/documentation_hacking.html
+++ b/libstdc++-v3/doc/html/manual/documentation_hacking.html
@@ -381,10 +381,15 @@
       </p><p>
       </p><pre class="screen"><strong class="userinput"><code>make doc-xml-single-docbook</code></strong></pre><p>
       </p><p>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<code class="filename">doc/docbook/</code> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <code class="filename">doc/docbook/html</code>.
+      </p><p>
+	The </p><pre class="screen">doc-html-docbook-regenerate</pre><p> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
       </p><p>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <code class="literal">XSL_STYLE_DIR</code> to
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index f493b275632..f0c8d3ed97e 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname"></span> <span class="surname"></span></h3></div><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Silvius</span> <span class="surname">Rus</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname"></span> <span class="surname"></span></h3></div><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Silvius</span> <span class="surname">Rus</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
       <a class="link" href="https://www.fsf.org" target="_top">FSF</a>
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
diff --git a/libstdc++-v3/doc/html/manual/memory.html b/libstdc++-v3/doc/html/manual/memory.html
index 0330df1dfaf..8a150af50ce 100644
--- a/libstdc++-v3/doc/html/manual/memory.html
+++ b/libstdc++-v3/doc/html/manual/memory.html
@@ -314,13 +314,13 @@
     </em>. </span>
       isoc++_1998
     <span class="pagenums">20.4 Memory. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.3"></a><p><span class="title"><em>
-	<a class="link" href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
+      <a class="link" href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
       The Standard Librarian: What Are Allocators Good For?
-	</a>
-      </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
+      </a>
+    </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
 	C/C++ Users Journal
-      . </span></span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
-	<a class="link" href="https://www.hoard.org" target="_top">
+      . </span></span><span class="pubdate">2000-12. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
+	<a class="link" href="http://hoard.org" target="_top">
       The Hoard Memory Allocator
 	</a>
       </em>. </span><span class="author"><span class="firstname">Emery</span> <span class="surname">Berger</span>. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.5"></a><p><span class="title"><em>
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index ebae5e34da5..440b8671e0c 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -5,8 +5,7 @@
 </th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 202a</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2020.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
 This status table is based on the table of contents of ISO/IEC 14882:2003.
 </p><p>
-This page describes the C++ support in mainline GCC SVN, not in any
-particular release.
+This page describes the C++ support in the GCC 9 series.
 </p><div class="table"><a id="table.cxx98_status"></a><p class="title"><strong>Table 1.1. C++ 1998/2003 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 1998/2003 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>18</em></span>
       </td><td colspan="3" align="left">
@@ -155,8 +154,7 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This page describes the C++11 support in mainline GCC SVN, not in any
-particular release.
+This page describes the C++11 support in the GCC 9 series.
 </p><div class="table"><a id="table.cxx11_status"></a><p class="title"><strong>Table 1.2. C++ 2011 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>18</em></span>
       </td><td colspan="3" align="left">
@@ -388,8 +386,7 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This page describes the C++14 and library TS support in mainline GCC SVN,
-not in any particular release.
+This page describes the C++14 and library TS support in the GCC 9 series.
 </p><div class="table"><a id="table.cxx14_status"></a><p class="title"><strong>Table 1.3. C++ 2014 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 2014 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Paper</th><th align="left">Title</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3669.pdf" target="_top">
 	  N3669
@@ -523,8 +520,7 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This section describes the C++17 and library TS support in mainline GCC SVN,
-not in any particular release.
+This section describes the C++17 and library TS support in the GCC 9 series.
 </p><p>
 The following table lists new library features that are included in
 the C++17 standard. The "Proposal" column provides a link to the
@@ -1011,8 +1007,7 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This section describes the C++20 and library TS support in mainline GCC SVN,
-not in any particular release.
+This section describes the C++20 and library TS support in the GCC 9 series.
 </p><p>
 The following table lists new library features that have been accepted into
 the C++2a working draft. The "Proposal" column provides a link to the
@@ -1110,11 +1105,12 @@ Feature-testing recommendations for C++</a>.
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0809r0.pdf" target="_top">
 	P0809R0
 	</a>
-      </td><td align="center"> </td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  Constexpr iterator requirements </td><td align="left">
+      </td><td align="center"> </td><td align="left"> </td></tr><tr><td align="left">  Constexpr iterator requirements </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0858r0.html" target="_top">
 	P0858R0
 	</a>
-      </td><td align="center"> </td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  Symmetry for spaceship </td><td align="left">
+      </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_string_view &gt;= 201803L</code>
+      and <code class="code">__cpp_lib_array_constexpr &gt;= 201803L</code> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  Symmetry for spaceship </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0905r1.html" target="_top">
 	P0905R1
 	</a>
@@ -1373,8 +1369,7 @@ In this implementation the header names are prefixed by
 <code class="code">tr1/</code>, for instance <code class="code">&lt;tr1/functional&gt;</code>,
 <code class="code">&lt;tr1/memory&gt;</code>, and so on.
 </p><p>
-This page describes the TR1 support in mainline GCC SVN, not in any particular
-release.
+This page describes the TR1 support in the GCC 9 series.
 </p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.8. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
 	<p>
 	  Uses code from
@@ -1394,8 +1389,7 @@ ISO/IEC TR 24733 Date: 2009-08-28
 Extension for the programming language C++ to support
 decimal floating-point arithmetic
 </p><p>
-This page describes the TR 24733 support in mainline GCC SVN, not in any
-particular release.
+This page describes the TR 24733 support in the GCC 9 series.
 </p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.9. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>0</em></span>
       </td><td colspan="3" align="left">
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
index b4bf333e26a..aff6c8d6004 100644
--- a/libstdc++-v3/doc/xml/faq.xml
+++ b/libstdc++-v3/doc/xml/faq.xml
@@ -34,9 +34,8 @@
      clauses 20 through 33 and annex D (prior to the 2017 standard
      the library clauses started with 17).  For those who want to see
      exactly how far the project has come, or just want the latest
-     bleeding-edge code, the up-to-date source is available over
-     anonymous SVN, and can be browsed over the
-     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/svn.html">web</link>.
+     bleeding-edge code, the up-to-date source can be cloned via
+     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/git.html">Git</link>.
     </para> 
 
     <para>
@@ -296,27 +295,11 @@
     download sites</link> is provided on the main GCC site.
     </para>
     <para>
-    Current libstdc++ sources can always be checked out of the main
-    GCC source repository using the appropriate version control
-    tool. At this time, that tool
-    is <application>Subversion</application>.
-    </para>
-    <para>
-    <application>Subversion</application>, or <acronym>SVN</acronym>, is
-    one of several revision control packages.  It was selected for GNU
-    projects because it's free (speech), free (beer), and very high
-    quality.  The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://subversion.tigris.org"> Subversion
-    home page</link> has a better description.
-    </para>
-    <para>
-    The <quote>anonymous client checkout</quote> feature of SVN is
-    similar to anonymous FTP in that it allows anyone to retrieve
-    the latest libstdc++ sources.
-    </para> 
-    <para>
-    For more information
-    see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/svn.html"><acronym>SVN</acronym>
-    details</link>.
+    Current libstdc++ sources can always be found in the main GCC source
+    repository, available using the appropriate version control tool.
+    At this time, that tool is <application>Git</application>.
+    For more details see the documentation on
+    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/git.html">using the Git repository</link>.
     </para>
   </answer>
 </qandaentry>
diff --git a/libstdc++-v3/doc/xml/manual/abi.xml b/libstdc++-v3/doc/xml/manual/abi.xml
index d1e6b989a71..969edd7c834 100644
--- a/libstdc++-v3/doc/xml/manual/abi.xml
+++ b/libstdc++-v3/doc/xml/manual/abi.xml
@@ -268,7 +268,9 @@ compatible.
     <listitem><para>GCC 7.1.0: libstdc++.so.6.0.23</para></listitem>
     <listitem><para>GCC 7.2.0: libstdc++.so.6.0.24</para></listitem>
     <listitem><para>GCC 8.0.0: libstdc++.so.6.0.25</para></listitem>
-    <listitem><para>GCC 9.0.0: libstdc++.so.6.0.26</para></listitem>
+    <listitem><para>GCC 9.1.0: libstdc++.so.6.0.26</para></listitem>
+    <listitem><para>GCC 9.2.0: libstdc++.so.6.0.27</para></listitem>
+    <listitem><para>GCC 9.3.0: libstdc++.so.6.0.28</para></listitem>
     </itemizedlist>
     <para>
       Note 1: Error should be libstdc++.so.3.0.3.
diff --git a/libstdc++-v3/doc/xml/manual/allocator.xml b/libstdc++-v3/doc/xml/manual/allocator.xml
index 8d49b919ff6..633d33c5ff1 100644
--- a/libstdc++-v3/doc/xml/manual/allocator.xml
+++ b/libstdc++-v3/doc/xml/manual/allocator.xml
@@ -499,12 +499,12 @@
   </biblioentry>
 
   <biblioentry>
-      <title>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
+    <title>
+      <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	    xlink:href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
       The Standard Librarian: What Are Allocators Good For?
-	</link>
-      </title>
+      </link>
+    </title>
 
     <author><personname><firstname>Matt</firstname><surname>Austern</surname></personname></author>
     <publisher>
@@ -512,12 +512,13 @@
 	C/C++ Users Journal
       </publishername>
     </publisher>
+    <pubdate>2000-12</pubdate>
   </biblioentry>
 
   <biblioentry>
       <title>
 	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="https://www.hoard.org">
+	      xlink:href="http://hoard.org">
       The Hoard Memory Allocator
 	</link>
       </title>
diff --git a/libstdc++-v3/doc/xml/manual/appendix_contributing.xml b/libstdc++-v3/doc/xml/manual/appendix_contributing.xml
index 41335475f3b..eb011cbd4bc 100644
--- a/libstdc++-v3/doc/xml/manual/appendix_contributing.xml
+++ b/libstdc++-v3/doc/xml/manual/appendix_contributing.xml
@@ -170,14 +170,12 @@
 
       <listitem>
 	<para>
-	  The patch itself. If you are accessing the SVN
-	  repository use <command>svn update; svn diff NEW</command>;
-	  else, use <command>diff -cp OLD NEW</command> ... If your
+	  The patch itself. If you are using the Git repository use
+	  <command>git diff</command> or <command>git format-patch</command>
+	  to produce a patch;
+	  otherwise, use <command>diff -cp OLD NEW</command>. If your
 	  version of diff does not support these options, then get the
-	  latest version of GNU
-	  diff. The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/wiki/SvnTricks">SVN
-	  Tricks</link> wiki page has information on customising the
-	  output of <code>svn diff</code>.
+	  latest version of GNU diff.
 	</para>
       </listitem>
 
diff --git a/libstdc++-v3/doc/xml/manual/documentation_hacking.xml b/libstdc++-v3/doc/xml/manual/documentation_hacking.xml
index fffa1fc775a..043f2fa44dc 100644
--- a/libstdc++-v3/doc/xml/manual/documentation_hacking.xml
+++ b/libstdc++-v3/doc/xml/manual/documentation_hacking.xml
@@ -805,13 +805,20 @@
       </para>
 
       <para>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<filename class="directory">doc/docbook/</filename> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <filename
 	class="directory">doc/docbook/html</filename>.
       </para>
 
+      <para>
+	The <screen>doc-html-docbook-regenerate</screen> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
+      </para>
+
       <para>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <literal>XSL_STYLE_DIR</literal> to
diff --git a/libstdc++-v3/doc/xml/manual/spine.xml b/libstdc++-v3/doc/xml/manual/spine.xml
index 2b6973ba0ae..9585f1eed01 100644
--- a/libstdc++-v3/doc/xml/manual/spine.xml
+++ b/libstdc++-v3/doc/xml/manual/spine.xml
@@ -27,6 +27,7 @@
     <year>2017</year>
     <year>2018</year>
     <year>2019</year>
+    <year>2020</year>
     <holder>
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://www.fsf.org">FSF</link>
     </holder>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
index 2b05ff6601a..44a042c2724 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
@@ -18,8 +18,7 @@ This status table is based on the table of contents of ISO/IEC 14882:2003.
 </para>
 
 <para>
-This page describes the C++ support in mainline GCC SVN, not in any
-particular release.
+This page describes the C++ support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
index 0fa4bc0dffe..568102823b0 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
@@ -27,8 +27,7 @@ presence of the required flag.
 </para>
 
 <para>
-This page describes the C++11 support in mainline GCC SVN, not in any
-particular release.
+This page describes the C++11 support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
index a33b4ec1611..7b604307c8e 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
@@ -20,8 +20,7 @@ presence of the required flag.
 </para>
 
 <para>
-This page describes the C++14 and library TS support in mainline GCC SVN,
-not in any particular release.
+This page describes the C++14 and library TS support in the GCC 9 series.
 </para>
 
 <table frame="all" xml:id="table.cxx14_status">
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
index 40fe7cd2037..e1513142415 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
@@ -20,8 +20,7 @@ presence of the required flag.
 </para>
 
 <para>
-This section describes the C++17 and library TS support in mainline GCC SVN,
-not in any particular release.
+This section describes the C++17 and library TS support in the GCC 9 series.
 </para>
 
 <para>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
index 89e540d018b..fc7fe0a3d9f 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
@@ -20,8 +20,7 @@ presence of the required flag.
 </para>
 
 <para>
-This section describes the C++20 and library TS support in mainline GCC SVN,
-not in any particular release.
+This section describes the C++20 and library TS support in the GCC 9 series.
 </para>
 
 <para>
@@ -309,15 +308,15 @@ Feature-testing recommendations for C++</link>.
     </row>
 
     <row>
-      <?dbhtml bgcolor="#C8B0B0" ?>
       <entry>  Constexpr iterator requirements </entry>
       <entry>
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0858r0.html">
 	P0858R0
 	</link>
       </entry>
-      <entry align="center"> </entry>
-      <entry />
+      <entry align="center"> 9.1 </entry>
+      <entry> <code>__cpp_lib_string_view &gt;= 201803L</code>
+      and <code>__cpp_lib_array_constexpr &gt;= 201803L</code> </entry>
     </row>
 
     <row>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml b/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml
index 32ad20a2fb2..c1e65752156 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml
@@ -22,8 +22,7 @@ In this implementation the header names are prefixed by
 </para>
 
 <para>
-This page describes the TR1 support in mainline GCC SVN, not in any particular
-release.
+This page describes the TR1 support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
diff --git a/libstdc++-v3/doc/xml/manual/status_cxxtr24733.xml b/libstdc++-v3/doc/xml/manual/status_cxxtr24733.xml
index e8d445116a2..a3ea8b285f6 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxxtr24733.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxxtr24733.xml
@@ -16,8 +16,7 @@ decimal floating-point arithmetic
 </para>
 
 <para>
-This page describes the TR 24733 support in mainline GCC SVN, not in any
-particular release.
+This page describes the TR 24733 support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 1deacb80ca2..7958f436242 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -1050,6 +1050,7 @@ allstamped = \
 # catenation.
 allcreated = \
 	${host_builddir}/c++config.h \
+	${host_builddir}/largefile-config.h \
 	${thread_host_headers} \
 	${pch_build}
 
@@ -1283,10 +1284,19 @@ stamp-float128:
 	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
 endif
 
+# This header is not installed, it's only used to build libstdc++ itself.
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+	@rm -f $@.tmp
+	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
+	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
+	@-grep 'define _LARGE_FILES' ${CONFIG_HEADER} >> $@.tmp
+	@mv $@.tmp $@
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 			      ${glibcxx_srcdir}/include/bits/c++config \
+			      ${host_builddir}/largefile-config.h \
 			      stamp-${host_alias} \
 			      ${toplevel_srcdir}/gcc/DATESTAMP \
 			      stamp-namespace-version \
@@ -1324,6 +1334,9 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \
 	    -e 's/VERSION/_GLIBCXX_VERSION/g' \
 	    -e 's/WORDS_/_GLIBCXX_WORDS_/g' \
+	    -e 's/_DARWIN_USE_64_BIT_INODE/_GLIBCXX_DARWIN_USE_64_BIT_INODE/g' \
+	    -e 's/_FILE_OFFSET_BITS/_GLIBCXX_FILE_OFFSET_BITS/g' \
+	    -e 's/_LARGE_FILES/_GLIBCXX_LARGE_FILES/g' \
 	    -e 's/ICONV_CONST/_GLIBCXX_ICONV_CONST/g' \
 	    -e '/[	 ]_GLIBCXX_LONG_DOUBLE_COMPAT[	 ]/d' \
 	    < ${CONFIG_HEADER} >> $@ ;\
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index bc475c6dd90..631c77280b0 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -1384,6 +1384,7 @@ allstamped = \
 # catenation.
 allcreated = \
 	${host_builddir}/c++config.h \
+	${host_builddir}/largefile-config.h \
 	${thread_host_headers} \
 	${pch_build}
 
@@ -1765,10 +1766,19 @@ stamp-host: ${host_headers} ${bits_host_headers} ${ext_host_headers} ${host_head
 @ENABLE_FLOAT128_FALSE@stamp-float128:
 @ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
 
+# This header is not installed, it's only used to build libstdc++ itself.
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+	@rm -f $@.tmp
+	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
+	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
+	@-grep 'define _LARGE_FILES' ${CONFIG_HEADER} >> $@.tmp
+	@mv $@.tmp $@
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 			      ${glibcxx_srcdir}/include/bits/c++config \
+			      ${host_builddir}/largefile-config.h \
 			      stamp-${host_alias} \
 			      ${toplevel_srcdir}/gcc/DATESTAMP \
 			      stamp-namespace-version \
@@ -1806,6 +1816,9 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \
 	    -e 's/VERSION/_GLIBCXX_VERSION/g' \
 	    -e 's/WORDS_/_GLIBCXX_WORDS_/g' \
+	    -e 's/_DARWIN_USE_64_BIT_INODE/_GLIBCXX_DARWIN_USE_64_BIT_INODE/g' \
+	    -e 's/_FILE_OFFSET_BITS/_GLIBCXX_FILE_OFFSET_BITS/g' \
+	    -e 's/_LARGE_FILES/_GLIBCXX_LARGE_FILES/g' \
 	    -e 's/ICONV_CONST/_GLIBCXX_ICONV_CONST/g' \
 	    -e '/[	 ]_GLIBCXX_LONG_DOUBLE_COMPAT[	 ]/d' \
 	    < ${CONFIG_HEADER} >> $@ ;\
diff --git a/libstdc++-v3/include/bits/algorithmfwd.h b/libstdc++-v3/include/bits/algorithmfwd.h
index 40e051aa9e3..5e47fffe86e 100644
--- a/libstdc++-v3/include/bits/algorithmfwd.h
+++ b/libstdc++-v3/include/bits/algorithmfwd.h
@@ -154,7 +154,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    */
 
   /**
-   * @defgroup set_algorithms Set Operation
+   * @defgroup set_algorithms Set Operations
    * @ingroup sorting_algorithms
    *
    * These algorithms are common set operations performed on sequences
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index 7a7e78819ba..7e0962edd19 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -668,6 +668,8 @@ namespace std
 // PSTL configuration
 
 #if __cplusplus >= 201703L
+// This header is not installed for freestanding:
+#if __has_include(<pstl/pstl_config.h>)
 // Preserved here so we have some idea which version of upstream we've pulled in
 // #define PSTL_VERSION 104
 // #define PSTL_VERSION_MAJOR (PSTL_VERSION/100)
@@ -686,6 +688,7 @@ namespace std
 # define __PSTL_ASSERT_MSG(_Condition, _Message) __glibcxx_assert(_Condition)
 
 #include <pstl/pstl_config.h>
+#endif // __has_include
+#endif // C++17
 
-#endif
 // End of prewritten config; the settings discovered at configure time follow.
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index e56a0a7f138..5dc624dbb1e 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -612,6 +612,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
   size_t hash_value(const path& __p) noexcept;
 
+  /// Exception type thrown by the Filesystem library
+  class filesystem_error : public std::system_error
+  {
+  public:
+    filesystem_error(const string& __what_arg, error_code __ec);
+
+    filesystem_error(const string& __what_arg, const path& __p1,
+		     error_code __ec);
+
+    filesystem_error(const string& __what_arg, const path& __p1,
+		     const path& __p2, error_code __ec);
+
+    filesystem_error(const filesystem_error&) = default;
+    filesystem_error& operator=(const filesystem_error&) = default;
+
+    // No move constructor or assignment operator.
+    // Copy rvalues instead, so that _M_impl is not left empty.
+
+    ~filesystem_error();
+
+    const path& path1() const noexcept;
+    const path& path2() const noexcept;
+    const char* what() const noexcept;
+
+  private:
+    struct _Impl;
+    std::__shared_ptr<const _Impl> _M_impl;
+  };
+
+  /// Create a path from a UTF-8-encoded sequence of char
   template<typename _InputIterator>
     inline auto
     u8path(_InputIterator __first, _InputIterator __last)
@@ -642,6 +672,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 #endif
     }
 
+  /// Create a path from a UTF-8-encoded sequence of char
   template<typename _Source>
     inline auto
     u8path(const _Source& __source)
@@ -663,34 +694,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 #endif
     }
 
-  class filesystem_error : public std::system_error
-  {
-  public:
-    filesystem_error(const string& __what_arg, error_code __ec);
-
-    filesystem_error(const string& __what_arg, const path& __p1,
-		     error_code __ec);
-
-    filesystem_error(const string& __what_arg, const path& __p1,
-		     const path& __p2, error_code __ec);
-
-    filesystem_error(const filesystem_error&) = default;
-    filesystem_error& operator=(const filesystem_error&) = default;
-
-    // No move constructor or assignment operator.
-    // Copy rvalues instead, so that _M_impl is not left empty.
-
-    ~filesystem_error();
-
-    const path& path1() const noexcept;
-    const path& path2() const noexcept;
-    const char* what() const noexcept;
-
-  private:
-    struct _Impl;
-    std::__shared_ptr<const _Impl> _M_impl;
-  };
-
   struct path::_Cmpt : path
   {
     _Cmpt(basic_string_view<value_type> __s, _Type __t, size_t __pos)
diff --git a/libstdc++-v3/include/bits/ios_base.h b/libstdc++-v3/include/bits/ios_base.h
index 06a3e0870f3..be908b3ffd2 100644
--- a/libstdc++-v3/include/bits/ios_base.h
+++ b/libstdc++-v3/include/bits/ios_base.h
@@ -445,7 +445,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     /// Open for output.  Default for @c ofstream and fstream.
     static const openmode out =		_S_out;
 
-    /// Open for input.  Default for @c ofstream.
+    /// Truncate an existing stream when opening.  Default for @c ofstream.
     static const openmode trunc =	_S_trunc;
 
     // 27.4.2.1.5  Type ios_base::seekdir
diff --git a/libstdc++-v3/include/bits/memoryfwd.h b/libstdc++-v3/include/bits/memoryfwd.h
index 8b1664a398d..732ac805322 100644
--- a/libstdc++-v3/include/bits/memoryfwd.h
+++ b/libstdc++-v3/include/bits/memoryfwd.h
@@ -66,9 +66,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<>
     class allocator<void>;
 
+#if __cplusplus >= 201103L
   /// Declare uses_allocator so it can be specialized in \<queue\> etc.
   template<typename, typename>
     struct uses_allocator;
+#endif
 
   /// @} group memory
 
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
index 2b1df4cb59e..14f680f50c4 100644
--- a/libstdc++-v3/include/bits/random.h
+++ b/libstdc++-v3/include/bits/random.h
@@ -3715,8 +3715,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	       std::bernoulli_distribution& __x)
     {
       double __p;
-      __is >> __p;
-      __x.param(bernoulli_distribution::param_type(__p));
+      if (__is >> __p)
+	__x.param(bernoulli_distribution::param_type(__p));
       return __is;
     }
 
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index b80ab82ba15..9e0f1322f33 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -905,9 +905,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _IntType __a, __b;
-      __is >> __a >> __b;
-      __x.param(typename uniform_int_distribution<_IntType>::
-		param_type(__a, __b));
+      if (__is >> __a >> __b)
+	__x.param(typename uniform_int_distribution<_IntType>::
+		  param_type(__a, __b));
 
       __is.flags(__flags);
       return __is;
@@ -967,9 +967,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::skipws);
 
       _RealType __a, __b;
-      __is >> __a >> __b;
-      __x.param(typename uniform_real_distribution<_RealType>::
-		param_type(__a, __b));
+      if (__is >> __a >> __b)
+	__x.param(typename uniform_real_distribution<_RealType>::
+		  param_type(__a, __b));
 
       __is.flags(__flags);
       return __is;
@@ -1111,8 +1111,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::skipws);
 
       double __p;
-      __is >> __p;
-      __x.param(typename geometric_distribution<_IntType>::param_type(__p));
+      if (__is >> __p)
+	__x.param(typename geometric_distribution<_IntType>::param_type(__p));
 
       __is.flags(__flags);
       return __is;
@@ -1228,9 +1228,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _IntType __k;
       double __p;
-      __is >> __k >> __p >> __x._M_gd;
-      __x.param(typename negative_binomial_distribution<_IntType>::
-		param_type(__k, __p));
+      if (__is >> __k >> __p >> __x._M_gd)
+	__x.param(typename negative_binomial_distribution<_IntType>::
+		  param_type(__k, __p));
 
       __is.flags(__flags);
       return __is;
@@ -1438,8 +1438,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::skipws);
 
       double __mean;
-      __is >> __mean >> __x._M_nd;
-      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));
+      if (__is >> __mean >> __x._M_nd)
+	__x.param(typename poisson_distribution<_IntType>::param_type(__mean));
 
       __is.flags(__flags);
       return __is;
@@ -1707,9 +1707,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _IntType __t;
       double __p;
-      __is >> __t >> __p >> __x._M_nd;
-      __x.param(typename binomial_distribution<_IntType>::
-		param_type(__t, __p));
+      if (__is >> __t >> __p >> __x._M_nd)
+	__x.param(typename binomial_distribution<_IntType>::
+		  param_type(__t, __p));
 
       __is.flags(__flags);
       return __is;
@@ -1767,9 +1767,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __lambda;
-      __is >> __lambda;
-      __x.param(typename exponential_distribution<_RealType>::
-		param_type(__lambda));
+      if (__is >> __lambda)
+	__x.param(typename exponential_distribution<_RealType>::
+		  param_type(__lambda));
 
       __is.flags(__flags);
       return __is;
@@ -1938,12 +1938,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       double __mean, __stddev;
-      __is >> __mean >> __stddev
-	   >> __x._M_saved_available;
-      if (__x._M_saved_available)
-	__is >> __x._M_saved;
-      __x.param(typename normal_distribution<_RealType>::
-		param_type(__mean, __stddev));
+      bool __saved_avail;
+      if (__is >> __mean >> __stddev >> __saved_avail)
+	{
+	  if (__saved_avail && (__is >> __x._M_saved))
+	    {
+	      __x._M_saved_available = __saved_avail;
+	      __x.param(typename normal_distribution<_RealType>::
+			param_type(__mean, __stddev));
+	    }
+	}
 
       __is.flags(__flags);
       return __is;
@@ -2001,9 +2005,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __m, __s;
-      __is >> __m >> __s >> __x._M_nd;
-      __x.param(typename lognormal_distribution<_RealType>::
-		param_type(__m, __s));
+      if (__is >> __m >> __s >> __x._M_nd)
+	__x.param(typename lognormal_distribution<_RealType>::
+		  param_type(__m, __s));
 
       __is.flags(__flags);
       return __is;
@@ -2073,9 +2077,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __n;
-      __is >> __n >> __x._M_gd;
-      __x.param(typename chi_squared_distribution<_RealType>::
-		param_type(__n));
+      if (__is >> __n >> __x._M_gd)
+	__x.param(typename chi_squared_distribution<_RealType>::
+		  param_type(__n));
 
       __is.flags(__flags);
       return __is;
@@ -2160,9 +2164,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __a, __b;
-      __is >> __a >> __b;
-      __x.param(typename cauchy_distribution<_RealType>::
-		param_type(__a, __b));
+      if (__is >> __a >> __b)
+	__x.param(typename cauchy_distribution<_RealType>::
+		  param_type(__a, __b));
 
       __is.flags(__flags);
       return __is;
@@ -2238,9 +2242,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __m, __n;
-      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
-      __x.param(typename fisher_f_distribution<_RealType>::
-		param_type(__m, __n));
+      if (__is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y)
+	__x.param(typename fisher_f_distribution<_RealType>::
+		  param_type(__m, __n));
 
       __is.flags(__flags);
       return __is;
@@ -2312,8 +2316,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __n;
-      __is >> __n >> __x._M_nd >> __x._M_gd;
-      __x.param(typename student_t_distribution<_RealType>::param_type(__n));
+      if (__is >> __n >> __x._M_nd >> __x._M_gd)
+	__x.param(typename student_t_distribution<_RealType>::param_type(__n));
 
       __is.flags(__flags);
       return __is;
@@ -2482,9 +2486,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __alpha_val, __beta_val;
-      __is >> __alpha_val >> __beta_val >> __x._M_nd;
-      __x.param(typename gamma_distribution<_RealType>::
-		param_type(__alpha_val, __beta_val));
+      if (__is >> __alpha_val >> __beta_val >> __x._M_nd)
+	__x.param(typename gamma_distribution<_RealType>::
+		  param_type(__alpha_val, __beta_val));
 
       __is.flags(__flags);
       return __is;
@@ -2559,9 +2563,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __a, __b;
-      __is >> __a >> __b;
-      __x.param(typename weibull_distribution<_RealType>::
-		param_type(__a, __b));
+      if (__is >> __a >> __b)
+	__x.param(typename weibull_distribution<_RealType>::
+		  param_type(__a, __b));
 
       __is.flags(__flags);
       return __is;
@@ -2635,9 +2639,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       _RealType __a, __b;
-      __is >> __a >> __b;
-      __x.param(typename extreme_value_distribution<_RealType>::
-		param_type(__a, __b));
+      if (__is >> __a >> __b)
+	__x.param(typename extreme_value_distribution<_RealType>::
+		  param_type(__a, __b));
 
       __is.flags(__flags);
       return __is;
@@ -2762,6 +2766,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __os;
     }
 
+namespace __detail
+{
+  template<typename _ValT, typename _CharT, typename _Traits>
+    basic_istream<_CharT, _Traits>&
+    __extract_params(basic_istream<_CharT, _Traits>& __is,
+		     vector<_ValT>& __vals, size_t __n)
+    {
+      __vals.reserve(__n);
+      while (__n--)
+	{
+	  _ValT __val;
+	  if (__is >> __val)
+	    __vals.push_back(__val);
+	  else
+	    break;
+	}
+      return __is;
+    }
+} // namespace __detail
+
   template<typename _IntType, typename _CharT, typename _Traits>
     std::basic_istream<_CharT, _Traits>&
     operator>>(std::basic_istream<_CharT, _Traits>& __is,
@@ -2774,20 +2798,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       size_t __n;
-      __is >> __n;
-
-      std::vector<double> __prob_vec;
-      __prob_vec.reserve(__n);
-      for (; __n != 0; --__n)
+      if (__is >> __n)
 	{
-	  double __prob;
-	  __is >> __prob;
-	  __prob_vec.push_back(__prob);
+	  std::vector<double> __prob_vec;
+	  if (__detail::__extract_params(__is, __prob_vec, __n))
+	    __x.param({__prob_vec.begin(), __prob_vec.end()});
 	}
 
-      __x.param(typename discrete_distribution<_IntType>::
-		param_type(__prob_vec.begin(), __prob_vec.end()));
-
       __is.flags(__flags);
       return __is;
     }
@@ -2989,29 +3006,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       size_t __n;
-      __is >> __n;
-
-      std::vector<_RealType> __int_vec;
-      __int_vec.reserve(__n + 1);
-      for (size_t __i = 0; __i <= __n; ++__i)
-	{
-	  _RealType __int;
-	  __is >> __int;
-	  __int_vec.push_back(__int);
-	}
-
-      std::vector<double> __den_vec;
-      __den_vec.reserve(__n);
-      for (size_t __i = 0; __i < __n; ++__i)
+      if (__is >> __n)
 	{
-	  double __den;
-	  __is >> __den;
-	  __den_vec.push_back(__den);
+	  std::vector<_RealType> __int_vec;
+	  if (__detail::__extract_params(__is, __int_vec, __n + 1))
+	    {
+	      std::vector<double> __den_vec;
+	      if (__detail::__extract_params(__is, __den_vec, __n))
+		{
+		  __x.param({ __int_vec.begin(), __int_vec.end(),
+			      __den_vec.begin() });
+		}
+	    }
 	}
 
-      __x.param(typename piecewise_constant_distribution<_RealType>::
-	  param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
-
       __is.flags(__flags);
       return __is;
     }
@@ -3205,29 +3213,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __is.flags(__ios_base::dec | __ios_base::skipws);
 
       size_t __n;
-      __is >> __n;
-
-      std::vector<_RealType> __int_vec;
-      __int_vec.reserve(__n + 1);
-      for (size_t __i = 0; __i <= __n; ++__i)
+      if (__is >> __n)
 	{
-	  _RealType __int;
-	  __is >> __int;
-	  __int_vec.push_back(__int);
-	}
-
-      std::vector<double> __den_vec;
-      __den_vec.reserve(__n + 1);
-      for (size_t __i = 0; __i <= __n; ++__i)
-	{
-	  double __den;
-	  __is >> __den;
-	  __den_vec.push_back(__den);
+	  vector<_RealType> __int_vec;
+	  if (__detail::__extract_params(__is, __int_vec, __n + 1))
+	    {
+	      vector<double> __den_vec;
+	      if (__detail::__extract_params(__is, __den_vec, __n + 1))
+		{
+		  __x.param({ __int_vec.begin(), __int_vec.end(),
+			      __den_vec.begin() });
+		}
+	    }
 	}
-
-      __x.param(typename piecewise_linear_distribution<_RealType>::
-	  param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
-
       __is.flags(__flags);
       return __is;
     }
diff --git a/libstdc++-v3/include/bits/refwrap.h b/libstdc++-v3/include/bits/refwrap.h
index 6b4335a22ac..d95f7c57172 100644
--- a/libstdc++-v3/include/bits/refwrap.h
+++ b/libstdc++-v3/include/bits/refwrap.h
@@ -334,7 +334,8 @@ _GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)
 	operator()(_Args&&... __args) const
 	{
 #if __cplusplus > 201703L
-	  static_assert(sizeof(type), "type must be complete");
+	  if constexpr (is_object_v<type>)
+	    static_assert(sizeof(type), "type must be complete");
 #endif
 	  return std::__invoke(get(), std::forward<_Args>(__args)...);
 	}
diff --git a/libstdc++-v3/include/bits/std_function.h b/libstdc++-v3/include/bits/std_function.h
index b70ed564d11..b59f6978971 100644
--- a/libstdc++-v3/include/bits/std_function.h
+++ b/libstdc++-v3/include/bits/std_function.h
@@ -359,10 +359,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
-  template<typename _From, typename _To>
-    using __check_func_return_type
-      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;
-
   /**
    *  @brief Primary class template for std::function.
    *  @ingroup functors
@@ -375,8 +371,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       private _Function_base
     {
       template<typename _Func,
-	       typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
-	struct _Callable : __check_func_return_type<_Res2, _Res> { };
+	       typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
+	struct _Callable
+	: __is_invocable_impl<_Res2, _Res>::type
+	{ };
 
       // Used so the return type convertibility checks aren't done when
       // performing overload resolution for copy construction/assignment.
diff --git a/libstdc++-v3/include/bits/stl_algo.h b/libstdc++-v3/include/bits/stl_algo.h
index 3411a63b1a3..61319d1fd15 100644
--- a/libstdc++-v3/include/bits/stl_algo.h
+++ b/libstdc++-v3/include/bits/stl_algo.h
@@ -3877,6 +3877,45 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
     }
 
+#if __cplusplus >= 201703L
+  /**
+   *  @brief Apply a function to every element of a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __n      A value convertible to an integer.
+   *  @param  __f      A unary function object.
+   *  @return   `__first+__n`
+   *
+   *  Applies the function object `__f` to each element in the range
+   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
+   *  If `__f` has a return value it is ignored.
+  */
+  template<typename _InputIterator, typename _Size, typename _Function>
+    _InputIterator
+    for_each_n(_InputIterator __first, _Size __n, _Function __f)
+    {
+      typename iterator_traits<_InputIterator>::difference_type __n2 = __n;
+      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
+      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
+	{
+	  if (__n2 <= 0)
+	    return __first;
+	  auto __last = __first + __n2;
+	  std::for_each(__first, __last, std::move(__f));
+	  return __last;
+	}
+      else
+	{
+	  while (__n2-->0)
+	    {
+	      __f(*__first);
+	      ++__first;
+	    }
+	  return __first;
+	}
+    }
+#endif // C++17
+
   /**
    *  @brief Find the first occurrence of a value in a sequence.
    *  @ingroup non_mutating_algorithms
diff --git a/libstdc++-v3/include/bits/stl_algobase.h b/libstdc++-v3/include/bits/stl_algobase.h
index 3b1139401ee..6e9316a24cd 100644
--- a/libstdc++-v3/include/bits/stl_algobase.h
+++ b/libstdc++-v3/include/bits/stl_algobase.h
@@ -301,7 +301,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // (2) If we're using random access iterators, then write the loop as
   // a for loop with an explicit count.
 
-  template<bool, bool, typename>
+  template<bool _IsMove, bool _IsSimple, typename _Category>
     struct __copy_move
     {
       template<typename _II, typename _OI>
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 5c86efc0db2..5a95399162f 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -158,13 +158,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #else
       // Conversion from iterator to const_iterator.
       template<typename _Iter,
-              typename = _Require<is_same<_Self, const_iterator>,
-                                  is_same<_Iter, iterator>>>
+	       typename = _Require<is_same<_Self, const_iterator>,
+				   is_same<_Iter, iterator>>>
        _Deque_iterator(const _Iter& __x) noexcept
        : _M_cur(__x._M_cur), _M_first(__x._M_first),
-         _M_last(__x._M_last), _M_node(__x._M_node) { }
+	 _M_last(__x._M_last), _M_node(__x._M_node) { }
+
+      _Deque_iterator(const _Deque_iterator& __x) noexcept
+       : _M_cur(__x._M_cur), _M_first(__x._M_first),
+	 _M_last(__x._M_last), _M_node(__x._M_node) { }
 
-      _Deque_iterator(const _Deque_iterator&) = default;
       _Deque_iterator& operator=(const _Deque_iterator&) = default;
 #endif
 
diff --git a/libstdc++-v3/include/bits/stl_numeric.h b/libstdc++-v3/include/bits/stl_numeric.h
index e859c76bc44..387bed91174 100644
--- a/libstdc++-v3/include/bits/stl_numeric.h
+++ b/libstdc++-v3/include/bits/stl_numeric.h
@@ -60,12 +60,16 @@
 #include <debug/debug.h>
 #include <bits/move.h> // For _GLIBCXX_MOVE
 
-#if __cplusplus >= 201103L
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  /** @defgroup numeric_ops Generalized Numeric operations
+   *  @ingroup algorithms
+   */
+
+#if __cplusplus >= 201103L
   /**
    *  @brief  Create a range of sequentially increasing values.
    *
@@ -76,6 +80,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @param  __last  End of range.
    *  @param  __value  Starting value.
    *  @return  Nothing.
+   *  @ingroup numeric_ops
    */
   template<typename _ForwardIterator, typename _Tp>
     void
@@ -94,14 +99,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  ++__value;
 	}
     }
+#endif
 
 _GLIBCXX_END_NAMESPACE_VERSION
-} // namespace std
 
-#endif
-
-namespace std _GLIBCXX_VISIBILITY(default)
-{
 _GLIBCXX_BEGIN_NAMESPACE_ALGO
 
 #if __cplusplus > 201703L
@@ -112,6 +113,9 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 # define _GLIBCXX_MOVE_IF_20(_E) _E
 #endif
 
+  /// @addtogroup numeric_ops
+  /// @{
+
   /**
    *  @brief  Accumulate values in a range.
    *
@@ -139,8 +143,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
   /**
    *  @brief  Accumulate values in a range with operation.
    *
-   *  Accumulates the values in the range [first,last) using the function
-   *  object @p __binary_op.  The initial value is @p __init.  The values are
+   *  Accumulates the values in the range `[first,last)` using the function
+   *  object `__binary_op`.  The initial value is `__init`.  The values are
    *  processed in order.
    *
    *  @param  __first  Start of range.
@@ -390,6 +394,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       return ++__result;
     }
 
+  // @} group numeric_ops
+
 #undef _GLIBCXX_MOVE_IF_20
 
 _GLIBCXX_END_NAMESPACE_ALGO
diff --git a/libstdc++-v3/include/bits/stl_uninitialized.h b/libstdc++-v3/include/bits/stl_uninitialized.h
index 0d42b253df1..f5ca74329e2 100644
--- a/libstdc++-v3/include/bits/stl_uninitialized.h
+++ b/libstdc++-v3/include/bits/stl_uninitialized.h
@@ -122,9 +122,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #if __cplusplus < 201103L
       const bool __assignable = true;
 #else
-      // trivial types can have deleted assignment
+      // Trivial types can have deleted copy constructor, but the std::copy
+      // optimization that uses memmove would happily "copy" them anyway.
+      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
+	  "result type must be constructible from value type of input range");
+
       typedef typename iterator_traits<_InputIterator>::reference _RefType1;
       typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
+      // Trivial types can have deleted assignment, so using std::copy
+      // would be ill-formed. Require assignability before using std::copy:
       const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
 #endif
 
@@ -186,7 +192,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #if __cplusplus < 201103L
       const bool __assignable = true;
 #else
-      // trivial types can have deleted assignment
+      // Trivial types can have deleted copy constructor, but the std::fill
+      // optimization that uses memmove would happily "copy" them anyway.
+      static_assert(is_constructible<_ValueType, const _Tp&>::value,
+	  "result type must be constructible from input type");
+
+      // Trivial types can have deleted assignment, so using std::fill
+      // would be ill-formed. Require assignability before using std::fill:
       const bool __assignable = is_copy_assignable<_ValueType>::value;
 #endif
 
@@ -248,7 +260,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #if __cplusplus < 201103L
       const bool __assignable = true;
 #else
-      // trivial types can have deleted assignment
+      // Trivial types can have deleted copy constructor, but the std::fill
+      // optimization that uses memmove would happily "copy" them anyway.
+      static_assert(is_constructible<_ValueType, const _Tp&>::value,
+	  "result type must be constructible from input type");
+
+      // Trivial types can have deleted assignment, so using std::fill
+      // would be ill-formed. Require assignability before using std::fill:
       const bool __assignable = is_copy_assignable<_ValueType>::value;
 #endif
       return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
index d8129747eb5..c934873a722 100644
--- a/libstdc++-v3/include/bits/unique_ptr.h
+++ b/libstdc++-v3/include/bits/unique_ptr.h
@@ -155,6 +155,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Dp&       _M_deleter() { return std::get<1>(_M_t); }
       const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
 
+      void
+      swap(__uniq_ptr_impl& __rhs) noexcept
+      {
+	using std::swap;
+	swap(this->_M_ptr(), __rhs._M_ptr());
+	swap(this->_M_deleter(), __rhs._M_deleter());
+      }
+
     private:
       tuple<pointer, _Dp> _M_t;
     };
@@ -398,8 +406,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void
       swap(unique_ptr& __u) noexcept
       {
-	using std::swap;
-	swap(_M_t, __u._M_t);
+	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
+	_M_t.swap(__u._M_t);
       }
 
       // Disable copy from lvalue.
@@ -673,8 +681,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void
       swap(unique_ptr& __u) noexcept
       {
-	using std::swap;
-	swap(_M_t, __u._M_t);
+	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
+	_M_t.swap(__u._M_t);
       }
 
       // Disable copy from lvalue.
diff --git a/libstdc++-v3/include/c_global/cmath b/libstdc++-v3/include/c_global/cmath
index b843c18f1da..01e56a559fe 100644
--- a/libstdc++-v3/include/c_global/cmath
+++ b/libstdc++-v3/include/c_global/cmath
@@ -1891,7 +1891,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Fp>
     constexpr _Fp
-    __lerp(_Fp __a, _Fp __b, _Fp __t)
+    __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept
     {
       if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
 	return __t * __b + (1 - __t) * __a;
@@ -1908,15 +1908,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   constexpr float
-  lerp(float __a, float __b, float __t)
+  lerp(float __a, float __b, float __t) noexcept
   { return std::__lerp(__a, __b, __t); }
 
   constexpr double
-  lerp(double __a, double __b, double __t)
+  lerp(double __a, double __b, double __t) noexcept
   { return std::__lerp(__a, __b, __t); }
 
   constexpr long double
-  lerp(long double __a, long double __b, long double __t)
+  lerp(long double __a, long double __b, long double __t) noexcept
   { return std::__lerp(__a, __b, __t); }
 #endif // C++20
 
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 467bdfda3ed..3b397737bb6 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -50,6 +50,9 @@
 #ifdef _GLIBCXX_HAVE_ARPA_INET_H
 # include <arpa/inet.h>		// inet_ntop
 #endif
+#ifdef _GLIBCXX_HAVE_NETINET_IN_H
+# include <netinet/in.h>	// IPPROTO_IP
+#endif
 #ifdef _GLIBCXX_HAVE_NETINET_TCP_H
 # include <netinet/tcp.h>	// TCP_NODELAY
 #endif
@@ -539,7 +542,7 @@ namespace ip
     const auto& __aa = __a._M_bytes;
     const auto& __bb = __b._M_bytes;
     int __i = 0;
-    for (; __aa[__i] == __bb[__i] && __i < 16; ++__i)
+    for (; __i < 16 && __aa[__i] == __bb[__i]; ++__i)
       ;
     return __i == 16 ? __a.scope_id() == __b.scope_id() : false;
   }
@@ -554,7 +557,7 @@ namespace ip
     const auto& __aa = __a._M_bytes;
     const auto& __bb = __b._M_bytes;
     int __i = 0;
-    for (; __aa[__i] == __bb[__i] && __i < 16; ++__i)
+    for (; __i < 16 && __aa[__i] == __bb[__i]; ++__i)
       ;
     return __i == 16 ? __a.scope_id() < __b.scope_id() : __aa[__i] < __bb[__i];
   }
diff --git a/libstdc++-v3/include/pstl/glue_numeric_defs.h b/libstdc++-v3/include/pstl/glue_numeric_defs.h
index 55187f1f6ea..12e967b1629 100644
--- a/libstdc++-v3/include/pstl/glue_numeric_defs.h
+++ b/libstdc++-v3/include/pstl/glue_numeric_defs.h
@@ -55,7 +55,7 @@ exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIte
                _ForwardIterator2 __result, _Tp __init);
 
 template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>
-_ForwardIterator2
+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
 exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
                _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op);
 
diff --git a/libstdc++-v3/include/pstl/glue_numeric_impl.h b/libstdc++-v3/include/pstl/glue_numeric_impl.h
index bde0b03f3fb..748f47ce0c0 100644
--- a/libstdc++-v3/include/pstl/glue_numeric_impl.h
+++ b/libstdc++-v3/include/pstl/glue_numeric_impl.h
@@ -100,7 +100,7 @@ exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIte
 }
 
 template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>
-_ForwardIterator2
+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
 exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
                _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op)
 {
diff --git a/libstdc++-v3/include/std/complex b/libstdc++-v3/include/std/complex
index 0a4f68bc438..45450e8ca01 100644
--- a/libstdc++-v3/include/std/complex
+++ b/libstdc++-v3/include/std/complex
@@ -1898,41 +1898,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Tp>
     std::complex<_Tp> proj(const std::complex<_Tp>&);
 
+  // Generic implementation of std::proj, does not work for infinities.
   template<typename _Tp>
-    std::complex<_Tp>
+    inline std::complex<_Tp>
     __complex_proj(const std::complex<_Tp>& __z)
-    {
-      const _Tp __den = (__z.real() * __z.real()
-			 + __z.imag() * __z.imag() + _Tp(1.0));
-
-      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,
-			       (_Tp(2.0) * __z.imag()) / __den);
-    }
+    { return __z; }
 
 #if _GLIBCXX_USE_C99_COMPLEX
-  inline __complex__ float
-  __complex_proj(__complex__ float __z)
-  { return __builtin_cprojf(__z); }
-
-  inline __complex__ double
-  __complex_proj(__complex__ double __z)
-  { return __builtin_cproj(__z); }
-
-  inline __complex__ long double
-  __complex_proj(const __complex__ long double& __z)
-  { return __builtin_cprojl(__z); }
+  inline complex<float>
+  __complex_proj(const complex<float>& __z)
+  { return __builtin_cprojf(__z.__rep()); }
+
+  inline complex<double>
+  __complex_proj(const complex<double>& __z)
+  { return __builtin_cproj(__z.__rep()); }
+
+  inline complex<long double>
+  __complex_proj(const complex<long double>& __z)
+  { return __builtin_cprojl(__z.__rep()); }
+#elif defined _GLIBCXX_USE_C99_MATH_TR1
+  inline complex<float>
+  __complex_proj(const complex<float>& __z)
+  {
+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))
+      return complex<float>(__builtin_inff(),
+			    __builtin_copysignf(0.0f, __z.imag()));
+    return __z;
+  }
+
+  inline complex<double>
+  __complex_proj(const complex<double>& __z)
+  {
+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))
+      return complex<double>(__builtin_inf(),
+			     __builtin_copysign(0.0, __z.imag()));
+    return __z;
+  }
+
+  inline complex<long double>
+  __complex_proj(const complex<long double>& __z)
+  {
+    if (__builtin_isinf(__z.real()) || __builtin_isinf(__z.imag()))
+      return complex<long double>(__builtin_infl(),
+				  __builtin_copysignl(0.0l, __z.imag()));
+    return __z;
+  }
+#endif
 
-  template<typename _Tp>
-    inline std::complex<_Tp>
-    proj(const std::complex<_Tp>& __z)
-    { return __complex_proj(__z.__rep()); }
-#else
   template<typename _Tp>
     inline std::complex<_Tp>
     proj(const std::complex<_Tp>& __z)
     { return __complex_proj(__z); }
-#endif
 
+  // Overload for scalars
   template<typename _Tp>
     inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
     proj(_Tp __x)
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index 8cf2c670648..528452fed40 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -837,7 +837,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
 #if __cplusplus > 201703L
-#define __cpp_lib_bind_front 201902L
+#define __cpp_lib_bind_front 201907L
 
   template<typename _Fd, typename... _BoundArgs>
     struct _Bind_front
@@ -923,7 +923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Fn, typename... _Args>
     using _Bind_front_t
-      = _Bind_front<decay_t<_Fn>, unwrap_ref_decay_t<_Args>...>;
+      = _Bind_front<decay_t<_Fn>, decay_t<_Args>...>;
 
   template<typename _Fn, typename... _Args>
     _Bind_front_t<_Fn, _Args...>
diff --git a/libstdc++-v3/include/std/memory_resource b/libstdc++-v3/include/std/memory_resource
index 7f1f0ca5e91..7ff5d17afe7 100644
--- a/libstdc++-v3/include/std/memory_resource
+++ b/libstdc++-v3/include/std/memory_resource
@@ -88,7 +88,7 @@ namespace pmr
   public:
     memory_resource() = default;
     memory_resource(const memory_resource&) = default;
-    virtual ~memory_resource() = default;
+    virtual ~memory_resource(); // key function
 
     memory_resource& operator=(const memory_resource&) = default;
 
@@ -600,7 +600,7 @@ namespace pmr
 
     monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;
 
-    virtual ~monotonic_buffer_resource() { release(); }
+    virtual ~monotonic_buffer_resource(); // key function
 
     monotonic_buffer_resource&
     operator=(const monotonic_buffer_resource&) = delete;
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index bef823bf526..87a50e572d1 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -220,6 +220,472 @@ _GLIBCXX_END_NAMESPACE_VERSION
 #endif // C++20
 
 #if __cplusplus > 201402L
+#include <bits/stl_function.h>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @addtogroup numeric_ops
+  /// @{
+
+  /// @cond undocumented
+  template<typename _It, typename _Traits = iterator_traits<_It>,
+	   typename _Cat = typename _Traits::iterator_category>
+    using __is_random_access_iter
+      = is_base_of<random_access_iterator_tag, _Cat>;
+  /// @endcond
+
+  /**
+   *  @brief  Calculate reduction of values in a range.
+   *
+   *  @param  __first  Start of range.
+   *  @param  __last  End of range.
+   *  @param  __init  Starting value to add other values to.
+   *  @param  __binary_op A binary function object.
+   *  @return  The final sum.
+   *
+   *  Reduce the values in the range `[first,last)` using a binary operation.
+   *  The initial value is `init`.  The values are not necessarily processed
+   *  in order.
+   *
+   *  This algorithm is similar to `std::accumulate` but is not required to
+   *  perform the operations in order from first to last. For operations
+   *  that are commutative and associative the result will be the same as
+   *  for `std::accumulate`, but for other operations (such as floating point
+   *  arithmetic) the result can be different.
+   */
+  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
+    _Tp
+    reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
+	   _BinaryOperation __binary_op)
+    {
+      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, _Tp&>);
+      static_assert(is_convertible_v<value_type, _Tp>);
+      if constexpr (__is_random_access_iter<_InputIterator>::value)
+	{
+	  while ((__last - __first) >= 4)
+	    {
+	      _Tp __v1 = __binary_op(__first[0], __first[1]);
+	      _Tp __v2 = __binary_op(__first[2], __first[3]);
+	      _Tp __v3 = __binary_op(__v1, __v2);
+	      __init = __binary_op(__init, __v3);
+	      __first += 4;
+	    }
+	}
+      for (; __first != __last; ++__first)
+	__init = __binary_op(__init, *__first);
+      return __init;
+    }
+
+ /**
+   *  @brief  Calculate reduction of values in a range.
+   *
+   *  @param  __first  Start of range.
+   *  @param  __last  End of range.
+   *  @param  __init  Starting value to add other values to.
+   *  @return  The final sum.
+   *
+   *  Reduce the values in the range `[first,last)` using addition.
+   *  Equivalent to calling `std::reduce(first, last, init, std::plus<>())`.
+   */
+  template<typename _InputIterator, typename _Tp>
+    inline _Tp
+    reduce(_InputIterator __first, _InputIterator __last, _Tp __init)
+    { return std::reduce(__first, __last, std::move(__init), plus<>()); }
+
+  /**
+   *  @brief  Calculate reduction of values in a range.
+   *
+   *  @param  __first  Start of range.
+   *  @param  __last  End of range.
+   *  @return  The final sum.
+   *
+   *  Reduce the values in the range `[first,last)` using addition, with
+   *  an initial value of `T{}`, where `T` is the iterator's value type.
+   *  Equivalent to calling `std::reduce(first, last, T{}, std::plus<>())`.
+   */
+  template<typename _InputIterator>
+    inline typename iterator_traits<_InputIterator>::value_type
+    reduce(_InputIterator __first, _InputIterator __last)
+    {
+      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      return std::reduce(__first, __last, value_type{}, plus<>());
+    }
+
+  /**
+   *  @brief  Combine elements from two ranges and reduce
+   *
+   *  @param  __first1  Start of first range.
+   *  @param  __last1  End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __init  Starting value to add other values to.
+   *  @param  __binary_op1 The function used to perform reduction.
+   *  @param  __binary_op2 The function used to combine values from the ranges.
+   *  @return  The final sum.
+   *
+   *  Call `binary_op2(first1[n],first2[n])` for each `n` in `[0,last1-first1)`
+   *  and then use `binary_op1` to reduce the values returned by `binary_op2`
+   *  to a single value of type `T`.
+   *
+   *  The range beginning at `first2` must contain at least `last1-first1`
+   *  elements.
+   */
+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
+	   typename _BinaryOperation1, typename _BinaryOperation2>
+    _Tp
+    transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
+		     _InputIterator2 __first2, _Tp __init,
+		     _BinaryOperation1 __binary_op1,
+		     _BinaryOperation2 __binary_op2)
+    {
+      if constexpr (__and_v<__is_random_access_iter<_InputIterator1>,
+			    __is_random_access_iter<_InputIterator2>>)
+	{
+	  while ((__last1 - __first1) >= 4)
+	    {
+	      _Tp __v1 = __binary_op1(__binary_op2(__first1[0], __first2[0]),
+				      __binary_op2(__first1[1], __first2[1]));
+	      _Tp __v2 = __binary_op1(__binary_op2(__first1[2], __first2[2]),
+				      __binary_op2(__first1[3], __first2[3]));
+	      _Tp __v3 = __binary_op1(__v1, __v2);
+	      __init = __binary_op1(__init, __v3);
+	      __first1 += 4;
+	      __first2 += 4;
+	    }
+	}
+      for (; __first1 != __last1; ++__first1, (void) ++__first2)
+	__init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
+      return __init;
+    }
+
+  /**
+   *  @brief  Combine elements from two ranges and reduce
+   *
+   *  @param  __first1  Start of first range.
+   *  @param  __last1  End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __init  Starting value to add other values to.
+   *  @return  The final sum.
+   *
+   *  Call `first1[n]*first2[n]` for each `n` in `[0,last1-first1)` and then
+   *  use addition to sum those products to a single value of type `T`.
+   *
+   *  The range beginning at `first2` must contain at least `last1-first1`
+   *  elements.
+   */
+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
+    inline _Tp
+    transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
+		     _InputIterator2 __first2, _Tp __init)
+    {
+      return std::transform_reduce(__first1, __last1, __first2,
+				   std::move(__init),
+				   plus<>(), multiplies<>());
+    }
+
+  /**
+   *  @brief  Transform the elements of a range and reduce
+   *
+   *  @param  __first  Start of range.
+   *  @param  __last  End of range.
+   *  @param  __init  Starting value to add other values to.
+   *  @param  __binary_op The function used to perform reduction.
+   *  @param  __unary_op The function used to transform values from the range.
+   *  @return  The final sum.
+   *
+   *  Call `unary_op(first[n])` for each `n` in `[0,last-first)` and then
+   *  use `binary_op` to reduce the values returned by `unary_op`
+   *  to a single value of type `T`.
+   */
+  template<typename _InputIterator, typename _Tp,
+	   typename _BinaryOperation, typename _UnaryOperation>
+    _Tp
+    transform_reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
+		     _BinaryOperation __binary_op, _UnaryOperation __unary_op)
+    {
+      if constexpr (__is_random_access_iter<_InputIterator>::value)
+	{
+	  while ((__last - __first) >= 4)
+	    {
+	      _Tp __v1 = __binary_op(__unary_op(__first[0]),
+				     __unary_op(__first[1]));
+	      _Tp __v2 = __binary_op(__unary_op(__first[2]),
+				     __unary_op(__first[3]));
+	      _Tp __v3 = __binary_op(__v1, __v2);
+	      __init = __binary_op(__init, __v3);
+	      __first += 4;
+	    }
+	}
+      for (; __first != __last; ++__first)
+	__init = __binary_op(__init, __unary_op(*__first));
+      return __init;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __init   Initial value.
+   *  @param __binary_op Function to perform summation.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements (and the initial value),
+   *  using `binary_op` for summation.
+   *
+   *  This function generates an "exclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N-1 input elements,
+   *  so the Nth input element is not included.
+   */
+  template<typename _InputIterator, typename _OutputIterator, typename _Tp,
+	   typename _BinaryOperation>
+    _OutputIterator
+    exclusive_scan(_InputIterator __first, _InputIterator __last,
+		   _OutputIterator __result, _Tp __init,
+		   _BinaryOperation __binary_op)
+    {
+      while (__first != __last)
+	{
+	  auto __v = __init;
+	  __init = __binary_op(__init, *__first);
+	  ++__first;
+	  *__result++ = std::move(__v);
+	}
+      return __result;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __init   Initial value.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements (and the initial value),
+   *  using `std::plus<>` for summation.
+   *
+   *  This function generates an "exclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N-1 input elements,
+   *  so the Nth input element is not included.
+   */
+  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
+    inline _OutputIterator
+    exclusive_scan(_InputIterator __first, _InputIterator __last,
+		   _OutputIterator __result, _Tp __init)
+    {
+      return std::exclusive_scan(__first, __last, __result, std::move(__init),
+				 plus<>());
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __binary_op Function to perform summation.
+   *  @param __init   Initial value.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements (and the initial value),
+   *  using `binary_op` for summation.
+   *
+   *  This function generates an "inclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N input elements,
+   *  so the Nth input element is included.
+   */
+  template<typename _InputIterator, typename _OutputIterator,
+	   typename _BinaryOperation, typename _Tp>
+    _OutputIterator
+    inclusive_scan(_InputIterator __first, _InputIterator __last,
+		   _OutputIterator __result, _BinaryOperation __binary_op,
+		   _Tp __init)
+    {
+      for (; __first != __last; ++__first)
+	*__result++ = __init = __binary_op(__init, *__first);
+      return __result;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __binary_op Function to perform summation.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements, using `binary_op` for summation.
+   *
+   *  This function generates an "inclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N input elements,
+   *  so the Nth input element is included.
+   */
+  template<typename _InputIterator, typename _OutputIterator,
+	   typename _BinaryOperation>
+    _OutputIterator
+    inclusive_scan(_InputIterator __first, _InputIterator __last,
+		   _OutputIterator __result, _BinaryOperation __binary_op)
+    {
+      if (__first != __last)
+	{
+	  auto __init = *__first;
+	  *__result++ = __init;
+	  ++__first;
+	  if (__first != __last)
+	    __result = std::inclusive_scan(__first, __last, __result,
+					   __binary_op, std::move(__init));
+	}
+      return __result;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements, using `std::plus<>` for summation.
+   *
+   *  This function generates an "inclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N input elements,
+   *  so the Nth input element is included.
+   */
+  template<typename _InputIterator, typename _OutputIterator>
+    inline _OutputIterator
+    inclusive_scan(_InputIterator __first, _InputIterator __last,
+		   _OutputIterator __result)
+    { return std::inclusive_scan(__first, __last, __result, plus<>()); }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __init   Initial value.
+   *  @param __binary_op Function to perform summation.
+   *  @param __unary_op Function to transform elements of the input range.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements (and the initial value),
+   *  using `__unary_op` to transform the input elements
+   *  and using `__binary_op` for summation.
+   *
+   *  This function generates an "exclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N-1 input elements,
+   *  so the Nth input element is not included.
+   */
+  template<typename _InputIterator, typename _OutputIterator, typename _Tp,
+	   typename _BinaryOperation, typename _UnaryOperation>
+    _OutputIterator
+    transform_exclusive_scan(_InputIterator __first, _InputIterator __last,
+			     _OutputIterator __result, _Tp __init,
+			     _BinaryOperation __binary_op,
+			     _UnaryOperation __unary_op)
+    {
+      while (__first != __last)
+	{
+	  auto __v = __init;
+	  __init = __binary_op(__init, __unary_op(*__first));
+	  ++__first;
+	  *__result++ = std::move(__v);
+	}
+      return __result;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __binary_op Function to perform summation.
+   *  @param __unary_op Function to transform elements of the input range.
+   *  @param __init   Initial value.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements (and the initial value),
+   *  using `__unary_op` to transform the input elements
+   *  and using `__binary_op` for summation.
+   *
+   *  This function generates an "inclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N input elements,
+   *  so the Nth input element is included.
+   */
+  template<typename _InputIterator, typename _OutputIterator,
+	   typename _BinaryOperation, typename _UnaryOperation, typename _Tp>
+    _OutputIterator
+    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
+			     _OutputIterator __result,
+			     _BinaryOperation __binary_op,
+			     _UnaryOperation __unary_op,
+			     _Tp __init)
+    {
+      for (; __first != __last; ++__first)
+	*__result++ = __init = __binary_op(__init, __unary_op(*__first));
+      return __result;
+    }
+
+  /** @brief Output the cumulative sum of one range to a second range
+   *
+   *  @param __first  Start of input range.
+   *  @param __last   End of input range.
+   *  @param __result Start of output range.
+   *  @param __binary_op Function to perform summation.
+   *  @param __unary_op Function to transform elements of the input range.
+   *  @return The end of the output range.
+   *
+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
+   *  to the output range. Each element of the output range contains the
+   *  running total of all earlier elements,
+   *  using `__unary_op` to transform the input elements
+   *  and using `__binary_op` for summation.
+   *
+   *  This function generates an "inclusive" scan, meaning the Nth element
+   *  of the output range is the sum of the first N input elements,
+   *  so the Nth input element is included.
+   */
+  template<typename _InputIterator, typename _OutputIterator,
+	  typename _BinaryOperation, typename _UnaryOperation>
+    _OutputIterator
+    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
+			     _OutputIterator __result,
+			     _BinaryOperation __binary_op,
+			     _UnaryOperation __unary_op)
+    {
+      if (__first != __last)
+	{
+	  auto __init = __unary_op(*__first);
+	  *__result++ = __init;
+	  ++__first;
+	  if (__first != __last)
+	    __result = std::transform_inclusive_scan(__first, __last, __result,
+						     __binary_op, __unary_op,
+						     std::move(__init));
+	}
+      return __result;
+    }
+
+  // @} group numeric_ops
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace std
+
 // Parallel STL algorithms
 # if __PSTL_EXECUTION_POLICIES_DEFINED
 // If <execution> has already been included, pull in implementations
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index 440813dcf76..9bad55829ce 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -2662,14 +2662,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // __is_invocable (std::is_invocable for C++11)
 
-  template<typename _Result, typename _Ret, typename = void>
+  // The primary template is used for invalid INVOKE expressions.
+  template<typename _Result, typename _Ret,
+	   bool = is_void<_Ret>::value, typename = void>
     struct __is_invocable_impl : false_type { };
 
+  // Used for valid INVOKE and INVOKE<void> expressions.
   template<typename _Result, typename _Ret>
-    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
-    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
+    struct __is_invocable_impl<_Result, _Ret,
+			       /* is_void<_Ret> = */ true,
+			       __void_t<typename _Result::type>>
+    : true_type
     { };
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
+  // Used for INVOKE<R> expressions to check the implicit conversion to R.
+  template<typename _Result, typename _Ret>
+    struct __is_invocable_impl<_Result, _Ret,
+			       /* is_void<_Ret> = */ false,
+			       __void_t<typename _Result::type>>
+    {
+    private:
+      // The type of the INVOKE expression.
+      // Unlike declval, this doesn't add_rvalue_reference.
+      static typename _Result::type _S_get();
+
+      template<typename _Tp>
+	static void _S_conv(_Tp);
+
+      // This overload is viable if INVOKE(f, args...) can convert to _Tp.
+      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
+	static true_type
+	_S_test(int);
+
+      template<typename _Tp>
+	static false_type
+	_S_test(...);
+
+    public:
+      using type = decltype(_S_test<_Ret>(1));
+    };
+#pragma GCC diagnostic pop
+
   template<typename _Fn, typename... _ArgTypes>
     struct __is_invocable
     : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
diff --git a/libstdc++-v3/include/std/version b/libstdc++-v3/include/std/version
index a513e09eb2f..3c288301952 100644
--- a/libstdc++-v3/include/std/version
+++ b/libstdc++-v3/include/std/version
@@ -149,7 +149,7 @@
 
 #if __cplusplus > 201703L
 // c++2a
-#define __cpp_lib_bind_front 201902L
+#define __cpp_lib_bind_front 201907L
 #define __cpp_lib_bounded_array_traits 201902L
 #if __cpp_impl_destroying_delete
 # define __cpp_lib_destroying_delete 201806L
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
index 434a4cc87ec..28c877c0484 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset
+++ b/libstdc++-v3/include/tr2/dynamic_bitset
@@ -34,10 +34,9 @@
 #include <limits>
 #include <vector>
 #include <string>
-#include <memory> // For std::allocator
-#include <bits/functexcept.h>   // For invalid_argument, out_of_range,
-				// overflow_error
-#include <iosfwd>
+#include <istream>
+#include <bits/functexcept.h>
+#include <bits/stl_algo.h>	// For fill
 #include <bits/cxxabi_forced.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,41 +75,48 @@ namespace tr2
       std::vector<block_type, allocator_type> _M_w;
 
       explicit
-      __dynamic_bitset_base(const allocator_type& __alloc = allocator_type())
+      __dynamic_bitset_base(const allocator_type& __alloc)
       : _M_w(__alloc)
       { }
 
-      explicit
-      __dynamic_bitset_base(__dynamic_bitset_base&& __b)
-      { this->_M_w.swap(__b._M_w); }
+      __dynamic_bitset_base() = default;
+      __dynamic_bitset_base(const __dynamic_bitset_base&) = default;
+      __dynamic_bitset_base(__dynamic_bitset_base&& __b) = default;
+      __dynamic_bitset_base& operator=(const __dynamic_bitset_base&) = default;
+      __dynamic_bitset_base& operator=(__dynamic_bitset_base&&) = default;
+      ~__dynamic_bitset_base() = default;
 
       explicit
       __dynamic_bitset_base(size_type __nbits, unsigned long long __val = 0ULL,
 			   const allocator_type& __alloc = allocator_type())
-      : _M_w(__nbits / _S_bits_per_block
-	     + (__nbits % _S_bits_per_block > 0),
-	     __val, __alloc)
+      : _M_w(__nbits / _S_bits_per_block + (__nbits % _S_bits_per_block > 0),
+	     block_type(0), __alloc)
       {
-	unsigned long long __mask = ~static_cast<block_type>(0);
-	size_t __n = std::min(this->_M_w.size(),
-			      sizeof(unsigned long long) / sizeof(block_type));
-	for (size_t __i = 0; __i < __n; ++__i)
+	if (__nbits < std::numeric_limits<decltype(__val)>::digits)
+	  __val &= ~(-1ULL << __nbits);
+	if (__val == 0)
+	  return;
+
+	if _GLIBCXX17_CONSTEXPR (sizeof(__val) == sizeof(block_type))
+	  _M_w[0] = __val;
+	else
 	  {
-	    this->_M_w[__i] = (__val & __mask) >> (__i * _S_bits_per_block);
-	    __mask <<= _S_bits_per_block;
+	    const size_t __n
+	      = std::min(_M_w.size(), sizeof(__val) / sizeof(block_type));
+	    for (size_t __i = 0; __val && __i < __n; ++__i)
+	      {
+		_M_w[__i] = static_cast<block_type>(__val);
+		__val >>= _S_bits_per_block;
+	      }
 	  }
       }
 
       void
-      _M_assign(const __dynamic_bitset_base& __b)
-      { this->_M_w = __b._M_w; }
-
-      void
-      _M_swap(__dynamic_bitset_base& __b)
+      _M_swap(__dynamic_bitset_base& __b) noexcept
       { this->_M_w.swap(__b._M_w); }
 
       void
-      _M_clear()
+      _M_clear() noexcept
       { this->_M_w.clear(); }
 
       void
@@ -129,7 +135,7 @@ namespace tr2
       }
 
       allocator_type
-      _M_get_allocator() const
+      _M_get_allocator() const noexcept
       { return this->_M_w.get_allocator(); }
 
       static size_type
@@ -149,23 +155,23 @@ namespace tr2
       { return (static_cast<block_type>(1)) << _S_whichbit(__pos); }
 
       block_type&
-      _M_getword(size_type __pos)
+      _M_getword(size_type __pos) noexcept
       { return this->_M_w[_S_whichword(__pos)]; }
 
       block_type
-      _M_getword(size_type __pos) const
+      _M_getword(size_type __pos) const noexcept
       { return this->_M_w[_S_whichword(__pos)]; }
 
       block_type&
-      _M_hiword()
+      _M_hiword() noexcept
       { return this->_M_w[_M_w.size() - 1]; }
 
       block_type
-      _M_hiword() const
+      _M_hiword() const noexcept
       { return this->_M_w[_M_w.size() - 1]; }
 
       void
-      _M_do_and(const __dynamic_bitset_base& __x)
+      _M_do_and(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -175,7 +181,7 @@ namespace tr2
       }
 
       void
-      _M_do_or(const __dynamic_bitset_base& __x)
+      _M_do_or(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -185,7 +191,7 @@ namespace tr2
       }
 
       void
-      _M_do_xor(const __dynamic_bitset_base& __x)
+      _M_do_xor(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -195,7 +201,7 @@ namespace tr2
       }
 
       void
-      _M_do_dif(const __dynamic_bitset_base& __x)
+      _M_do_dif(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -211,28 +217,27 @@ namespace tr2
       _M_do_right_shift(size_t __shift);
 
       void
-      _M_do_flip()
+      _M_do_flip() noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
 	  this->_M_w[__i] = ~this->_M_w[__i];
       }
 
       void
-      _M_do_set()
+      _M_do_set() noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
-	  this->_M_w[__i] = ~static_cast<block_type>(0);
+	  this->_M_w[__i] = static_cast<block_type>(-1);
       }
 
       void
-      _M_do_reset()
+      _M_do_reset() noexcept
       {
-	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
-	  this->_M_w[__i] = static_cast<block_type>(0);
+	std::fill(_M_w.begin(), _M_w.end(), static_cast<block_type>(0));
       }
 
       bool
-      _M_is_equal(const __dynamic_bitset_base& __x) const
+      _M_is_equal(const __dynamic_bitset_base& __x) const noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  {
@@ -246,7 +251,7 @@ namespace tr2
       }
 
       bool
-      _M_is_less(const __dynamic_bitset_base& __x) const
+      _M_is_less(const __dynamic_bitset_base& __x) const noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  {
@@ -264,17 +269,17 @@ namespace tr2
       }
 
       size_t
-      _M_are_all_aux() const
+      _M_are_all_aux() const noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size() - 1; ++__i)
-	  if (_M_w[__i] != ~static_cast<block_type>(0))
+	  if (_M_w[__i] != static_cast<block_type>(-1))
 	    return 0;
 	return ((this->_M_w.size() - 1) * _S_bits_per_block
 		+ __builtin_popcountll(this->_M_hiword()));
       }
 
       bool
-      _M_is_any() const
+      _M_is_any() const noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
 	  if (this->_M_w[__i] != static_cast<block_type>(0))
@@ -283,7 +288,7 @@ namespace tr2
       }
 
       bool
-      _M_is_subset_of(const __dynamic_bitset_base& __b)
+      _M_is_subset_of(const __dynamic_bitset_base& __b) noexcept
       {
 	if (__b._M_w.size() == this->_M_w.size())
 	  {
@@ -297,7 +302,7 @@ namespace tr2
       }
 
       bool
-      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const
+      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const noexcept
       {
 	if (this->is_subset_of(__b))
 	  {
@@ -311,7 +316,7 @@ namespace tr2
       }
 
       size_t
-      _M_do_count() const
+      _M_do_count() const noexcept
       {
 	size_t __result = 0;
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -357,6 +362,7 @@ namespace tr2
    *
    *  See N2050,
    *  Proposal to Add a Dynamically Sizeable Bitset to the Standard Library.
+   *  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf
    *
    *  In the general unoptimized case, storage is allocated in
    *  word-sized blocks.  Let B be the number of bits in a word, then
@@ -435,7 +441,7 @@ namespace tr2
       {
 	size_type __shift = this->_M_Nb % bits_per_block;
 	if (__shift > 0)
-	  this->_M_hiword() &= ~((~static_cast<block_type>(0)) << __shift);
+	  this->_M_hiword() &= block_type(~(block_type(-1) << __shift));
       }
 
       //  Set the unused bits in the uppermost word.
@@ -444,22 +450,22 @@ namespace tr2
       {
 	size_type __shift = this->_M_Nb % bits_per_block;
 	if (__shift > 0)
-	  this->_M_hiword() |= ((~static_cast<block_type>(0)) << __shift);
+	  this->_M_hiword() |= block_type(block_type(-1) << __shift);
       }
 
       /**
        *  These versions of single-bit set, reset, flip, and test
        *  do no range checking.
        */
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_set(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_set(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_set(size_type __pos, int __val)
+      dynamic_bitset&
+      _M_unchecked_set(size_type __pos, int __val) noexcept
       {
 	if (__val)
 	  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
@@ -468,26 +474,26 @@ namespace tr2
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_reset(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_reset(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_flip(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_flip(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
 	return *this;
       }
 
       bool
-      _M_unchecked_test(size_type __pos) const
+      _M_unchecked_test(size_type __pos) const noexcept
       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
 		!= static_cast<_WordT>(0)); }
 
-      size_type _M_Nb;
+      size_type _M_Nb = 0;
 
     public:
       /**
@@ -511,22 +517,16 @@ namespace tr2
 	block_type *_M_wp;
 	size_type _M_bpos;
 
-	// left undefined
-	reference();
-
       public:
-	reference(dynamic_bitset& __b, size_type __pos)
+	reference(dynamic_bitset& __b, size_type __pos) noexcept
 	{
 	  this->_M_wp = &__b._M_getword(__pos);
 	  this->_M_bpos = _Base::_S_whichbit(__pos);
 	}
 
-	~reference()
-	{ }
-
 	// For b[i] = __x;
 	reference&
-	operator=(bool __x)
+	operator=(bool __x) noexcept
 	{
 	  if (__x)
 	    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);
@@ -537,7 +537,7 @@ namespace tr2
 
 	// For b[i] = b[__j];
 	reference&
-	operator=(const reference& __j)
+	operator=(const reference& __j) noexcept
 	{
 	  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
 	    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);
@@ -548,16 +548,16 @@ namespace tr2
 
 	// Flips the bit
 	bool
-	operator~() const
+	operator~() const noexcept
 	{ return (*(_M_wp) & _Base::_S_maskbit(this->_M_bpos)) == 0; }
 
 	// For __x = b[i];
-	operator bool() const
+	operator bool() const noexcept
 	{ return (*(this->_M_wp) & _Base::_S_maskbit(this->_M_bpos)) != 0; }
 
 	// For b[i].flip();
 	reference&
-	flip()
+	flip() noexcept
 	{
 	  *this->_M_wp ^= _Base::_S_maskbit(this->_M_bpos);
 	  return *this;
@@ -569,10 +569,14 @@ namespace tr2
       typedef bool const_reference;
 
       // 23.3.5.1 constructors:
+
+      /// All bits set to zero.
+      dynamic_bitset() = default;
+
       /// All bits set to zero.
       explicit
-      dynamic_bitset(const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc), _M_Nb(0)
+      dynamic_bitset(const allocator_type& __alloc)
+      : _Base(__alloc)
       { }
 
       /// Initial bits bitwise-copied from a single word (others set to zero).
@@ -585,7 +589,7 @@ namespace tr2
 
       dynamic_bitset(initializer_list<block_type> __il,
 		     const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc), _M_Nb(0)
+      : _Base(__alloc)
       { this->append(__il); }
 
       /**
@@ -609,8 +613,7 @@ namespace tr2
 		       __n = std::basic_string<_CharT, _Traits, _Alloc1>::npos,
 		       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'),
 		       const allocator_type& __alloc = allocator_type())
-	: _Base(__alloc),
-	  _M_Nb(0) // Watch for npos.
+	: _Base(__alloc)
 	{
 	  if (__pos > __str.size())
 	    __throw_out_of_range(__N("dynamic_bitset::bitset initial position "
@@ -619,8 +622,7 @@ namespace tr2
 	  // Watch for npos.
 	  this->_M_Nb = (__n > __str.size() ? __str.size() - __pos : __n);
 	  this->resize(this->_M_Nb);
-	  this->_M_copy_from_string(__str, __pos, __n,
-				    _CharT('0'), _CharT('1'));
+	  this->_M_copy_from_string(__str, __pos, __n);
 	}
 
       /**
@@ -633,61 +635,42 @@ namespace tr2
       explicit
       dynamic_bitset(const char* __str,
 		     const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc)
+      : _Base(__builtin_strlen(__str), 0ULL, __alloc),
+	_M_Nb(__builtin_strlen(__str))
       {
-	size_t __len = 0;
-	if (__str)
-	  while (__str[__len] != '\0')
-	    ++__len;
-	this->resize(__len);
-	this->_M_copy_from_ptr<char,std::char_traits<char>>
-		   (__str, __len, 0, __len, '0', '1');
+	this->_M_copy_from_ptr(__str, _M_Nb, 0, _M_Nb);
       }
 
-      /**
-       *  @brief  Copy constructor.
-       */
-      dynamic_bitset(const dynamic_bitset& __b)
-      : _Base(__b), _M_Nb(__b.size())
-      { }
+      /// Copy constructor.
+      dynamic_bitset(const dynamic_bitset&) = default;
 
-      /**
-       *  @brief  Move constructor.
-       */
-      dynamic_bitset(dynamic_bitset&& __b)
-      : _Base(std::forward<_Base>(__b)), _M_Nb(__b.size())
-      { }
+      /// Move constructor.
+      dynamic_bitset(dynamic_bitset&& __b) noexcept
+      : _Base(std::move(__b)), _M_Nb(__b._M_Nb)
+      { __b.clear(); }
 
-      /**
-       *  @brief  Swap with another bitset.
-       */
+      /// Swap with another bitset.
       void
-      swap(dynamic_bitset& __b)
+      swap(dynamic_bitset& __b) noexcept
       {
 	this->_M_swap(__b);
 	std::swap(this->_M_Nb, __b._M_Nb);
       }
 
-      /**
-       *  @brief  Assignment.
-       */
-      dynamic_bitset&
-      operator=(const dynamic_bitset& __b)
-      {
-	if (&__b != this)
-	  {
-	    this->_M_assign(__b);
-	    this->_M_Nb = __b._M_Nb;
-	  }
-      }
+      /// Copy assignment operator.
+      dynamic_bitset& operator=(const dynamic_bitset&) = default;
 
-      /**
-       *  @brief  Move assignment.
-       */
+      /// Move assignment operator.
       dynamic_bitset&
       operator=(dynamic_bitset&& __b)
+      noexcept(std::is_nothrow_move_assignable<_Base>::value)
       {
-	this->swap(__b);
+	static_cast<_Base&>(*this) = static_cast<_Base&&>(__b);
+	_M_Nb = __b._M_Nb;
+	if _GLIBCXX17_CONSTEXPR (std::is_nothrow_move_assignable<_Base>::value)
+	  __b._M_Nb = 0;
+	else if (get_allocator() == __b.get_allocator())
+	  __b._M_Nb = 0;
 	return *this;
       }
 
@@ -695,7 +678,7 @@ namespace tr2
        *  @brief  Return the allocator for the bitset.
        */
       allocator_type
-      get_allocator() const
+      get_allocator() const noexcept
       { return this->_M_get_allocator(); }
 
       /**
@@ -734,6 +717,8 @@ namespace tr2
 	++this->_M_Nb;
       }
 
+      // XXX why is there no pop_back() member in the proposal?
+
       /**
        *  @brief  Append a block.
        */
@@ -770,36 +755,36 @@ namespace tr2
        *
        *  These should be self-explanatory.
        */
-      dynamic_bitset<_WordT, _Alloc>&
-      operator&=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator&=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_and(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator&=(dynamic_bitset<_WordT, _Alloc>&& __rhs)
+      dynamic_bitset&
+      operator&=(dynamic_bitset&& __rhs)
       {
 	this->_M_do_and(std::move(__rhs));
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator|=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator|=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_or(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator^=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator^=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_xor(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator-=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator-=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_dif(__rhs);
 	return *this;
@@ -813,7 +798,7 @@ namespace tr2
        *
        *  These should be self-explanatory.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       operator<<=(size_type __pos)
       {
 	if (__builtin_expect(__pos < this->_M_Nb, 1))
@@ -826,7 +811,7 @@ namespace tr2
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       operator>>=(size_type __pos)
       {
 	if (__builtin_expect(__pos < this->_M_Nb, 1))
@@ -844,7 +829,7 @@ namespace tr2
       /**
        *  @brief Sets every bit to true.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       set()
       {
 	this->_M_do_set();
@@ -858,7 +843,7 @@ namespace tr2
        *  @param  __val  Either true or false, defaults to true.
        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       set(size_type __pos, bool __val = true)
       {
 	if (__pos >= _M_Nb)
@@ -869,7 +854,7 @@ namespace tr2
       /**
        *  @brief Sets every bit to false.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       reset()
       {
 	this->_M_do_reset();
@@ -883,7 +868,7 @@ namespace tr2
        *
        *  Same as writing @c set(__pos, false).
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       reset(size_type __pos)
       {
 	if (__pos >= _M_Nb)
@@ -894,7 +879,7 @@ namespace tr2
       /**
        *  @brief Toggles every bit to its opposite value.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       flip()
       {
 	this->_M_do_flip();
@@ -907,7 +892,7 @@ namespace tr2
        *  @param  __pos  The index of the bit.
        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       flip(size_type __pos)
       {
 	if (__pos >= _M_Nb)
@@ -916,7 +901,7 @@ namespace tr2
       }
 
       /// See the no-argument flip().
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator~() const
       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }
 
@@ -978,19 +963,23 @@ namespace tr2
 	}
 
       // Helper functions for string operations.
-      template<typename _CharT, typename _Traits>
+      template<typename _Traits = std::char_traits<char>,
+	       typename _CharT = typename _Traits::char_type>
 	void
 	_M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
-			 _CharT, _CharT);
+			 _CharT __zero = _CharT('0'),
+			 _CharT __one = _CharT('1'));
 
       template<typename _CharT, typename _Traits, typename _Alloc1>
 	void
-	_M_copy_from_string(const std::basic_string<_CharT,
-			    _Traits, _Alloc1>& __str, size_t __pos, size_t __n,
+	_M_copy_from_string(const basic_string<_CharT, _Traits, _Alloc1>& __str,
+			    size_t __pos, size_t __n,
 			    _CharT __zero = _CharT('0'),
 			    _CharT __one = _CharT('1'))
-	{ _M_copy_from_ptr<_CharT, _Traits>(__str.data(), __str.size(),
-					    __pos, __n, __zero, __one); }
+	{
+	  _M_copy_from_ptr<_Traits>(__str.data(), __str.size(), __pos, __n,
+				    __zero, __one);
+	}
 
       template<typename _CharT, typename _Traits, typename _Alloc1>
 	void
@@ -1065,13 +1054,13 @@ namespace tr2
 
       //@{
       /// Self-explanatory.
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator<<(size_type __pos) const
-      { return dynamic_bitset<_WordT, _Alloc>(*this) <<= __pos; }
+      { return dynamic_bitset(*this) <<= __pos; }
 
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator>>(size_type __pos) const
-      { return dynamic_bitset<_WordT, _Alloc>(*this) >>= __pos; }
+      { return dynamic_bitset(*this) >>= __pos; }
       //@}
 
       /**
@@ -1102,14 +1091,14 @@ namespace tr2
       { return this->_M_is_proper_subset_of(__b); }
 
       friend bool
-      operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,
-		 const dynamic_bitset<_WordT, _Alloc>& __rhs)
-      { return __lhs._M_is_equal(__rhs); }
+      operator==(const dynamic_bitset& __lhs,
+		 const dynamic_bitset& __rhs) noexcept
+      { return __lhs._M_Nb == __rhs._M_Nb && __lhs._M_is_equal(__rhs); }
 
       friend bool
-      operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,
-		const dynamic_bitset<_WordT, _Alloc>& __rhs)
-      { return __lhs._M_is_less(__rhs); }
+      operator<(const dynamic_bitset& __lhs,
+		const dynamic_bitset& __rhs) noexcept
+      { return __lhs._M_is_less(__rhs) || __lhs._M_Nb < __rhs._M_Nb; }
     };
 
   template<typename _WordT, typename _Alloc>
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset.tcc b/libstdc++-v3/include/tr2/dynamic_bitset.tcc
index 8228d7bc472..bbd2cb3bb04 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset.tcc
+++ b/libstdc++-v3/include/tr2/dynamic_bitset.tcc
@@ -174,7 +174,7 @@ namespace tr2
 
   // Definitions of non-inline member functions.
   template<typename _WordT, typename _Alloc>
-    template<typename _CharT, typename _Traits>
+    template<typename _Traits, typename _CharT>
       void
       dynamic_bitset<_WordT, _Alloc>::
       _M_copy_from_ptr(const _CharT* __str, size_t __len,
diff --git a/libstdc++-v3/libsupc++/eh_term_handler.cc b/libstdc++-v3/libsupc++/eh_term_handler.cc
index 6a368c0699e..4b330bc9177 100644
--- a/libstdc++-v3/libsupc++/eh_term_handler.cc
+++ b/libstdc++-v3/libsupc++/eh_term_handler.cc
@@ -24,21 +24,8 @@
 
 #include <bits/c++config.h>
 #include "unwind-cxx.h"
+#include "eh_term_handler.h"
 
-/* We default to the talkative, informative handler in a normal hosted
-   library.  This pulls in the demangler, the dyn-string utilities, and
-   elements of the I/O library.  For a low-memory environment, you can return
-   to the earlier "silent death" handler by configuring GCC with
-   --disable-libstdcxx-verbose and rebuilding the library.
-   In a freestanding environment, we default to this latter approach.  */
-
-#if _GLIBCXX_HOSTED && _GLIBCXX_VERBOSE && __cpp_exceptions
 /* The current installed user handler.  */
 std::terminate_handler __cxxabiv1::__terminate_handler =
-	__gnu_cxx::__verbose_terminate_handler;
-#else
-# include <cstdlib>
-/* The current installed user handler.  */
-std::terminate_handler __cxxabiv1::__terminate_handler = std::abort;
-#endif
-
+	_GLIBCXX_DEFAULT_TERM_HANDLER;
diff --git a/libstdc++-v3/libsupc++/eh_term_handler.h b/libstdc++-v3/libsupc++/eh_term_handler.h
new file mode 100644
index 00000000000..e4774bdf9c5
--- /dev/null
+++ b/libstdc++-v3/libsupc++/eh_term_handler.h
@@ -0,0 +1,39 @@
+// -*- C++ -*- default std::terminate handler
+// Copyright (C) 2002-2019 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <bits/c++config.h>
+
+/* We default to the talkative, informative handler in a normal hosted
+   library.  This pulls in the demangler, the dyn-string utilities, and
+   elements of the I/O library.  For a low-memory environment, you can return
+   to the earlier "silent death" handler by configuring GCC with
+   --disable-libstdcxx-verbose and rebuilding the library.
+   In a freestanding environment, we default to this latter approach.  */
+
+#if _GLIBCXX_HOSTED && _GLIBCXX_VERBOSE && __cpp_exceptions
+# define _GLIBCXX_DEFAULT_TERM_HANDLER __gnu_cxx::__verbose_terminate_handler
+#else
+# include <cstdlib>
+# define _GLIBCXX_DEFAULT_TERM_HANDLER std::abort
+#endif
diff --git a/libstdc++-v3/libsupc++/eh_terminate.cc b/libstdc++-v3/libsupc++/eh_terminate.cc
index 6acae0593ac..d5f24ea1000 100644
--- a/libstdc++-v3/libsupc++/eh_terminate.cc
+++ b/libstdc++-v3/libsupc++/eh_terminate.cc
@@ -26,6 +26,7 @@
 #include "exception"
 #include <cstdlib>
 #include "unwind-cxx.h"
+#include "eh_term_handler.h"
 #include <bits/exception_defines.h>
 #include <bits/atomic_lockfree_defines.h>
 
@@ -73,6 +74,9 @@ std::unexpected ()
 std::terminate_handler
 std::set_terminate (std::terminate_handler func) throw()
 {
+  if (!func)
+    func = _GLIBCXX_DEFAULT_TERM_HANDLER;
+
   std::terminate_handler old;
 #if ATOMIC_POINTER_LOCK_FREE > 1
   __atomic_exchange (&__terminate_handler, &func, &old, __ATOMIC_ACQ_REL);
@@ -100,6 +104,9 @@ std::get_terminate () noexcept
 std::unexpected_handler
 std::set_unexpected (std::unexpected_handler func) throw()
 {
+  if (!func)
+    func = std::terminate;
+
   std::unexpected_handler old;
 #if ATOMIC_POINTER_LOCK_FREE > 1
   __atomic_exchange (&__unexpected_handler, &func, &old, __ATOMIC_ACQ_REL);
diff --git a/libstdc++-v3/libsupc++/new_opa.cc b/libstdc++-v3/libsupc++/new_opa.cc
index 0303ecde6bd..9c7f53d7073 100644
--- a/libstdc++-v3/libsupc++/new_opa.cc
+++ b/libstdc++-v3/libsupc++/new_opa.cc
@@ -43,6 +43,21 @@ extern "C" void *memalign(std::size_t boundary, std::size_t size);
 using std::new_handler;
 using std::bad_alloc;
 
+#if ! _GLIBCXX_HOSTED
+extern "C"
+{
+# if _GLIBCXX_HAVE_ALIGNED_ALLOC
+  void *aligned_alloc(size_t alignment, size_t size);
+# elif _GLIBCXX_HAVE__ALIGNED_MALLOC
+  void *_aligned_malloc(size_t size, size_t alignment);
+# elif _GLIBCXX_HAVE_POSIX_MEMALIGN
+  void *posix_memalign(void **, size_t alignment, size_t size);
+# elif _GLIBCXX_HAVE_MEMALIGN
+  void *memalign(size_t alignment, size_t size);
+# endif
+}
+#endif
+
 namespace __gnu_cxx {
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
 using ::aligned_alloc;
@@ -114,9 +129,10 @@ operator new (std::size_t sz, std::align_val_t al)
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
-# ifdef _AIX
+# if defined _AIX || defined __APPLE__
   /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
-   * that alignment is a multiple of sizeof(void*).  */
+   * that alignment is a multiple of sizeof(void*).
+   * OS X 10.15 has the same requirement.  */
   if (align < sizeof(void*))
     align = sizeof(void*);
 # endif
diff --git a/libstdc++-v3/python/libstdcxx/v6/xmethods.py b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
index c405d8a25d5..85285ea5096 100644
--- a/libstdc++-v3/python/libstdcxx/v6/xmethods.py
+++ b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
@@ -728,7 +728,7 @@ class SharedPtrUseCountWorker(gdb.xmethod.XMethodWorker):
         return gdb.lookup_type('long')
 
     def __call__(self, obj):
-        refcounts = ['_M_refcount']['_M_pi']
+        refcounts = obj['_M_refcount']['_M_pi']
         return refcounts['_M_use_count'] if refcounts else 0
 
 class SharedPtrUniqueWorker(SharedPtrUseCountWorker):
diff --git a/libstdc++-v3/src/c++11/debug.cc b/libstdc++-v3/src/c++11/debug.cc
index f5a49992efa..efd1a9e0254 100644
--- a/libstdc++-v3/src/c++11/debug.cc
+++ b/libstdc++-v3/src/c++11/debug.cc
@@ -381,10 +381,17 @@ namespace __gnu_debug
   _Safe_iterator_base::
   _M_detach()
   {
-    if (_M_sequence)
+    // This function can run concurrently with the sequence destructor,
+    // so there is a TOCTTOU race here: the sequence could be destroyed
+    // after we check that _M_sequence is not null. Use the pointer value
+    // to acquire the mutex (rather than via _M_sequence->_M_get_mutex()).
+    // If the sequence destructor runs between loading the pointer and
+    // locking the mutex, it will detach this iterator and set _M_sequence
+    // to null, and then _M_detach_single() will do nothing.
+    if (auto seq = __atomic_load_n(&_M_sequence, __ATOMIC_ACQUIRE))
       {
-	_M_sequence->_M_detach(this);
-	_M_reset();
+	__gnu_cxx::__scoped_lock sentry(get_safe_base_mutex(seq));
+	_M_detach_single();
       }
   }
 
@@ -403,7 +410,7 @@ namespace __gnu_debug
   _Safe_iterator_base::
   _M_reset() throw ()
   {
-    _M_sequence = 0;
+    __atomic_store_n(&_M_sequence, (_Safe_sequence_base*)0, __ATOMIC_RELEASE);
     _M_version = 0;
     _M_prior = 0;
     _M_next = 0;
@@ -466,10 +473,10 @@ namespace __gnu_debug
   _Safe_local_iterator_base::
   _M_detach()
   {
-    if (_M_sequence)
+    if (auto seq = __atomic_load_n(&_M_sequence, __ATOMIC_ACQUIRE))
       {
-	_M_get_container()->_M_detach_local(this);
-	_M_reset();
+	__gnu_cxx::__scoped_lock sentry(get_safe_base_mutex(seq));
+	_M_detach_single();
       }
   }
 
diff --git a/libstdc++-v3/src/c++17/fs_dir.cc b/libstdc++-v3/src/c++17/fs_dir.cc
index d8c48f6d6d8..bcbcd7ba6b3 100644
--- a/libstdc++-v3/src/c++17/fs_dir.cc
+++ b/libstdc++-v3/src/c++17/fs_dir.cc
@@ -26,6 +26,7 @@
 # define _GLIBCXX_USE_CXX11_ABI 1
 #endif
 
+#include <bits/largefile-config.h>
 #include <filesystem>
 #include <utility>
 #include <stack>
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index d8064819d36..5f1f47b9fb7 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -28,6 +28,7 @@
 # define NEED_DO_SPACE
 #endif
 
+#include <bits/largefile-config.h>
 #include <filesystem>
 #include <functional>
 #include <ostream>
@@ -950,7 +951,7 @@ fs::file_size(const path& p, error_code& ec) noexcept
     S(const stat_type& st) : type(make_file_type(st)), size(st.st_size) { }
     S() : type(file_type::not_found) { }
     file_type type;
-    size_t size;
+    uintmax_t size;
   };
   auto s = do_stat(p, ec, [](const auto& st) { return S{st}; }, S{});
   if (s.type == file_type::regular)
@@ -1299,12 +1300,17 @@ fs::remove_all(const path& p, error_code& ec)
   uintmax_t count = 0;
   if (s.type() == file_type::directory)
     {
-      for (directory_iterator d(p, ec), end; !ec && d != end; d.increment(ec))
-	count += fs::remove_all(d->path(), ec);
-      if (ec.value() == ENOENT)
-	ec.clear();
-      else if (ec)
-	return -1;
+      directory_iterator d(p, ec), end;
+      while (!ec && d != end)
+	{
+	  const auto removed = fs::remove_all(d->path(), ec);
+	  if (removed == numeric_limits<uintmax_t>::max())
+	    return -1;
+	  count += removed;
+	  d.increment(ec);
+	  if (ec)
+	    return -1;
+	}
     }
 
   if (fs::remove(p, ec))
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 14842452354..54bef75efd8 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -968,16 +968,7 @@ path::operator+=(const path& p)
 	}
 
       if (it != last && it->_M_type() == _Type::_Root_dir)
-	{
-	  ++it;
-	  if (it == last)
-	    {
-	      // This root-dir becomes a trailing slash
-	      auto pos = _M_pathname.length() + p._M_pathname.length();
-	      ::new(output++) _Cmpt({}, _Type::_Filename, pos);
-	      ++_M_cmpts._M_impl->_M_size;
-	    }
-	}
+	++it;
 
       while (it != last)
 	{
diff --git a/libstdc++-v3/src/c++17/memory_resource.cc b/libstdc++-v3/src/c++17/memory_resource.cc
index b6698011f5c..e28526d1bfe 100644
--- a/libstdc++-v3/src/c++17/memory_resource.cc
+++ b/libstdc++-v3/src/c++17/memory_resource.cc
@@ -37,6 +37,10 @@ namespace std _GLIBCXX_VISIBILITY(default)
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 namespace pmr
 {
+  // This was defined inline in 9.1 and 9.2 so code compiled by those
+  // versions will not use this symbol.
+  memory_resource::~memory_resource() = default;
+
   namespace
   {
     class newdel_res_t final : public memory_resource
@@ -167,6 +171,10 @@ namespace pmr
 
   // Member functions for std::pmr::monotonic_buffer_resource
 
+  // This was defined inline in 9.1 and 9.2 so code compiled by those
+  // versions will not use this symbol.
+  monotonic_buffer_resource::~monotonic_buffer_resource() { release(); }
+
   // Memory allocated by the upstream resource is managed in a linked list
   // of _Chunk objects. A _Chunk object recording the size and alignment of
   // the allocated block and a pointer to the previous chunk is placed
diff --git a/libstdc++-v3/src/c++17/string-inst.cc b/libstdc++-v3/src/c++17/string-inst.cc
index c095a90587e..4dc0a9ca449 100644
--- a/libstdc++-v3/src/c++17/string-inst.cc
+++ b/libstdc++-v3/src/c++17/string-inst.cc
@@ -26,6 +26,12 @@
 // ISO C++ 14882:2017 24  Strings library
 //
 
+#ifndef _GLIBCXX_USE_CXX11_ABI
+// Instantiations in this file use the new SSO std::string ABI unless included
+// by another file which defines _GLIBCXX_USE_CXX11_ABI=0.
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
 #include <string>
 
 namespace std _GLIBCXX_VISIBILITY(default)
diff --git a/libstdc++-v3/src/c++98/locale_init.cc b/libstdc++-v3/src/c++98/locale_init.cc
index e5e9d74379f..07d95dc09fd 100644
--- a/libstdc++-v3/src/c++98/locale_init.cc
+++ b/libstdc++-v3/src/c++98/locale_init.cc
@@ -303,7 +303,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   locale::classic()
   {
     _S_initialize();
-    return *(new (&c_locale) locale(_S_classic));
+    return *(const locale*)c_locale;
   }
 
   void
@@ -313,6 +313,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // One reference for _S_classic, one for _S_global
     _S_classic = new (&c_locale_impl) _Impl(2);
     _S_global = _S_classic;
+    new (&c_locale) locale(_S_classic);
   }
 
   void
diff --git a/libstdc++-v3/src/filesystem/dir.cc b/libstdc++-v3/src/filesystem/dir.cc
index 3e6e598fa64..ac3bd3aafb3 100644
--- a/libstdc++-v3/src/filesystem/dir.cc
+++ b/libstdc++-v3/src/filesystem/dir.cc
@@ -26,6 +26,7 @@
 # define _GLIBCXX_USE_CXX11_ABI 1
 #endif
 
+#include <bits/largefile-config.h>
 #include <experimental/filesystem>
 
 #ifndef _GLIBCXX_HAVE_DIRENT_H
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 6dc9b137dbf..21d0bbabb43 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -76,7 +76,7 @@ namespace __gnu_posix
   inline int stat(const wchar_t* path, stat_type* buffer)
   { return ::_wstat(path, buffer); }
 
-  inline lstat(const wchar_t* path, stat_type* buffer)
+  inline int lstat(const wchar_t* path, stat_type* buffer)
   {
     // TODO symlinks not currently supported
     return stat(path, buffer);
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 36b5d2c24f6..5c5d6b9ef26 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -28,6 +28,7 @@
 # define NEED_DO_SPACE
 #endif
 
+#include <bits/largefile-config.h>
 #include <experimental/filesystem>
 #include <functional>
 #include <ostream>
@@ -806,7 +807,7 @@ fs::file_size(const path& p, error_code& ec) noexcept
     S(const stat_type& st) : type(make_file_type(st)), size(st.st_size) { }
     S() : type(file_type::not_found) { }
     file_type type;
-    size_t size;
+    uintmax_t size;
   };
   auto s = do_stat(p, ec, [](const auto& st) { return S{st}; }, S{});
   if (s.type == file_type::regular)
@@ -1098,12 +1099,17 @@ fs::remove_all(const path& p, error_code& ec) noexcept
   uintmax_t count = 0;
   if (s.type() == file_type::directory)
     {
-      for (directory_iterator d(p, ec), end; !ec && d != end; d.increment(ec))
-	count += fs::remove_all(d->path(), ec);
-      if (ec.value() == ENOENT)
-	ec.clear();
-      else if (ec)
-	return -1;
+      directory_iterator d(p, ec), end;
+      while (!ec && d != end)
+	{
+	  const auto removed = fs::remove_all(d->path(), ec);
+	  if (removed == numeric_limits<uintmax_t>::max())
+	    return -1;
+	  count += removed;
+	  d.increment(ec);
+	  if (ec)
+	    return -1;
+	}
     }
 
   if (fs::remove(p, ec))
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++1998/charset.cc b/libstdc++-v3/testsuite/17_intro/headers/c++1998/charset.cc
index 4425e1cf63e..e76edea1559 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++1998/charset.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++1998/charset.cc
@@ -1,5 +1,5 @@
 // { dg-options "-finput-charset=ascii" }
 // { dg-do compile }
-// { dg-skip-if "non-ascii in system headers" { *-*-darwin10*  *-*-darwin[89]* } }
+// { dg-skip-if "non-ascii in system headers" { *-*-hpux* *-*-darwin10*  *-*-darwin[89]* } }
 
 #include <bits/extc++.h>
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2011/charset.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2011/charset.cc
index 4425e1cf63e..e76edea1559 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2011/charset.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2011/charset.cc
@@ -1,5 +1,5 @@
 // { dg-options "-finput-charset=ascii" }
 // { dg-do compile }
-// { dg-skip-if "non-ascii in system headers" { *-*-darwin10*  *-*-darwin[89]* } }
+// { dg-skip-if "non-ascii in system headers" { *-*-hpux* *-*-darwin10*  *-*-darwin[89]* } }
 
 #include <bits/extc++.h>
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2014/charset.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2014/charset.cc
index 4425e1cf63e..e76edea1559 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2014/charset.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2014/charset.cc
@@ -1,5 +1,5 @@
 // { dg-options "-finput-charset=ascii" }
 // { dg-do compile }
-// { dg-skip-if "non-ascii in system headers" { *-*-darwin10*  *-*-darwin[89]* } }
+// { dg-skip-if "non-ascii in system headers" { *-*-hpux* *-*-darwin10*  *-*-darwin[89]* } }
 
 #include <bits/extc++.h>
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2017/charset.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2017/charset.cc
index 4425e1cf63e..e76edea1559 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2017/charset.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2017/charset.cc
@@ -1,5 +1,5 @@
 // { dg-options "-finput-charset=ascii" }
 // { dg-do compile }
-// { dg-skip-if "non-ascii in system headers" { *-*-darwin10*  *-*-darwin[89]* } }
+// { dg-skip-if "non-ascii in system headers" { *-*-hpux* *-*-darwin10*  *-*-darwin[89]* } }
 
 #include <bits/extc++.h>
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2020/charset.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2020/charset.cc
index 4425e1cf63e..e76edea1559 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2020/charset.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2020/charset.cc
@@ -1,5 +1,5 @@
 // { dg-options "-finput-charset=ascii" }
 // { dg-do compile }
-// { dg-skip-if "non-ascii in system headers" { *-*-darwin10*  *-*-darwin[89]* } }
+// { dg-skip-if "non-ascii in system headers" { *-*-hpux* *-*-darwin10*  *-*-darwin[89]* } }
 
 #include <bits/extc++.h>
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index 66c639ff3a3..a47d53503e3 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -100,6 +100,10 @@
 
 #define tmp (
 
+#if __cplusplus < 201103L
+#define uses_allocator  (
+#endif
+
 #if __cplusplus < 201703L
 // <charconv> defines to_chars_result::ptr and to_chars_result::ec
 #define ec (
diff --git a/libstdc++-v3/testsuite/18_support/set_terminate.cc b/libstdc++-v3/testsuite/18_support/set_terminate.cc
new file mode 100644
index 00000000000..81f182a7a76
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/set_terminate.cc
@@ -0,0 +1,57 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do run }
+
+#include <exception>
+#include <testsuite_hooks.h>
+
+void term_handler() { __builtin_abort(); }
+
+void
+test01()
+{
+  const std::terminate_handler orig = std::get_terminate();
+  VERIFY( orig != 0 ); // GNU-specific behaviour
+
+  std::terminate_handler prev = std::set_terminate(term_handler);
+  VERIFY( std::get_terminate() == term_handler );
+  VERIFY( prev == orig );
+
+  prev = std::set_terminate(orig);
+  VERIFY( std::get_terminate() == orig );
+  VERIFY( prev == term_handler );
+}
+
+void
+test02()
+{
+  // PR libstdc++/90682
+  std::set_terminate(0); // Undefined in C++98, unspecified in C++11 and later
+  const std::terminate_handler dfault = std::get_terminate();
+  VERIFY( dfault != 0 ); // GNU-specific behaviour
+  const std::terminate_handler prev = std::set_terminate(0);
+  VERIFY( prev == dfault );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/18_support/set_unexpected.cc b/libstdc++-v3/testsuite/18_support/set_unexpected.cc
new file mode 100644
index 00000000000..7c3f3d44790
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/set_unexpected.cc
@@ -0,0 +1,57 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do run { target { c++11_only || c++14_only } } }
+
+#include <exception>
+#include <testsuite_hooks.h>
+
+void unex_handler() { __builtin_abort(); }
+
+void
+test01()
+{
+  const std::unexpected_handler orig = std::get_unexpected();
+  VERIFY( orig == std::terminate ); // GNU-specific behaviour
+
+  std::unexpected_handler prev = std::set_unexpected(unex_handler);
+  VERIFY( std::get_unexpected() == unex_handler );
+  VERIFY( prev == orig );
+
+  prev = std::set_unexpected(orig);
+  VERIFY( std::get_unexpected() == orig );
+  VERIFY( prev == unex_handler );
+}
+
+void
+test02()
+{
+  // PR libstdc++/90682
+  std::set_unexpected(0); // Undefined in C++98, unspecified in C++11 and C++14
+  const std::unexpected_handler dfault = std::get_unexpected();
+  VERIFY( dfault == std::terminate ); // GNU-specific behaviour
+  const std::unexpected_handler prev = std::set_unexpected(0);
+  VERIFY( prev == dfault );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/function/91456.cc b/libstdc++-v3/testsuite/20_util/function/91456.cc
new file mode 100644
index 00000000000..a2d412d7bec
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function/91456.cc
@@ -0,0 +1,37 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <functional>
+
+struct Immovable {
+  Immovable() = default;
+  Immovable(const Immovable&) = delete;
+  Immovable& operator=(const Immovable&) = delete;
+};
+
+Immovable get() { return {}; }
+const Immovable i = get();                      // OK
+std::function<const Immovable()> f{&get};       // fails
+const Immovable i2 = f();
+
+const Immovable cget() { return {}; }
+Immovable ci = cget();                          // OK
+std::function<Immovable()> cf{&cget};           // fails
+Immovable ci2 = cf();
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/bind_front/1.cc b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/1.cc
index 8ebc2bab41a..c6cf5cf2baf 100644
--- a/libstdc++-v3/testsuite/20_util/function_objects/bind_front/1.cc
+++ b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/1.cc
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_bind_front
 # error "Feature test macro for bind_front is missing"
-#elif __cpp_lib_bind_front < 201811L
+#elif __cpp_lib_bind_front < 201902L
 # error "Feature test macro for bind_front has wrong value"
 #endif
 
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/bind_front/2.cc b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/2.cc
new file mode 100644
index 00000000000..b68cc65f719
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/2.cc
@@ -0,0 +1,91 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <functional>
+#include <memory>
+#include <string>
+#include <testsuite_hooks.h>
+
+// P1651R0 bind_front should not unwrap reference_wrapper
+
+#ifndef __cpp_lib_bind_front
+# error "Feature test macro for bind_front is missing"
+#elif __cpp_lib_bind_front < 201907L
+# error "Feature test macro for bind_front has wrong value"
+#endif
+
+void functionAcceptingStringView(std::string_view) { }
+
+void
+test01()
+{
+  std::string s;
+  auto fs = std::bind_front(&functionAcceptingStringView, std::string_view(s));
+  fs();
+}
+
+template <typename F>
+struct PartialApply {
+    PartialApply(F f) : f(f) {}
+    F f;
+
+    template <typename... A> decltype(auto) operator()(A const&... a) const {
+        if constexpr (std::is_invocable<F const&, A const&...>::value) {
+            return f(a...);
+        } else {
+            return bind_front(*this, a...);
+        }
+    }
+};
+
+void
+test02()
+{
+  struct Thingy { };
+  std::unique_ptr<Thingy> thingy;
+  auto func = [](const std::unique_ptr<Thingy>&, int) {};
+  PartialApply{func}(std::ref(thingy))(10);
+}
+
+void
+test03()
+{
+  std::string str;
+  auto func = [](const std::string& s, int) -> const std::string& { return s; };
+
+  // sref refers to copy of str stored in bind_front result:
+  const std::string& sref = PartialApply{func}(std::ref(str))(10);
+
+  // pre-P1651R0 this is a use of a dangling reference:
+  const char& c = sref[0];
+
+  // post-P1651R0 the bind_front result stores a reference_wrapper by value,
+  // and so sref is bound to str instead of dangling:
+  VERIFY( &c == str.data() );
+  VERIFY( &sref == &str );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/invoke/1.cc b/libstdc++-v3/testsuite/20_util/function_objects/invoke/1.cc
index e6a4a2ac560..fe8d681e87b 100644
--- a/libstdc++-v3/testsuite/20_util/function_objects/invoke/1.cc
+++ b/libstdc++-v3/testsuite/20_util/function_objects/invoke/1.cc
@@ -24,7 +24,18 @@ struct abstract {
   void operator()() noexcept;
 };
 
-static_assert( noexcept(std::__invoke(std::declval<abstract>())), "" );
-#if __cpp_lib_invoke
-static_assert( noexcept(std::invoke(std::declval<abstract>())), "" );
-#endif
+static_assert( noexcept(std::__invoke(std::declval<abstract>())),
+    "It should be possible to use abstract types with INVOKE" );
+
+struct F {
+  void operator()() &;
+  void operator()() && noexcept;
+  int operator()(int);
+  double* operator()(int, int) noexcept;
+};
+struct D { D(void*); };
+
+static_assert( !noexcept(std::__invoke(std::declval<F&>())), "" );
+static_assert( noexcept(std::__invoke(std::declval<F>())), "" );
+static_assert( !noexcept(std::__invoke(std::declval<F>(), 1)), "" );
+static_assert( noexcept(std::__invoke(std::declval<F>(), 1, 2)), "" );
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/invoke/3.cc b/libstdc++-v3/testsuite/20_util/function_objects/invoke/3.cc
new file mode 100644
index 00000000000..74999eca0c3
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function_objects/invoke/3.cc
@@ -0,0 +1,49 @@
+// Copyright (C) 2016-2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <functional>
+
+struct abstract {
+  virtual ~abstract() = 0;
+  void operator()() noexcept;
+};
+
+static_assert( noexcept(std::__invoke(std::declval<abstract>())),
+    "It should be possible to use abstract types with INVOKE" );
+static_assert( noexcept(std::invoke(std::declval<abstract>())),
+    "It should be possible to use abstract types with INVOKE" );
+
+struct F {
+  void operator()() &;
+  void operator()() && noexcept;
+  int operator()(int);
+  double* operator()(int, int) noexcept;
+};
+struct D { D(void*); };
+
+static_assert( !noexcept(std::__invoke(std::declval<F&>())), "" );
+static_assert( noexcept(std::__invoke(std::declval<F>())), "" );
+static_assert( !noexcept(std::__invoke(std::declval<F>(), 1)), "" );
+static_assert( noexcept(std::__invoke(std::declval<F>(), 1, 2)), "" );
+
+static_assert( !noexcept(std::invoke(std::declval<F&>())), "" );
+static_assert( noexcept(std::invoke(std::declval<F>())), "" );
+static_assert( !noexcept(std::invoke(std::declval<F>(), 1)), "" );
+static_assert( noexcept(std::invoke(std::declval<F>(), 1, 2)), "" );
diff --git a/libstdc++-v3/testsuite/20_util/is_invocable/91456.cc b/libstdc++-v3/testsuite/20_util/is_invocable/91456.cc
new file mode 100644
index 00000000000..d510d221a7d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/is_invocable/91456.cc
@@ -0,0 +1,34 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <type_traits>
+
+#include <functional>
+
+struct Immovable {
+  Immovable() = default;
+  Immovable(const Immovable&) = delete;
+  Immovable& operator=(const Immovable&) = delete;
+};
+
+Immovable get() { return {}; }
+const Immovable i = get();                      // OK
+std::function<const Immovable()> f{&get};       // fails
+const Immovable i2 = f();
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc
index 0a365a910fc..24ab3d786ec 100644
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc
@@ -119,9 +119,11 @@ void test01()
   static_assert( ! is_nt_invocable_r< T,     F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< NT,    F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< Ex,    F  >(), "call throws");
+  static_assert( ! is_nt_invocable_r< void,  F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< T,     CF >(), "conversion throws");
   static_assert(   is_nt_invocable_r< NT,    CF >(), "" );
   static_assert( ! is_nt_invocable_r< Ex,    CF >(), "conversion fails");
+  static_assert(   is_nt_invocable_r< void,  CF >(), "");
 
   static_assert( ! is_nt_invocable< F,   int >(), "call throws");
   static_assert(   is_nt_invocable< F&,  int >(), "");
@@ -140,12 +142,14 @@ void test01()
 
   static_assert(   is_nt_invocable_r< char&,  CF,  int >(), "");
   static_assert(   is_nt_invocable_r< char&,  CF&, int >(), "");
+  static_assert(   is_nt_invocable_r< void,   CF&, int >(), "");
 
   static_assert( ! is_nt_invocable_r< T,      CF&, int >(),
 		   "conversion throws");
   static_assert(   is_nt_invocable_r< NT,     CF&, int >(), "");
   static_assert( ! is_nt_invocable_r< Ex,     CF&, int >(),
 		   "conversion fails, would use explicit constructor");
+  static_assert(   is_nt_invocable_r< void,   CF&, int >(), "");
 
   static_assert( ! is_nt_invocable< F, int, int >(),
 		   "would call private member");
diff --git a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/93208.cc b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/93208.cc
new file mode 100644
index 00000000000..b0cfdbddad2
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/93208.cc
@@ -0,0 +1,29 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+// { dg-final { scan-assembler-not "_ZT\[IS\]NSt3pmr15memory_resourceE" } }
+// { dg-final { scan-assembler-not "_ZT\[IS\]NSt3pmr25monotonic\[a-z_\]*E" } }
+
+#include <memory_resource>
+
+void* f(int n)
+{
+  std::pmr::monotonic_buffer_resource res;
+  return res.allocate(n);
+}
diff --git a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc
index d3b82107217..22b9805612f 100644
--- a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc
+++ b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc
@@ -34,4 +34,4 @@ test01(T* result)
   T t[1];
   std::uninitialized_copy(t, t+1, result); // { dg-error "here" }
 }
-// { dg-prune-output "use of deleted function" }
+// { dg-error "constructible from value" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/89164.cc b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/89164.cc
new file mode 100644
index 00000000000..fa1ae59e664
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/89164.cc
@@ -0,0 +1,38 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <vector>
+
+// PR libstdc++/89164
+
+struct X
+{
+  X() = default;
+  X(const X&) = delete;
+};
+
+void test01()
+{
+  X x[1];
+  alignas(X) unsigned char buf[sizeof(X)];
+  X* p = (X*)buf;
+
+  std::uninitialized_copy(x, x+1, p); // { dg-error "here" }
+}
+// { dg-error "must be constructible" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy_n/89164.cc b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy_n/89164.cc
new file mode 100644
index 00000000000..361a7989bbf
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy_n/89164.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <vector>
+
+struct X {
+  X() = default;
+  X(const X&) = delete;
+};
+
+void test01()
+{
+  X x[1];
+  alignas(X) unsigned char buf[sizeof(X)];
+  X* p = (X*)buf;
+
+  std::uninitialized_copy_n(x, 1, p); // { dg-error "here" }
+}
+// { dg-error "must be constructible" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/89164.cc b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/89164.cc
new file mode 100644
index 00000000000..8634c8044aa
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/89164.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <vector>
+
+struct X {
+  X() = default;
+  X(const X&) = delete;
+};
+
+void f()
+{
+  X x;
+  alignas(X) unsigned char buf[sizeof(X)];
+  X* p = (X*)buf;
+
+  std::uninitialized_fill(p, p+1, x); // { dg-error "here" }
+}
+// { dg-error "must be constructible" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill_n/89164.cc b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill_n/89164.cc
new file mode 100644
index 00000000000..a2d7dc7a338
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill_n/89164.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <vector>
+
+struct X {
+  X() = default;
+  X(const X&) = delete;
+};
+
+void test01()
+{
+  X x;
+  alignas(X) unsigned char buf[sizeof(X)];
+  X* p = (X*)buf;
+
+  std::uninitialized_fill_n(p, 1, x); // { dg-error "here" }
+}
+// { dg-error "must be constructible" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc b/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc
new file mode 100644
index 00000000000..8ed236333ac
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc
@@ -0,0 +1,98 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <memory>
+#include <testsuite_hooks.h>
+
+struct incomplete;
+
+// This function isn't called, we just need to check it compiles.
+void
+test01(std::unique_ptr<incomplete>& p1, std::unique_ptr<incomplete>& p2)
+{
+  // PR libstdc++/93562
+  p1.swap(p2);
+  swap(p1, p2);
+}
+
+// This function isn't called, we just need to check it compiles.
+void
+test02(std::unique_ptr<incomplete[]>& p1, std::unique_ptr<incomplete[]>& p2)
+{
+  // PR libstdc++/93562
+  p1.swap(p2);
+  swap(p1, p2);
+}
+
+namespace A
+{
+  struct Deleter
+  {
+    Deleter& operator=(const Deleter&) = delete;
+
+    void operator()(int* p) const noexcept { delete p; }
+
+    // found by ADL
+    friend void swap(Deleter& lhs, Deleter& rhs) noexcept
+    { std::swap(lhs.id, rhs.id); }
+
+    int id;
+  };
+
+  static_assert(!std::is_move_assignable<Deleter>::value, "not assignable");
+#if __cplusplus >= 201703L
+  static_assert(std::is_swappable_v<Deleter>, "but swappable");
+#endif
+} // namespace A
+
+void
+test03()
+{
+  std::unique_ptr<int, A::Deleter> p1(new int(1), { -1 });
+  std::unique_ptr<int, A::Deleter> p2(new int(2), { -2 });
+  int* const pi1 = p1.get();
+  int* const pi2 = p2.get();
+  // This type must swappable even though the deleter is not move-assignable:
+  swap(p1, p2);
+  VERIFY(p1.get() == pi2);
+  VERIFY(p1.get_deleter().id == -2);
+  VERIFY(p2.get() == pi1);
+  VERIFY(p2.get_deleter().id == -1);
+}
+
+void
+test04()
+{
+  std::unique_ptr<int[], A::Deleter> p1(new int[1]{1}, { -1 });
+  std::unique_ptr<int[], A::Deleter> p2(new int[2]{2, 2}, { -2 });
+  int* const pi1 = p1.get();
+  int* const pi2 = p2.get();
+  // This type must swappable even though the deleter is not move-assignable:
+  swap(p1, p2);
+  VERIFY(p1.get() == pi2);
+  VERIFY(p1.get_deleter().id == -2);
+  VERIFY(p2.get() == pi1);
+  VERIFY(p2.get_deleter().id == -1);
+}
+
+int main()
+{
+  test03();
+  test04();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc
index 0be1e965103..fdb03865e3d 100644
--- a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_assign" }
 
 #include <deque>
diff --git a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc
index d99bd63abb5..1cb8cf1a7ec 100644
--- a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <deque>
diff --git a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc
index 9962bbfa225..4d3c9b31434 100644
--- a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <deque>
diff --git a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc
index 8051196011b..83ee4492ff3 100644
--- a/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_insert" }
 
 #include <deque>
diff --git a/libstdc++-v3/testsuite/23_containers/deque/types/92267.cc b/libstdc++-v3/testsuite/23_containers/deque/types/92267.cc
new file mode 100644
index 00000000000..cab8d25f0db
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/deque/types/92267.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <deque>
+
+using std::deque;
+using std::is_trivially_copy_constructible;
+
+// PR libstdc++/92267
+static_assert(!is_trivially_copy_constructible<deque<int>::iterator>::value);
+static_assert(!is_trivially_copy_constructible<deque<int>::const_iterator>::value);
diff --git a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc
index a3da00b03e9..a4dd34d8a6d 100644
--- a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_assign" }
 
 #include <list>
diff --git a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc
index fc8d48fb934..4cb886c3006 100644
--- a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <list>
diff --git a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc
index 0fccc43192f..b186b067cc3 100644
--- a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <list>
diff --git a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc
index 86a1b3c53a0..e617e67d5df 100644
--- a/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <list>
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/requirements/debug_container.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/requirements/debug_container.cc
index d6afae9c2e9..903802878d7 100644
--- a/libstdc++-v3/testsuite/23_containers/unordered_map/requirements/debug_container.cc
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/requirements/debug_container.cc
@@ -30,7 +30,7 @@ template class __gnu_debug::unordered_map<string, float>;
 template class __gnu_debug::unordered_map<string, int,
                                           hash<string>, equal_to<string>, 
                                           allocator<pair<const string, int>>>;
-#ifndef __STRICT_ANSI__
+#if !defined __STRICT_ANSI__ && __cplusplus <= 201703L
 template class __gnu_debug::unordered_map<string, float,
                                           hash<string>, equal_to<string>, 
                                           allocator<char>>;
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/ext_ptr.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/ext_ptr.cc
index 707e6d27d00..b7a63c5e393 100644
--- a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/ext_ptr.cc
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/ext_ptr.cc
@@ -15,7 +15,8 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do run { target { c++11_only || c++14_only } } }
+// { dg-do compile { target c++17 } }
 
 #include <unordered_set>
 #include <memory>
diff --git a/libstdc++-v3/testsuite/23_containers/vector/cons/89164.cc b/libstdc++-v3/testsuite/23_containers/vector/cons/89164.cc
new file mode 100644
index 00000000000..e280731403b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/cons/89164.cc
@@ -0,0 +1,40 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <vector>
+
+// PR libstdc++/89164
+
+struct X
+{
+  X() = default;
+  X(const X&) = delete;
+};
+
+void test01()
+{
+  X x[1];
+  // Should not be able to create vector using uninitialized_copy:
+  std::vector<X> v1{x, x+1};	// { dg-error "here" }
+
+  // Should not be able to create vector using uninitialized_fill_n:
+  std::vector<X> v2{2u, X{}};	// { dg-error "here" }
+}
+// { dg-error "constructible from value" "" { target *-*-* } 0 }
+// { dg-error "constructible from input" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/23_containers/vector/cons/89164_c++17.cc b/libstdc++-v3/testsuite/23_containers/vector/cons/89164_c++17.cc
new file mode 100644
index 00000000000..db7d8d5c850
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/cons/89164_c++17.cc
@@ -0,0 +1,50 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <vector>
+
+// PR libstdc++/89164
+
+struct X
+{
+  X() = default;
+  X(const X&) = delete;
+};
+
+void test01()
+{
+  X x[1];
+  // Should not be able to create vector using uninitialized_copy:
+  std::vector<X> v1{x, x+1};	// { dg-error "here" }
+
+  // Should not be able to create vector using uninitialized_fill_n:
+  std::vector<X> v2{2u, X{}};	// { dg-error "here" }
+}
+
+void test02()
+{
+#if __cplusplus >= 201703L
+  // Can create initializer_list<X> with C++17 guaranteed copy elision,
+  // but shouldn't be able to copy from it with uninitialized_copy:
+  std::vector<X> v3{X{}, X{}, X{}};   // { dg-error "here" }
+#endif
+}
+// { dg-error "constructible from value" "" { target *-*-* } 0 }
+// { dg-error "constructible from input" "" { target *-*-* } 0 }
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc
index ae825128c58..397445612c5 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_assign" }
 
 #include <vector>
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
index 2794cae0935..f78f750cf5a 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <vector>
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
index f8fe1d6618e..4d1b774d75c 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_initialize" }
 
 #include <vector>
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc
index 55fcc00bc51..fee6d70c3c1 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-prune-output "cannot convert" }
 // { dg-prune-output "no matching function .*_M_fill_insert" }
 
 #include <vector>
diff --git a/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n.cc b/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n.cc
new file mode 100644
index 00000000000..016ff57cb28
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n.cc
@@ -0,0 +1,88 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <algorithm>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+void test01()
+{
+  using __gnu_test::test_container;
+  using __gnu_test::input_iterator_wrapper;
+  int array[5] = { 1, 2, 3, 4, 5 };
+  test_container<int, input_iterator_wrapper> con(array);
+
+  int sum = 0;
+  struct Func
+  {
+    Func(int& i) : i(i) { }
+    Func(Func&&) = default;
+    Func& operator=(Func&&) = delete;
+    void operator()(int n) const { i += n; }
+    int& i;
+  };
+
+  struct Size
+  {
+    Size(short v) : val(v) { }
+    operator short() const { return val; }
+    short val;
+  };
+  auto res = std::for_each_n(con.begin(), Size(con.size()), Func(sum));
+
+  VERIFY( res == con.end() );
+  VERIFY( sum == 15 );
+}
+
+void
+test02()
+{
+  using __gnu_test::test_container;
+  using __gnu_test::random_access_iterator_wrapper;
+  int array[5] = { 2, 4, 6, 8, 10 };
+  test_container<int, random_access_iterator_wrapper> con(array);
+
+  int prod = 1;
+  struct Func
+  {
+    Func(int& i) : i(i) { }
+    Func(Func&&) = default;
+    Func& operator=(Func&&) = delete;
+    void operator()(int n) const { i *= n; }
+    int& i;
+  };
+
+  struct Size
+  {
+    Size(short v) : val(v) { }
+    operator short() const { return val; }
+    short val;
+  };
+  auto res = std::for_each_n(con.begin(), Size(con.size()), Func(prod));
+
+  VERIFY( res == con.end() );
+  VERIFY( prod == 3840 );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n_debug.cc b/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n_debug.cc
new file mode 100644
index 00000000000..24c14efbbf9
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n_debug.cc
@@ -0,0 +1,44 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+#include <algorithm>
+#include <debug/vector>
+#include <debug/list>
+
+void
+test01()
+{
+  __gnu_debug::vector<int> v{1, 2, 3};
+  std::for_each_n(v.begin(), -2, [](int){});
+}
+
+void
+test02()
+{
+  __gnu_debug::list<int> l{1, 2, 3};
+  std::for_each_n(l.begin(), -2, [](int){});
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/complex/proj.cc b/libstdc++-v3/testsuite/26_numerics/complex/proj.cc
new file mode 100644
index 00000000000..64e0dec7129
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/complex/proj.cc
@@ -0,0 +1,403 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <complex>
+#include <limits>
+#include <testsuite_hooks.h>
+
+namespace test
+{
+#ifdef _GLIBCXX_USE_C99_MATH_TR1
+  using std::copysign;
+#else
+  bool copysign(float x, float y)
+  { return __builtin_copysignf(x, y); }
+
+  bool copysign(double x, double y)
+  { return __builtin_copysign(x, y); }
+
+  bool copysign(long double x, long double y)
+  { return __builtin_copysignl(x, y); }
+#endif
+}
+
+template<typename T>
+bool eq(const std::complex<T>& x, const std::complex<T>& y)
+{
+  bool nan_reals = std::isnan(x.real()) && std::isnan(y.real());
+  bool nan_imags = std::isnan(x.imag()) && std::isnan(y.imag());
+
+  bool sign_reals
+    = test::copysign(T(1), x.real()) == test::copysign(T(1), y.real());
+  bool sign_imags
+    = test::copysign(T(1), x.imag()) == test::copysign(T(1), y.imag());
+
+  return ((x.real() == y.real() && sign_reals) || nan_reals)
+    && ((x.imag() == y.imag() && sign_imags) || nan_imags);
+}
+
+void
+test01()
+{
+  const double qnan = std::numeric_limits<double>::quiet_NaN();
+  const double pinf = std::numeric_limits<double>::infinity();
+  const double ninf = -pinf;
+
+  std::complex<double> c00(0, 0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+
+  const std::complex<double> c01(0, 1);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+
+  const std::complex<double> c10(1, 0);
+  VERIFY( eq( std::proj(c10)  , c10 ) );
+  VERIFY( eq( std::proj(-c10) , -c10 ) );
+
+  const std::complex<double> c12(1, 2);
+  VERIFY( eq( std::proj(c12)  , c12 ) );
+  VERIFY( eq( std::proj(-c12) , -c12 ) );
+
+  const std::complex<double> c0q(0, qnan);
+  VERIFY( eq( std::proj(c0q)  , c0q ) );
+  VERIFY( eq( std::proj(-c0q) , -c0q ) );
+
+  const std::complex<double> c1q(1, qnan);
+  VERIFY( eq( std::proj(c1q)  , c1q ) );
+  VERIFY( eq( std::proj(-c1q) , -c1q ) );
+
+  const std::complex<double> cq0(qnan, 0);
+  VERIFY( eq( std::proj(cq0)  , cq0 ) );
+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );
+
+  const std::complex<double> cq1(qnan, 1);
+  VERIFY( eq( std::proj(cq1)  , cq1 ) );
+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );
+
+  const std::complex<double> cqq(qnan, qnan);
+  VERIFY( eq( std::proj(cqq)  , cqq ) );
+  VERIFY( eq( std::proj(-cqq) , -cqq ) );
+
+  const std::complex<double> c0p(0, pinf);
+  VERIFY( eq( std::proj(c0p)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c0p) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> c1p(1, pinf);
+  VERIFY( eq( std::proj(c1p)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c1p) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cqp(qnan, pinf);
+  VERIFY( eq( std::proj(cqp)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cqp) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cpp(pinf, pinf);
+  VERIFY( eq( std::proj(cpp)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpp) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double>  c0n(0, ninf);
+  VERIFY( eq( std::proj(c0n) , std::complex<double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c0n) , std::complex<double>(pinf, +0.0) ) );
+
+  const std::complex<double> c1n(1, ninf);
+  VERIFY( eq( std::proj(c1n)  , std::complex<double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c1n) , std::complex<double>(pinf, +0.0) ) );
+
+  const std::complex<double> cqn(qnan, ninf);
+  VERIFY( eq( std::proj(cqn)  , std::complex<double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cqn) , std::complex<double>(pinf, +0.0) ) );
+
+  const std::complex<double> cpn(pinf, ninf);
+  VERIFY( eq( std::proj(cpn)  , std::complex<double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cpn) , std::complex<double>(pinf, +0.0) ) );
+
+  const std::complex<double> cnn(ninf, ninf);
+  VERIFY( eq( std::proj(cnn)  , std::complex<double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cnn) , std::complex<double>(pinf, +0.0) ) );
+
+  const std::complex<double> cp0(pinf, 0);
+  VERIFY( eq( std::proj(cp0)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp0) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cp1(pinf, 1);
+  VERIFY( eq( std::proj(cp1)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp1) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cpq(pinf, qnan);
+  VERIFY( eq( std::proj(cpq)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpq) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cn0(ninf, 0);
+  VERIFY( eq( std::proj(cn0)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn0) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cn1(ninf, 1);
+  VERIFY( eq( std::proj(cn1)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn1) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cnq(ninf, qnan);
+  VERIFY( eq( std::proj(cnq)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnq) , std::complex<double>(pinf, -0.0) ) );
+
+  const std::complex<double> cnp(ninf, pinf);
+  VERIFY( eq( std::proj(cnp)  , std::complex<double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnp) , std::complex<double>(pinf, -0.0) ) );
+}
+
+void
+test02()
+{
+  const float qnan = std::numeric_limits<float>::quiet_NaN();
+  const float pinf = std::numeric_limits<float>::infinity();
+  const float ninf = -pinf;
+
+  std::complex<float> c00(0, 0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+
+  const std::complex<float> c01(0, 1);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+
+  const std::complex<float> c10(1, 0);
+  VERIFY( eq( std::proj(c10)  , c10 ) );
+  VERIFY( eq( std::proj(-c10) , -c10 ) );
+
+  const std::complex<float> c12(1, 2);
+  VERIFY( eq( std::proj(c12)  , c12 ) );
+  VERIFY( eq( std::proj(-c12) , -c12 ) );
+
+  const std::complex<float> c0q(0, qnan);
+  VERIFY( eq( std::proj(c0q)  , c0q ) );
+  VERIFY( eq( std::proj(-c0q) , -c0q ) );
+
+  const std::complex<float> c1q(1, qnan);
+  VERIFY( eq( std::proj(c1q)  , c1q ) );
+  VERIFY( eq( std::proj(-c1q) , -c1q ) );
+
+  const std::complex<float> cq0(qnan, 0);
+  VERIFY( eq( std::proj(cq0)  , cq0 ) );
+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );
+
+  const std::complex<float> cq1(qnan, 1);
+  VERIFY( eq( std::proj(cq1)  , cq1 ) );
+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );
+
+  const std::complex<float> cqq(qnan, qnan);
+  VERIFY( eq( std::proj(cqq)  , cqq ) );
+  VERIFY( eq( std::proj(-cqq) , -cqq ) );
+
+  const std::complex<float> c0p(0, pinf);
+  VERIFY( eq( std::proj(c0p)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c0p) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> c1p(1, pinf);
+  VERIFY( eq( std::proj(c1p)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c1p) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cqp(qnan, pinf);
+  VERIFY( eq( std::proj(cqp)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cqp) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cpp(pinf, pinf);
+  VERIFY( eq( std::proj(cpp)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpp) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float>  c0n(0, ninf);
+  VERIFY( eq( std::proj(c0n)  , std::complex<float>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c0n) , std::complex<float>(pinf, +0.0) ) );
+
+  const std::complex<float> c1n(1, ninf);
+  VERIFY( eq( std::proj(c1n)  , std::complex<float>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c1n) , std::complex<float>(pinf, +0.0) ) );
+
+  const std::complex<float> cqn(qnan, ninf);
+  VERIFY( eq( std::proj(cqn)  , std::complex<float>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cqn) , std::complex<float>(pinf, +0.0) ) );
+
+  const std::complex<float> cpn(pinf, ninf);
+  VERIFY( eq( std::proj(cpn)  , std::complex<float>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cpn) , std::complex<float>(pinf, +0.0) ) );
+
+  const std::complex<float> cnn(ninf, ninf);
+  VERIFY( eq( std::proj(cnn)  , std::complex<float>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cnn) , std::complex<float>(pinf, +0.0) ) );
+
+  const std::complex<float> cp0(pinf, 0);
+  VERIFY( eq( std::proj(cp0)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp0) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cp1(pinf, 1);
+  VERIFY( eq( std::proj(cp1)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp1) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cpq(pinf, qnan);
+  VERIFY( eq( std::proj(cpq)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpq) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cn0(ninf, 0);
+  VERIFY( eq( std::proj(cn0)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn0) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cn1(ninf, 1);
+  VERIFY( eq( std::proj(cn1)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn1) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cnq(ninf, qnan);
+  VERIFY( eq( std::proj(cnq)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnq) , std::complex<float>(pinf, -0.0) ) );
+
+  const std::complex<float> cnp(ninf, pinf);
+  VERIFY( eq( std::proj(cnp)  , std::complex<float>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnp) , std::complex<float>(pinf, -0.0) ) );
+}
+
+void
+test03()
+{
+  const long double qnan = std::numeric_limits<long double>::quiet_NaN();
+  const long double pinf = std::numeric_limits<long double>::infinity();
+  const long double ninf = -pinf;
+
+  std::complex<long double> c00(0, 0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c00)  , c00 ) );
+  VERIFY( eq( std::proj(-c00) , -c00 ) );
+
+  const std::complex<long double> c01(0, 1);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+  c00.real(-0.0);
+  VERIFY( eq( std::proj(c01)  , c01 ) );
+  VERIFY( eq( std::proj(-c01) , -c01 ) );
+
+  const std::complex<long double> c10(1, 0);
+  VERIFY( eq( std::proj(c10)  , c10 ) );
+  VERIFY( eq( std::proj(-c10) , -c10 ) );
+
+  const std::complex<long double> c12(1, 2);
+  VERIFY( eq( std::proj(c12)  , c12 ) );
+  VERIFY( eq( std::proj(-c12) , -c12 ) );
+
+  const std::complex<long double> c0q(0, qnan);
+  VERIFY( eq( std::proj(c0q)  , c0q ) );
+  VERIFY( eq( std::proj(-c0q) , -c0q ) );
+
+  const std::complex<long double> c1q(1, qnan);
+  VERIFY( eq( std::proj(c1q)  , c1q ) );
+  VERIFY( eq( std::proj(-c1q) , -c1q ) );
+
+  const std::complex<long double> cq0(qnan, 0);
+  VERIFY( eq( std::proj(cq0)  , cq0 ) );
+  VERIFY( eq( std::proj(-cq0) , -cq0 ) );
+
+  const std::complex<long double> cq1(qnan, 1);
+  VERIFY( eq( std::proj(cq1)  , cq1 ) );
+  VERIFY( eq( std::proj(-cq1) , -cq1 ) );
+
+  const std::complex<long double> cqq(qnan, qnan);
+  VERIFY( eq( std::proj(cqq)  , cqq ) );
+  VERIFY( eq( std::proj(-cqq) , -cqq ) );
+
+  const std::complex<long double> c0p(0, pinf);
+  VERIFY( eq( std::proj(c0p)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c0p) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> c1p(1, pinf);
+  VERIFY( eq( std::proj(c1p)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-c1p) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cqp(qnan, pinf);
+  VERIFY( eq( std::proj(cqp)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cqp) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cpp(pinf, pinf);
+  VERIFY( eq( std::proj(cpp)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpp) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double>  c0n(0, ninf);
+  VERIFY( eq( std::proj(c0n) , std::complex<long double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c0n) , std::complex<long double>(pinf, +0.0) ) );
+
+  const std::complex<long double> c1n(1, ninf);
+  VERIFY( eq( std::proj(c1n)  , std::complex<long double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-c1n) , std::complex<long double>(pinf, +0.0) ) );
+
+  const std::complex<long double> cqn(qnan, ninf);
+  VERIFY( eq( std::proj(cqn)  , std::complex<long double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cqn) , std::complex<long double>(pinf, +0.0) ) );
+
+  const std::complex<long double> cpn(pinf, ninf);
+  VERIFY( eq( std::proj(cpn)  , std::complex<long double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cpn) , std::complex<long double>(pinf, +0.0) ) );
+
+  const std::complex<long double> cnn(ninf, ninf);
+  VERIFY( eq( std::proj(cnn)  , std::complex<long double>(pinf, -0.0) ) );
+  VERIFY( eq( std::proj(-cnn) , std::complex<long double>(pinf, +0.0) ) );
+
+  const std::complex<long double> cp0(pinf, 0);
+  VERIFY( eq( std::proj(cp0)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp0) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cp1(pinf, 1);
+  VERIFY( eq( std::proj(cp1)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cp1) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cpq(pinf, qnan);
+  VERIFY( eq( std::proj(cpq)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cpq) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cn0(ninf, 0);
+  VERIFY( eq( std::proj(cn0)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn0) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cn1(ninf, 1);
+  VERIFY( eq( std::proj(cn1)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cn1) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cnq(ninf, qnan);
+  VERIFY( eq( std::proj(cnq)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnq) , std::complex<long double>(pinf, -0.0) ) );
+
+  const std::complex<long double> cnp(ninf, pinf);
+  VERIFY( eq( std::proj(cnp)  , std::complex<long double>(pinf, +0.0) ) );
+  VERIFY( eq( std::proj(-cnp) , std::complex<long double>(pinf, -0.0) ) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/exclusive_scan/1.cc b/libstdc++-v3/testsuite/26_numerics/exclusive_scan/1.cc
new file mode 100644
index 00000000000..05a0135d7ab
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/exclusive_scan/1.cc
@@ -0,0 +1,94 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.7 [exclusive.scan]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+using __gnu_test::test_container;
+using __gnu_test::input_iterator_wrapper;
+using __gnu_test::output_iterator_wrapper;
+
+/*
+template<class InputIterator, class OutputIterator, class T>
+  OutputIterator
+  exclusive_scan(InputIterator, InputIterator, OutputIterator, T);
+*/
+void
+test01()
+{
+  int out[10];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::exclusive_scan(ca.begin(), ca.end(), co.begin(), 5);
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+10 );
+  VERIFY( out[0] == 5 );
+  VERIFY( out[1] == 6 );
+  VERIFY( out[2] == 8 );
+  VERIFY( out[3] == 11 );
+  VERIFY( out[4] == 15 );
+  VERIFY( out[5] == 20 );
+  VERIFY( out[6] == 26 );
+  VERIFY( out[7] == 33 );
+  VERIFY( out[8] == 41 );
+  VERIFY( out[9] == 50 );
+}
+
+/*
+template<class InputIterator, class OutputIterator, class T,
+	 class BinaryOperation>
+  OutputIterator
+  exclusive_scan(InputIterator, InputIterator, OutputIterator, T,
+		 BinaryOperation);
+*/
+void
+test02()
+{
+  int out[10];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::exclusive_scan(ca.begin(), ca.end(), co.begin(), 2,
+				 [](int i, int j) { return 2*i + 2*j; });
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+10 );
+  VERIFY( out[0] == 2 );
+  VERIFY( out[1] == 6 );
+  VERIFY( out[2] == 16 );
+  VERIFY( out[3] == 38 );
+  VERIFY( out[4] == 84 );
+  VERIFY( out[5] == 178 );
+  VERIFY( out[6] == 368 );
+  VERIFY( out[7] == 750 );
+  VERIFY( out[8] == 1516 );
+  VERIFY( out[9] == 3050 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/inclusive_scan/1.cc b/libstdc++-v3/testsuite/26_numerics/inclusive_scan/1.cc
new file mode 100644
index 00000000000..68f1578928c
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/inclusive_scan/1.cc
@@ -0,0 +1,123 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.8 [inclusive.scan]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+using __gnu_test::test_container;
+using __gnu_test::input_iterator_wrapper;
+using __gnu_test::output_iterator_wrapper;
+
+/*
+template<class InputIterator, class OutputIterator>
+  OutputIterator
+  inclusive_scan(InputIterator, InputIterator, OutputIterator);
+*/
+void
+test01()
+{
+  int out[10];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin());
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+10 );
+  VERIFY( out[0] == 1 );
+  VERIFY( out[1] == (1+2) );
+  VERIFY( out[2] == (1+2+3) );
+  VERIFY( out[3] == (1+2+3+4) );
+  VERIFY( out[4] == (1+2+3+4+5) );
+  VERIFY( out[5] == (1+2+3+4+5+6) );
+  VERIFY( out[6] == (1+2+3+4+5+6+7) );
+  VERIFY( out[7] == (1+2+3+4+5+6+7+8) );
+  VERIFY( out[8] == (1+2+3+4+5+6+7+8+9) );
+  VERIFY( out[9] == (1+2+3+4+5+6+7+8+9+10) );
+}
+
+/*
+template<class InputIterator, class OutputIterator, class BinaryOperation>
+  OutputIterator
+  inclusive_scan(InputIterator, InputIterator, OutputIterator,
+		 BinaryOperation);
+*/
+void
+test02()
+{
+  int out[10];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin(),
+				 [](int i, int j) { return 2*i + 2*j; });
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+10 );
+  VERIFY( out[0] == 1 );
+  VERIFY( out[1] == (2*1+2*2) );
+  VERIFY( out[2] == (2*6+2*3) );
+  VERIFY( out[3] == (2*18+2*4) );
+  VERIFY( out[4] == (2*44+2*5) );
+  VERIFY( out[5] == (2*98+2*6));
+  VERIFY( out[6] == (2*208+2*7) );
+  VERIFY( out[7] == (2*430+2*8) );
+  VERIFY( out[8] == (2*876+2*9) );
+  VERIFY( out[9] == (2*1770+2*10) );
+}
+
+/*
+template<class InputIterator, class OutputIterator, class BinaryOperation, T>
+  OutputIterator
+  inclusive_scan(InputIterator, InputIterator, OutputIterator,
+		 BinaryOperation, T);
+*/
+void
+test03()
+{
+  int out[10];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin(),
+				 [](int i, int j) { return 2*i + 2*j; },
+				 1);
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+10 );
+  VERIFY( out[0] == 4 );
+  VERIFY( out[1] == (2*4+2*2) );
+  VERIFY( out[2] == (2*12+2*3) );
+  VERIFY( out[3] == (2*30+2*4) );
+  VERIFY( out[4] == (2*68+2*5) );
+  VERIFY( out[5] == (2*146+2*6) );
+  VERIFY( out[6] == (2*304+2*7));
+  VERIFY( out[7] == (2*622+2*8) );
+  VERIFY( out[8] == (2*1260+2*9) );
+  VERIFY( out[9] == (2*2538+2*10) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc b/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
index f365337e789..b360203adf4 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
@@ -12,4 +12,4 @@ auto x = std::generate_canonical<std::size_t,
 
 // { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 156 }
 
-// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3320 }
+// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3318 }
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/1.cc b/libstdc++-v3/testsuite/26_numerics/reduce/1.cc
new file mode 100644
index 00000000000..0434d2ecf49
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/1.cc
@@ -0,0 +1,82 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.3 [reduce]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+/*
+template<class InputIterator>
+  iterator_traits<InputIterator>::value_type
+  reduce(InputIterator, InputIterator);
+*/
+void
+test01()
+{
+  using __gnu_test::test_container;
+  using __gnu_test::input_iterator_wrapper;
+  int array[5] = { 1, 2, 3, 4, 5 };
+  test_container<int, input_iterator_wrapper> con(array);
+  int res = std::reduce(con.begin(), con.end());
+  VERIFY( res == 15 );
+}
+
+/*
+template<class InputIterator, class T>
+  T reduce(InputIterator, InputIterator, T);
+*/
+void
+test02()
+{
+  bool b[] = {true, false, true, true, false, true, false, true, true, false};
+  int res = std::reduce(std::begin(b), std::end(b), 100);
+  VERIFY( res == 106 );
+}
+
+/*
+template<class InputIterator, class T>
+  T reduce(InputIterator, InputIterator, T);
+template<class InputIterator, class T, class BinaryOperation>
+  T reduce(InputIterator, InputIterator, T, BinaryOperation);
+*/
+void
+test03()
+{
+  int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  auto res = std::reduce(std::begin(a), std::end(a), (short)11);
+  static_assert(std::is_same_v<decltype(res), short>);
+  VERIFY( res == 66 );
+
+  auto res2 = std::reduce(std::begin(a), std::end(a), -1l, std::multiplies<>());
+  static_assert(std::is_same_v<decltype(res2), long>);
+  VERIFY( res2 == -3628800 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/2.cc b/libstdc++-v3/testsuite/26_numerics/reduce/2.cc
new file mode 100644
index 00000000000..adbfaf877bd
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/2.cc
@@ -0,0 +1,70 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.3 [reduce]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+struct T
+{
+  T(int);
+  T(T&&); // MoveConstructible
+  T& operator=(T&&); // not required by the standard, but it needs to be
+  T operator+(const T&) const;
+};
+
+void
+test01()
+{
+  T t[1]{1};
+  std::reduce(t, t+1, T(0));
+
+  using __gnu_test::test_container;
+  using __gnu_test::input_iterator_wrapper;
+  test_container<T, input_iterator_wrapper> con(t);
+  std::reduce(con.begin(), con.end(), T(0));
+}
+
+struct Op
+{
+  T operator()(T&, T&) const&;
+
+  // The standard does *not* require invoking as an rvalue to be supported.
+  T operator()(T&, T&) && = delete;
+
+  // The standard does *not* require rvalue arguments to be supported
+  // (this is almost certainly a defect and should be allowed).
+  T operator()(T&&, T&&) const = delete;
+};
+
+void
+test02()
+{
+  T t[1]{1};
+  std::reduce(t, t+1, T(0), Op());
+
+  using __gnu_test::test_container;
+  using __gnu_test::input_iterator_wrapper;
+  test_container<T, input_iterator_wrapper> con(t);
+  std::reduce(con.begin(), con.end(), T(0), Op());
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/transform_exclusive_scan/1.cc b/libstdc++-v3/testsuite/26_numerics/transform_exclusive_scan/1.cc
new file mode 100644
index 00000000000..61dca6af6ac
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/transform_exclusive_scan/1.cc
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.9 [transform.exclusive.scan]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+int a[] = {1, 2, 3, 4, 5, 6, 7};
+
+using __gnu_test::test_container;
+using __gnu_test::input_iterator_wrapper;
+using __gnu_test::output_iterator_wrapper;
+
+/*
+template<class InputIterator, class OutputIterator, class T,
+	 class BinaryOperation, class UnaryOperation>
+  OutputIterator
+  transform_exclusive_scan(InputIterator, InputIterator, OutputIterator, T,
+			   BinaryOperation, UnaryOperation);
+*/
+void
+test01()
+{
+  int out[7];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::transform_exclusive_scan(ca.begin(), ca.end(), co.begin(), 5,
+					   std::multiplies<>(),
+					   std::negate<>());
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+7 );
+  VERIFY( out[0] == 5 );
+  VERIFY( out[1] == -5 );
+  VERIFY( out[2] == 10 );
+  VERIFY( out[3] == -30 );
+  VERIFY( out[4] == 120 );
+  VERIFY( out[5] == -600 );
+  VERIFY( out[6] == 3600 );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/transform_inclusive_scan/1.cc b/libstdc++-v3/testsuite/26_numerics/transform_inclusive_scan/1.cc
new file mode 100644
index 00000000000..16eeedb58ee
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/transform_inclusive_scan/1.cc
@@ -0,0 +1,94 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.10 [transform.inclusive.scan]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+int a[] = {1, 2, 3, 4, 5, 6, 7};
+
+using __gnu_test::test_container;
+using __gnu_test::input_iterator_wrapper;
+using __gnu_test::output_iterator_wrapper;
+
+/*
+template<class InputIterator, class OutputIterator, class BinaryOperation,
+	 class UnaryOperation>
+  OutputIterator
+  transform_inclusive_scan(InputIterator, InputIterator, OutputIterator,
+			   BinaryOperation, UnaryOperation);
+*/
+void
+test01()
+{
+  int out[7];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::transform_inclusive_scan(ca.begin(), ca.end(), co.begin(),
+					   std::multiplies<>(),
+					   [](int i) { return i+1; });
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+7 );
+  VERIFY( out[0] == 2 );
+  VERIFY( out[1] == (2*3) );
+  VERIFY( out[2] == (2*3*4) );
+  VERIFY( out[3] == (2*3*4*5) );
+  VERIFY( out[4] == (2*3*4*5*6) );
+  VERIFY( out[5] == (2*3*4*5*6*7) );
+  VERIFY( out[6] == (2*3*4*5*6*7*8) );
+}
+
+/*
+template<class InputIterator, class OutputIterator, class BinaryOperation,
+	 class UnaryOperation, class T>
+  OutputIterator
+  transform_inclusive_scan(InputIterator, InputIterator, OutputIterator,
+			   BinaryOperation, UnaryOperation, T);
+*/
+void
+test02()
+{
+  int out[7];
+  test_container<int, output_iterator_wrapper> co(out);
+  test_container<int, input_iterator_wrapper> ca(a);
+  auto end = std::transform_inclusive_scan(ca.begin(), ca.end(), co.begin(),
+					   std::multiplies<>(),
+					   [](int i) { return i+1; },
+					   3);
+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);
+  VERIFY( end.ptr == out+7 );
+  VERIFY( out[0] == 3*2 );
+  VERIFY( out[1] == (3*2*3) );
+  VERIFY( out[2] == (3*2*3*4) );
+  VERIFY( out[3] == (3*2*3*4*5) );
+  VERIFY( out[4] == (3*2*3*4*5*6) );
+  VERIFY( out[5] == (3*2*3*4*5*6*7) );
+  VERIFY( out[6] == (3*2*3*4*5*6*7*8) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/transform_reduce/1.cc b/libstdc++-v3/testsuite/26_numerics/transform_reduce/1.cc
new file mode 100644
index 00000000000..bb9a5bbce7e
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/transform_reduce/1.cc
@@ -0,0 +1,109 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 29.8.5 [transform.reduce]
+
+#include <numeric>
+#include <iterator>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+double b[] = {0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5};
+
+using __gnu_test::test_container;
+using __gnu_test::input_iterator_wrapper;
+
+/*
+template<class InputIterator1, class InputIterator2, class T>
+  T transform_reduce(InputIterator1, InputIterator1, InputIterator2, T);
+*/
+void
+test01()
+{
+  auto res = std::transform_reduce(std::begin(a), std::end(a), std::begin(b),
+				   1.0f);
+  static_assert(std::is_same_v<decltype(res), float>);
+  VERIFY( res == (float)(1 + 0.5 + 1 + 1.5 + 2 + 2.5 + 3 + 3.5 + 4 + 4.5 + 5) );
+
+  test_container<int, input_iterator_wrapper> ca(a);
+  test_container<double, input_iterator_wrapper> cb(b);
+
+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), cb.begin(),
+				   1.0f);
+  static_assert(std::is_same_v<decltype(res2), float>);
+  VERIFY( res2 == res );
+}
+
+/*
+template<class InputIterator1, class InputIterator2, class T,
+	 class BinaryOperation1, class BinaryOperation2>
+  T transform_reduce(InputIterator1, InputIterator1, InputIterator2, T,
+		     BinaryOperation1, BinaryOperation2);
+*/
+void
+test02()
+{
+  auto res = std::transform_reduce(std::begin(a), std::end(a), std::begin(b),
+				    1L, std::multiplies<>(), std::plus<int>());
+  static_assert(std::is_same_v<decltype(res), long>);
+  VERIFY( res == (1L * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10) );
+
+  test_container<int, input_iterator_wrapper> ca(a);
+  test_container<double, input_iterator_wrapper> cb(b);
+
+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), cb.begin(),
+				    1L, std::multiplies<>(), std::plus<int>());
+  static_assert(std::is_same_v<decltype(res2), long>);
+  VERIFY( res2 == res );
+}
+
+/*
+template<class InputIterator, class T, class BinaryOperation,
+	 class UnaryOperation>
+  T transform_reduce(InputIterator, InputIterator, T,
+		     BinaryOperation, UnaryOperation);
+*/
+void
+test03()
+{
+  auto res = std::transform_reduce(std::begin(a), std::end(a), 10.0,
+				   std::plus<>(),
+				   [](int i) { return i * i; });
+  static_assert(std::is_same_v<decltype(res), double>);
+  VERIFY( res == (10.0 + 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100) );
+
+  test_container<int, input_iterator_wrapper> ca(a);
+  test_container<double, input_iterator_wrapper> cb(b);
+
+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), 10.0,
+				   std::plus<>(),
+				   [](int i) { return i * i; });
+  static_assert(std::is_same_v<decltype(res2), double>);
+  VERIFY( res2 == (10.0 + 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/91067.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/91067.cc
index 54172d9f20b..39fbc7b5d96 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/91067.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/91067.cc
@@ -37,9 +37,25 @@ test02()
   d = std::move(d);
 }
 
+void
+test03()
+{
+  std::filesystem::directory_iterator d;
+  auto d2 = std::move(d);
+}
+
+void
+test04()
+{
+  std::filesystem::recursive_directory_iterator d;
+  auto d2 = std::move(d);
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
index 026aa57bc39..075906ea6fe 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
@@ -39,7 +39,7 @@ main()
   const std::filesystem::perm_options permopts{};
   std::filesystem::space_info sp;
   std::error_code ec;
-  bool b;
+  bool b [[maybe_unused]];
   std::uintmax_t size;
 
   std::filesystem::absolute(p);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
index b19b0f4d626..9513ecf2648 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
@@ -57,7 +57,7 @@ test01()
   VERIFY( !exists(to) );
 
   ec.clear();
-  opts != fs::copy_options::recursive;
+  opts |= fs::copy_options::recursive;
   fs::copy("/", to, opts, ec);
   VERIFY( ec == std::make_error_code(std::errc::is_a_directory) );
   VERIFY( !exists(to) );
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/file_size.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/file_size.cc
index 57c9e96e4dc..4c55aa0cced 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/file_size.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/file_size.cc
@@ -29,9 +29,9 @@ void
 test01()
 {
   std::error_code ec;
-  size_t size = fs::file_size(".", ec);
+  auto size = fs::file_size(".", ec);
   VERIFY( ec == std::errc::is_a_directory );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 
   try {
     size = fs::file_size(".");
@@ -40,7 +40,7 @@ test01()
     ec = e.code();
   }
   VERIFY( ec == std::errc::is_a_directory );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 }
 
 void
@@ -49,9 +49,9 @@ test02()
   fs::path p = __gnu_test::nonexistent_path();
 
   std::error_code ec;
-  size_t size = fs::file_size(p, ec);
+  auto size = fs::file_size(p, ec);
   VERIFY( ec );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 
   try {
     size = fs::file_size(p);
@@ -60,7 +60,7 @@ test02()
     ec = e.code();
   }
   VERIFY( ec );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 }
 
 int
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
index a19bac9c5f6..b0b176fc656 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
@@ -140,10 +140,43 @@ test03()
   VERIFY( !exists(p) );
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no permissions
+#else
+  // PR libstdc++/93201
+  std::error_code ec;
+  std::uintmax_t n;
+
+  auto dir = __gnu_test::nonexistent_path();
+  fs::create_directory(dir);
+  __gnu_test::scoped_file f(dir/"file");
+  // remove write permission on the directory:
+  fs::permissions(dir, fs::perms::owner_read|fs::perms::owner_exec);
+  n = fs::remove_all(dir, ec);
+  VERIFY( n == -1 );
+  VERIFY( ec == std::errc::permission_denied ); // not ENOTEMPTY
+
+  try {
+    fs::remove_all(dir);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::permission_denied );
+    // First path is the argument to remove_all
+    VERIFY( e.path1() == dir );
+  }
+
+  fs::permissions(dir, fs::perms::owner_write, fs::perm_options::add);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/92853.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/92853.cc
new file mode 100644
index 00000000000..62bde05c3ad
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/92853.cc
@@ -0,0 +1,61 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+#include <filesystem>
+#include <testsuite_fs.h>
+
+void
+test01()
+{
+  // PR libstdc++/92853
+  using std::filesystem::path;
+  path p1{ "." }, p2{ "/" };
+  p1 += p2;	// corrupts heap
+  path p3{ p1 };	// CRASH!
+  __gnu_test::compare_paths( p3, "./" );
+}
+
+void
+test02()
+{
+  using std::filesystem::path;
+  path p1{ "." }, p2{ "////" };
+  p1 += p2;
+  path p3{ p1 };
+  __gnu_test::compare_paths( p3, ".////" );
+}
+
+void
+test03()
+{
+  using std::filesystem::path;
+  path p1{ "./" }, p2{ "/" };
+  p1 += p2;
+  path p3{ p1 };
+  __gnu_test::compare_paths( p3, ".//" );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/path.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/path.cc
index 9f534e64cb7..16e668c0163 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/path.cc
@@ -55,6 +55,8 @@ test02()
     path x("//blah/di/blah");
     p += x;
     VERIFY( p.native() == prior_native + x.native() );
+    path copy(p);
+    compare_paths( copy, p );
   }
 }
 
@@ -66,10 +68,28 @@ test03()
   compare_paths(p, "a//b");
 }
 
+void
+test04()
+{
+  // Concat every test path onto every test path.
+  for (path p : __gnu_test::test_paths)
+  {
+    for (path x : __gnu_test::test_paths)
+    {
+      auto prior_native = p.native();
+      p += x;
+      VERIFY( p.native() == prior_native + x.native() );
+      path copy(p); // PR libstdc++/98523
+      compare_paths( copy, p );
+    }
+  }
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc
index 80ce25ef119..f51707b171c 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc
@@ -113,10 +113,29 @@ test03()
   p4 += s;
   compare_paths(p4, path(s0+'/'+s));
 }
+
+void
+test04()
+{
+  // Concat every test path onto every test path.
+  for (path p : __gnu_test::test_paths)
+  {
+    for (path x : __gnu_test::test_paths)
+    {
+      auto prior_native = p.native();
+      p += x.native();
+      VERIFY( p.native() == prior_native + x.native() );
+      path copy(p);
+      compare_paths( copy, p );
+    }
+  }
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
index 61028111fc3..477ec2a52bc 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
@@ -57,7 +57,7 @@ test01()
   VERIFY( !exists(to) );
 
   ec.clear();
-  opts != fs::copy_options::recursive;
+  opts |= fs::copy_options::recursive;
   fs::copy("/", to, opts, ec);
   VERIFY( ec == std::make_error_code(std::errc::is_a_directory) );
   VERIFY( !exists(to) );
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc
index b54776aa33f..7acd1efda05 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc
@@ -29,9 +29,9 @@ void
 test01()
 {
   std::error_code ec;
-  size_t size = fs::file_size(".", ec);
+  auto size = fs::file_size(".", ec);
   VERIFY( ec == std::errc::is_a_directory );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 
   try {
     size = fs::file_size(".");
@@ -40,7 +40,7 @@ test01()
     ec = e.code();
   }
   VERIFY( ec == std::errc::is_a_directory );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 }
 
 void
@@ -49,9 +49,9 @@ test02()
   fs::path p = __gnu_test::nonexistent_path();
 
   std::error_code ec;
-  size_t size = fs::file_size(p, ec);
+  auto size = fs::file_size(p, ec);
   VERIFY( ec );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 
   try {
     size = fs::file_size(p);
@@ -60,7 +60,7 @@ test02()
     ec = e.code();
   }
   VERIFY( ec );
-  VERIFY( size == -1 );
+  VERIFY( size == (std::uintmax_t)-1 );
 }
 
 int
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
index 99fb14a71d7..9d51a66c71f 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
@@ -108,9 +108,42 @@ test02()
   VERIFY( !exists(dir) );
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no permissions
+#else
+  // PR libstdc++/93201
+  std::error_code ec;
+  std::uintmax_t n;
+
+  auto dir = __gnu_test::nonexistent_path();
+  fs::create_directory(dir);
+  __gnu_test::scoped_file f(dir/"file");
+  // remove write permission on the directory:
+  fs::permissions(dir, fs::perms::owner_read|fs::perms::owner_exec);
+  n = fs::remove_all(dir, ec);
+  VERIFY( n == -1 );
+  VERIFY( ec == std::errc::permission_denied ); // not ENOTEMPTY
+
+  try {
+    fs::remove_all(dir);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::permission_denied );
+    // First path is the argument to remove_all
+    VERIFY( e.path1() == dir );
+  }
+
+  fs::permissions(dir, fs::perms::owner_write|fs::perms::add_perms);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/experimental/names.cc b/libstdc++-v3/testsuite/experimental/names.cc
index 233b3487981..cfda34948af 100644
--- a/libstdc++-v3/testsuite/experimental/names.cc
+++ b/libstdc++-v3/testsuite/experimental/names.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile }
+// { dg-do compile { target c++11 } }
 
 // Define macros for some common variables names that we must not use for
 // naming variables, parameters etc. in the library.
@@ -25,6 +25,9 @@
 #if __has_include(<experimental/filesystem>)
 # include <experimental/filesystem>
 #endif
+
+#if __cplusplus >= 201402L
+
 // Library Fundamentals
 #include <experimental/algorithm>
 #include <experimental/any>
@@ -66,3 +69,5 @@
 # include <experimental/timer>
 # include <experimental/executor>
 #endif
+
+#endif // C++14
diff --git a/libstdc++-v3/testsuite/ext/char8_t/atomic-1.cc b/libstdc++-v3/testsuite/ext/char8_t/atomic-1.cc
index cecd05df937..0841aa3bb06 100644
--- a/libstdc++-v3/testsuite/ext/char8_t/atomic-1.cc
+++ b/libstdc++-v3/testsuite/ext/char8_t/atomic-1.cc
@@ -1,6 +1,6 @@
 // Test that char8_t related atomic types and macros are not present when
 // -fchar8_t is not enabled.
-// { dg-do compile }
+// { dg-do compile { target c++11 } }
 // { dg-options "-fno-char8_t" }
 
 #include <atomic>
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
index a538b854038..255d3e7cff1 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
@@ -1,5 +1,5 @@
 // { dg-options "-g -O0" }
-// { dg-do run }
+// { dg-do run { target c++11 } }
 // { dg-skip-if "" { *-*-* } { "-D_GLIBCXX_PROFILE" } }
 
 // Copyright (C) 2014-2019 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc
new file mode 100644
index 00000000000..a811307c73a
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc
@@ -0,0 +1,50 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY( a == b );
+  b.resize(99);
+  VERIFY( a != b );
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(b < a) );
+  b.resize(99);
+  VERIFY( !(a < b) );
+  VERIFY( b < a );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc
new file mode 100644
index 00000000000..9e21a91ff52
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc
@@ -0,0 +1,105 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a;
+  VERIFY( a.size() == 0 );
+  VERIFY( a.empty() );
+  std::tr2::dynamic_bitset<> b(1);
+  VERIFY( b.size() == 1 );
+  VERIFY( !b.empty() );
+  VERIFY( a != b );
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(1, 0); // { 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test03()
+{
+  std::tr2::dynamic_bitset<> a;
+  a.resize(1);                        // { 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test04()
+{
+  std::tr2::dynamic_bitset<> a(3, 2); // { 0, 1, 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test05()
+{
+  std::tr2::dynamic_bitset<unsigned short> a(1, 0); // { 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test06()
+{
+  std::tr2::dynamic_bitset<unsigned short> a;
+  a.resize(1);                                      // { 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test07()
+{
+  std::tr2::dynamic_bitset<unsigned short> a(3, 2); // { 0, 1, 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test08()
+{
+  std::tr2::dynamic_bitset<> a(65, -1ULL);
+  std::tr2::dynamic_bitset<> b(64, -1ULL);
+  b.push_back(0);
+  VERIFY( a == b );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+  test05();
+  test06();
+  test07();
+  test08();
+}
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc
new file mode 100644
index 00000000000..06bc1158a82
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc
@@ -0,0 +1,55 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == n);
+  VERIFY(a.size() == 100);
+  VERIFY(b == a);
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b;
+  b = a;
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == n);
+  VERIFY(a.size() == 100);
+  VERIFY(b == a);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc
new file mode 100644
index 00000000000..ed320db300d
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc
@@ -0,0 +1,53 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b = std::move(a);
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == 0);
+  VERIFY(a.size() == 0);
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b;
+  b = std::move(a);
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == 0);
+  VERIFY(a.size() == 0);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc
new file mode 100644
index 00000000000..0aec1adf65b
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc
@@ -0,0 +1,36 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/92059
+  std::tr2::dynamic_bitset<> b1(10000), b2(10000);
+  b2 = b1; // crashed on missing return
+  VERIFY( b2 == b1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/util/testsuite_abi.cc b/libstdc++-v3/testsuite/util/testsuite_abi.cc
index 1277972049f..dfce3741521 100644
--- a/libstdc++-v3/testsuite/util/testsuite_abi.cc
+++ b/libstdc++-v3/testsuite/util/testsuite_abi.cc
@@ -208,6 +208,7 @@ check_version(symbol& test, bool added)
       known_versions.push_back("GLIBCXX_3.4.25");
       known_versions.push_back("GLIBCXX_3.4.26");
       known_versions.push_back("GLIBCXX_3.4.27");
+      known_versions.push_back("GLIBCXX_3.4.28");
       known_versions.push_back("CXXABI_1.3");
       known_versions.push_back("CXXABI_LDBL_1.3");
       known_versions.push_back("CXXABI_1.3.1");
@@ -239,7 +240,7 @@ check_version(symbol& test, bool added)
 	test.version_status = symbol::incompatible;
 
       // Check that added symbols are added in the latest pre-release version.
-      bool latestp = (test.version_name == "GLIBCXX_3.4.27"
+      bool latestp = (test.version_name == "GLIBCXX_3.4.28"
 		     || test.version_name == "CXXABI_1.3.12"
 		     || test.version_name == "CXXABI_FLOAT128"
 		     || test.version_name == "CXXABI_TM_1");
diff --git a/libstdc++-v3/testsuite/util/testsuite_allocator.h b/libstdc++-v3/testsuite/util/testsuite_allocator.h
index 0392421ca04..b02cbcaa55e 100644
--- a/libstdc++-v3/testsuite/util/testsuite_allocator.h
+++ b/libstdc++-v3/testsuite/util/testsuite_allocator.h
@@ -699,162 +699,162 @@ namespace __gnu_test
 
 #if __cplusplus >= 201703L
 #if __cpp_aligned_new && __cpp_rtti
-    // A concrete memory_resource, with error checking.
-    class memory_resource : public std::pmr::memory_resource
-    {
-    public:
-      memory_resource()
-      : lists(new allocation_lists)
-      { }
+  // A concrete memory_resource, with error checking.
+  class memory_resource : public std::pmr::memory_resource
+  {
+  public:
+    memory_resource()
+    : lists(new allocation_lists)
+    { }
 
-      memory_resource(const memory_resource& r) noexcept
-      : lists(r.lists)
-      { lists->refcount++; }
+    memory_resource(const memory_resource& r) noexcept
+    : lists(r.lists)
+    { lists->refcount++; }
 
-      memory_resource& operator=(const memory_resource&) = delete;
+    memory_resource& operator=(const memory_resource&) = delete;
 
-      ~memory_resource()
-      {
-	if (lists->refcount-- == 1)
-	  delete lists;  // last one out turns out the lights
-      }
+    ~memory_resource()
+    {
+      if (lists->refcount-- == 1)
+	delete lists;  // last one out turns out the lights
+    }
 
-      struct bad_size { };
-      struct bad_alignment { };
-      struct bad_address { };
+    struct bad_size { };
+    struct bad_alignment { };
+    struct bad_address { };
 
-      // Deallocate everything (moving the tracking info to the freed list)
-      void
-      deallocate_everything()
-      {
-	while (lists->active)
-	  {
-	    auto a = lists->active;
-	    // Intentionally virtual dispatch, to inform derived classes:
-	    this->do_deallocate(a->p, a->bytes, a->alignment);
-	  }
-      }
+    // Deallocate everything (moving the tracking info to the freed list)
+    void
+    deallocate_everything()
+    {
+      while (lists->active)
+	{
+	  auto a = lists->active;
+	  // Intentionally virtual dispatch, to inform derived classes:
+	  this->do_deallocate(a->p, a->bytes, a->alignment);
+	}
+    }
 
-      // Clear the freed list
-      void
-      forget_freed_allocations()
-      { lists->forget_allocations(lists->freed); }
+    // Clear the freed list
+    void
+    forget_freed_allocations()
+    { lists->forget_allocations(lists->freed); }
 
-      // Count how many allocations have been done and not freed.
-      std::size_t
-      number_of_active_allocations() const noexcept
-      {
-	std::size_t n = 0;
-	for (auto a = lists->active; a != nullptr; a = a->next)
-	  ++n;
-	return n;
-      }
+    // Count how many allocations have been done and not freed.
+    std::size_t
+    number_of_active_allocations() const noexcept
+    {
+      std::size_t n = 0;
+      for (auto a = lists->active; a != nullptr; a = a->next)
+	++n;
+      return n;
+    }
 
-    protected:
-      void*
-      do_allocate(std::size_t bytes, std::size_t alignment) override
-      {
-	// TODO perform a single allocation and put the allocation struct
-	// in the buffer using placement new? It means deallocation won't
-	// actually return memory to the OS, as it will stay in lists->freed.
-	//
-	// TODO adjust the returned pointer to be minimally aligned?
-	// e.g. if alignment==1 don't return something aligned to 2 bytes.
-	// Maybe not worth it, at least monotonic_buffer_resource will
-	// never ask upstream for anything with small alignment.
-	void* p = ::operator new(bytes, std::align_val_t(alignment));
-	lists->active = new allocation{p, bytes, alignment, lists->active};
-	return p;
-      }
+  protected:
+    void*
+    do_allocate(std::size_t bytes, std::size_t alignment) override
+    {
+      // TODO perform a single allocation and put the allocation struct
+      // in the buffer using placement new? It means deallocation won't
+      // actually return memory to the OS, as it will stay in lists->freed.
+      //
+      // TODO adjust the returned pointer to be minimally aligned?
+      // e.g. if alignment==1 don't return something aligned to 2 bytes.
+      // Maybe not worth it, at least monotonic_buffer_resource will
+      // never ask upstream for anything with small alignment.
+      void* p = ::operator new(bytes, std::align_val_t(alignment));
+      lists->active = new allocation{p, bytes, alignment, lists->active};
+      return p;
+    }
 
-      void
-      do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override
-      {
-	allocation** aptr = &lists->active;
-	while (*aptr)
-	  {
-	    allocation* a = *aptr;
-	    if (p == a->p)
-	      {
-		if (bytes != a->bytes)
-		  throw bad_size();
-		if (alignment != a->alignment)
-		  throw bad_alignment();
+    void
+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override
+    {
+      allocation** aptr = &lists->active;
+      while (*aptr)
+	{
+	  allocation* a = *aptr;
+	  if (p == a->p)
+	    {
+	      if (bytes != a->bytes)
+		throw bad_size();
+	      if (alignment != a->alignment)
+		throw bad_alignment();
 #if __cpp_sized_deallocation
-		::operator delete(p, bytes, std::align_val_t(alignment));
+	      ::operator delete(p, bytes, std::align_val_t(alignment));
 #else
-		::operator delete(p, std::align_val_t(alignment));
+	      ::operator delete(p, std::align_val_t(alignment));
 #endif
-		*aptr = a->next;
-		a->next = lists->freed;
-		lists->freed = a;
-		return;
-	      }
-	    aptr = &a->next;
-	  }
-	throw bad_address();
-      }
-
-      bool
-      do_is_equal(const std::pmr::memory_resource& r) const noexcept override
-      {
-	// Equality is determined by sharing the same allocation_lists object.
-	if (auto p = dynamic_cast<const memory_resource*>(&r))
-	  return p->lists == lists;
-	return false;
-      }
-
-    private:
-      struct allocation
-      {
-	void* p;
-	std::size_t bytes;
-	std::size_t alignment;
-	allocation* next;
-      };
-
-      // Maintain list of allocated blocks and list of freed blocks.
-      // Copies of this memory_resource share the same ref-counted lists.
-      struct allocation_lists
-      {
-	unsigned refcount = 1;
-	allocation* active = nullptr;
-	allocation* freed = nullptr;
-
-	void forget_allocations(allocation*& list)
-	{
-	  while (list)
-	    {
-	      auto p = list;
-	      list = list->next;
-	      delete p;
+	      *aptr = a->next;
+	      a->next = lists->freed;
+	      lists->freed = a;
+	      return;
 	    }
+	  aptr = &a->next;
 	}
+      throw bad_address();
+    }
 
-	~allocation_lists()
-	{
-	  forget_allocations(active); // Anything in this list is a leak!
-	  forget_allocations(freed);
-	}
-      };
+    bool
+    do_is_equal(const std::pmr::memory_resource& r) const noexcept override
+    {
+      // Equality is determined by sharing the same allocation_lists object.
+      if (auto p = dynamic_cast<const memory_resource*>(&r))
+	return p->lists == lists;
+      return false;
+    }
 
-      allocation_lists* lists;
+  private:
+    struct allocation
+    {
+      void* p;
+      std::size_t bytes;
+      std::size_t alignment;
+      allocation* next;
     };
-#endif // aligned-new && rtti
 
-    // Set the default resource, and restore the previous one on destruction.
-    struct default_resource_mgr
+    // Maintain list of allocated blocks and list of freed blocks.
+    // Copies of this memory_resource share the same ref-counted lists.
+    struct allocation_lists
     {
-      explicit default_resource_mgr(std::pmr::memory_resource* r)
-      : prev(std::pmr::set_default_resource(r))
-      { }
+      unsigned refcount = 1;
+      allocation* active = nullptr;
+      allocation* freed = nullptr;
 
-      ~default_resource_mgr()
-      { std::pmr::set_default_resource(prev); }
+      void forget_allocations(allocation*& list)
+      {
+	while (list)
+	  {
+	    auto p = list;
+	    list = list->next;
+	    delete p;
+	  }
+      }
 
-      std::pmr::memory_resource* prev;
+      ~allocation_lists()
+      {
+	forget_allocations(active); // Anything in this list is a leak!
+	forget_allocations(freed);
+      }
     };
 
+    allocation_lists* lists;
+  };
+#endif // aligned-new && rtti
+
+  // Set the default resource, and restore the previous one on destruction.
+  struct default_resource_mgr
+  {
+    explicit default_resource_mgr(std::pmr::memory_resource* r)
+    : prev(std::pmr::set_default_resource(r))
+    { }
+
+    ~default_resource_mgr()
+    { std::pmr::set_default_resource(prev); }
+
+    std::pmr::memory_resource* prev;
+  };
+
 #endif // C++17
 
 } // namespace __gnu_test
diff --git a/libstdc++-v3/testsuite/util/testsuite_iterators.h b/libstdc++-v3/testsuite/util/testsuite_iterators.h
index 4636d9995c1..ac646a59cb8 100644
--- a/libstdc++-v3/testsuite/util/testsuite_iterators.h
+++ b/libstdc++-v3/testsuite/util/testsuite_iterators.h
@@ -589,6 +589,10 @@ namespace __gnu_test
     ItType<T>
     end()
     { return it(bounds.last); }
+
+    std::size_t
+    size() const
+    { return bounds.last - bounds.first; }
   };
 }
 #endif
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index 280c506b9c3..c50e6c284e2 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,19 @@
+2020-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc_release: Add support for -b local-git-repo argument.
+
+2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	2020-01-13  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc_release: Use git instead of SVN.
+
+	2019-11-20  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	* gcc_release: Use https for gcc.gnu.org.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/maintainer-scripts/gcc_release b/maintainer-scripts/gcc_release
index bfb6b037bb1..74cce1af18d 100755
--- a/maintainer-scripts/gcc_release
+++ b/maintainer-scripts/gcc_release
@@ -9,7 +9,7 @@
 # Contents:
 #   Script to create a GCC release.
 #
-# Copyright (c) 2001-2018 Free Software Foundation.
+# Copyright (c) 2001-2020 Free Software Foundation.
 #
 # This file is part of GCC.
 #
@@ -64,20 +64,21 @@ inform() {
 usage() {
 cat <<EOF
 gcc_release -r release [-f] [further options]
-gcc_release -s name:svnbranch [further options]
+gcc_release -s name:gitbranch [further options]
 
 Options:
 
   -r release           Version of the form X.Y or X.Y.Z.
-  -s name:svnbranch    Create a snapshot, not a real release.
+  -s name:gitbranch    Create a snapshot, not a real release.
 
   -d destination       Local working directory where we will build the release
                        (default=${HOME}).
   -f                   Create a final release (and update ChangeLogs,...).
   -l                   Indicate that we are running on gcc.gnu.org.
   -p previous-tarball  Location of a previous tarball (to generate diff files).
-  -t tag               Tag to mark the release in SVN.
+  -t tag               Tag to mark the release in git.
   -u username          Username for upload operations.
+  -b local-git-repo    Local git repository to speed up cloning.
 EOF
     exit 1
 }
@@ -102,14 +103,21 @@ build_sources() {
     || error "Could not create \`${WORKING_DIRECTORY}'"
   changedir "${WORKING_DIRECTORY}"
 
+  # Check out the sources.
+  if [ -n "${GIT_REFERENCE}" ]; then
+    ${GIT} clone -q --dissociate --reference "${GIT_REFERENCE}" \
+		 -b "${GITBRANCH}" "${GITROOT}" "`basename ${SOURCE_DIRECTORY}`" || \
+        error "Could not check out release sources"
+  else
+    ${GIT} clone -q -b "${GITBRANCH}" "${GITROOT}" "`basename ${SOURCE_DIRECTORY}`" || \
+        error "Could not check out release sources"
+  fi
+
   # If this is a final release, make sure that the ChangeLogs
   # and version strings are updated.
   if [ ${FINAL} -ne 0 ]; then
     inform "Updating ChangeLogs and version files"
 
-    ${SVN} -q co "${SVNROOT}/${SVNBRANCH}" "`basename ${SOURCE_DIRECTORY}`" ||\
-           error "Could not check out release sources"
-
     grep -q "gcc-${RELEASE_MAJOR}/index.html gcc-${RELEASE_MAJOR}/changes.html" \
 	 ${SOURCE_DIRECTORY}/contrib/gennews ||\
 	   error "New release not listed in contrib/gennews"
@@ -139,7 +147,7 @@ build_sources() {
 
     rm -f NEWS
 
-    svnciargs=""
+    commit_files=""
     for x in `changedir ${SOURCE_DIRECTORY} && \
 	      find . -name ChangeLog`; do
       # Update this ChangeLog file only if it does not yet contain the
@@ -154,7 +162,7 @@ ${LONG_DATE}  Release Manager
 EOF
 	mv ${SOURCE_DIRECTORY}/${x}.new ${SOURCE_DIRECTORY}/${x} \
 	  || error "Could not update ${x}"
-	svnciargs="${svnciargs} ${x}"
+	commit_files="${commit_files} ${x}"
       fi
     done
 
@@ -169,7 +177,7 @@ EOF
 	(changedir ${SOURCE_DIRECTORY}/gcc && \
 	 echo ${RELEASE} > BASE-VER) || \
 	error "Could not update BASE-VER"
-	svnciargs="${svnciargs} gcc/BASE-VER"
+	commit_files="${commit_files} gcc/BASE-VER"
       else
 	error "Release number ${RELEASE} does not immediately follow BASE-VER"
       fi
@@ -177,16 +185,15 @@ EOF
     (changedir ${SOURCE_DIRECTORY}/gcc && \
      : > DEV-PHASE) || \
     error "Could not update DEV-PHASE"
-    svnciargs="${svnciargs} gcc/DEV-PHASE"
+    commit_files="${commit_files} gcc/DEV-PHASE"
 
     (changedir ${SOURCE_DIRECTORY} && \
-     ${SVN} -q ci -m 'Update ChangeLog and version files for release' ${svnciargs}) || \
+     ${GIT} commit -q -m 'Update ChangeLog and version files for release' ${commit_files} && \
+     ${GIT} push) || \
     error "Could not commit ChangeLog and version file updates"
 
     # Make sure we tag the sources for a final release.
-    TAG="tags/gcc_`echo ${RELEASE} | tr . _`_release"
-
-    rm -rf ${SOURCE_DIRECTORY}
+    TAG="releases/gcc-${RELEASE}"
   fi
 
   # Tag the sources.
@@ -195,30 +202,43 @@ EOF
     # We don't want to overwrite an existing tag.  So, if the tag
     # already exists, issue an error message; the release manager can
     # manually remove the tag if appropriate.
-    echo "${SVN} ls ${SVNROOT}/${TAG}/ChangeLog" 
-    if ${SVN} ls "${SVNROOT}/${TAG}/ChangeLog"; then 
+    if (changedir ${SOURCE_DIRECTORY} && \
+	${GIT} rev-parse "refs/tags/${TAG}" > /dev/null 2>&1); then
       error "Tag ${TAG} already exists"
     fi
-    ${SVN} -m "Tagging source as ${TAG}" cp "${SVNROOT}/${SVNBRANCH}" "${SVNROOT}/${TAG}" || \
+    (changedir ${SOURCE_DIRECTORY} && \
+     ${GIT} tag -s -m "GCC ${RELEASE} release" "${TAG}" && \
+     ${GIT} push origin tag "${TAG}") || \
       error "Could not tag sources"
-    SVNBRANCH=${TAG}
+    GITBRANCH=${TAG}
   fi
-  SVNREV=`${SVN} info "${SVNROOT}/${SVNBRANCH}"|awk '/Revision:/ {print $2}'`
 
-  # Export the current sources.
-  inform "Retrieving sources (svn export -r ${SVNREV} ${SVNROOT}/${SVNBRANCH})"
+  GITREV=`cd ${SOURCE_DIRECTORY} && ${GIT} rev-parse HEAD`
+  inform "Sources are commit ${GITREV}"
+
+  # Make sure there are no uncommitted changes in the sources.
+  status=${WORKING_DIRECTORY}/gitstatus.$$
+  (changedir ${SOURCE_DIRECTORY} && \
+   ${GIT} status --porcelain --ignored > "$status") || \
+    error "Could not get source directory status"
+  if [ -s "$status" ]; then
+    cat "$status"
+    error "Source directory has unexpected changes"
+  fi
+  rm "$status"
 
-  ${SVN} -q export -r${SVNREV} "${SVNROOT}/${SVNBRANCH}" "`basename ${SOURCE_DIRECTORY}`" ||\
-    error "Could not retrieve sources"
+  # Remove .git from the sources.
+  rm -rf "${SOURCE_DIRECTORY}/.git" || \
+    error "Could not remove .git from sources"
 
   # Run gcc_update on them to set up the timestamps nicely, and (re)write
-  # the LAST_UPDATED file containing the SVN tag/revision used.
+  # the LAST_UPDATED file containing the git tag/revision used.
   changedir "gcc-${RELEASE}"
   contrib/gcc_update --touch
-  echo "Obtained from SVN: ${SVNBRANCH} revision ${SVNREV}" > LAST_UPDATED
+  echo "Obtained from git: ${GITBRANCH} revision ${GITREV}" > LAST_UPDATED
 
   # For a prerelease or real release, we need to generate additional
-  # files not present in SVN.
+  # files not present in git.
   changedir "${SOURCE_DIRECTORY}"
   if [ $SNAPSHOT -ne 1 ]; then
     # Generate the documentation.
@@ -430,11 +450,11 @@ announce_snapshot() {
   changedir "${SNAPSHOTS_DIR}"
   echo \
 "Snapshot gcc-"${RELEASE}" is now available on
-  ftp://gcc.gnu.org/pub/gcc/snapshots/"${RELEASE}"/
+  https://gcc.gnu.org/pub/gcc/snapshots/"${RELEASE}"/
 and on various mirrors, see http://gcc.gnu.org/mirrors.html for details.
 
-This snapshot has been generated from the GCC "${BRANCH}" SVN branch
-with the following options: "svn://gcc.gnu.org/svn/gcc/${SVNBRANCH} revision ${SVNREV}"
+This snapshot has been generated from the GCC "${BRANCH}" git branch
+with the following options: "git://gcc.gnu.org/git/gcc.git branch ${GITBRANCH} revision ${GITREV}"
 
 You'll find:
 " > ${SNAPSHOT_README}
@@ -457,8 +477,8 @@ for testing purposes.</p>
 we highly recommend you join the GCC developers list.  Details for
 how to sign up can be found on the GCC project home page.</p>
 
-<p>This snapshot has been generated from the GCC "${BRANCH}" SVN branch
-with the following options: <code>"svn://gcc.gnu.org/svn/gcc/${SVNBRANCH} revision ${SVNREV}"</code></p>
+<p>This snapshot has been generated from the GCC "${BRANCH}" git branch
+with the following options: <code>"git://gcc.gnu.org/git/gcc.git branch ${GITBRANCH} revision ${GITREV}"</code></p>
 
 <table>" > ${SNAPSHOT_INDEX}
        
@@ -511,13 +531,13 @@ export LC_ALL
 DATE=`date "+%Y%m%d"`
 LONG_DATE=`date "+%Y-%m-%d"`
 
-SVN=${SVN:-svn}
-# The CVS server containing the GCC repository.
-SVN_SERVER="gcc.gnu.org"
+GIT=${GIT:-git}
+# The server containing the GCC repository.
+GIT_SERVER="gcc.gnu.org"
 # The path to the repository on that server.
-SVN_REPOSITORY="/svn/gcc"
+GIT_REPOSITORY="/git/gcc.git"
 # The username to use when connecting to the server.
-SVN_USERNAME="${USER}"
+GIT_USERNAME="${USER}"
 
 # The machine to which files will be uploaded.
 GCC_HOSTNAME="gcc.gnu.org"
@@ -546,7 +566,7 @@ BRANCH=""
 
 # The name of the branch from which the release should be made, as used
 # for our version control system.
-SVNBRANCH=""
+GITBRANCH=""
 
 # The tag to apply to the sources used for the release.
 TAG=""
@@ -554,6 +574,9 @@ TAG=""
 # The old tarballs from which to generate diffs.
 OLD_TARS=""
 
+# Local gcc git checkout to speed up git cloning.
+GIT_REFERENCE=""
+
 # The directory that will be used to construct the release.  The
 # release itself will be placed in a subdirectory of this directory.
 DESTINATION=${HOME}
@@ -600,16 +623,16 @@ TAR="${TAR:-tar}"
 ########################################################################
 
 # Parse the options.
-while getopts "d:fr:u:t:p:s:l" ARG; do
+while getopts "d:fr:u:t:p:s:lb:" ARG; do
     case $ARG in
     d)    DESTINATION="${OPTARG}";;
     r)    RELEASE="${OPTARG}";;
     t)    TAG="${OPTARG}";;
-    u)    SVN_USERNAME="${OPTARG}";;
+    u)    GIT_USERNAME="${OPTARG}";;
     f)    FINAL=1;;
     s)    SNAPSHOT=1
           BRANCH=${OPTARG%:*}
-          SVNBRANCH=${OPTARG#*:}
+          GITBRANCH=${OPTARG#*:}
           ;;
     l)    LOCAL=1
 	  SCP=cp
@@ -618,6 +641,7 @@ while getopts "d:fr:u:t:p:s:l" ARG; do
           if [ ! -f ${OPTARG} ]; then
 	    error "-p argument must name a tarball"
 	  fi;;
+    b)    GIT_REFERENCE="${OPTARG}";;
     \?)   usage;;
     esac
 done
@@ -643,7 +667,7 @@ while [ $# -ne 0 ]; do
 done
 
 # Perform consistency checking.
-if [ ${LOCAL} -eq 0 ] && [ -z ${SVN_USERNAME} ]; then
+if [ ${LOCAL} -eq 0 ] && [ -z ${GIT_USERNAME} ]; then
   error "No username specified"
 fi
 
@@ -673,12 +697,8 @@ if [ $SNAPSHOT -eq 0 ]; then
   fi
 
   # Compute the name of the branch, which is based solely on the major
-  # and minor release numbers.
-  if [ ${RELEASE_MAJOR} -ge 5 ]; then
-    SVNBRANCH="branches/gcc-${RELEASE_MAJOR}-branch"
-  else
-    SVNBRANCH="branches/gcc-${RELEASE_MAJOR}_${RELEASE_MINOR}-branch"
-  fi
+  # release number.
+  GITBRANCH="releases/gcc-${RELEASE_MAJOR}"
 
   # If this is not a final release, set various parameters accordingly.
   if [ ${FINAL} -ne 1 ]; then
@@ -707,13 +727,13 @@ fi
 WORKING_DIRECTORY="${DESTINATION}/gcc-${RELEASE}"
 SOURCE_DIRECTORY="${WORKING_DIRECTORY}/gcc-${RELEASE}"
 
-# Set up SVNROOT.
+# Set up GITROOT.
 if [ $LOCAL -eq 0 ]; then
-    SVNROOT="svn+ssh://${SVN_USERNAME}@${SVN_SERVER}${SVN_REPOSITORY}"
+    GITROOT="git+ssh://${GIT_USERNAME}@${GIT_SERVER}${GIT_REPOSITORY}"
 else
-    SVNROOT="file:///svn/gcc"
+    GITROOT="/git/gcc.git"
 fi
-export SVNROOT
+export GITROOT
 
 ########################################################################
 # Main Program
