amodra (1):
      [RS6000] Fix <bd>_<mode> and <bd>tf_<mode> splitters

anlauf (4):
      2019-03-02  Harald Anlauf  <anlauf@gmx.de>
      2019-03-03  Harald Anlauf  <anlauf@gmx.de> 	    Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-03-03  Harald Anlauf  <anlauf@gmx.de>
      2019-03-06  Harald Anlauf  <anlauf@gmx.de>

avieira (1):
      Backport of r269499 and related testism fix r269596.

ebotcazou (5):
      PR ada/89349 	Backport from mainline 	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
      * tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_IOR_EXPR>: Fix 	and move around comment. 	<BIT_AND_EXPR>: Likewise. 	<BIT_NOT_EXPR>: Add specific handling for boolean types.
      Backport from mainline 	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
      PR tree-optimization/89536 	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_NOT_EXPR>: Test 	only whether bit #0 of the value is 0 instead of the entire value.
      PR rtl-optimization/89588 	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for 	explicit unrolling factor more robust.

gccadmin (19):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

helijia (1):
      Backport from trunk 	2019-02-20  Li Jia He  <helijia@linux.ibm.com>

jakub (3):
      * BASE-VER: Set to 8.3.1.
      Backported from mainline 	2019-02-18  Jakub Jelinek  <jakub@redhat.com>
      PR c++/89585 	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even 	at toplevel, but diagnose them.

jamborm (1):
      Relax cgraph_node::clone_of_p to also look through former clones

jason (10):
      PR c++/88183 - ICE with .* fold-expression.
      PR c++/87513 - 'sorry' mangling PMF template-id.
      PR c++/89422 - ICE with -g and lambda in default arg in template.
      PR c++/89576 - if constexpr of lambda capture.
      PR c++/89381 - implicit copy and using-declaration.
      PR c++/87921 - wrong error with inline static data member.
      PR c++/88690 - C++17 ICE with empty base in aggregate.
      PR c++/88419 - C++17 ICE with class template arg deduction.
      PR c++/88869 - C++17 ICE with CTAD and explicit specialization.
      PR c++/88820 - ICE with CTAD and member template used in DMI.

jvdelisle (2):
      2019-03-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>

krebbel (2):
      S/390: Fix the vec_xl / vec_xst style builtins
      S/390: Fix immediate vector operands for some builtins.

luoxhu (1):
      backport r268834 from mainline to gcc-8-branch

marxin (4):
      Backport r268789
      Backport r268981
      Backport r269492
      Backport r269558

mpolacek (1):
      PR c++/89212 - ICE converting nullptr to pointer-to-member-function. 	* pt.c (tsubst_copy_and_build) <case CONSTRUCTOR>: Return early for 	null member pointer value.

pault (1):
      2019-02-23  Paul Thomas  <pault@gcc.gnu.org>

redi (1):
      PR libstdc++/89446 fix null pointer dereference in char_traits

rguenth (4):
      2019-03-01  Richard Biener  <rguenther@suse.de>
      2019-03-05  Richard Biener  <rguenther@suse.de>
      2019-03-12  Richard Biener  <rguenther@suse.de>
      2019-03-14  Richard Biener  <rguenther@suse.de>

tkoenig (7):
      2019-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org> 	Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>

tnfchris (3):
      AArch64: Make every option in options.def one line (GCC-8).
      AArch64: Have empty HWCAPs string ignored during native feature detection.
      AArch64: Fix command line options canonicalization version.

uros (1):
      PR target/89397 	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check 	TARGET_SSE in addition to TARGET_SSE_MATH.

vmakarov (1):
      2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 2bf50aaf17a..56b6be4ebb2 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-8.3.0
+8.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index d1fd9f6a7b9..c779ed45d92 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,274 @@
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* lra-constraints.c (inherit_in_ebb): Update
+	potential_reload_hard_regs along with live_hard_regs.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* tree-scalar-evolution.c (simplify_peeled_chrec): Do not
+	throw FP expressions at tree-affine.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* tree-cfgcleanup.h (cleanup_tree_cfg): Add SSA update flags
+	argument, defaulted to zero.
+	* passes.c (execute_function_todo): Pass down SSA update flags
+	to cleanup_tree_cfg.
+	* tree-cfgcleanup.c: Include tree-into-ssa.h and tree-cfgcleanup.h.
+	(cleanup_tree_cfg_1): After cleanup_control_flow_pre update SSA
+	form if requested.
+	(cleanup_tree_cfg_noloop): Pass down SSA update flags.
+	(cleanup_tree_cfg): Get and pass down SSA update flags.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* tree-ssa-loop-ch.c (ch_base::copy_headers): Restrict setting
+	of no-warning flag to cases that might emit the bogus warning.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_expand_builtin): Do the copy_to_reg not
+	only on the else branch.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add new types.
+	* config/s390/s390-builtins.def: (s390_vec_xl, s390_vec_xld2)
+	(s390_vec_xlw4): Make the memory operand into a const pointer.
+	(s390_vec_xld2, s390_vec_xlw4): Add a variant for single precision
+	float.
+	* config/s390/s390-c.c (s390_expand_overloaded_builtin): Generate
+	a new vector type with the alignment of the scalar memory operand.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* tree-ssa-math-opts.c (execute_cse_reciprocals_1): Properly
+	free the occurance tree after the early out.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89588
+	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for
+	explicit unrolling factor more robust.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88235
+	* cgraph.h (cgraph_node): New inline method former_thunk_p.
+	* cgraph.c (cgraph_node::dump): Dump a note if node is a former thunk.
+	(clone_of_p): Treat expanded thunks like thunks, be optimistic if they
+	have multiple callees.  At the end check if declarations match as
+	opposed to cgraph_nodes.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* config/aarch64/aarch64-option-extensions.def: Document it.
+	* config/aarch64/driver-aarch64.c (host_detect_local_cpu): Skip feature
+	if empty hwcaps.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-01  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/89517
+	* config/aarch64/aarch64-option-extensions.def (fp, simd, crypto,
+	fp16): Collapse line.
+
+2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/89539
+	* dwarf2out.c (output_comdat_type_unit): Add ATTRIBUTE_UNUSED to
+	early_lto_debug argument.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (use_debug_types): Disable when in_lto_p.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (output_comdat_type_unit): Add early_lto_debug
+	parameter, prefix section name with .gnu.debuglto_ if true.
+	(dwarf2out_finish): Pass false to output_comdat_type_unit.
+	(dwarf2out_early_finish): Pass true to output_comdat_type_unit.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/89514
+	* dwarf2out.c (size_of_die): Key on AT_ref (a)->comdat_type_p
+	rather than on use_debug_types, doing what output_die does.
+	(value_format): Likewise.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/89536
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_NOT_EXPR>: Test
+	only whether bit #0 of the value is 0 instead of the entire value.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/config/rs6000/rs6000.c (rs6000_gimple_fold_builtin)
+	<case ALTIVEC_BUILTIN_VSPLTISB, ALTIVEC_BUILTIN_VSPLTISH,
+	ALTIVEC_BUILTIN_VSPLTISW>: Don't convert the operand before
+	range checking it.
+
+2019-02-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-02-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89361
+	* config/s390/s390.c (s390_indirect_branch_attrvalue,
+	s390_indirect_branch_settings): Define unconditionally.
+	(s390_set_current_function): Likewise, but guard the whole body except
+	the s390_indirect_branch_settings call with
+	#if S390_USE_TARGET_ATTRIBUTE.
+	(TARGET_SET_CURRENT_FUNCTION): Redefine unconditionally.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_IOR_EXPR>: Fix
+	and move around comment.
+	<BIT_AND_EXPR>: Likewise.
+	<BIT_NOT_EXPR>: Add specific handling for boolean types.
+
+2019-02-24  Alan Modra  <amodra@gmail.com>
+
+	PR target/89271
+	* config/rs6000/rs6000.md (<bd>_<mode> split): Check for an int
+	output reg on add insn.
+	(<bd>tf_<mode> split): Likewise.  Match predicates with insn.
+
+2019-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 8.3.1.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index e4127e472aa..626c590a6ab 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,13 @@
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/gcc/ada/osint.adb b/gcc/ada/osint.adb
index 0c23761b6dc..896fbc7ee37 100644
--- a/gcc/ada/osint.adb
+++ b/gcc/ada/osint.adb
@@ -250,8 +250,7 @@ package body Osint is
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
diff --git a/gcc/ada/osint.ads b/gcc/ada/osint.ads
index 65a87fe4ce3..6c75b521456 100644
--- a/gcc/ada/osint.ads
+++ b/gcc/ada/osint.ads
@@ -255,10 +255,26 @@ package Osint is
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -754,22 +770,4 @@ private
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index 9f3a2929f6b..8f4019b1fb9 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -3007,7 +3007,9 @@ cgraph_node::collect_callers (void)
   return redirect_callers;
 }
 
-/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  */
+
+/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  Return
+   optimistically true if this cannot be determined.  */
 
 static bool
 clone_of_p (cgraph_node *node, cgraph_node *node2)
@@ -3019,12 +3021,17 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)
   /* There are no virtual clones of thunks so check former_clone_of or if we
      might have skipped thunks because this adjustments are no longer
      necessary.  */
-  while (node->thunk.thunk_p)
+  while (node->thunk.thunk_p || node->former_thunk_p ())
     {
       if (node2->former_clone_of == node->decl)
 	return true;
       if (!node->thunk.this_adjusting)
 	return false;
+      /* In case of instrumented expanded thunks, which can have multiple calls
+	 in them, we do not know how to continue and just have to be
+	 optimistic.  */
+      if (node->callees->next_callee)
+	return true;
       node = node->callees->callee->ultimate_alias_target ();
       skipped_thunk = true;
     }
@@ -3040,7 +3047,7 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)
 	return false;
     }
 
-  while (node != node2 && node2)
+  while (node2 && node->decl != node2->decl)
     node2 = node2->clone_of;
   return node2 != NULL;
 }
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index afb2745a841..2509cd28881 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -1258,6 +1258,9 @@ public:
      Note that at WPA stage, the function body may not be present in memory.  */
   inline bool has_gimple_body_p (void);
 
+  /* Return true if this node represents a former, i.e. an expanded, thunk.  */
+  inline bool former_thunk_p (void);
+
   /* Return true if function should be optimized for size.  */
   bool optimize_for_size_p (void);
 
@@ -2858,6 +2861,16 @@ cgraph_node::has_gimple_body_p (void)
   return definition && !thunk.thunk_p && !alias;
 }
 
+/* Return true if this node represents a former, i.e. an expanded, thunk.  */
+
+inline bool
+cgraph_node::former_thunk_p (void)
+{
+  return (!thunk.thunk_p
+	  && (thunk.fixed_offset
+	      || thunk.virtual_offset_p));
+}
+
 /* Walk all functions with body defined.  */
 #define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \
    for ((node) = symtab->first_function_with_gimple_body (); (node); \
diff --git a/gcc/common/config/aarch64/aarch64-common.c b/gcc/common/config/aarch64/aarch64-common.c
index a9fc5f1707e..4bd61e8be1f 100644
--- a/gcc/common/config/aarch64/aarch64-common.c
+++ b/gcc/common/config/aarch64/aarch64-common.c
@@ -41,6 +41,8 @@
 
 #undef	TARGET_OPTION_OPTIMIZATION_TABLE
 #define TARGET_OPTION_OPTIMIZATION_TABLE aarch_option_optimization_table
+#undef TARGET_OPTION_INIT_STRUCT
+#define TARGET_OPTION_INIT_STRUCT aarch64_option_init_struct
 
 /* Set default optimization options.  */
 static const struct default_options aarch_option_optimization_table[] =
@@ -113,8 +115,6 @@ aarch64_handle_option (struct gcc_options *opts,
     }
 }
 
-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
-
 /* An ISA extension in the co-processor and main instruction set space.  */
 struct aarch64_option_extension
 {
@@ -122,15 +122,28 @@ struct aarch64_option_extension
   const unsigned long flag_canonical;
   const unsigned long flags_on;
   const unsigned long flags_off;
+  const bool is_synthetic;
 };
 
 /* ISA extensions in AArch64.  */
 static const struct aarch64_option_extension all_extensions[] =
 {
-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, Z) \
-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF},
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
+#include "config/aarch64/aarch64-option-extensions.def"
+  {NULL, 0, 0, 0, false}
+};
+
+/* A copy of the ISA extensions list for AArch64 sorted by the popcount of
+   bits and extension turned on.  Cached for efficiency.  */
+static struct aarch64_option_extension all_extensions_by_on[] =
+{
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
 #include "config/aarch64/aarch64-option-extensions.def"
-  {NULL, 0, 0, 0}
+  {NULL, 0, 0, 0, false}
 };
 
 struct processor_name_to_arch
@@ -232,6 +245,76 @@ aarch64_parse_extension (const char *str, unsigned long *isa_flags)
   return AARCH64_PARSE_OK;
 }
 
+/* Comparer to sort aarch64's feature extensions by population count. Largest
+   first.  */
+
+typedef const struct aarch64_option_extension opt_ext;
+
+int opt_ext_cmp (const void* a, const void* b)
+{
+  opt_ext *opt_a = (opt_ext *)a;
+  opt_ext *opt_b = (opt_ext *)b;
+
+  /* We consider the total set of bits an options turns on to be the union of
+     the singleton set containing the option itself and the set of options it
+     turns on as a dependency.  As an example +dotprod turns on FL_DOTPROD and
+     FL_SIMD.  As such the set of bits represented by this option is
+     {FL_DOTPROD, FL_SIMD}. */
+  unsigned long total_flags_a = opt_a->flag_canonical & opt_a->flags_on;
+  unsigned long total_flags_b = opt_b->flag_canonical & opt_b->flags_on;
+  int popcnt_a = popcount_hwi ((HOST_WIDE_INT)total_flags_a);
+  int popcnt_b = popcount_hwi ((HOST_WIDE_INT)total_flags_b);
+  int order = popcnt_b - popcnt_a;
+
+  /* If they have the same amount of bits set, give it a more
+     deterministic ordering by using the value of the bits themselves.  */
+  if (order == 0)
+    return total_flags_b - total_flags_a;
+
+  return order;
+}
+
+/* Implement TARGET_OPTION_INIT_STRUCT.  */
+
+static void
+aarch64_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)
+{
+    /* Sort the extensions based on how many bits they set, order the larger
+       counts first.  We sort the list because this makes processing the
+       feature bits O(n) instead of O(n^2).  While n is small, the function
+       to calculate the feature strings is called on every options push,
+       pop and attribute change (arm_neon headers, lto etc all cause this to
+       happen quite frequently).  It is a trade-off between time and space and
+       so time won.  */
+    int n_extensions
+      = sizeof (all_extensions) / sizeof (struct aarch64_option_extension);
+    qsort (&all_extensions_by_on, n_extensions,
+	   sizeof (struct aarch64_option_extension), opt_ext_cmp);
+}
+
+/* Checks to see if enough bits from the option OPT are enabled in
+   ISA_FLAG_BITS to be able to replace the individual options with the
+   canonicalized version of the option.  This is done based on two rules:
+
+   1) Synthetic groups, such as +crypto we only care about the bits that are
+      turned on. e.g. +aes+sha2 can be replaced with +crypto.
+
+   2) Options that themselves have a bit, such as +rdma, in this case, all the
+      feature bits they turn on must be available and the bit for the option
+      itself must be.  In this case it's effectively a reduction rather than a
+      grouping. e.g. +fp+simd is not enough to turn on +rdma, for that you would
+      need +rdma+fp+simd which is reduced down to +rdma.
+*/
+
+static bool
+aarch64_contains_opt (unsigned long isa_flag_bits, opt_ext *opt)
+{
+  unsigned long flags_check
+    = opt->is_synthetic ? opt->flags_on : opt->flag_canonical;
+
+  return (isa_flag_bits & flags_check) == flags_check;
+}
+
 /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS
    gives the default set of flags which are implied by whatever -march
    we'd put out.  Our job is to figure out the minimal set of "+" and
@@ -245,26 +328,97 @@ aarch64_get_extension_string_for_isa_flags (unsigned long isa_flags,
   const struct aarch64_option_extension *opt = NULL;
   std::string outstr = "";
 
-  /* Pass one: Find all the things we need to turn on.  As a special case,
-     we always want to put out +crc if it is enabled.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((isa_flags & opt->flag_canonical
-	 && !(default_arch_flags & opt->flag_canonical))
-	|| (default_arch_flags & opt->flag_canonical
-            && opt->flag_canonical == AARCH64_ISA_CRC))
-      {
-	outstr += "+";
-	outstr += opt->name;
-      }
+  unsigned long isa_flag_bits = isa_flags;
 
-  /* Pass two: Find all the things we need to turn off.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((~isa_flags) & opt->flag_canonical
-	&& !((~default_arch_flags) & opt->flag_canonical))
+  /* Pass one: Minimize the search space by reducing the set of options
+     to the smallest set that still turns on the same features as before in
+     conjunction with the bits that are turned on by default for the selected
+     architecture.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      /* If the bit is on by default, then all the options it turns on are also
+	 on by default due to the transitive dependencies.
+
+         If the option is enabled explicitly in the set then we need to emit
+	 an option for it.  Since this list is sorted by extensions setting the
+	 largest number of featers first, we can be sure that nothing else will
+	 ever need to set the bits we already set.  Consider the following
+	 situation:
+
+	  Feat1 = A + B + C
+	  Feat2 = A + B
+	  Feat3 = A + D
+	  Feat4 = B + C
+	  Feat5 = C
+
+	The following results are expected:
+
+	  A + C = A + Feat5
+	  B + C = Feat4
+	  Feat4 + A = Feat1
+	  Feat2 + Feat5 = Feat1
+	  Feat1 + C = Feat1
+          Feat3 + Feat4 = Feat1 + D
+
+	This search assumes that all invidual feature bits are use visible,
+	in other words the user must be able to do +A, +B, +C and +D.  */
+      if (aarch64_contains_opt (isa_flag_bits | default_arch_flags, opt))
       {
-	outstr += "+no";
-	outstr += opt->name;
+	/* We remove all the dependent bits, to prevent them from being turned
+	   on twice.  This only works because we assume that all there are
+	   individual options to set all bits standalone.  */
+	isa_flag_bits &= ~opt->flags_on;
+	isa_flag_bits |= opt->flag_canonical;
       }
+    }
+
+   /* By toggling bits on and off, we may have set bits on that are already
+      enabled by default.  So we mask the default set out so we don't emit an
+      option for them.  Instead of checking for this each time during Pass One
+      we just mask all default bits away at the end.  */
+   isa_flag_bits &= ~default_arch_flags;
+
+   /* We now have the smallest set of features we need to process.  A subsequent
+      linear scan of the bits in isa_flag_bits will allow us to print the ext
+      names.  However as a special case if CRC was enabled before, always print
+      it.  This is required because some CPUs have an incorrect specification
+      in older assemblers.  Even though CRC should be the default for these
+      cases the -mcpu values won't turn it on.  */
+  if (isa_flags & AARCH64_ISA_CRC)
+    isa_flag_bits |= AARCH64_ISA_CRC;
+
+  /* Pass Two:
+     Print the option names that we're sure we must turn on.  These are only
+     optional extension names.  Mandatory ones have already been removed and
+     ones we explicitly want off have been too.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if (isa_flag_bits & opt->flag_canonical)
+	{
+	  outstr += "+";
+	  outstr += opt->name;
+	}
+    }
+
+  /* Pass Three:
+     Print out a +no for any mandatory extension that we are
+     turning off.  By this point aarch64_parse_extension would have ensured
+     that any optional extensions are turned off.  The only things left are
+     things that can't be turned off usually, e.g. something that is on by
+     default because it's mandatory and we want it off.  For turning off bits
+     we don't guarantee the smallest set of flags, but instead just emit all
+     options the user has specified.
+
+     The assembler requires all +<opts> to be printed before +no<opts>.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if ((~isa_flags) & opt->flag_canonical
+		&& !((~default_arch_flags) & opt->flag_canonical))
+	{
+	  outstr += "+no";
+	  outstr += opt->name;
+	}
+    }
 
   return outstr;
 }
@@ -345,5 +499,7 @@ aarch64_rewrite_mcpu (int argc, const char **argv)
   return aarch64_rewrite_selected_cpu (argv[argc - 1]);
 }
 
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
+
 #undef AARCH64_CPU_NAME_LENGTH
 
diff --git a/gcc/config/aarch64/aarch64-option-extensions.def b/gcc/config/aarch64/aarch64-option-extensions.def
index 5fe5e3f7ddd..a575448e406 100644
--- a/gcc/config/aarch64/aarch64-option-extensions.def
+++ b/gcc/config/aarch64/aarch64-option-extensions.def
@@ -21,88 +21,97 @@
 
    Before using #include to read this file, define a macro:
 
-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)
-
-   EXT_NAME is the name of the extension, represented as a string constant.
-   FLAGS_CANONICAL is the canonical internal name for this flag.
-   FLAGS_ON are the bitwise-or of the features that enabling the extension
-   adds, or zero if enabling this extension has no effect on other features.
-   FLAGS_OFF are the bitwise-or of the features that disabling the extension
-   removes, or zero if disabling this extension has no effect on other
-   features.
-   FEAT_STRING is a string containing the entries in the 'Features' field of
-   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
-   extension being available.  Sometimes multiple entries are needed to enable
-   the extension (for example, the 'crypto' extension depends on four
-   entries: aes, pmull, sha1, sha2 being present).  In that case this field
-   should contain a space (" ") separated list of the strings in 'Features'
-   that are required.  Their order is not important.  */
+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF,
+			    SYNTHETIC, FEATURE_STRING)
+
+   - EXT_NAME is the name of the extension, represented as a string constant.
+   - FLAGS_CANONICAL is the canonical internal name for this flag.
+   - FLAGS_ON are the bitwise-or of the features that enabling the extension
+     adds, or zero if enabling this extension has no effect on other features.
+   - FLAGS_OFF are the bitwise-or of the features that disabling the extension
+     removes, or zero if disabling this extension has no effect on other
+     features.
+   - SYNTHETIC is a boolean to indicate whether the option is a purely synthetic
+     grouping of options and that the option itself has no feature bit (e.g.
+     crypto).  This is used to determine when sum of the individual options in
+     FLAGS_ON can be replaced by FLAG_CANONICAL in options minimization.  If the
+     group is synthetic then they can be replaced when all options in FLAGS_ON
+     are enabled, otherwise they can only be replaced when
+     FLAGS_ON | FLAG_CANONICAL are enabled.
+   - FEAT_STRING is a string containing the entries in the 'Features' field of
+     /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
+     extension being available.  Sometimes multiple entries are needed to enable
+     the extension (for example, the 'crypto' extension depends on four
+     entries: aes, pmull, sha1, sha2 being present).  In that case this field
+     should contain a space (" ") separated list of the strings in 'Features'
+     that are required.  Their order is not important.  An empty string means
+     do not detect this feature during auto detection.  */
+
+/* NOTE: This file is being parsed by config.gcc and so the
+   AARCH64_OPT_EXTENSION must adhere to a strict format:
+   1) No space between the AARCH64_OPT_EXTENSION and the opening (.
+   2) No space between the opening ( and the extension name.
+   3) No space after the extension name before the ,.
+   4) Spaces are only allowed after a , and around |.
+   5) Everything must be on one line.  */
 
 /* Enabling "fp" just enables "fp".
    Disabling "fp" also disables "simd", "crypto", "fp16", "aes", "sha2",
    "sha3", sm3/sm4 and "sve".  */
-AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, "fp")
+AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "fp")
 
 /* Enabling "simd" also enables "fp".
    Disabling "simd" also disables "crypto", "dotprod", "aes", "sha2", "sha3",
    "sm3/sm4" and "sve".  */
-AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE,
-		      "asimd")
+AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO | AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "asimd")
 
-/* Enabling "crypto" also enables "fp" and "simd".
+/* Enabling "crypto" also enables "fp", "simd", "aes" and "sha2".
    Disabling "crypto" disables "crypto", "aes", "sha2", "sha3" and "sm3/sm4".  */
-AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD,\
-		      AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4,\
-		      "aes pmull sha1 sha2")
+AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_AES | AARCH64_FL_SHA2, AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4, true, "aes pmull sha1 sha2")
 
 /* Enabling or disabling "crc" only changes "crc".  */
-AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, "crc32")
+AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, false, "crc32")
 
 /* Enabling or disabling "lse" only changes "lse".  */
-AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, "atomics")
+AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, false, "atomics")
 
 /* Enabling "fp16" also enables "fp".
    Disabling "fp16" disables "fp16", "fp16fml" and "sve".  */
-AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP,
-		      AARCH64_FL_F16FML | AARCH64_FL_SVE, "fphp asimdhp")
+AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP, AARCH64_FL_F16FML | AARCH64_FL_SVE, false, "fphp asimdhp")
 
 /* Enabling or disabling "rcpc" only changes "rcpc".  */
-AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, "lrcpc")
+AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, false, "lrcpc")
 
 /* Enabling "rdma" also enables "fp", "simd".
    Disabling "rdma" just disables "rdma".  */
-AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, "asimdrdm")
+AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, false, "asimdrdm")
 
 /* Enabling "dotprod" also enables "simd".
    Disabling "dotprod" only disables "dotprod".  */
-AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, "asimddp")
+AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, false, "asimddp")
 
 /* Enabling "aes" also enables "simd".
    Disabling "aes" just disables "aes".  */
-AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, "aes")
+AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, false, "aes")
 
 /* Enabling "sha2" also enables "simd".
    Disabling "sha2" just disables "sha2".  */
-AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, "sha1 sha2")
+AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, false, "sha1 sha2")
 
 /* Enabling "sha3" enables "simd" and "sha2".
    Disabling "sha3" just disables "sha3".  */
-AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, "sha3 sha512")
+AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, false, "sha3 sha512")
 
 /* Enabling "sm4" also enables "simd".
    Disabling "sm4" just disables "sm4".  */
-AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, "sm3 sm4")
+AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, false, "sm3 sm4")
 
 /* Enabling "fp16fml" also enables "fp" and "fp16".
    Disabling "fp16fml" just disables "fp16fml".  */
-AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, "asimdfml")
+AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, false, "asimdfml")
 
 /* Enabling "sve" also enables "fp16", "fp" and "simd".
    Disabling "sve" just disables "sve".  */
-AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, "sve")
+AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, false, "sve")
 
 #undef AARCH64_OPT_EXTENSION
diff --git a/gcc/config/aarch64/driver-aarch64.c b/gcc/config/aarch64/driver-aarch64.c
index 4e83c7a7679..c68bdfdc57f 100644
--- a/gcc/config/aarch64/driver-aarch64.c
+++ b/gcc/config/aarch64/driver-aarch64.c
@@ -36,7 +36,8 @@ struct aarch64_arch_extension
   const char *feat_string;
 };
 
-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, FEATURE_STRING) \
   { EXT_NAME, FLAG_CANONICAL, FEATURE_STRING },
 static struct aarch64_arch_extension aarch64_extensions[] =
 {
@@ -249,27 +250,35 @@ host_detect_local_cpu (int argc, const char **argv)
 	{
 	  for (i = 0; i < num_exts; i++)
 	    {
-	      char *p = NULL;
-	      char *feat_string
-		= concat (aarch64_extensions[i].feat_string, NULL);
+	      const char *p = aarch64_extensions[i].feat_string;
+
+	      /* If the feature contains no HWCAPS string then ignore it for the
+		 auto detection.  */
+	      if (*p == '\0')
+		continue;
+
 	      bool enabled = true;
 
 	      /* This may be a multi-token feature string.  We need
-		 to match all parts, which could be in any order.
-		 If this isn't a multi-token feature string, strtok is
-		 just going to return a pointer to feat_string.  */
-	      p = strtok (feat_string, " ");
-	      while (p != NULL)
+		 to match all parts, which could be in any order.  */
+	      size_t len = strlen (buf);
+	      do
 		{
-		  if (strstr (buf, p) == NULL)
+		  const char *end = strchr (p, ' ');
+		  if (end == NULL)
+		    end = strchr (p, '\0');
+		  if (memmem (buf, len, p, end - p) == NULL)
 		    {
 		      /* Failed to match this token.  Turn off the
 			 features we'd otherwise enable.  */
 		      enabled = false;
 		      break;
 		    }
-		  p = strtok (NULL, " ");
+		  if (*end == '\0')
+		    break;
+		  p = end + 1;
 		}
+	      while (1);
 
 	      if (enabled)
 		extension_flags |= aarch64_extensions[i].flag;
@@ -359,12 +368,12 @@ host_detect_local_cpu (int argc, const char **argv)
 not_found:
   {
    /* If detection fails we ignore the option.
-      Clean up and return empty string.  */
+      Clean up and return NULL.  */
 
     if (f)
       fclose (f);
 
-    return "";
+    return NULL;
   }
 }
 
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 2809112f68d..b12ae385802 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -191,7 +191,7 @@ extern tree arm_fp16_type_node;
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv4))
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 7732f882f78..f1de97f73df 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -4958,6 +4958,12 @@ ix86_option_override_internal (bool main_args_p,
 			   opts->x_param_values,
 			   opts_set->x_param_values);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -39641,7 +39647,7 @@ ix86_vectorize_builtin_scatter (const_tree vectype,
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -50999,7 +51005,7 @@ ix86_float_exceptions_rounding_supported_p (void)
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51007,7 +51013,7 @@ ix86_float_exceptions_rounding_supported_p (void)
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51042,7 +51048,7 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -51399,7 +51405,7 @@ ix86_excess_precision (enum excess_precision_type type)
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index d5cab80f60f..0a75bd10976 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -1908,7 +1908,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index 5a3416235da..6c5757eadf5 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -418,6 +418,11 @@
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
 #define vec_revb __builtin_vec_revb
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
diff --git a/gcc/config/rs6000/crypto.md b/gcc/config/rs6000/crypto.md
index 0f34e141580..5dc569996e2 100644
--- a/gcc/config/rs6000/crypto.md
+++ b/gcc/config/rs6000/crypto.md
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 5abbd3e791b..d2896fce7c3 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -2442,13 +2442,22 @@ BU_P9_OVERLOAD_2 (CMPRB2,	"byte_in_either_range")
 BU_P9_OVERLOAD_2 (CMPEQB,	"byte_in_set")
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 22e40f9109f..fee41e171a7 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -16765,23 +16765,13 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
     case ALTIVEC_BUILTIN_VSPLTISH:
     case ALTIVEC_BUILTIN_VSPLTISW:
       {
-	 int size;
-
-         if (fn_code == ALTIVEC_BUILTIN_VSPLTISB)
-           size = 8;
-         else if (fn_code == ALTIVEC_BUILTIN_VSPLTISH)
-           size = 16;
-         else
-           size = 32;
-
 	 arg0 = gimple_call_arg (stmt, 0);
 	 lhs = gimple_call_lhs (stmt);
 
 	 /* Only fold the vec_splat_*() if the lower bits of arg 0 is a
 	    5-bit signed constant in range -16 to +15.  */
 	 if (TREE_CODE (arg0) != INTEGER_CST
-	     || !IN_RANGE (sext_hwi(TREE_INT_CST_LOW (arg0), size),
-			   -16, 15))
+	     || !IN_RANGE (TREE_INT_CST_LOW (arg0), -16, 15))
 	   return false;
 	 gimple_seq stmts = NULL;
 	 location_t loc = gimple_location (stmt);
@@ -18261,6 +18251,7 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     {
     /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18276,9 +18267,13 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     case ALTIVEC_BUILTIN_VMULOUH:
     case P8V_BUILTIN_VMULOUW:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 4d69c1dfa0e..fa65b2a8bcc 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -12699,7 +12699,7 @@
 				const0_rtx);
   emit_insn (gen_rtx_SET (operands[3],
 			  gen_rtx_COMPARE (CCmode, operands[1], const1_rtx)));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (operands[0], <MODE>mode))
     emit_insn (gen_add<mode>3 (operands[0], operands[1], constm1_rtx));
   else
     {
@@ -12768,7 +12768,7 @@
 		       (const_int 0)]))
 	  (match_operand 4)
 	  (match_operand 5)))
-   (set (match_operand:P 6 "int_reg_operand")
+   (set (match_operand:P 6 "nonimmediate_operand")
 	(plus:P (match_dup 0)
 		(const_int -1)))
    (clobber (match_scratch:P 7))
@@ -12801,7 +12801,7 @@
   else
      emit_insn (gen_cceq_ior_compare_complement (operands[9], andexpr, ctrcmpcc,
 						 operands[8], cccmp, ccin));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (ctrout, <MODE>mode))
      emit_insn (gen_add<mode>3 (ctrout, ctr, constm1_rtx));
   else
     {
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
index 2acc55fe0af..6f257c6de77 100644
--- a/gcc/config/s390/s390-builtin-types.def
+++ b/gcc/config/s390/s390-builtin-types.def
@@ -260,6 +260,7 @@ DEF_FN_TYPE_2 (BT_FN_V4SF_FLT_INT, BT_V4SF, BT_FLT, BT_INT)
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_V4SF, BT_V4SF, BT_V4SF, BT_V4SF)
 DEF_FN_TYPE_2 (BT_FN_V4SI_BV4SI_V4SI, BT_V4SI, BT_BV4SI, BT_V4SI)
+DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDCONSTPTR, BT_V4SI, BT_INT, BT_VOIDCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDPTR, BT_V4SI, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_UV4SI_UV4SI, BT_V4SI, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_2 (BT_FN_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -492,6 +493,7 @@ DEF_OV_TYPE (BT_OV_USHORT_UV8HI_INT, BT_USHORT, BT_UV8HI, BT_INT)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI, BT_UV16QI, BT_BV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI_INTPTR, BT_UV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_UV16QI, BT_UV16QI, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARCONSTPTR, BT_UV16QI, BT_LONG, BT_UCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARPTR, BT_UV16QI, BT_LONG, BT_UCHARPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHAR, BT_UV16QI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR, BT_UV16QI, BT_UCHARCONSTPTR)
@@ -523,6 +525,7 @@ DEF_OV_TYPE (BT_OV_UV16QI_UV8HI_UV8HI_INTPTR, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_
 DEF_OV_TYPE (BT_OV_UV16QI_V16QI, BT_UV16QI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_V8HI_V8HI, BT_UV16QI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_UV2DI_BV2DI_UV2DI, BT_UV2DI, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG, BT_UV2DI, BT_ULONGLONG)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR, BT_UV2DI, BT_ULONGLONGCONSTPTR)
@@ -556,6 +559,8 @@ DEF_OV_TYPE (BT_OV_UV2DI_V2DI, BT_UV2DI, BT_V2DI)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI, BT_UV4SI, BT_BV4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI_INTPTR, BT_UV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_UV4SI, BT_UV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_FLTPTR, BT_UV4SI, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTCONSTPTR, BT_UV4SI, BT_LONG, BT_UINTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTPTR, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_UINT, BT_UV4SI, BT_UINT)
 DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR, BT_UV4SI, BT_UINTCONSTPTR)
@@ -593,6 +598,7 @@ DEF_OV_TYPE (BT_OV_UV4SI_V4SI, BT_UV4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI, BT_UV8HI, BT_BV8HI, BT_BV8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI_INTPTR, BT_UV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_UV8HI, BT_UV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTCONSTPTR, BT_UV8HI, BT_LONG, BT_USHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTPTR, BT_UV8HI, BT_LONG, BT_USHORTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORT, BT_UV8HI, BT_USHORT)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR, BT_UV8HI, BT_USHORTCONSTPTR)
@@ -626,6 +632,7 @@ DEF_OV_TYPE (BT_OV_UV8HI_UV8HI_V8HI, BT_UV8HI, BT_UV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_V4SI_V4SI, BT_UV8HI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_UV8HI_V8HI, BT_UV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V16QI_BV16QI_V16QI, BT_V16QI, BT_BV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARCONSTPTR, BT_V16QI, BT_LONG, BT_SCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARPTR, BT_V16QI, BT_LONG, BT_SCHARPTR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHAR, BT_V16QI, BT_SCHAR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR, BT_V16QI, BT_SCHARCONSTPTR)
@@ -660,6 +667,7 @@ DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_UINT, BT_V2DF, BT_DBLCONSTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_USHORT, BT_V2DF, BT_DBLCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_INT, BT_V2DF, BT_DBL, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_V2DF_INT, BT_V2DF, BT_DBL, BT_V2DF, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLCONSTPTR, BT_V2DF, BT_LONG, BT_DBLCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLPTR, BT_V2DF, BT_LONG, BT_DBLPTR)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI, BT_V2DF, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI_INT, BT_V2DF, BT_UV2DI, BT_INT)
@@ -687,6 +695,7 @@ DEF_OV_TYPE (BT_OV_V2DI_LONGLONGCONSTPTR_USHORT, BT_V2DI, BT_LONGLONGCONSTPTR, B
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_INT, BT_V2DI, BT_LONGLONG, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_LONGLONG, BT_V2DI, BT_LONGLONG, BT_LONGLONG)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_V2DI_INT, BT_V2DI, BT_LONGLONG, BT_V2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGCONSTPTR, BT_V2DI, BT_LONG, BT_LONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGPTR, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
 DEF_OV_TYPE (BT_OV_V2DI_V16QI, BT_V2DI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_V2DI_V2DI, BT_V2DI, BT_V2DI)
@@ -716,7 +725,7 @@ DEF_OV_TYPE (BT_OV_V4SF_FLTCONSTPTR_UINT, BT_V4SF, BT_FLTCONSTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_V4SF_FLTCONSTPTR_USHORT, BT_V4SF, BT_FLTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_INT, BT_V4SF, BT_FLT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_V4SF_INT, BT_V4SF, BT_FLT, BT_V4SF, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTPTR, BT_V4SF, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTCONSTPTR, BT_V4SF, BT_LONG, BT_FLTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF, BT_V4SF, BT_V4SF)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_BV4SI, BT_V4SF, BT_V4SF, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
@@ -737,6 +746,7 @@ DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_UINT, BT_V4SI, BT_INTCONSTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_USHORT, BT_V4SI, BT_INTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_INT, BT_V4SI, BT_INT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_V4SI_INT, BT_V4SI, BT_INT, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_LONG_INTCONSTPTR, BT_V4SI, BT_LONG, BT_INTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_LONG_INTPTR, BT_V4SI, BT_LONG, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_UV4SI_V4SI_V4SI, BT_V4SI, BT_UV4SI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -764,6 +774,7 @@ DEF_OV_TYPE (BT_OV_V4SI_V8HI, BT_V4SI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI, BT_V4SI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI_V4SI, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V8HI_BV8HI_V8HI, BT_V8HI, BT_BV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTCONSTPTR, BT_V8HI, BT_LONG, BT_SHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTPTR, BT_V8HI, BT_LONG, BT_SHORTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_SHORT, BT_V8HI, BT_SHORT)
 DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR, BT_V8HI, BT_SHORTCONSTPTR)
@@ -802,6 +813,7 @@ DEF_OV_TYPE (BT_OV_VOID_UV16QI_UCHARPTR_UINT, BT_VOID, BT_UV16QI, BT_UCHARPTR, B
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR, BT_VOID, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_ULONGLONGPTR_UINT, BT_VOID, BT_UV2DI, BT_ULONGLONGPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_FLTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_FLTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_UINTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UINTPTR_UINT, BT_VOID, BT_UV4SI, BT_UINTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index 0fbe838cbf9..365e794316a 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -328,36 +328,38 @@ B_DEF      (s390_vgmh,                  vec_genmaskv8hi,    0,
 B_DEF      (s390_vgmf,                  vec_genmaskv4si,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV4SI_UCHAR_UCHAR)
 B_DEF      (s390_vgmg,                  vec_genmaskv2di,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV2DI_UCHAR_UCHAR)
 
-OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
-
-OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
-
-OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_u32,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
+OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
+
+OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xld2_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
+
+OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_flt,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
 
 OB_DEF     (s390_vec_splats,            s390_vec_splats_s8, s390_vec_splats_dbl,B_VX,               BT_FN_OV4SI_INT)
 OB_DEF_VAR (s390_vec_splats_s8,         s390_vlrepb,        0,                  0,                  BT_OV_V16QI_SCHAR)
@@ -746,13 +748,14 @@ OB_DEF_VAR (s390_vec_xstd2_s64,         MAX,                0,
 OB_DEF_VAR (s390_vec_xstd2_u64,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR)      /* vst */
 OB_DEF_VAR (s390_vec_xstd2_dbl,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V2DF_LONG_DBLPTR)             /* vst */
 
-OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_u32, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
+OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_flt, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
 OB_DEF_VAR (s390_vec_xstw4_s8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_V16QI_LONG_SCHARPTR)          /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_UV16QI_LONG_UCHARPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V8HI_LONG_SHORTPTR)           /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV8HI_LONG_USHORTPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V4SI_LONG_INTPTR)             /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV4SI_LONG_UINTPTR)           /* vst */
+OB_DEF_VAR (s390_vec_xstw4_flt,         MAX,                B_VXE,              O2_LIT,             BT_OV_VOID_V4SF_LONG_FLTPTR)             /* vst */
 
 OB_DEF     (s390_vec_store_len,         s390_vec_store_len_s8,s390_vec_store_len_dbl,B_VX,          BT_FN_VOID_OV4SI_VOIDPTR_UINT)
 OB_DEF_VAR (s390_vec_store_len_s8,      s390_vstl,          0,                  0,                  BT_OV_VOID_V16QI_SCHARPTR_UINT)
diff --git a/gcc/config/s390/s390-c.c b/gcc/config/s390/s390-c.c
index 4a72d499cee..8fb46b03af3 100644
--- a/gcc/config/s390/s390-c.c
+++ b/gcc/config/s390/s390-c.c
@@ -477,16 +477,30 @@ s390_expand_overloaded_builtin (location_t loc,
     case S390_OVERLOADED_BUILTIN_s390_vec_xl:
     case S390_OVERLOADED_BUILTIN_s390_vec_xld2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xlw4:
-      return build2 (MEM_REF, return_type,
-		     fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
-		     build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      {
+	/* Build a vector type with the alignment of the source
+	   location in order to enable correct alignment hints to be
+	   generated for vl.  */
+	tree mem_type = build_aligned_type (return_type,
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[1]))));
+	return build2 (MEM_REF, mem_type,
+		       fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
+		       build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_xst:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstd2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstw4:
-      return build2 (MODIFY_EXPR, TREE_TYPE((*arglist)[0]),
-		     build1 (INDIRECT_REF, TREE_TYPE((*arglist)[0]),
-			     fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
-		     (*arglist)[0]);
+      {
+	/* Build a vector type with the alignment of the target
+	   location in order to enable correct alignment hints to be
+	   generated for vst.  */
+	tree mem_type = build_aligned_type (TREE_TYPE((*arglist)[0]),
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[2]))));
+	return build2 (MODIFY_EXPR, mem_type,
+		       build1 (INDIRECT_REF, mem_type,
+			       fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
+		       (*arglist)[0]);
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_load_pair:
       return build_constructor_va (return_type, 2,
 				   NULL_TREE, (*arglist)[0],
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index 374be7de5db..f2b6676cd0f 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -937,6 +937,8 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 	  continue;
 	}
 
+      /* A memory operand is rejected by the memory_operand predicate.
+	 Try making the address legal by copying it into a register.  */
       if (MEM_P (op[arity])
 	  && insn_op->predicate == memory_operand
 	  && (GET_MODE (XEXP (op[arity], 0)) == Pmode
@@ -960,10 +962,14 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 	{
 	  op[arity] = tmp_rtx;
 	}
-      else if (GET_MODE (op[arity]) == insn_op->mode
-	       || GET_MODE (op[arity]) == VOIDmode
-	       || (insn_op->predicate == address_operand
-		   && GET_MODE (op[arity]) == Pmode))
+
+      /* The predicate rejects the operand although the mode is fine.
+	 Copy the operand to register.  */
+      if (!insn_op->predicate (op[arity], insn_op->mode)
+	  && (GET_MODE (op[arity]) == insn_op->mode
+	      || GET_MODE (op[arity]) == VOIDmode
+	      || (insn_op->predicate == address_operand
+		  && GET_MODE (op[arity]) == Pmode)))
 	{
 	  /* An address_operand usually has VOIDmode in the expander
 	     so we cannot use this.  */
@@ -16039,6 +16045,7 @@ s390_can_inline_p (tree caller, tree callee)
 
   return ret;
 }
+#endif
 
 /* Set VAL to correct enum value according to the indirect-branch or
    function-return attribute in ATTR.  */
@@ -16112,6 +16119,7 @@ s390_indirect_branch_settings (tree fndecl)
     s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
 }
 
+#if S390_USE_TARGET_ATTRIBUTE
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -16127,6 +16135,7 @@ s390_activate_target_options (tree new_tree)
     TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
   s390_previous_fndecl = NULL_TREE;
 }
+#endif
 
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
@@ -16134,6 +16143,7 @@ s390_activate_target_options (tree new_tree)
 static void
 s390_set_current_function (tree fndecl)
 {
+#if S390_USE_TARGET_ATTRIBUTE
   /* Only change the context if the function changes.  This hook is called
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
@@ -16165,10 +16175,9 @@ s390_set_current_function (tree fndecl)
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
-
+#endif
   s390_indirect_branch_settings (fndecl);
 }
-#endif
 
 /* Implement TARGET_USE_BY_PIECES_INFRASTRUCTURE_P.  */
 
@@ -16907,10 +16916,10 @@ s390_case_values_threshold (void)
 #undef TARGET_ASM_FILE_END
 #define TARGET_ASM_FILE_END s390_asm_file_end
 
-#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION s390_set_current_function
 
+#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_OPTION_VALID_ATTRIBUTE_P
 #define TARGET_OPTION_VALID_ATTRIBUTE_P s390_valid_target_attribute_p
 
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 05de96e23fc..ad157c3f961 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,58 @@
+2019-03-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88820 - ICE with CTAD and member template used in DMI.
+	* pt.c (do_class_deduction): Handle parm used as its own arg.
+
+	PR c++/88869 - C++17 ICE with CTAD and explicit specialization.
+	* pt.c (do_class_deduction): Don't include explicit specialization
+	args in outer_args.
+
+	PR c++/88419 - C++17 ICE with class template arg deduction.
+	* pt.c (make_template_placeholder): Set TYPE_CANONICAL after
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+	PR c++/88690 - C++17 ICE with empty base in aggregate.
+	* typeck2.c (process_init_constructor_record): Skip trivial
+	initialization of an empty base.
+
+	PR c++/87921 - wrong error with inline static data member.
+	* decl2.c (c_parse_final_cleanups): Don't force out uninstantiated
+	inline static data members.
+
+	PR c++/89381 - implicit copy and using-declaration.
+	* class.c (classtype_has_move_assign_or_move_ctor_p): Don't consider
+	op= brought in by a using-declaration.
+
+	PR c++/89576 - if constexpr of lambda capture.
+	* semantics.c (maybe_convert_cond): Do convert a non-dependent
+	condition in a template.
+	* typeck.c (condition_conversion): Handle being called in a
+	template.
+
+	PR c++/89422 - ICE with -g and lambda in default arg in template.
+	* pt.c (tsubst_function_decl): SET_DECL_FRIEND_CONTEXT sooner.
+
+	PR c++/87513 - 'sorry' mangling PMF template-id.
+	* mangle.c (write_expression): Handle SCOPE_REF to BASELINK.
+
+	PR c++/88183 - ICE with .* fold-expression.
+	* pt.c (fold_expression) [DOTSTAR_EXPR]: Remove special handling.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2019-02-26  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-02-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89212 - ICE converting nullptr to pointer-to-member-function.
+	* pt.c (tsubst_copy_and_build) <case CONSTRUCTOR>: Return early for
+	null member pointer value.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index 834ba17a85d..0b789b17337 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -5171,7 +5171,9 @@ classtype_has_move_assign_or_move_ctor_p (tree t, bool user_p)
     for (ovl_iterator iter (get_class_binding_direct
 			    (t, assign_op_identifier));
 	 iter; ++iter)
-      if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))
+      if ((!user_p || !DECL_ARTIFICIAL (*iter))
+	  && DECL_CONTEXT (*iter) == t
+	  && move_fn_p (*iter))
 	return true;
   
   return false;
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 6a67c4e5b33..1043af49b91 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -4905,7 +4905,10 @@ c_parse_final_cleanups (void)
 	{
 	  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl)
 	      /* Don't write it out if we haven't seen a definition.  */
-	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl)))
+	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl))
+	      /* Or haven't instantiated it.  */
+	      || (DECL_TEMPLATE_INSTANTIATION (decl)
+		  && !DECL_TEMPLATE_INSTANTIATED (decl)))
 	    continue;
 	  import_export_decl (decl);
 	  /* If this static data member is needed, provide it to the
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index 2f65709d7d8..5146162404f 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -3047,7 +3047,8 @@ write_expression (tree expr)
 	{
 	  scope = TREE_OPERAND (expr, 0);
 	  member = TREE_OPERAND (expr, 1);
-	  gcc_assert (!BASELINK_P (member));
+	  if (BASELINK_P (member))
+	    member = BASELINK_FUNCTIONS (member);
 	}
       else
 	{
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 18b09affb59..e479ed96d30 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -19125,8 +19125,9 @@ cp_parser_asm_definition (cp_parser* parser)
   location_t volatile_loc = UNKNOWN_LOCATION;
   location_t inline_loc = UNKNOWN_LOCATION;
   location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
 
-  if (cp_parser_allow_gnu_extensions_p (parser) && parser->in_function_body)
+  if (cp_parser_allow_gnu_extensions_p (parser))
     for (;;)
       {
 	cp_token *token = cp_lexer_peek_token (parser->lexer);
@@ -19152,6 +19153,8 @@ cp_parser_asm_definition (cp_parser* parser)
 	      }
 	    else
 	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19163,6 +19166,8 @@ cp_parser_asm_definition (cp_parser* parser)
 	      }
 	    else
 	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19182,6 +19187,12 @@ cp_parser_asm_definition (cp_parser* parser)
   bool inline_p = (inline_loc != UNKNOWN_LOCATION);
   bool goto_p = (goto_loc != UNKNOWN_LOCATION);
 
+  if (!parser->in_function_body && (inline_p || goto_p))
+    {
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
+    }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index f1a8feef397..d0001c4895b 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -11732,8 +11732,6 @@ fold_expression (tree t, tree left, tree right, tsubst_flags_t complain)
     {
     case COMPOUND_EXPR:
       return build_x_compound_expr (input_location, left, right, complain);
-    case DOTSTAR_EXPR:
-      return build_m_component_ref (left, right, complain);
     default:
       return build_x_binary_op (input_location, code,
                                 left, TREE_CODE (left),
@@ -13023,6 +13021,11 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
 	set_constraints (r, ci);
       }
 
+  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
+    SET_DECL_FRIEND_CONTEXT (r,
+			     tsubst (DECL_FRIEND_CONTEXT (t),
+				     args, complain, in_decl));
+
   /* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do
      this in the special friend case mentioned above where
      GEN_TMPL is NULL.  */
@@ -13084,11 +13087,6 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
 	   && !grok_op_properties (r, /*complain=*/true))
     return error_mark_node;
 
-  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
-    SET_DECL_FRIEND_CONTEXT (r,
-			     tsubst (DECL_FRIEND_CONTEXT (t),
-				     args, complain, in_decl));
-
   /* Possibly limit visibility based on template args.  */
   DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;
   if (DECL_VISIBILITY_SPECIFIED (t))
@@ -18797,6 +18795,12 @@ tsubst_copy_and_build (tree t,
 	   looked up by digest_init.  */
 	process_index_p = !(type && MAYBE_CLASS_TYPE_P (type));
 
+	if (null_member_pointer_value_p (t))
+	  {
+	    gcc_assert (same_type_p (type, TREE_TYPE (t)));
+	    RETURN (t);
+	  }
+
 	n = vec_safe_copy (CONSTRUCTOR_ELTS (t));
         newlen = vec_safe_length (n);
 	FOR_EACH_VEC_SAFE_ELT (n, idx, ce)
@@ -25998,8 +26002,10 @@ make_auto (void)
 tree
 make_template_placeholder (tree tmpl)
 {
-  tree t = make_auto_1 (DECL_NAME (tmpl), true);
+  tree t = make_auto_1 (DECL_NAME (tmpl), false);
   CLASS_PLACEHOLDER_TEMPLATE (t) = tmpl;
+  /* Our canonical type depends on the placeholder.  */
+  TYPE_CANONICAL (t) = canonical_type_parameter (t);
   return t;
 }
 
@@ -26534,6 +26540,9 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,
 	error ("non-class template %qT used without template arguments", tmpl);
       return error_mark_node;
     }
+  if (init && TREE_TYPE (init) == ptype)
+    /* Using the template parm as its own argument.  */
+    return ptype;
 
   tree type = TREE_TYPE (tmpl);
 
@@ -26601,7 +26610,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,
 
   tree outer_args = NULL_TREE;
   if (DECL_CLASS_SCOPE_P (tmpl)
-      && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (tmpl)))
+      && CLASSTYPE_TEMPLATE_INSTANTIATION (DECL_CONTEXT (tmpl)))
     {
       outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));
       type = TREE_TYPE (most_general_template (tmpl));
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index a5460fa392e..0d7d75a1a60 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -645,10 +645,13 @@ maybe_convert_cond (tree cond)
     return NULL_TREE;
 
   /* Wait until we instantiate templates before doing conversion.  */
-  if (processing_template_decl)
+  if (processing_template_decl
+      && (type_dependent_expression_p (cond)
+	  /* For GCC 8 only convert non-dependent condition in a lambda.  */
+	  || !current_lambda_expr ()))
     return cond;
 
-  if (warn_sequence_point)
+  if (warn_sequence_point && !processing_template_decl)
     verify_sequence_points (cond);
 
   /* Do the conversion.  */
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 9ffea19fba9..afc1fd795b2 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -5747,18 +5747,17 @@ cp_truthvalue_conversion (tree expr)
     return c_common_truthvalue_conversion (input_location, expr);
 }
 
-/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
+/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  This
+   is a low-level function; most callers should use maybe_convert_cond.  */
 
 tree
 condition_conversion (tree expr)
 {
   tree t;
-  /* Anything that might happen in a template should go through
-     maybe_convert_cond.  */
-  gcc_assert (!processing_template_decl);
   t = perform_implicit_conversion_flags (boolean_type_node, expr,
 					 tf_warning_or_error, LOOKUP_NORMAL);
-  t = fold_build_cleanup_point_expr (boolean_type_node, t);
+  if (!processing_template_decl)
+    t = fold_build_cleanup_point_expr (boolean_type_node, t);
   return t;
 }
 
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index b91c98d594b..34284074a21 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -1538,6 +1538,13 @@ process_init_constructor_record (tree type, tree init, int nested,
 	    }
 	}
 
+      if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field))
+	  && !TREE_SIDE_EFFECTS (next))
+	/* Don't add trivial initialization of an empty base/field to the
+	   constructor, as they might not be ordered the way the back-end
+	   expects.  */
+	continue;
+
       /* If this is a bitfield, now convert to the lowered type.  */
       if (type != TREE_TYPE (field))
 	next = cp_convert_and_check (TREE_TYPE (field), next, complain);
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 11e926e9d47..297f7d5975b 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -19708,20 +19708,33 @@ If the cryptographic instructions are enabled (@option{-mcrypto} or
 @smallexample
 vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);
 
+vector unsigned char vec_sbox_be (vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                     vector unsigned long long);
 
+vector unsigned char vec_cipher_be (vector unsigned char, vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_cipherlast_be (vector unsigned char,
+                                        vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                      vector unsigned long long);
 
+vector unsigned char vec_ncipher_be (vector unsigned char,
+                                     vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_ncipherlast_be (vector unsigned char,
+                                         vector unsigned char);
+
 vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                 vector unsigned char,
                                                 vector unsigned char);
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 0940959cb54..36884c71fe0 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -2875,9 +2875,13 @@ const struct gcc_debug_hooks dwarf2_lineno_debug_hooks =
    separate comdat sections since the linker will then be able to
    remove duplicates.  But not all tools support .debug_types sections
    yet.  For Dwarf V5 or higher .debug_types doesn't exist any more,
-   it is DW_UT_type unit type in .debug_info section.  */
+   it is DW_UT_type unit type in .debug_info section.  For late LTO
+   debug there should be almost no types emitted so avoid enabling
+   -fdebug-types-section there.  */
 
-#define use_debug_types (dwarf_version >= 4 && flag_debug_types_section)
+#define use_debug_types (dwarf_version >= 4 \
+			 && flag_debug_types_section \
+			 && !in_lto_p)
 
 /* Various DIE's use offsets relative to the beginning of the
    .debug_info section to refer to each other.  */
@@ -3713,7 +3717,7 @@ static void output_die_abbrevs (unsigned long, dw_die_ref);
 static void output_die (dw_die_ref);
 static void output_compilation_unit_header (enum dwarf_unit_type);
 static void output_comp_unit (dw_die_ref, int, const unsigned char *);
-static void output_comdat_type_unit (comdat_type_node *);
+static void output_comdat_type_unit (comdat_type_node *, bool);
 static const char *dwarf2_name (tree, int);
 static void add_pubname (tree, dw_die_ref);
 static void add_enumerator_pubname (const char *, dw_die_ref);
@@ -9425,7 +9429,7 @@ size_of_die (dw_die_ref die)
 		 we use DW_FORM_ref_addr.  In DWARF2, DW_FORM_ref_addr
 		 is sized by target address length, whereas in DWARF3
 		 it's always sized as an offset.  */
-	      if (use_debug_types)
+	      if (AT_ref (a)->comdat_type_p)
 		size += DWARF_TYPE_SIGNATURE_SIZE;
 	      else if (dwarf_version == 2)
 		size += DWARF2_ADDR_SIZE;
@@ -9869,7 +9873,12 @@ value_format (dw_attr_node *a)
       return DW_FORM_flag;
     case dw_val_class_die_ref:
       if (AT_ref_external (a))
-	return use_debug_types ? DW_FORM_ref_sig8 : DW_FORM_ref_addr;
+	{
+	  if (AT_ref (a)->comdat_type_p)
+	    return DW_FORM_ref_sig8;
+	  else
+	    return DW_FORM_ref_addr;
+	}
       else
 	return DW_FORM_ref;
     case dw_val_class_fde_ref:
@@ -11217,7 +11226,8 @@ output_skeleton_debug_sections (dw_die_ref comp_unit,
 /* Output a comdat type unit DIE and its children.  */
 
 static void
-output_comdat_type_unit (comdat_type_node *node)
+output_comdat_type_unit (comdat_type_node *node,
+			 bool early_lto_debug ATTRIBUTE_UNUSED)
 {
   const char *secname;
   char *tmp;
@@ -11244,14 +11254,16 @@ output_comdat_type_unit (comdat_type_node *node)
   if (dwarf_version >= 5)
     {
       if (!dwarf_split_debug_info)
-	secname = ".debug_info";
+	secname = early_lto_debug ? DEBUG_LTO_INFO_SECTION : DEBUG_INFO_SECTION;
       else
-	secname = ".debug_info.dwo";
+	secname = (early_lto_debug
+		   ? DEBUG_LTO_DWO_INFO_SECTION : DEBUG_DWO_INFO_SECTION);
     }
   else if (!dwarf_split_debug_info)
-    secname = ".debug_types";
+    secname = early_lto_debug ? ".gnu.debuglto_.debug_types" : ".debug_types";
   else
-    secname = ".debug_types.dwo";
+    secname = (early_lto_debug
+	       ? ".gnu.debuglto_.debug_types.dwo" : ".debug_types.dwo");
 
   tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);
   sprintf (tmp, dwarf_version >= 5 ? "wi." : "wt.");
@@ -31398,7 +31410,7 @@ dwarf2out_finish (const char *)
                          ? dl_section_ref
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, false);
       *slot = ctnode;
     }
 
@@ -32039,7 +32051,7 @@ dwarf2out_early_finish (const char *filename)
                          ? debug_line_section_label
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, true);
       *slot = ctnode;
     }
 
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 4d2782f1b19..03edb662ff8 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,131 @@
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* expr.c (simplify_const_ref): Avoid null pointer dereference.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (gfc_set_constant_character_len): Clear original string
+	representation after padding has been performed to target length.
+	* resolve.c (gfc_resolve_substring_charlen): Check substring
+	length for constantness prior to general calculation of length.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Add is_mold
+	to garguments. If we are dealing with a MOLD, call
+	gfc_expr_to_initialize().
+	* trans-stmt.c (gfc_trans_allocate): For MOLD, pass is_mold=true
+	to gfc_find_and_cut_at_last_class_ref.
+	* trans.h (gfc_find_and_cut_at_last_class_ref): Add optional
+	argument is_mold with default false.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* trans-io.c (transfer_expr): Do not return if there are no
+	components to the derived type or class.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* check.c (gfc_calculate_transfer_sizes): Correct checks for cases
+	where storage size of elements of MOLD is 0.
+
+	PR fortran/89492
+	* check.c (gfc_calculate_transfer_sizes): Handle cases where
+	storage size of elements of MOLD is 0.
+
+	PR fortran/89266
+	PR fortran/88326
+	* target-memory.c (gfc_element_size): Return false if element size
+	cannot be determined; element size is returned separately.
+	(gfc_target_expr_size): Return false if expression size cannot be
+	determined; expression size is returned separately.
+	* target-memory.h: Adjust prototypes.
+	* check.c (gfc_calculate_transfer_sizes): Adjust references to
+	gfc_target_expr_size, gfc_element_size.
+	* arith.c (hollerith2representation): Likewise.
+	* class.c (find_intrinsic_vtab): Likewise.
+	* simplify.c (gfc_simplify_sizeof): Likewise.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* class.c (gfc_get_len_component): Add argument k for kind.
+	If the kind of the resulting expression is not equal to k,
+	convert it.
+	* gfortran.h (gfc_len_component): Adjust prototype.
+	* simplify.c (gfc_simplify_len): Pass kind to
+	gfc_get_len_component.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
index fc9b3f90c65..ef9d67412d6 100644
--- a/gcc/fortran/arith.c
+++ b/gcc/fortran/arith.c
@@ -2548,10 +2548,10 @@ gfc_character2character (gfc_expr *src, int kind)
 static void
 hollerith2representation (gfc_expr *result, gfc_expr *src)
 {
-  int src_len, result_len;
+  size_t src_len, result_len;
 
   src_len = src->representation.length - src->ts.u.pad;
-  result_len = gfc_target_expr_size (result);
+  gfc_target_expr_size (result, &result_len);
 
   if (src_len > result_len)
     {
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index f304154ac68..febf77fd3e7 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -5413,16 +5413,41 @@ gfc_calculate_transfer_sizes (gfc_expr *source, gfc_expr *mold, gfc_expr *size,
     return false;
 
   /* Calculate the size of the source.  */
-  *source_size = gfc_target_expr_size (source);
-  if (*source_size == 0)
+  if (!gfc_target_expr_size (source, source_size))
     return false;
 
   /* Determine the size of the element.  */
-  result_elt_size = gfc_element_size (mold);
-  if (result_elt_size == 0)
+  if (!gfc_element_size (mold, &result_elt_size))
     return false;
 
-  if (mold->expr_type == EXPR_ARRAY || mold->rank || size)
+  /* If the storage size of SOURCE is greater than zero and MOLD is an array,
+   * a scalar with the type and type parameters of MOLD shall not have a
+   * storage size equal to zero.
+   * If MOLD is a scalar and SIZE is absent, the result is a scalar.
+   * If MOLD is an array and SIZE is absent, the result is an array and of
+   * rank one. Its size is as small as possible such that its physical
+   * representation is not shorter than that of SOURCE.
+   * If SIZE is present, the result is an array of rank one and size SIZE.
+   */
+  if (result_elt_size == 0 && *source_size > 0 && !size
+      && mold->expr_type == EXPR_ARRAY)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L is an "
+		 "array and shall not have storage size 0 when %<SOURCE%> "
+		 "argument has size greater than 0", &mold->where);
+      return false;
+    }
+
+  if (result_elt_size == 0 && *source_size == 0 && !size)
+    {
+      *result_size = 0;
+      if (result_length_p)
+	*result_length_p = 0;
+      return true;
+    }
+
+  if ((result_elt_size > 0 && (mold->expr_type == EXPR_ARRAY || mold->rank))
+      || size)
     {
       int result_length;
 
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 2eae7f0f351..cb9f0d9f23d 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -561,7 +561,7 @@ gfc_intrinsic_hash_value (gfc_typespec *ts)
    ref to the _len component.  */
 
 gfc_expr *
-gfc_get_len_component (gfc_expr *e)
+gfc_get_len_component (gfc_expr *e, int k)
 {
   gfc_expr *ptr;
   gfc_ref *ref, **last;
@@ -586,6 +586,14 @@ gfc_get_len_component (gfc_expr *e)
     }
   /* And replace if with a ref to the _len component.  */
   gfc_add_len_component (ptr);
+  if (k != ptr->ts.kind)
+    {
+      gfc_typespec ts;
+      gfc_clear_ts (&ts);
+      ts.type = BT_INTEGER;
+      ts.kind = k;
+      gfc_convert_type_warn (ptr, &ts, 2, 0);
+    }
   return ptr;
 }
 
@@ -2661,6 +2669,7 @@ find_intrinsic_vtab (gfc_typespec *ts)
 	      gfc_namespace *sub_ns;
 	      gfc_namespace *contained;
 	      gfc_expr *e;
+	      size_t e_size;
 
 	      gfc_get_symbol (name, ns, &vtype);
 	      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL,
@@ -2695,11 +2704,13 @@ find_intrinsic_vtab (gfc_typespec *ts)
 	      e = gfc_get_expr ();
 	      e->ts = *ts;
 	      e->expr_type = EXPR_VARIABLE;
+	      if (ts->type == BT_CHARACTER)
+		e_size = ts->kind;
+	      else
+		gfc_element_size (e, &e_size);
 	      c->initializer = gfc_get_int_expr (gfc_size_kind,
 						 NULL,
-						 ts->type == BT_CHARACTER
-						 ? ts->kind
-						 : gfc_element_size (e));
+						 e_size);
 	      gfc_free_expr (e);
 
 	      /* Add component _extends.  */
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 9ce89c093c0..41b1a992a57 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -1678,6 +1678,14 @@ gfc_set_constant_character_len (gfc_charlen_t len, gfc_expr *expr,
       free (expr->value.character.string);
       expr->value.character.string = s;
       expr->value.character.length = len;
+      /* If explicit representation was given, clear it
+	 as it is no longer needed after padding.  */
+      if (expr->representation.length)
+	{
+	  expr->representation.length = 0;
+	  free (expr->representation.string);
+	  expr->representation.string = NULL;
+	}
     }
 }
 
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 6ef4eb864e6..2731a714fca 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1784,8 +1784,14 @@ simplify_const_ref (gfc_expr *p)
 			string_len = 0;
 
 		      if (!p->ts.u.cl)
-			p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
-						      NULL);
+			{
+			  if (p->symtree)
+			    p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
+							  NULL);
+			  else
+			    p->ts.u.cl = gfc_new_charlen (gfc_current_ns,
+							  NULL);
+			}
 		      else
 			gfc_free_expr (p->ts.u.cl->length);
 
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 698d211d74e..abdefe12ed2 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -3426,7 +3426,7 @@ bool gfc_is_class_scalar_expr (gfc_expr *);
 bool gfc_is_class_container_ref (gfc_expr *e);
 gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);
 unsigned int gfc_hash_value (gfc_symbol *);
-gfc_expr *gfc_get_len_component (gfc_expr *e);
+gfc_expr *gfc_get_len_component (gfc_expr *e, int);
 bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,
 			     gfc_array_spec **);
 gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index f70747a586f..7291039782e 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1681,8 +1681,6 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -4881,6 +4879,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)
   gfc_ref *char_ref;
   gfc_expr *start, *end;
   gfc_typespec *ts = NULL;
+  mpz_t diff;
 
   for (char_ref = e->ref; char_ref; char_ref = char_ref->next)
     {
@@ -4932,11 +4931,25 @@ gfc_resolve_substring_charlen (gfc_expr *e)
       return;
     }
 
-  /* Length = (end - start + 1).  */
-  e->ts.u.cl->length = gfc_subtract (end, start);
-  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
-				gfc_get_int_expr (gfc_charlen_int_kind,
-						  NULL, 1));
+  /* Length = (end - start + 1).
+     Check first whether it has a constant length.  */
+  if (gfc_dep_difference (end, start, &diff))
+    {
+      gfc_expr *len = gfc_get_constant_expr (BT_INTEGER, gfc_charlen_int_kind,
+					     &e->where);
+
+      mpz_add_ui (len->value.integer, diff, 1);
+      mpz_clear (diff);
+      e->ts.u.cl->length = len;
+      /* The check for length < 0 is handled below */
+    }
+  else
+    {
+      e->ts.u.cl->length = gfc_subtract (end, start);
+      e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
+				    gfc_get_int_expr (gfc_charlen_int_kind,
+						      NULL, 1));
+    }
 
   /* F2008, 6.4.1:  Both the starting point and the ending point shall
      be within the range 1, 2, ..., n unless the starting point exceeds
@@ -7640,13 +7653,54 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -11011,6 +11065,9 @@ deferred_op_assign (gfc_code **code, gfc_namespace *ns)
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 0d0f57922ea..65fc19151e7 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -4469,7 +4469,7 @@ gfc_simplify_len (gfc_expr *e, gfc_expr *kind)
     /* The expression in assoc->target points to a ref to the _data component
        of the unlimited polymorphic entity.  To get the _len component the last
        _data ref needs to be stripped and a ref to the _len component added.  */
-    return gfc_get_len_component (e->symtree->n.sym->assoc->target);
+    return gfc_get_len_component (e->symtree->n.sym->assoc->target, k);
   else
     return NULL;
 }
@@ -6921,6 +6921,7 @@ gfc_simplify_sizeof (gfc_expr *x)
 {
   gfc_expr *result = NULL;
   mpz_t array_size;
+  size_t res_size;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6936,7 +6937,8 @@ gfc_simplify_sizeof (gfc_expr *x)
 
   result = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,
 				  &x->where);
-  mpz_set_si (result->value.integer, gfc_target_expr_size (x));
+  gfc_target_expr_size (x, &res_size);
+  mpz_set_si (result->value.integer, res_size);
 
   return result;
 }
@@ -6950,6 +6952,7 @@ gfc_simplify_storage_size (gfc_expr *x,
 {
   gfc_expr *result = NULL;
   int k;
+  size_t siz;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6965,7 +6968,8 @@ gfc_simplify_storage_size (gfc_expr *x,
 
   result = gfc_get_constant_expr (BT_INTEGER, k, &x->where);
 
-  mpz_set_si (result->value.integer, gfc_element_size (x));
+  gfc_element_size (x, &siz);
+  mpz_set_si (result->value.integer, siz);
   mpz_mul_ui (result->value.integer, result->value.integer, BITS_PER_UNIT);
 
   return range_check (result, "STORAGE_SIZE");
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 4ea66e3f387..ebb57eda9c5 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -522,7 +522,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -1801,7 +1801,8 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index 6b9292b5faf..c924cb529d1 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -73,26 +73,30 @@ size_character (gfc_charlen_t length, int kind)
 
 
 /* Return the size of a single element of the given expression.
-   Identical to gfc_target_expr_size for scalars.  */
+   Equivalent to gfc_target_expr_size for scalars.  */
 
-size_t
-gfc_element_size (gfc_expr *e)
+bool
+gfc_element_size (gfc_expr *e, size_t *siz)
 {
   tree type;
 
   switch (e->ts.type)
     {
     case BT_INTEGER:
-      return size_integer (e->ts.kind);
+      *siz = size_integer (e->ts.kind);
+      return true;
     case BT_REAL:
-      return size_float (e->ts.kind);
+      *siz = size_float (e->ts.kind);
+      return true;
     case BT_COMPLEX:
-      return size_complex (e->ts.kind);
+      *siz = size_complex (e->ts.kind);
+      return true;
     case BT_LOGICAL:
-      return size_logical (e->ts.kind);
+      *siz = size_logical (e->ts.kind);
+      return true;
     case BT_CHARACTER:
       if (e->expr_type == EXPR_CONSTANT)
-	return size_character (e->value.character.length, e->ts.kind);
+	*siz = size_character (e->value.character.length, e->ts.kind);
       else if (e->ts.u.cl != NULL && e->ts.u.cl->length != NULL
 	       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT
 	       && e->ts.u.cl->length->ts.type == BT_INTEGER)
@@ -100,13 +104,18 @@ gfc_element_size (gfc_expr *e)
 	  HOST_WIDE_INT length;
 
 	  gfc_extract_hwi (e->ts.u.cl->length, &length);
-	  return size_character (length, e->ts.kind);
+	  *siz = size_character (length, e->ts.kind);
 	}
       else
-	return 0;
+	{
+	  *siz = 0;
+	  return false;
+	}
+      return true;
 
     case BT_HOLLERITH:
-      return e->representation.length;
+      *siz = e->representation.length;
+      return true;
     case BT_DERIVED:
     case BT_CLASS:
     case BT_VOID:
@@ -120,36 +129,43 @@ gfc_element_size (gfc_expr *e)
 	type = gfc_typenode_for_spec (&ts);
 	size = int_size_in_bytes (type);
 	gcc_assert (size >= 0);
-	return size;
+	*siz = size;
       }
+      return true;
     default:
       gfc_internal_error ("Invalid expression in gfc_element_size.");
-      return 0;
+      *siz = 0;
+      return false;
     }
+  return true;
 }
 
 
 /* Return the size of an expression in its target representation.  */
 
-size_t
-gfc_target_expr_size (gfc_expr *e)
+bool
+gfc_target_expr_size (gfc_expr *e, size_t *size)
 {
   mpz_t tmp;
-  size_t asz;
+  size_t asz, el_size;
 
   gcc_assert (e != NULL);
 
+  *size = 0;
   if (e->rank)
     {
       if (gfc_array_size (e, &tmp))
 	asz = mpz_get_ui (tmp);
       else
-	asz = 0;
+	return false;
     }
   else
     asz = 1;
 
-  return asz * gfc_element_size (e);
+  if (!gfc_element_size (e, &el_size))
+    return false;
+  *size = asz * el_size;
+  return true;
 }
 
 
@@ -675,7 +691,7 @@ expr_to_char (gfc_expr *e, locus *loc,
 
   /* Otherwise, use the target-memory machinery to write a bitwise image, appropriate
      to the target, in a buffer and check off the initialized part of the buffer.  */
-  len = gfc_target_expr_size (e);
+  gfc_target_expr_size (e, &len);
   buffer = (unsigned char*)alloca (len);
   len = gfc_target_encode_expr (e, buffer, len);
 
@@ -722,7 +738,9 @@ gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, locus *loc,
       for (c = gfc_constructor_first (e->value.constructor);
 	   c; c = gfc_constructor_next (c))
 	{
-	  size_t elt_size = gfc_target_expr_size (c->expr);
+	  size_t elt_size;
+
+	  gfc_target_expr_size (c->expr, &elt_size);
 
 	  if (mpz_cmp_si (c->offset, 0) != 0)
 	    len = elt_size * (size_t)mpz_get_si (c->offset);
diff --git a/gcc/fortran/target-memory.h b/gcc/fortran/target-memory.h
index 8f25899a92c..0a4316e6641 100644
--- a/gcc/fortran/target-memory.h
+++ b/gcc/fortran/target-memory.h
@@ -24,8 +24,8 @@ along with GCC; see the file COPYING3.  If not see
 /* Convert a BOZ to REAL or COMPLEX.  */
 bool gfc_convert_boz (gfc_expr *, gfc_typespec *);
 
-size_t gfc_element_size (gfc_expr *);
-size_t gfc_target_expr_size (gfc_expr *);
+bool gfc_element_size (gfc_expr *, size_t *);
+bool gfc_target_expr_size (gfc_expr *, size_t *);
 
 /* Write a constant expression in binary form to a target buffer.  */
 size_t gfc_encode_character (int, size_t, const gfc_char_t *, unsigned char *,
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 548380a4e86..a2172c3ddeb 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1977,7 +1977,7 @@ get_proc_pointer_decl (gfc_symbol *sym)
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -2150,7 +2150,7 @@ module_sym:
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -5384,6 +5384,33 @@ generate_coarray_sym_init (gfc_symbol *sym)
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index 8ed79f135cf..b95cf8ddc4f 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -352,7 +352,7 @@ gfc_vptr_size_get (tree vptr)
    of refs following.  */
 
 gfc_expr *
-gfc_find_and_cut_at_last_class_ref (gfc_expr *e)
+gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold)
 {
   gfc_expr *base_expr;
   gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;
@@ -394,7 +394,10 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)
       e->ref = NULL;
     }
 
-  base_expr = gfc_copy_expr (e);
+  if (is_mold)
+    base_expr = gfc_expr_to_initialize (e);
+  else
+    base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -3834,7 +3837,8 @@ conv_base_obj_fcn_val (gfc_se * se, tree base_object, gfc_expr * expr)
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3852,7 +3856,7 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -6276,7 +6280,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
index 2626c4651e2..b07ce83c378 100644
--- a/gcc/fortran/trans-io.c
+++ b/gcc/fortran/trans-io.c
@@ -2408,8 +2408,6 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,
 
     case_bt_struct:
     case BT_CLASS:
-      if (ts->u.derived->components == NULL)
-	return;
       if (gfc_bt_struct (ts->type) || ts->type == BT_CLASS)
 	{
 	  gfc_symbol *derived;
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 5b2d4e8279d..eb976c70a3a 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -6606,7 +6606,7 @@ gfc_trans_allocate (gfc_code * code)
 	  /* Use class_init_assign to initialize expr.  */
 	  gfc_code *ini;
 	  ini = gfc_get_code (EXEC_INIT_ASSIGN);
-	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr);
+	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr, true);
 	  tmp = gfc_trans_class_init_assign (ini);
 	  gfc_free_statements (ini);
 	  gfc_add_expr_to_block (&block, tmp);
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index f50eb0a9f01..a3659e65e43 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1213,7 +1213,8 @@ gfc_typenode_for_spec (gfc_typespec * spec, int codim)
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -2978,7 +2979,8 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2991,9 +2993,57 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
+
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, NULL, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
 
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -3051,6 +3101,10 @@ gfc_get_function_type (gfc_symbol * sym)
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
diff --git a/gcc/fortran/trans-types.h b/gcc/fortran/trans-types.h
index 197b173f041..28312cfd33e 100644
--- a/gcc/fortran/trans-types.h
+++ b/gcc/fortran/trans-types.h
@@ -88,7 +88,7 @@ tree gfc_sym_type (gfc_symbol *);
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index d16c15061c6..103ad6787ad 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -412,7 +412,7 @@ tree gfc_class_data_get (tree);
 tree gfc_class_vptr_get (tree);
 tree gfc_class_len_get (tree);
 tree gfc_class_len_or_zero_get (tree);
-gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);
+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);
 /* Get an accessor to the class' vtab's * field, when a class handle is
    available.  */
 tree gfc_class_vtab_hash_get (tree);
@@ -579,7 +579,8 @@ void gfc_merge_block_scope (stmtblock_t * block);
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
diff --git a/gcc/input.c b/gcc/input.c
index b6675768722..26c2bf21d52 100644
--- a/gcc/input.c
+++ b/gcc/input.c
@@ -3538,6 +3538,34 @@ for_each_line_table_case (void (*testcase) (const line_table_case &))
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3577,6 +3605,8 @@ input_c_tests ()
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
diff --git a/gcc/loop-unroll.c b/gcc/loop-unroll.c
index 5a0393224cb..4b36e7c44c3 100644
--- a/gcc/loop-unroll.c
+++ b/gcc/loop-unroll.c
@@ -399,7 +399,7 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)
     {
       /* However we cannot unroll completely at the RTL level a loop with
 	 constant number of iterations; it should have been peeled instead.  */
-      if ((unsigned) loop->unroll - 1 > desc->niter - 2)
+      if ((unsigned) loop->unroll > desc->niter - 1)
 	{
 	  if (dump_file)
 	    fprintf (dump_file, ";; Loop should have been peeled\n");
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index 5405c4d2adb..e3adf78e57c 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -6293,6 +6293,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)
 			add_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),
 					     reg_renumber[dst_regno]);
 		      AND_COMPL_HARD_REG_SET (live_hard_regs, s);
+		      AND_COMPL_HARD_REG_SET (potential_reload_hard_regs, s);
 		    }
 		  /* We should invalidate potential inheritance or
 		     splitting for the current insn usages to the next
diff --git a/gcc/passes.c b/gcc/passes.c
index 65ad690f6d9..a6c118543e6 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -1944,7 +1944,7 @@ execute_function_todo (function *fn, void *data)
   /* Always cleanup the CFG before trying to update SSA.  */
   if (flags & TODO_cleanup_cfg)
     {
-      cleanup_tree_cfg ();
+      cleanup_tree_cfg (flags & TODO_update_ssa_any);
 
       /* When cleanup_tree_cfg merges consecutive blocks, it may
 	 perform some simplistic propagation when removing single
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 0e79e53fb61..dabc5403f28 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -358,10 +358,10 @@ get_initial_register_offset (int from, int to)
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 7d5e65b1a74..1cb4b8e97fc 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,257 @@
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* gcc.target/i386/pr85860.c: New.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* gcc.dg/torture/pr89677.c: New testcase.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* gcc.dg/tree-ssa/reassoc-43.c: Avoid false match in regex.
+	* g++.dg/tree-prof/devirt.C: Scan tracer dump for foldings
+	that happen now earlier.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* tree-ssa-loop-ch.c (ch_base::copy_headers): Restrict setting
+	of no-warning flag to cases that might emit the bogus warning.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-addc-u128.c: New test.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/xl-xst-align-1.c: New test.
+	* gcc.target/s390/zvector/xl-xst-align-2.c: New test.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* gfortran.dg/pr89664.f90: New testcase.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-c++-common/unroll-6.c: New test.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/i386/indirect-thunk-extern-7.c: Add -fjump-tables to
+	dg-options.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	* g++.dg/ipa/pr88235.C: New test.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* gfortran.dg/substr_8.f90: New test.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* gcc.target/aarch64/options_set_10.c: New test.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/transfer_simplify_12.f90: New test.
+	* gfortran.dg/substr_simplify.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* gfortran.dg/allocate_with_mold_3.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* gfortran.dg/dtio_34.f90: New test.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* gfortran.dg/pr89492.f90: Adjust testcase.
+	* gfortran.dg/transfer_check_5.f90: New test.
+
+	PR fortran/89492
+	* gfortran.dg/pr89492.f90: New test.
+
+	PR fortran/89266
+	PR fortran/88326
+	* gfortran.dg/pr89266.f90: New test.
+	* gfortran.dg/pr88326.f90: New test.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190228-1.c: New test.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/testsuite/gcc.target/powerpc/pr88100.c: New testcase.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt77.adb: New test.
+	* gnat.dg/opt77_pkg.ad[sb]: New helper.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* gfortran.dg/warn_conversion_11.f90: New test.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90: New test
+
+2019-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/unroll-6.c b/gcc/testsuite/c-c++-common/unroll-6.c
new file mode 100644
index 00000000000..fd74f19bed5
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/unroll-6.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-loop-optimize" } */
+
+void test (void)
+{
+  #pragma GCC unroll 2
+  for (int nv = 0; nv <= 2; nv += 2)
+    {}
+}
diff --git a/gcc/testsuite/g++.dg/asm-qual-3.C b/gcc/testsuite/g++.dg/asm-qual-3.C
index 95c9b570a5f..6faf0ef5e06 100644
--- a/gcc/testsuite/g++.dg/asm-qual-3.C
+++ b/gcc/testsuite/g++.dg/asm-qual-3.C
@@ -2,11 +2,11 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++98" }
 
-asm const ("");    // { dg-error {expected '\(' before 'const'} }
-asm volatile (""); // { dg-error {expected '\(' before 'volatile'} }
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
 asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
-asm inline ("");   // { dg-error {expected '\(' before 'inline'} }
-asm goto ("");     // { dg-error {expected '\(' before 'goto'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
 
 // There are many other things wrong with this code, so:
 // { dg-excess-errors "" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C b/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C
new file mode 100644
index 00000000000..03285022087
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C
@@ -0,0 +1,9 @@
+// PR c++/87513
+// { dg-do compile { target c++11 } }
+
+struct A { template <long> void foo (); };
+template <long t> auto bar () -> decltype (&A::foo<t>);
+void foo ()
+{
+  bar<0> ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/implicit16.C b/gcc/testsuite/g++.dg/cpp0x/implicit16.C
new file mode 100644
index 00000000000..229f2b4cd81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/implicit16.C
@@ -0,0 +1,37 @@
+// PR c++/89381
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct base
+{
+  base() { }
+  base(const base&) { }
+  base(base&&) { }
+  base& operator=(const base&) { return *this; }
+  base& operator=(base&&) { return *this; }
+};
+
+struct foo : base<int>
+{
+    using base<int>::base;
+    using base<int>::operator=;
+};
+
+//using workaround = decltype(foo{*static_cast<foo const*>(0)});
+
+struct bar
+{
+    bar& operator=(foo ve)
+    {
+        value = ve;
+        return *this;
+    }
+
+    foo value;
+};
+
+int main()
+{
+    foo a;
+    foo b{a};
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C
new file mode 100644
index 00000000000..f0436adfe9a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C
@@ -0,0 +1,10 @@
+// PR c++/89422
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -g }
+
+template <int> struct S
+{
+  friend void foo (int a = []{ return 0; }()) {}
+  int b;
+};
+S<0> t;
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr40.C b/gcc/testsuite/g++.dg/cpp0x/nullptr40.C
new file mode 100644
index 00000000000..21c188bdb5e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr40.C
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<class X, void(X::*foo)() = nullptr>
+struct p
+{
+    template<void(X::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<A> i = 1;
+    void bar();
+    p<A, &A::bar> j;
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr41.C b/gcc/testsuite/g++.dg/cpp0x/nullptr41.C
new file mode 100644
index 00000000000..54e66af2095
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr41.C
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<typename U, typename W, typename Y, class X, W(X::*foo)() = nullptr>
+struct p
+{
+    template<U(Y::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<void, void, A, A> i = 1;
+    void bar();
+    p<void, void, A, A, &A::bar> j;
+};
diff --git a/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C b/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C
new file mode 100644
index 00000000000..bc1793e79ca
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C
@@ -0,0 +1,8 @@
+// PR c++/88690
+// { dg-do compile { target c++11 } }
+
+struct A { int a = 1; };
+struct B { int b = 0; };
+struct C { C() = default; C (const C&) = delete; };
+struct D : public B, public C {};
+struct E : A { D f; } g{};
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C
new file mode 100644
index 00000000000..2baa3acb8c1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C
@@ -0,0 +1,22 @@
+// PR c++/88419
+// { dg-do compile { target c++17 } }
+
+template<class> struct ref_view {
+  template<class T> ref_view(T&&);
+};
+
+template<class R> ref_view(R&) -> ref_view<R>;
+
+struct ref_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(ref_view{r}));
+};
+
+template<class R> struct indirect_view {
+  indirect_view(R);
+};
+
+struct indirect_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(indirect_view{r}));
+};
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C
new file mode 100644
index 00000000000..4fc66fcbe15
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C
@@ -0,0 +1,11 @@
+// PR c++/88869
+// { dg-do compile { target c++17 } }
+
+template <typename> struct B;
+template <> struct B<int> {
+  template <typename T> struct C {
+    T e;
+    C (T f) : e(f) {}
+  };
+  void foo () { C c (42); }
+};
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C
new file mode 100644
index 00000000000..3a06e6fb522
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C
@@ -0,0 +1,9 @@
+// PR c++/88820
+// { dg-do compile { target c++17 } }
+
+template <int> struct S;
+
+template <S> struct W {
+  template <typename> static int foo();
+  bool b = foo<int>();
+};
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C
new file mode 100644
index 00000000000..8bfde6c1bdb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C
@@ -0,0 +1,11 @@
+// PR c++/89576
+// { dg-do compile { target c++17 } }
+
+template <class T>
+void foo()
+{
+    constexpr int x = 0;
+    [&] {
+        if constexpr (x) {}
+    };
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C b/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C
new file mode 100644
index 00000000000..5a53c866284
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C
@@ -0,0 +1,19 @@
+// PR c++/88183
+// { dg-do compile { target c++17 } }
+
+struct A { int i; };
+
+template <class T> T& g(T);
+
+template <class U, class... Vs>
+void f(U u, Vs... vs)
+{ 
+  [vs...](auto x) {
+    (g(x) .* ... .* vs) = 42;
+  }(u);
+}
+
+int main()
+{
+  f(A(), &A::i);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/inline-var5.C b/gcc/testsuite/g++.dg/cpp1z/inline-var5.C
new file mode 100644
index 00000000000..27730106f27
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/inline-var5.C
@@ -0,0 +1,16 @@
+// PR c++/87921
+// { dg-do compile { target c++17 } }
+
+template <class H>
+struct X
+{
+  static inline long x[] = { 1L };
+  long foo () { return x[0]; }
+};
+
+void
+bar ()
+{
+  class L {};
+  X<L> v {};
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr88235.C b/gcc/testsuite/g++.dg/ipa/pr88235.C
new file mode 100644
index 00000000000..29f3252b828
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr88235.C
@@ -0,0 +1,55 @@
+// { dg-do compile }
+// { dg-options "-O1 -fdevirtualize -finline-small-functions -fipa-cp -fipa-cp-clone --param ipa-cp-eval-threshold=125 --param max-inline-insns-single=4" }
+
+extern "C" int printf (const char *, ...);
+enum E { vf_request, vf_event } want;
+
+int errs = 0;
+
+class ivResource {
+public:
+  virtual ~ivResource () { }
+};
+
+class ivHandler   : public ivResource   {
+public:
+  virtual void event() { }
+};
+
+class ivGlyph   : public ivResource   {
+public:
+  virtual ~ivGlyph  () { }
+  virtual void request () {
+    if (want!=vf_request)
+      ++errs;
+  }
+};
+
+class ItemView : public ivGlyph, public ivHandler {
+public:
+  virtual void event () {
+    if (want!=vf_event)
+      ++errs;
+  }
+} a;
+
+ivGlyph *bar() {
+  return &a;
+}
+
+ivHandler *bar2() {
+  return &a;
+}
+
+int main() {
+  want=vf_request;
+  bar()->request();
+  want=vf_event;
+  bar2()->event();
+  if (errs) {
+    printf("FAIL\n");
+    return 1;
+  }
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/devirt.C b/gcc/testsuite/g++.dg/tree-prof/devirt.C
index 3de5dbcf688..d8fb2d9ef46 100644
--- a/gcc/testsuite/g++.dg/tree-prof/devirt.C
+++ b/gcc/testsuite/g++.dg/tree-prof/devirt.C
@@ -1,5 +1,5 @@
 /* PR ipa/88561 */
-/* { dg-options "-O3 -fdump-tree-dom3-details" } */
+/* { dg-options "-O3 -fdump-tree-tracer-details -fdump-tree-dom3-details" } */
 
 struct nsISupports
 {
@@ -121,6 +121,6 @@ main ()
     __builtin_abort ();
 }
 
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "dom3" { target { lp64 || llp64 } } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "dom3" { target ilp32 } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "dom3" } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "tracer" { target { lp64 || llp64 } } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "tracer" { target ilp32 } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "tracer" } } */
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190228-1.c b/gcc/testsuite/gcc.c-torture/execute/20190228-1.c
new file mode 100644
index 00000000000..e71f33a279b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20190228-1.c
@@ -0,0 +1,16 @@
+/* PR tree-optimization/89536 */
+/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */
+
+int a = 1;
+
+int main (void)
+{
+  a = ~(a && 1); 
+  if (a < -1)
+    a = ~a;
+  
+  if (!a)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr89505.c b/gcc/testsuite/gcc.dg/torture/pr89505.c
new file mode 100644
index 00000000000..6fca475ad9d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr89505.c
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr89677.c b/gcc/testsuite/gcc.dg/torture/pr89677.c
new file mode 100644
index 00000000000..a45ca1f61a1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr89677.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target int32plus } */
+
+int a, b, d;
+unsigned c;
+float e, f, g;
+void h() {
+    float *i = &g;
+    for (; c < 10; c += 3)
+      for (; d; d += 3) {
+	  a = *i;
+	  g = f + 0;
+	  f = b + *i + (b - e + 305219) + -b + 3;
+      }
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
index ea44f300f94..90e1e86b3cb 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
@@ -50,4 +50,4 @@ c_parser_translation_unit (c_parser * parser)
 	}
     }
 }
-/* { dg-final { scan-tree-dump-not "0 != 0" "reassoc2"} } */
+/* { dg-final { scan-tree-dump-not "\[ (\]0 != 0" "reassoc2"} } */
diff --git a/gcc/testsuite/gcc.dg/uninit-pr89296.c b/gcc/testsuite/gcc.dg/uninit-pr89296.c
new file mode 100644
index 00000000000..9d81b32b979
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-pr89296.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int get_a_value ();
+void printk(const char *);
+void test_func()
+{
+    int loop;
+    while (!loop) {             /* { dg-warning "is used uninitialized" } */
+	loop = get_a_value();
+	printk("...");
+    }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_1.c b/gcc/testsuite/gcc.target/aarch64/options_set_1.c
new file mode 100644
index 00000000000..40d9a05c905
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_1.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc} 1 } } */
+
+/* Check to see if crc is output by default.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_10.c b/gcc/testsuite/gcc.target/aarch64/options_set_10.c
new file mode 100644
index 00000000000..1fc8aa86fd6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_10.c
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not {\.arch .+\+profile.*} } } */
+
+ /* Check that an empty feature string is not detected during mcpu=native.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_2.c b/gcc/testsuite/gcc.target/aarch64/options_set_2.c
new file mode 100644
index 00000000000..3476febce70
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check to see if crc and crypto are maintained if crypto specified.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_3.c b/gcc/testsuite/gcc.target/aarch64/options_set_3.c
new file mode 100644
index 00000000000..4558339f16c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_3.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if smallest set is maintained when outputting. */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_4.c b/gcc/testsuite/gcc.target/aarch64/options_set_4.c
new file mode 100644
index 00000000000..15514bfe93e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_4.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if individual bits that make up a grouping is specified that only the
+   grouping is kept. */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_5.c b/gcc/testsuite/gcc.target/aarch64/options_set_5.c
new file mode 100644
index 00000000000..b4c0901195e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_5.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc\+aes} 1 } } */
+
+/* Check if turning off feature bits works correctly and grouping is no
+   longer valid.   */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_6.c b/gcc/testsuite/gcc.target/aarch64/options_set_6.c
new file mode 100644
index 00000000000..90a055928a2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_6.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Group as a whole was requested to be turned on, crypto itself is a bit and so
+   just turning off one feature can't turn it off.   */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_7.c b/gcc/testsuite/gcc.target/aarch64/options_set_7.c
new file mode 100644
index 00000000000..71a2c8a1905
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_7.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+dotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if enabling default features drops the superfluous bits.   */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_8.c b/gcc/testsuite/gcc.target/aarch64/options_set_8.c
new file mode 100644
index 00000000000..83be1bd7a5c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_8.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+nodotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if trying to turn off default features propagates the commandline
+   option.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_9.c b/gcc/testsuite/gcc.target/aarch64/options_set_9.c
new file mode 100644
index 00000000000..e3c7cdc54ff
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_9.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8-a+simd+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\-a} 1 } } */
+
+ /* Check that grouping of bits that don't form a synthetic group don't turn
+    on the parent. e.g. rdma turns on simd+fp, but simd+fp does not turn on
+    rdma since rdma is it's own group.  crypto however turns on aes and sha2
+    and turning on sha2 and eas should turn on crypto!.  */
diff --git a/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
new file mode 100644
index 00000000000..2620e570004
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
index 3c72036dbaf..53868f46558 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
index b7339745116..95c5cc176ae 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
index ea009245a58..e6f064959a1 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
diff --git a/gcc/testsuite/gcc.target/i386/pr85860.c b/gcc/testsuite/gcc.target/i386/pr85860.c
new file mode 100644
index 00000000000..aef78a4b958
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85860.c
@@ -0,0 +1,23 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -fno-guess-branch-probability -flive-range-shrinkage -mbmi2" } */
+
+int a, b, c, d, e;
+
+extern int bar(void);
+
+__int128
+foo (unsigned g, int h, long i, __int128 j, short k, __int128 l)
+{
+  unsigned __int128 m = j;
+  do
+    {
+      j %= 5;
+      c = c >> (m & 31);
+      e = __builtin_sub_overflow (b, 0, &m);
+      d = bar ();
+      l *= __builtin_mul_overflow_p ((unsigned) d, ~(unsigned __int128) 1,
+				     (unsigned __int128) 0);
+    }
+  while (a);
+  return m + j + k + l;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
index 234041d5c35..38245ffc370 100644
--- a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
@@ -4,37 +4,63 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@ v4si_t crypto8d (v4si_t a)
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr88100.c b/gcc/testsuite/gcc.target/powerpc/pr88100.c
new file mode 100644
index 00000000000..4452145ce95
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr88100.c
@@ -0,0 +1,44 @@
+/* PR88100.  Verify that rs6000 gimple-folding code handles the
+   vec_splat_{su}{8,16,32} invalid data properly. */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+#include <altivec.h>
+
+vector unsigned char
+splatu1 (void)
+{
+  return vec_splat_u8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned short
+splatu2 (void)
+{
+  return vec_splat_u16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned int
+splatu3 (void)
+{
+  return vec_splat_u32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed char
+splats1 (void)
+{
+  return vec_splat_s8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed short
+splats2 (void)
+{
+  return vec_splat_s16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed int
+splats3 (void)
+{
+  return vec_splat_s32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c b/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c
new file mode 100644
index 00000000000..3ab0c71e3b2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector -fno-asynchronous-unwind-tables" } */
+
+#include <vecintrin.h>
+
+vector unsigned char test(void)
+{
+   vector unsigned char a = { 0 };
+   return __builtin_s390_vec_addc_u128 (a, a);
+}
diff --git a/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c
new file mode 100644
index 00000000000..bf9cc2824e7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c
@@ -0,0 +1,45 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector float
+foo (float *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure no alignment hints are generated.  */
+
+/* { dg-final { scan-assembler-not "vl.*,3" } } */
+/* { dg-final { scan-assembler-not "vst.*,3" } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c
new file mode 100644
index 00000000000..fe69fd8a680
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+typedef float __attribute__((aligned(8))) float_aligned;
+
+vector float
+foo (float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float_aligned *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float_aligned *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure alignment hints are generated if the source or target
+   operand is properly aligned.  */
+
+/* { dg-final { scan-assembler-times "vl\t%v\[0-9\]*,0\\(%r2\\),3" 4 } } */
+/* { dg-final { scan-assembler-times "vst\t%v\[0-9\]*,0\\(%r2\\),3" 2 } } */
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90 b/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90
new file mode 100644
index 00000000000..797edbe7d49
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90
@@ -0,0 +1,21 @@
+! { dg-do  run }
+! PR fortran/89174 - this used to segfault on execution.
+! Test case by Neil Carlson.
+module mod
+  type :: array_data
+    class(*), allocatable :: mold
+  contains
+    procedure :: push
+  end type
+contains
+  subroutine push(this, value)
+    class(array_data), intent(inout) :: this
+    class(*), intent(in) :: value
+    allocate(this%mold, mold=value) ! <== SEGFAULTS HERE
+  end subroutine
+end module
+
+use mod
+type(array_data) :: foo
+call foo%push(42)
+end
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_0.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90
new file mode 100644
index 00000000000..58715c7db40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_1.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90
new file mode 100644
index 00000000000..9549869a6be
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
diff --git a/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90 b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
new file mode 100644
index 00000000000..2cb0b183c88
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90 b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
new file mode 100644
index 00000000000..0e806f0955b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_data_1.f90 b/gcc/testsuite/gfortran.dg/coarray_data_1.f90
new file mode 100644
index 00000000000..94ab4c26cec
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_data_1.f90
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_32.f90 b/gcc/testsuite/gfortran.dg/deferred_character_32.f90
new file mode 100644
index 00000000000..3969d97ffc9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_32.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
diff --git a/gcc/testsuite/gfortran.dg/dtio_34.f90 b/gcc/testsuite/gfortran.dg/dtio_34.f90
new file mode 100644
index 00000000000..7cecc8b9141
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dtio_34.f90
@@ -0,0 +1,32 @@
+! { dg-do run }
+! PR84387 Defined output does not work for a derived type that
+! has no components 
+module m
+   type :: t
+      private
+      !integer :: m_i = 0  !<-- ***
+   contains
+      private
+      procedure, pass(this) :: write_t
+      generic, public :: write(formatted) => write_t
+   end type
+contains
+   subroutine write_t(this, lun, iotype, vlist, istat, imsg)
+      ! argument definitions
+      class(t), intent(in)            :: this
+      integer, intent(in)             :: lun
+      character(len=*), intent(in)    :: iotype
+      integer, intent(in)             :: vlist(:)
+      integer, intent(out)            :: istat
+      character(len=*), intent(inout) :: imsg
+      write(lun, fmt=*, iostat=istat, iomsg=imsg) "Hello World!"
+      return
+   end subroutine write_t
+
+end module
+
+program p
+   use m, only : t
+   type(t) :: foo
+   print "(dt)", foo ! { dg-output " Hello World!" }
+end program
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
index 57c1b1f6028..f33f6c8b946 100644
--- a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
index 57c1b1f6028..f33f6c8b946 100644
--- a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_0.f b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f
new file mode 100644
index 00000000000..5beee9391c6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judicaël Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_1.f b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f
new file mode 100644
index 00000000000..f293a0054bd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
diff --git a/gcc/testsuite/gfortran.dg/pr77583.f90 b/gcc/testsuite/gfortran.dg/pr77583.f90
new file mode 100644
index 00000000000..c2ee0744297
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr77583.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88326.f90 b/gcc/testsuite/gfortran.dg/pr88326.f90
new file mode 100644
index 00000000000..3cde68369f4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88326.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+! PR fortran/88326 - ICE in gfc_conv_array_initializer
+
+program p
+  character, parameter :: x(3) = ['a','b','c']
+  character    :: y(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character(0) :: z(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character    :: u(0) = transfer('', x)
+  print *, y, z, u
+end
diff --git a/gcc/testsuite/gfortran.dg/pr89266.f90 b/gcc/testsuite/gfortran.dg/pr89266.f90
new file mode 100644
index 00000000000..f078adeb4fc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89266.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+!
+! PR fortran/89266 - ICE with TRANSFER of len=0 character array constructor
+
+program test
+  implicit none
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  character(*), parameter :: p = transfer ( n , n)
+  character(*), parameter :: q = transfer ([n], n)
+  character(6), save      :: r = transfer ([''], n)
+  character(6), save      :: s = transfer ( n , n)
+  character(6), save      :: t = transfer ([n], n)
+  integer,      parameter :: a(0) = 0
+  integer,      parameter :: b(0) = transfer (a, a)
+  integer,      save      :: c(0) = transfer (a, a)
+  if (len (o) /= 0) stop 1
+  if (len (p) /= 0) stop 2
+  if (len (q) /= 0) stop 3
+  if (r /= "") stop 4
+  if (s /= "") stop 5
+  if (t /= "") stop 6
+  if (size (b) /= 0 .or. any (b /= 0)) stop 7
+  if (size (c) /= 0 .or. any (c /= 0)) stop 8
+end program test
diff --git a/gcc/testsuite/gfortran.dg/pr89492.f90 b/gcc/testsuite/gfortran.dg/pr89492.f90
new file mode 100644
index 00000000000..00405519269
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89492.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+!
+! PR fortran/89492 - Endless compilation of an invalid TRANSFER after r269177
+! Test error recovery for invalid uses of TRANSFER
+! Test proper simplification for MOLD with size 0
+!
+! Derived from original testcase by Dominique d'Humieres
+
+program bug4a
+  implicit none
+  type bug4
+! Intentionally left empty
+  end type bug4
+  integer, parameter :: k = size(transfer('',['']))  ! k = 0
+  integer, parameter :: i = len (transfer('',['']))  ! i = 0
+  integer, parameter :: l = len (transfer('', '' ))  ! l = 0
+  integer, parameter :: m(k) = k
+  integer, parameter :: j(i) = i
+  integer, parameter :: n(l) = l
+  print *, k,i,l,m,j,n
+  print *,      transfer(1,[''])                ! { dg-error "shall not have storage size 0" }
+  print *,      transfer(1, '' )                ! No error
+  print *, size(transfer(1,['']))               ! { dg-error "shall not have storage size 0" }
+  print *, len (transfer(1, '' ))               ! No error
+  print *, size(transfer([1],[bug4()]))         ! { dg-error "shall not have storage size 0" }
+  print *, transfer(transfer([1],[bug4()]),[1]) ! { dg-error "shall not have storage size 0" }
+end program bug4a
diff --git a/gcc/testsuite/gfortran.dg/pr89664.f90 b/gcc/testsuite/gfortran.dg/pr89664.f90
new file mode 100644
index 00000000000..55578069957
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89664.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-Ofast" }
+
+subroutine s (x)
+   real :: x
+   call sub (x)
+end
+subroutine sub (x)
+   real :: x, y
+   logical :: a, b
+   real :: f1, f2, f3, f4
+   y = f1()
+   a = .false.
+   if ( f2() > f3() ) a = .true.
+   b = .false.
+   if ( f2() > f4() ) b = .true.
+   if ( a ) then
+      x = 1.0
+   else if ( b ) then
+      x = 1.0/y**2
+   else
+      x = 1.0/y - y**2
+   end if
+end
diff --git a/gcc/testsuite/gfortran.dg/public_private_module_10.f90 b/gcc/testsuite/gfortran.dg/public_private_module_10.f90
new file mode 100644
index 00000000000..1877cc23279
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/public_private_module_10.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
diff --git a/gcc/testsuite/gfortran.dg/substr_8.f90 b/gcc/testsuite/gfortran.dg/substr_8.f90
new file mode 100644
index 00000000000..a3b77873f7c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/substr_8.f90
@@ -0,0 +1,15 @@
+! { dg-do run }
+! PR fortran/71203 - used to ICE on zero-length arrays or substrings
+! Derived from original test cases by Gerhard Steinmetz
+
+program p
+  implicit none
+  character(3), parameter :: a(4) = ' '
+  character(*), parameter :: b(4) = 'abc'
+  character(*), parameter :: x(*) = a(2:2)(3:1)
+  character(*), parameter :: y(*) = a(2:1)(3:1)
+  character(*), parameter :: z(*) = b(2:1)(2:3)
+  if (size (x) /= 1 .or. len(x) /= 0) stop 1
+  if (size (y) /= 0 .or. len(y) /= 0) stop 2
+  if (size (z) /= 0 .or. len(z) /= 2) stop 3
+end
diff --git a/gcc/testsuite/gfortran.dg/substr_simplify.f90 b/gcc/testsuite/gfortran.dg/substr_simplify.f90
new file mode 100644
index 00000000000..7e1e1c24369
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/substr_simplify.f90
@@ -0,0 +1,20 @@
+! { dg-do run }
+!
+! Test fixes for substring simplications derived from
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef', y = 'efcdab'
+  character(6), save      :: t = transfer ([(s(i:i),  i=1,len(s)  )], s)
+  character(*), parameter :: u = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(6), save      :: v = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(*), parameter :: w = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  character(6), save      :: x = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+  if (len (u) /= len (s) .or. u /= s) stop 2
+  if (len (v) /= len (s) .or. v /= s) stop 3
+  if (len (w) /= len (s) .or. w /= s) stop 4
+  if (len (x) /= len (s) .or. x /= s) stop 5
+end
diff --git a/gcc/testsuite/gfortran.dg/transfer_check_5.f90 b/gcc/testsuite/gfortran.dg/transfer_check_5.f90
new file mode 100644
index 00000000000..4e416e18aac
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transfer_check_5.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! { dg-options "-Wsurprising" }
+!
+! PR fortran/89516 - ICE in gfc_calculate_transfer_sizes at gcc/fortran/check.c:5506
+! Found by Martin Liška
+
+program test
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  print *, transfer(1,'',size=0) ! No warning
+  print *, transfer(1,'',size=1) ! No warning
+  print *, transfer('',1,size=0) ! No warning
+  print *, transfer('',1,size=1) ! { dg-warning "has partly undefined result" }
+end program test
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90
new file mode 100644
index 00000000000..344b3ae1229
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-options "-O -std=legacy" }
+!
+! Test fixes for some findings while resolving PR fortran/89077
+
+program test
+  implicit none
+  integer :: i
+  character(*)  ,parameter :: s =  'abcdef'   ! Length will be 6
+  character(*)  ,parameter :: h = 6Habcdef    ! Length will be 8 (Hollerith!)
+  character(10) ,parameter :: k = 6Habcdef
+  character(10) ,parameter :: t = transfer (s, s)
+  character(10) ,save      :: u = transfer (s, s)
+  character(10) ,parameter :: v = transfer (h, h)
+  character(10) ,save      :: w = transfer (h, h)
+  character(10) ,parameter :: x = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  character(10) ,save      :: y = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  if (len (h) /= 8) stop 1
+  if (h /= s) stop 2
+  if (k /= s) stop 3
+  if (t /= s) stop 4
+  if (u /= s) stop 5
+  if (v /= s) stop 6
+  if (w /= s) stop 7
+  if (x /= "fedcba") stop 8
+  if (y /= x) stop 9
+end program test
diff --git a/gcc/testsuite/gfortran.dg/warn_conversion_11.f90 b/gcc/testsuite/gfortran.dg/warn_conversion_11.f90
new file mode 100644
index 00000000000..3393e07d31e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/warn_conversion_11.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-Wconversion" }
+! PR 86119 - this used to warn.
+program proglen
+
+implicit none
+
+   class(*), allocatable :: s
+   integer :: l2
+
+   allocate(s, source = '123  ')
+
+   select type(s)
+   type is (character(len=*))
+      l2 = len(s)
+   end select
+
+end program proglen
diff --git a/gcc/testsuite/gnat.dg/opt77.adb b/gcc/testsuite/gnat.dg/opt77.adb
new file mode 100644
index 00000000000..4d0288abfaf
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt77.adb
@@ -0,0 +1,14 @@
+-- { dg-do run }
+-- { dg-options "-O -fno-inline" }
+
+with Opt77_Pkg; use Opt77_Pkg;
+
+procedure Opt77 is
+  N : Natural := 0;
+  To_Add : Boolean;
+begin
+  Proc ("One", N, To_Add);
+  if To_Add then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt77_pkg.adb b/gcc/testsuite/gnat.dg/opt77_pkg.adb
new file mode 100644
index 00000000000..b3c1e4b81d8
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt77_pkg.adb
@@ -0,0 +1,28 @@
+package body Opt77_Pkg is
+
+  function Compare (S : String) return Boolean is
+  begin
+    return S = "Two";
+  end;
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean) is
+    To_Take : Boolean := False;
+    To_Read : Boolean := False;
+  begin
+    To_Add := False;
+
+    if S = "One" then
+      To_Read := True;
+      To_Take := Compare (S);
+    end if;
+
+    if To_Read and not To_Take then
+      N := N + 1;
+    end if;
+
+    if To_Take then
+      To_Add := True;
+    end if;
+  end;
+
+end Opt77_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt77_pkg.ads b/gcc/testsuite/gnat.dg/opt77_pkg.ads
new file mode 100644
index 00000000000..ce3985a1363
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt77_pkg.ads
@@ -0,0 +1,5 @@
+package Opt77_Pkg is
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean);
+
+end Opt77_Pkg;
diff --git a/gcc/tree-cfgcleanup.c b/gcc/tree-cfgcleanup.c
index c261e71d43b..6d57329d4eb 100644
--- a/gcc/tree-cfgcleanup.c
+++ b/gcc/tree-cfgcleanup.c
@@ -43,6 +43,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple-match.h"
 #include "gimple-fold.h"
 #include "tree-ssa-loop-niter.h"
+#include "tree-into-ssa.h"
+#include "tree-cfgcleanup.h"
 
 
 /* The set of blocks in that at least one of the following changes happened:
@@ -761,7 +763,7 @@ cleanup_control_flow_pre ()
 /* Iterate the cfg cleanups, while anything changes.  */
 
 static bool
-cleanup_tree_cfg_1 (void)
+cleanup_tree_cfg_1 (unsigned ssa_update_flags)
 {
   bool retval = false;
   basic_block bb;
@@ -786,6 +788,8 @@ cleanup_tree_cfg_1 (void)
 
   /* After doing the above SSA form should be valid (or an update SSA
      should be required).  */
+  if (ssa_update_flags)
+    update_ssa (ssa_update_flags);
 
   /* Continue by iterating over all basic blocks looking for BB merging
      opportunities.  */
@@ -828,7 +832,7 @@ mfb_keep_latches (edge e)
    Return true if the flowgraph was modified, false otherwise.  */
 
 static bool
-cleanup_tree_cfg_noloop (void)
+cleanup_tree_cfg_noloop (unsigned ssa_update_flags)
 {
   bool changed;
 
@@ -908,7 +912,7 @@ cleanup_tree_cfg_noloop (void)
 	  }
     }
 
-  changed |= cleanup_tree_cfg_1 ();
+  changed |= cleanup_tree_cfg_1 (ssa_update_flags);
 
   gcc_assert (dom_info_available_p (CDI_DOMINATORS));
 
@@ -966,9 +970,9 @@ repair_loop_structures (void)
 /* Cleanup cfg and repair loop structures.  */
 
 bool
-cleanup_tree_cfg (void)
+cleanup_tree_cfg (unsigned ssa_update_flags)
 {
-  bool changed = cleanup_tree_cfg_noloop ();
+  bool changed = cleanup_tree_cfg_noloop (ssa_update_flags);
 
   if (current_loops != NULL
       && loops_state_satisfies_p (LOOPS_NEED_FIXUP))
diff --git a/gcc/tree-cfgcleanup.h b/gcc/tree-cfgcleanup.h
index 0b33d875365..7b6dbc1ee79 100644
--- a/gcc/tree-cfgcleanup.h
+++ b/gcc/tree-cfgcleanup.h
@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 
 /* In tree-cfgcleanup.c  */
 extern bitmap cfgcleanup_altered_bbs;
-extern bool cleanup_tree_cfg (void);
+extern bool cleanup_tree_cfg (unsigned = 0);
 extern bool fixup_noreturn_call (gimple *stmt);
 
 #endif /* GCC_TREE_CFGCLEANUP_H */
diff --git a/gcc/tree-scalar-evolution.c b/gcc/tree-scalar-evolution.c
index fefc9de96af..c955352018a 100644
--- a/gcc/tree-scalar-evolution.c
+++ b/gcc/tree-scalar-evolution.c
@@ -1421,6 +1421,11 @@ simplify_peeled_chrec (struct loop *loop, tree arg, tree init_cond)
       return build_polynomial_chrec (loop->num, init_cond, right);
     }
 
+  /* The affine code only deals with pointer and integer types.  */
+  if (!POINTER_TYPE_P (type)
+      && !INTEGRAL_TYPE_P (type))
+    return chrec_dont_know;
+
   /* Try harder to check if they are equal.  */
   tree_to_aff_combination_expand (left, type, &aff1, &peeled_chrec_map);
   tree_to_aff_combination_expand (step_val, type, &aff2, &peeled_chrec_map);
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index f60e96cdfbe..0ebcc6d43c7 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -170,11 +170,10 @@ edge_info::derive_equivalences (tree name, tree value, int recursion_limit)
   gimple *def_stmt = SSA_NAME_DEF_STMT (name);
   if (is_gimple_assign (def_stmt))
     {
-      /* We know the result of DEF_STMT was zero.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
       enum tree_code code = gimple_assign_rhs_code (def_stmt);
       switch (code)
 	{
+	/* If the result of an OR is zero, then its operands are, too.  */
 	case BIT_IOR_EXPR:
 	  if (integer_zerop (value))
 	    {
@@ -188,8 +187,7 @@ edge_info::derive_equivalences (tree name, tree value, int recursion_limit)
 	    }
 	  break;
 
-      /* We know the result of DEF_STMT was one.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
+	/* If the result of an AND is nonzero, then its operands are, too.  */
 	case BIT_AND_EXPR:
 	  if (!integer_zerop (value))
 	    {
@@ -296,7 +294,6 @@ edge_info::derive_equivalences (tree name, tree value, int recursion_limit)
 	    break;
 	  }
 
-
 	case EQ_EXPR:
 	case NE_EXPR:
 	  {
@@ -336,7 +333,28 @@ edge_info::derive_equivalences (tree name, tree value, int recursion_limit)
 	case NEGATE_EXPR:
 	  {
 	    tree rhs = gimple_assign_rhs1 (def_stmt);
-	    tree res = fold_build1 (code, TREE_TYPE (rhs), value);
+	    tree res;
+	    /* If this is a NOT and the operand has a boolean range, then we
+	       know its value must be zero or one.  We are not supposed to
+	       have a BIT_NOT_EXPR for boolean types with precision > 1 in
+	       the general case, see e.g. the handling of TRUTH_NOT_EXPR in
+	       the gimplifier, but it can be generated by match.pd out of
+	       a BIT_XOR_EXPR wrapped in a BIT_AND_EXPR.  Now the handling
+	       of BIT_AND_EXPR above already forces a specific semantics for
+	       boolean types with precision > 1 so we must do the same here,
+	       otherwise we could change the semantics of TRUTH_NOT_EXPR for
+	       boolean types with precision > 1.  */
+	    if (code == BIT_NOT_EXPR
+		&& TREE_CODE (rhs) == SSA_NAME
+		&& ssa_name_has_boolean_range (rhs))
+	      {
+		if ((TREE_INT_CST_LOW (value) & 1) == 0)
+		  res = build_one_cst (TREE_TYPE (rhs));
+		else
+		  res = build_zero_cst (TREE_TYPE (rhs));
+	      }
+	    else
+	      res = fold_build1 (code, TREE_TYPE (rhs), value);
 	    derive_equivalences (rhs, res, recursion_limit - 1);
 	    break;
 	  }
diff --git a/gcc/tree-ssa-loop-ch.c b/gcc/tree-ssa-loop-ch.c
index 488999dd8ce..92e0c435e98 100644
--- a/gcc/tree-ssa-loop-ch.c
+++ b/gcc/tree-ssa-loop-ch.c
@@ -376,11 +376,23 @@ ch_base::copy_headers (function *fun)
 		{
 		  gimple *stmt = gsi_stmt (bsi);
 		  if (gimple_code (stmt) == GIMPLE_COND)
-		    gimple_set_no_warning (stmt, true);
+		    {
+		      tree lhs = gimple_cond_lhs (stmt);
+		      if (gimple_cond_code (stmt) != EQ_EXPR
+			  && gimple_cond_code (stmt) != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))
+			gimple_set_no_warning (stmt, true);
+		    }
 		  else if (is_gimple_assign (stmt))
 		    {
 		      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);
-		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)
+		      tree rhs1 = gimple_assign_rhs1 (stmt);
+		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison
+			  && rhs_code != EQ_EXPR
+			  && rhs_code != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (rhs1)))
 			gimple_set_no_warning (stmt, true);
 		    }
 		}
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index 8463979b4c8..a8f275bb78f 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -603,7 +603,7 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)
 
   /* If it is more profitable to optimize 1 / x, don't optimize 1 / (x * x).  */
   if (sqrt_recip_count > square_recip_count)
-    return;
+    goto out;
 
   /* Do the expensive part only if we can hope to optimize something.  */
   if (count + square_recip_count >= threshold && count >= 1)
@@ -646,6 +646,7 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)
 	}
     }
 
+out:
   for (occ = occ_head; occ; )
     occ = free_bb (occ);
 
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 373946f518a..0e69629f879 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -7552,7 +7552,10 @@ compute_dependence_clique (void)
 	    }
 	  if (used)
 	    {
-	      bitmap_set_bit (rvars, restrict_var->id);
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
 	      varinfo_t escaped = get_varinfo (find (escaped_id));
 	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
 		escaped_p = true;
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index afc70cfce6c..bc1208a689b 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,22 @@
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index a84084c99f0..72fe2c0dcec 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -755,6 +755,11 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 2909548317c..c5c76614119 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,9 @@
+2019-03-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/89020
+	* io/close.c (st_close): Generate error if calls to 'remove' return
+	an error.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
index 879bdf4e082..fdf19eeeea0 100644
--- a/libgfortran/io/close.c
+++ b/libgfortran/io/close.c
@@ -90,7 +90,10 @@ st_close (st_parameter_close *clp)
 	      else
 		{
 #if HAVE_UNLINK_OPEN_FILE
-		  remove (u->filename);
+
+		  if (remove (u->filename))
+		    generate_error (&clp->common, LIBERROR_OS,
+				    "File cannot be deleted");
 #else
 		  path = strdup (u->filename);
 #endif
@@ -103,7 +106,9 @@ st_close (st_parameter_close *clp)
 #if !HAVE_UNLINK_OPEN_FILE
       if (path != NULL)
 	{
-	  remove (path);
+	  if (remove (path))
+	    generate_error (&clp->common, LIBERROR_OS,
+			    "File cannot be deleted");
 	  free (path);
 	}
 #endif
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index aac255a46f9..45bb87b3342 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,11 @@
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index 1945494d7e2..a2a883f3565 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -248,7 +248,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
new file mode 100644
index 00000000000..768ba63ddfe
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++17 }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
