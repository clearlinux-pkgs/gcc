Jakub Jelinek (7):
      Bump BASE-VER
      cprop: Fix -fcompare-debug bug in constprop_register [PR100148]
      testsuite: Add -fchecking to dg-ice tests
      vmsdbgout: Remove useless register keywords
      cfgcleanup: Fix -fcompare-debug issue in outgoing_edges_match [PR100254]
      veclower: Fix up vec_shl matching of VEC_PERM_EXPR [PR100239]
      aarch64: Fix UB in the compiler [PR100200]

Michael Meissner (1):
      Backport fix for PR target/98952

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 68d8f15e23c..668182d21a4 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.1.0
+11.1.1
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 8650fb7f264..260a896ac48 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -1885,8 +1885,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)
 
   /* Ensure the same EH region.  */
   {
-    rtx n1 = find_reg_note (BB_END (bb1), REG_EH_REGION, 0);
-    rtx n2 = find_reg_note (BB_END (bb2), REG_EH_REGION, 0);
+    rtx n1 = find_reg_note (last1, REG_EH_REGION, 0);
+    rtx n2 = find_reg_note (last2, REG_EH_REGION, 0);
 
     if (!n1 && n2)
       return false;
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 12625a4bee3..7985940ba42 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -10778,7 +10778,7 @@ aarch64_print_operand (FILE *f, rtx x, int code)
 	}
 
       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)
-	asm_fprintf (f, "%wd", -INTVAL (elt));
+	asm_fprintf (f, "%wd", -UINTVAL (elt));
       else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_FLOAT
 	       && aarch64_print_vector_float_operand (f, x, true))
 	;
@@ -21598,7 +21598,7 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
     case MINUS:
       if (CONST_INT_P (value))
 	{
-	  value = GEN_INT (-INTVAL (value));
+	  value = GEN_INT (-UINTVAL (value));
 	  code = PLUS;
 	}
       /* Fall through.  */
@@ -23514,7 +23514,7 @@ aarch64_expand_subvti (rtx op0, rtx low_dest, rtx low_in1,
     {
       if (aarch64_plus_immediate (low_in2, DImode))
 	emit_insn (gen_subdi3_compare1_imm (low_dest, low_in1, low_in2,
-					    GEN_INT (-INTVAL (low_in2))));
+					    GEN_INT (-UINTVAL (low_in2))));
       else
 	{
 	  low_in2 = force_reg (DImode, low_in2);
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index abfd8452674..aef6da9732d 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -747,7 +747,8 @@
 	   constant can be represented in SImode, this is important
 	   for the corner case where operand[1] is INT_MIN.  */
 
-	operands[1] = GEN_INT (trunc_int_for_mode (-INTVAL (operands[1]), SImode));
+	operands[1]
+	  = GEN_INT (trunc_int_for_mode (-UINTVAL (operands[1]), SImode));
 
 	if (!(*insn_data[CODE_FOR_addsi3].operand[2].predicate)
 	      (operands[1], SImode))
@@ -5008,7 +5009,7 @@
     /* (SZ - cnt) % SZ == -cnt % SZ */
     if (CONST_INT_P (operands[2]))
       {
-        operands[2] = GEN_INT ((-INTVAL (operands[2]))
+        operands[2] = GEN_INT ((-UINTVAL (operands[2]))
 			       & (GET_MODE_BITSIZE (<MODE>mode) - 1));
         if (operands[2] == const0_rtx)
           {
diff --git a/gcc/config/aarch64/predicates.md b/gcc/config/aarch64/predicates.md
index c55842b9c74..49f02ae0381 100644
--- a/gcc/config/aarch64/predicates.md
+++ b/gcc/config/aarch64/predicates.md
@@ -121,12 +121,12 @@
 
 (define_predicate "aarch64_sub_immediate"
   (and (match_code "const_int")
-       (match_test "aarch64_uimm12_shift (-INTVAL (op))")))
+       (match_test "aarch64_uimm12_shift (-UINTVAL (op))")))
 
 (define_predicate "aarch64_plus_immediate"
   (and (match_code "const_int")
        (ior (match_test "aarch64_uimm12_shift (INTVAL (op))")
-	    (match_test "aarch64_uimm12_shift (-INTVAL (op))"))))
+	    (match_test "aarch64_uimm12_shift (-UINTVAL (op))"))))
 
 (define_predicate "aarch64_plus_operand"
   (ior (match_operand 0 "register_operand")
diff --git a/gcc/cprop.c b/gcc/cprop.c
index 73034ce72d0..6f34f6b2418 100644
--- a/gcc/cprop.c
+++ b/gcc/cprop.c
@@ -1007,16 +1007,18 @@ static int
 constprop_register (rtx from, rtx src, rtx_insn *insn)
 {
   rtx sset;
+  rtx_insn *next_insn;
 
   /* Check for reg or cc0 setting instructions followed by
      conditional branch instructions first.  */
   if ((sset = single_set (insn)) != NULL
-      && NEXT_INSN (insn)
-      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))
+      && (next_insn = next_nondebug_insn (insn)) != NULL
+      && any_condjump_p (next_insn)
+      && onlyjump_p (next_insn))
     {
       rtx dest = SET_DEST (sset);
       if ((REG_P (dest) || CC0_P (dest))
-	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn),
+	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, next_insn,
 			 from, src))
 	return 1;
     }
diff --git a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
index d770b91dd09..8c3884bdc00 100644
--- a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
+++ b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
@@ -1,7 +1,7 @@
 /* Test OpenACC 'kernels' construct decomposition.  */
 
 /* { dg-additional-options "-fopt-info-omp-all" } */
-/* { dg-additional-options "--param=openacc-kernels=decompose" } */
+/* { dg-additional-options "-fchecking --param=openacc-kernels=decompose" } */
 /* { dg-ice "TODO" }
    { dg-prune-output "during GIMPLE pass: omplower" } */
 
diff --git a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
index ae059eb354b..8bf60a9a509 100644
--- a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
+++ b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
@@ -1,6 +1,6 @@
 /* Test OpenACC 'kernels' construct decomposition.  */
 
-/* { dg-additional-options "--param=openacc-kernels=decompose" } */
+/* { dg-additional-options "-fchecking --param=openacc-kernels=decompose" } */
 /* { dg-ice "TODO" }
    { dg-prune-output "during GIMPLE pass: omplower" } */
 
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
index 2c9d2f9b329..eae0d8c377b 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
@@ -1,5 +1,6 @@
 // PR c++/52830
 // { dg-do compile { target c++11 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "comptypes" }
 
 template<bool b> struct eif { typedef void type; };
diff --git a/gcc/testsuite/g++.dg/cpp0x/vt-88982.C b/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
index cb9530dcee1..7a868233d73 100644
--- a/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
+++ b/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
@@ -1,5 +1,6 @@
 // PR c++/88982
 // { dg-do compile { target c++11 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "tsubst_pack_expansion" }
 
 template<typename...Ts> struct A {
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
index c24c3b85d78..bed5ea0cfc0 100644
--- a/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
@@ -1,5 +1,6 @@
 // PR c++/88003
 // { dg-do compile { target c++14 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "poplevel_class" }
 
 auto test() {
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
index d6c8bae525f..0cdb400d21c 100644
--- a/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
@@ -1,5 +1,6 @@
 // PR c++/87765
 // { dg-do compile { target c++17 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "cxx_eval_constant_expression" }
 
 template <int N>
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
index f5f79a71ec2..512afad8e4f 100644
--- a/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
@@ -1,5 +1,6 @@
 // PR c++/89565
 // { dg-do compile { target c++20 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "resolve_args" }
 
 template <auto>
diff --git a/gcc/testsuite/g++.dg/opt/pr100148.C b/gcc/testsuite/g++.dg/opt/pr100148.C
new file mode 100644
index 00000000000..d038879b6b8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100148.C
@@ -0,0 +1,27 @@
+// PR rtl-optimization/100148
+// { dg-do compile }
+// { dg-options "-O2 -fno-dce -fno-tree-dce -fno-tree-dominator-opts -fno-tree-sink -fcompare-debug" }
+
+int i;
+enum E { } e, ee;
+
+bool
+baz (int)
+{
+  return ee;
+}
+
+bool bar ();
+bool a, b;
+
+void
+foo ()
+{
+  switch (ee)
+    {
+    case 0:
+      e = E (a ? : i);
+    case 1:
+      !(b || baz (0) && bar ());
+    }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100254.C b/gcc/testsuite/g++.dg/opt/pr100254.C
new file mode 100644
index 00000000000..dbdac1638c7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100254.C
@@ -0,0 +1,101 @@
+// PR rtl-optimization/100254
+// { dg-do compile }
+// { dg-options "-O2 -fno-guess-branch-probability -fipa-pta -fnon-call-exceptions -fcompare-debug" }
+// { dg-additional-options "-mtune=goldmont" { target i?86-*-* x86_64-*-* } }
+
+struct _Rb_tree_node_base {
+  typedef _Rb_tree_node_base *_Base_ptr;
+  typedef _Rb_tree_node_base *_Const_Base_ptr;
+  _Base_ptr _M_left;
+};
+template <typename _Key_compare> struct _Rb_tree_key_compare {
+  _Key_compare _M_key_compare;
+};
+struct _Rb_tree_header {
+  _Rb_tree_node_base _M_header;
+};
+struct _Rb_tree_iterator {
+  _Rb_tree_iterator(_Rb_tree_node_base::_Base_ptr);
+  friend bool operator==(_Rb_tree_iterator, _Rb_tree_iterator);
+};
+template <typename _Tp> struct _Rb_tree_const_iterator {
+  typedef _Rb_tree_const_iterator _Self;
+  _Rb_tree_const_iterator(_Rb_tree_node_base::_Const_Base_ptr) {}
+  _Tp operator*();
+  template <typename _Up>
+  friend bool operator!=(_Rb_tree_const_iterator<_Up>, _Rb_tree_const_iterator<_Up>);
+};
+template <typename _Key, typename _Val, typename _Compare> struct _Rb_tree {
+  template <typename _Key_compare>
+  struct _Rb_tree_impl : _Rb_tree_key_compare<_Key_compare>, _Rb_tree_header {};
+  _Rb_tree_impl<_Compare> _M_impl;
+  _Key _S_key();
+  typedef _Rb_tree_const_iterator<_Val> const_iterator;
+  const_iterator begin() { return _M_impl._M_header._M_left; }
+  _Rb_tree_iterator find(const _Key &);
+};
+template <typename _Key, typename _Val, typename _Compare>
+_Rb_tree_iterator _Rb_tree<_Key, _Val, _Compare>::find(const _Key &__k) {
+  _Rb_tree_iterator __j = 0;
+  return __j == 0 || _M_impl._M_key_compare(__k, _S_key()) ? 0 : __j;
+}
+template <typename _Key, typename _Compare = _Key> struct set {
+  typedef _Key key_type;
+  typedef _Rb_tree<key_type, _Key, _Compare> _Rep_type;
+  _Rep_type _M_t;
+  typedef typename _Rep_type::const_iterator iterator;
+  iterator begin() { return _M_t.begin(); }
+  iterator end();
+  void find(key_type __x) { _M_t.find(__x); }
+};
+struct WindowDesc {
+  WindowDesc(short);
+} _station_view_desc(0);
+struct Window {
+  void IsWidgetLowered();
+  virtual void OnClick(int, int, int);
+};
+int AllocateWindowDescFront_window_number;
+template <typename Wcls> void AllocateWindowDescFront(WindowDesc *desc, bool) {
+  Wcls(desc, AllocateWindowDescFront_window_number);
+}
+class CargoDataEntry;
+struct CargoSorter {
+  bool operator()(const CargoDataEntry *, const CargoDataEntry *) const;
+};
+struct CargoDataEntry {
+  ~CargoDataEntry();
+  char Retrieve_cargo;
+  void Retrieve() {
+    CargoDataEntry t(Retrieve_cargo);
+    children->find(&t);
+  }
+  CargoDataEntry(char);
+  set<CargoDataEntry *, CargoSorter> *children;
+};
+CargoDataEntry::CargoDataEntry(char) : children() {}
+CargoDataEntry::~CargoDataEntry() {
+  if (children)
+    for (set<CargoDataEntry *>::iterator i = children->begin();
+         i != children->end();)
+      delete *i;
+}
+bool CargoSorter::operator()(const CargoDataEntry *,
+                             const CargoDataEntry *) const { return false; }
+struct StationViewWindow : Window {
+  StationViewWindow(WindowDesc *, int);
+  CargoDataEntry HandleCargoWaitingClick_filter;
+  void OnClick(int, int widget, int) {
+    switch (widget) {
+    case 0:
+      HandleCargoWaitingClick_filter.Retrieve();
+      HandleCargoWaitingClick_filter.Retrieve();
+    case 1:
+      IsWidgetLowered();
+    }
+  }
+};
+void ShowStationViewWindow_station() {
+  AllocateWindowDescFront<StationViewWindow>(&_station_view_desc,
+                                             ShowStationViewWindow_station);
+}
diff --git a/gcc/testsuite/gcc.dg/pr100239.c b/gcc/testsuite/gcc.dg/pr100239.c
new file mode 100644
index 00000000000..1ade810c52b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100239.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/100239 */
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+typedef short __attribute__((__vector_size__ (8 * sizeof (short)))) V;
+V v, w;
+
+void
+foo (void)
+{
+  w = __builtin_shuffle (v != v, 0 < (V) {}, (V) {192} >> 5);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr98952.c b/gcc/testsuite/gcc.target/powerpc/pr98952.c
new file mode 100644
index 00000000000..c487fbc403e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr98952.c
@@ -0,0 +1,28 @@
+/* { dg-do run { target { powerpc*-*-linux* && ilp32 } } } */
+/* { dg-options "-O2" } */
+
+/* PR 96983 reported that the test in libgcc's tramp.S was backwards and it
+   would abort if the trampoline size passed to the function was greater than
+   the size the runtime was expecting (40).  It should abort if the size is less
+   than 40, not greater than 40.  This test creates a call to __trampoline_setup
+   with a much larger buffer to make sure the function does not abort.
+
+   We do not run this test on 64-bit since __trampoline_setup is not present in
+   64-bit systems.
+
+   We only run the test under Linux in case the other systems have some
+   different variant for __trampoline_setup.  */
+
+#ifndef SIZE
+#define SIZE 100
+#endif
+
+extern void __trampoline_setup (int *, unsigned, void *, void *);
+
+int main (void)
+{
+  int tramp[SIZE / sizeof (int)];
+
+  __trampoline_setup (tramp, SIZE, 0, 0);
+  return 0;
+}
diff --git a/gcc/tree-vect-generic.c b/gcc/tree-vect-generic.c
index c8d8493e6ea..3348545d18b 100644
--- a/gcc/tree-vect-generic.c
+++ b/gcc/tree-vect-generic.c
@@ -1515,7 +1515,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)
 					      elements + i - first)
 		     : maybe_ge (poly_uint64 (indices[i]), elements))
 	      break;
-	  if (i == elements)
+	  if (first && i == elements)
 	    {
 	      gimple_assign_set_rhs3 (stmt, mask);
 	      update_stmt (stmt);
diff --git a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
index a7640004b87..c226bc69c85 100644
--- a/gcc/vmsdbgout.c
+++ b/gcc/vmsdbgout.c
@@ -365,13 +365,13 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];
 #define ASM_OUTPUT_DEBUG_STRING(FILE,P)		\
   do						\
     {						\
-      register int slen = strlen (P);		\
-      register const char *p = (P);		\
-      register int i;				\
+      int slen = strlen (P);			\
+      const char *p = (P);			\
+      int i;					\
       fprintf (FILE, "\t.ascii \"");		\
       for (i = 0; i < slen; i++)		\
 	{					\
-	  register int c = p[i];		\
+	  int c = p[i];				\
 	  if (c == '\"' || c == '\\')		\
 	    putc ('\\', FILE);			\
 	  if (c >= ' ' && c < 0177)		\
@@ -1229,7 +1229,7 @@ vmsdbgout_end_epilogue (unsigned int line, const char *file)
    a lexical block.  */
 
 static void
-vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_begin_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.begin_block) (line, blocknum);
@@ -1242,7 +1242,7 @@ vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
    lexical block.  */
 
 static void
-vmsdbgout_end_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_end_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.end_block) (line, blocknum);
@@ -1315,8 +1315,8 @@ static unsigned int
 lookup_filename (const char *file_name)
 {
   static unsigned int last_file_lookup_index = 0;
-  register char *fn;
-  register unsigned i;
+  char *fn;
+  unsigned i;
   const char *fnam;
   long long cdt = 0;
   long ebk = 0;
@@ -1405,8 +1405,8 @@ vmsdbgout_write_source_line (unsigned line, const char *filename,
 }
 
 static void
-vmsdbgout_source_line (register unsigned line, unsigned int column,
-		       register const char *filename,
+vmsdbgout_source_line (unsigned line, unsigned int column,
+		       const char *filename,
                        int discriminator, bool is_stmt)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
diff --git a/libgcc/config/rs6000/tramp.S b/libgcc/config/rs6000/tramp.S
index 4236a82b402..68baf16de9f 100644
--- a/libgcc/config/rs6000/tramp.S
+++ b/libgcc/config/rs6000/tramp.S
@@ -64,8 +64,7 @@ FUNC_START(__trampoline_setup)
         mflr	r11
         addi	r7,r11,trampoline_initial-4-.LCF0 /* trampoline address -4 */
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,2		/* # words to move */
 	addi	r9,r3,-4	/* adjust pointer for lwzu */
 	mtctr	r4
@@ -156,8 +155,7 @@ FUNC_START(__trampoline_setup)
 	ld 7,.LC0@toc@l(7)	/* trampoline address -8 */
 #endif
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,3		/* # doublewords to move */
 	addi	r9,r3,-8	/* adjust pointer for stdu */
 	mtctr	r4
