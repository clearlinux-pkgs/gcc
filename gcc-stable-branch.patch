GCC Administrator (1):
      Daily bump.

Harald Anlauf (3):
      Fortran: reject FORMAT tag of unknown type.
      Fortran: ICE, OOM while calculating sizes of derived type array components
      Fortran: extend check for array arguments and reject CLASS array elements.

Iain Buclaw (5):
      d: Change in DotTemplateExp type semantics leading to regression (PR101619)
      d: Compile-time reflection for supported built-ins (PR101127)
      d: __FUNCTION__ doesn't work in core.stdc.stdio functions without cast (PR101441)
      d: fix ICE at convert_expr(tree_node*, Type*, Type*) (PR101490)
      d: Wrong evaluation order of binary expressions (PR101640)

Jakub Jelinek (2):
      expmed: Fix store_integral_bit_field [PR101562]
      gimple-fold: Fix up __builtin_clear_padding on classes with virtual inheritence [PR101586]

Martin Uecker (1):
      Correct a mistake in a warnung for -Wnonnull.

Richard Biener (1):
      Update BASE-VER to 11.2.1

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index b85c6c7b035..dc170a12af1 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.2.0
+11.2.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 00a21af58a8..cb1b0d28a7c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,27 @@
+2021-07-28  Martin Uecker  <muecker@gwdg.de>
+
+	* calls.c (maybe_warn_rdwr_sizes): Correct argument
+	numbers in warning that were switched.
+
+2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101586
+	* gimple-fold.c (clear_padding_type): Ignore FIELD_DECLs with byte
+	positions above or equal to sz except for diagnostics of flexible
+	array members.
+
+2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/101562
+	* expmed.c (store_integral_bit_field): Only use movstrict_optab
+	if the operand isn't paradoxical.
+
 2021-07-28  Release Manager
 
 	* GCC 11.2.0 released.
diff --git a/gcc/calls.c b/gcc/calls.c
index 883d08ba5f2..870b9ac7776 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -2126,8 +2126,8 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)
 					   "array %s is null but "
 					   "the corresponding bound argument "
 					   "%i value is %s",
-					   exp, sizidx + 1, argtypestr.c_str (),
-					   ptridx + 1, sizstr);
+					   exp, ptridx + 1, argtypestr.c_str (),
+					   sizidx + 1, sizstr);
 		}
 	      else
 		arg_warned = warning_at (loc, OPT_Wnonnull,
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index b22bff42f52..27334e65749 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,51 @@
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* expr.cc (binary_op): Use build2 instead of fold_build2.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* d-codegen.cc (build_array_index): Handle void arrays same as byte.
+	* d-convert.cc (convert_expr): Handle converting to zero-sized arrays.
+	* dmd/dcast.c (castTo): Handle casting to zero-sized arrays.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* dmd/expression.c (FuncInitExp::resolveLoc): Set type as `string'.
+	(PrettyFuncInitExp::resolveLoc): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* d-builtins.cc (d_builtin_function_ext_scope): New function.
+	* d-lang.cc (LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE): Define.
+	* d-tree.h (d_builtin_function_ext_scope): Declare.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101619
+	* dmd/expression.c (DotTemplateExp::checkType): New function.
+	(DotTemplateExp::checkValue): New function.
+	* dmd/expression.h (class DotTemplateExp): Declare checkType and
+	checkValue.
+
 2021-07-28  Release Manager
 
 	* GCC 11.2.0 released.
diff --git a/gcc/d/d-builtins.cc b/gcc/d/d-builtins.cc
index 400bce0a141..6d294697223 100644
--- a/gcc/d/d-builtins.cc
+++ b/gcc/d/d-builtins.cc
@@ -1205,5 +1205,20 @@ d_builtin_function (tree decl)
   return decl;
 }
 
+/* Same as d_builtin_function, but used to delay putting in back-end builtin
+   functions until the ISA that defines the builtin has been declared.
+   However in D, there is no global namespace.  All builtins get pushed into the
+   `gcc.builtins' module, which is constructed during the semantic analysis
+   pass, which has already finished by the time target attributes are evaluated.
+   So builtins are not pushed because they would be ultimately ignored.
+   The purpose of having this function then is to improve compile-time
+   reflection support to allow user-code to determine whether a given back end
+   function is enabled by the ISA.  */
+
+tree
+d_builtin_function_ext_scope (tree decl)
+{
+  return decl;
+}
 
 #include "gt-d-d-builtins.h"
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index ce7c17baaaf..f35de90b54c 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -1639,21 +1639,9 @@ build_array_index (tree ptr, tree index)
   /* Array element size.  */
   tree size_exp = size_in_bytes (target_type);
 
-  if (integer_zerop (size_exp))
+  if (integer_zerop (size_exp) || integer_onep (size_exp))
     {
-      /* Test for array of void.  */
-      if (TYPE_MODE (target_type) == TYPE_MODE (void_type_node))
-	index = fold_convert (type, index);
-      else
-	{
-	  /* Should catch this earlier.  */
-	  error ("invalid use of incomplete type %qD", TYPE_NAME (target_type));
-	  ptr_type = error_mark_node;
-	}
-    }
-  else if (integer_onep (size_exp))
-    {
-      /* Array of bytes -- No need to multiply.  */
+      /* Array of void or bytes -- No need to multiply.  */
       index = fold_convert (type, index);
     }
   else
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index 3073edaae9f..237c084acf5 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -473,13 +473,18 @@ convert_expr (tree exp, Type *etype, Type *totype)
 
 	  tree ptrtype = build_ctype (tbtype->nextOf ()->pointerTo ());
 
-	  if ((dim * esize) % tsize != 0)
+	  if (esize != tsize)
 	    {
-	      error ("cannot cast %qs to %qs since sizes do not line up",
-		     etype->toChars (), totype->toChars ());
-	      return error_mark_node;
+	      /* Array element sizes do not match, so we must adjust the
+		 dimensions.  */
+	      if (tsize == 0 || (dim * esize) % tsize != 0)
+		{
+		  error ("cannot cast %qs to %qs since sizes do not line up",
+			 etype->toChars (), totype->toChars ());
+		  return error_mark_node;
+		}
+	      dim = (dim * esize) / tsize;
 	    }
-	  dim = (dim * esize) / tsize;
 
 	  /* Assumes casting to dynamic array of same type or void.  */
 	  return d_array_value (build_ctype (totype), size_int (dim),
diff --git a/gcc/d/d-lang.cc b/gcc/d/d-lang.cc
index a65af290cb8..6ad3823d910 100644
--- a/gcc/d/d-lang.cc
+++ b/gcc/d/d-lang.cc
@@ -1745,6 +1745,7 @@ d_enum_underlying_base_type (const_tree type)
 #undef LANG_HOOKS_GET_ALIAS_SET
 #undef LANG_HOOKS_TYPES_COMPATIBLE_P
 #undef LANG_HOOKS_BUILTIN_FUNCTION
+#undef LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE
 #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE
 #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL
 #undef LANG_HOOKS_GIMPLIFY_EXPR
@@ -1776,6 +1777,7 @@ d_enum_underlying_base_type (const_tree type)
 #define LANG_HOOKS_GET_ALIAS_SET	    d_get_alias_set
 #define LANG_HOOKS_TYPES_COMPATIBLE_P	    d_types_compatible_p
 #define LANG_HOOKS_BUILTIN_FUNCTION	    d_builtin_function
+#define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE d_builtin_function_ext_scope
 #define LANG_HOOKS_REGISTER_BUILTIN_TYPE    d_register_builtin_type
 #define LANG_HOOKS_FINISH_INCOMPLETE_DECL   d_finish_incomplete_decl
 #define LANG_HOOKS_GIMPLIFY_EXPR	    d_gimplify_expr
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index 6ef9af2a991..b03d60a5c0e 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -502,6 +502,7 @@ extern const attribute_spec d_langhook_common_attribute_table[];
 extern Type *build_frontend_type (tree);
 
 extern tree d_builtin_function (tree);
+extern tree d_builtin_function_ext_scope (tree);
 extern void d_init_builtins (void);
 extern void d_register_builtin_type (tree, const char *);
 extern void d_build_builtins_module (Module *);
diff --git a/gcc/d/dmd/dcast.c b/gcc/d/dmd/dcast.c
index 4dd648bcc48..d84ab7ffc21 100644
--- a/gcc/d/dmd/dcast.c
+++ b/gcc/d/dmd/dcast.c
@@ -1496,13 +1496,16 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)
                     // cast(U[])sa; // ==> cast(U[])sa[];
                     d_uns64 fsize = t1b->nextOf()->size();
                     d_uns64 tsize = tob->nextOf()->size();
-                    if ((((TypeSArray *)t1b)->dim->toInteger() * fsize) % tsize != 0)
+                    if (fsize != tsize)
                     {
-                        // copied from sarray_toDarray() in e2ir.c
-                        e->error("cannot cast expression %s of type %s to %s since sizes don't line up",
-                            e->toChars(), e->type->toChars(), t->toChars());
-                        result = new ErrorExp();
-                        return;
+                        dinteger_t dim = ((TypeSArray *)t1b)->dim->toInteger();
+                        if (tsize == 0 || (dim * fsize) % tsize != 0)
+                        {
+                            e->error("cannot cast expression `%s` of type `%s` to `%s` since sizes don't line up",
+                                     e->toChars(), e->type->toChars(), t->toChars());
+                            result = new ErrorExp();
+                            return;
+                        }
                     }
                     goto Lok;
                 }
diff --git a/gcc/d/dmd/expression.c b/gcc/d/dmd/expression.c
index 153819aa172..18aa6aa9ab4 100644
--- a/gcc/d/dmd/expression.c
+++ b/gcc/d/dmd/expression.c
@@ -4200,6 +4200,18 @@ DotTemplateExp::DotTemplateExp(Loc loc, Expression *e, TemplateDeclaration *td)
     this->td = td;
 }
 
+bool DotTemplateExp::checkType()
+{
+    error("%s %s has no type", td->kind(), toChars());
+    return true;
+}
+
+bool DotTemplateExp::checkValue()
+{
+    error("%s %s has no value", td->kind(), toChars());
+    return true;
+}
+
 /************************************************************/
 
 DotVarExp::DotVarExp(Loc loc, Expression *e, Declaration *var, bool hasOverloads)
@@ -5608,7 +5620,7 @@ Expression *FuncInitExp::resolveLoc(Loc loc, Scope *sc)
         s = "";
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = expressionSemantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
@@ -5642,7 +5654,7 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)
 
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = expressionSemantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
diff --git a/gcc/d/dmd/expression.h b/gcc/d/dmd/expression.h
index 2ed8fac373e..9413ad9a931 100644
--- a/gcc/d/dmd/expression.h
+++ b/gcc/d/dmd/expression.h
@@ -930,6 +930,8 @@ public:
     TemplateDeclaration *td;
 
     DotTemplateExp(Loc loc, Expression *e, TemplateDeclaration *td);
+    bool checkType();
+    bool checkValue();
     void accept(Visitor *v) { v->visit(this); }
 };
 
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index e76cae98f7e..b78778eb8ef 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -157,7 +157,7 @@ binary_op (tree_code code, tree type, tree arg0, tree arg1)
 	  eptype = type;
 	}
 
-      ret = fold_build2 (code, eptype, arg0, arg1);
+      ret = build2 (code, eptype, arg0, arg1);
     }
 
   return d_convert (type, ret);
diff --git a/gcc/expmed.c b/gcc/expmed.c
index 1fb63170be9..3143f38e057 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -921,7 +921,10 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,
 	}
 
       subreg_off = bitnum / BITS_PER_UNIT;
-      if (validate_subreg (fieldmode, GET_MODE (arg0), arg0, subreg_off))
+      if (validate_subreg (fieldmode, GET_MODE (arg0), arg0, subreg_off)
+	  /* STRICT_LOW_PART must have a non-paradoxical subreg as
+	     operand.  */
+	  && !paradoxical_subreg_p (fieldmode, GET_MODE (arg0)))
 	{
 	  arg0 = gen_rtx_SUBREG (fieldmode, arg0, subreg_off);
 
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 9357857fcaf..f4c61fa5c61 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,31 @@
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101536
+	* check.c (array_check): Adjust check for the case of CLASS
+	arrays.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101514
+	* target-memory.c (gfc_interpret_derived): Size of array component
+	of derived type can only be computed here for explicit shape.
+	* trans-types.c (gfc_get_nodesc_array_type): Do not dereference
+	NULL pointers.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101084
+	* io.c (resolve_tag_format): Extend FORMAT check to unknown type.
+
 2021-07-28  Release Manager
 
 	* GCC 11.2.0 released.
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 27bf3a7eafe..851af1b30dc 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -731,12 +731,11 @@ logical_array_check (gfc_expr *array, int n)
 static bool
 array_check (gfc_expr *e, int n)
 {
-  if (e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok
+  if (e->rank != 0 && e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok
 	&& CLASS_DATA (e)->attr.dimension
 	&& CLASS_DATA (e)->as->rank)
     {
       gfc_add_class_array_ref (e);
-      return true;
     }
 
   if (e->rank != 0 && e->ts.type != BT_PROCEDURE)
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 40cd76eb585..fc97df79eca 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -1763,7 +1763,7 @@ resolve_tag_format (gfc_expr *e)
   if (e->ts.type != BT_CHARACTER)
     {
       if (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS
-	  || e->ts.type == BT_VOID)
+	  || e->ts.type == BT_VOID || e->ts.type == BT_UNKNOWN)
 	{
 	  gfc_error ("Non-character non-Hollerith in FORMAT tag at %L",
 		     &e->where);
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index cfa8402dd3f..7b21a9e04e8 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -534,6 +534,9 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu
 	{
 	  int n;
 
+	  if (cmp->as->type != AS_EXPLICIT)
+	    return 0;
+
 	  e->expr_type = EXPR_ARRAY;
 	  e->rank = cmp->as->rank;
 
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 9f21b3ee780..604e816dc27 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1622,7 +1622,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,
       GFC_TYPE_ARRAY_STRIDE (type, n) = tmp;
 
       expr = as->lower[n];
-      if (expr->expr_type == EXPR_CONSTANT)
+      if (expr && expr->expr_type == EXPR_CONSTANT)
         {
           tmp = gfc_conv_mpz_to_tree (expr->value.integer,
 				      gfc_index_integer_kind);
@@ -1672,7 +1672,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,
   for (n = as->rank; n < as->rank + as->corank; n++)
     {
       expr = as->lower[n];
-      if (expr->expr_type == EXPR_CONSTANT)
+      if (expr && expr->expr_type == EXPR_CONSTANT)
 	tmp = gfc_conv_mpz_to_tree (expr->value.integer,
 				    gfc_index_integer_kind);
       else
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index 6079f88163f..0581338ea5f 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -4502,6 +4502,8 @@ clear_padding_type (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)
 		if (fldsz == 0)
 		  continue;
 		HOST_WIDE_INT pos = int_byte_position (field);
+		if (pos >= sz)
+		  continue;
 		HOST_WIDE_INT bpos
 		  = tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field));
 		bpos %= BITS_PER_UNIT;
@@ -4577,6 +4579,8 @@ clear_padding_type (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)
 	    else
 	      {
 		HOST_WIDE_INT pos = int_byte_position (field);
+		if (pos >= sz)
+		  continue;
 		HOST_WIDE_INT fldsz = tree_to_shwi (DECL_SIZE_UNIT (field));
 		gcc_assert (pos >= 0 && fldsz >= 0 && pos >= cur_pos);
 		clear_padding_add_padding (buf, pos - cur_pos);
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 83e26c02d4e..294b905db7c 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,99 @@
+2021-07-28  Martin Uecker  <muecker@gwdg.de>
+
+	* gcc.dg/Wnonnull-4.c: Correct argument numbers in warnings.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101536
+	* gfortran.dg/pr101536.f90: New test.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101514
+	* gfortran.dg/pr101514.f90: New test.
+
+2021-07-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101084
+	* gfortran.dg/fmt_nonchar_3.f90: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* gdc.dg/pr96429.d: Update test.
+	* gdc.dg/pr101640.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* gdc.dg/pr101490.d: New test.
+	* gdc.test/fail_compilation/fail22144.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* gdc.test/compilable/b19002.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* gdc.dg/pr101127a.d: New test.
+	* gdc.dg/pr101127b.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101619
+	* gdc.test/fail_compilation/fail7424b.d: Update test.
+	* gdc.test/fail_compilation/fail7424c.d: Update test.
+	* gdc.test/fail_compilation/fail7424d.d: Update test.
+	* gdc.test/fail_compilation/fail7424e.d: Update test.
+	* gdc.test/fail_compilation/fail7424f.d: Update test.
+	* gdc.test/fail_compilation/fail7424g.d: Update test.
+	* gdc.test/fail_compilation/fail7424h.d: Update test.
+	* gdc.test/fail_compilation/fail7424i.d: Update test.
+	* gdc.test/compilable/test22133.d: New test.
+	* gdc.test/fail_compilation/fail22133.d: New test.
+
+2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101586
+	* g++.dg/torture/builtin-clear-padding-4.C: New test.
+
+2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/101562
+	* gcc.c-torture/compile/pr101562.c: New test.
+
 2021-07-28  Release Manager
 
 	* GCC 11.2.0 released.
diff --git a/gcc/testsuite/g++.dg/torture/builtin-clear-padding-4.C b/gcc/testsuite/g++.dg/torture/builtin-clear-padding-4.C
new file mode 100644
index 00000000000..5936cdf876b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/builtin-clear-padding-4.C
@@ -0,0 +1,44 @@
+// PR middle-end/101586
+
+struct A { char a; };
+struct B : virtual A {};
+struct C : B {};
+struct D : virtual A, C {};
+
+__attribute__((noipa)) A *
+baz (C *p, D *q)
+{
+  if (p)
+    return dynamic_cast <A *> (p);
+  else
+    return dynamic_cast <A *> (q);
+}
+
+void
+foo ()
+{ 
+  C c;
+  c.a = 42;
+  __builtin_clear_padding (&c);
+  A *p = baz (&c, 0);
+  if (c.a != 42 || p->a != 42)
+    __builtin_abort ();
+}
+
+void
+bar ()
+{
+  D d;
+  d.a = 42;
+  __builtin_clear_padding (&d);
+  A *p = baz (0, &d);
+  if (d.a != 42 || p->a != 42)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo ();
+  bar ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr101562.c b/gcc/testsuite/gcc.c-torture/compile/pr101562.c
new file mode 100644
index 00000000000..ea4a5f7103a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr101562.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/101562 */
+
+struct S { char c; };
+void baz (struct S a, struct S b);
+
+void
+foo (void)
+{
+  struct S x[1];
+  *(short *)&x[0] = 256;
+  baz (x[0], x[1]);
+}
+
+void
+bar (void)
+{
+  struct S x[1];
+  x[0].c = 0;
+  x[1].c = 1;
+  baz (x[0], x[1]);
+}
diff --git a/gcc/testsuite/gcc.dg/Wnonnull-4.c b/gcc/testsuite/gcc.dg/Wnonnull-4.c
index 180a40d4606..2c1c45a9856 100644
--- a/gcc/testsuite/gcc.dg/Wnonnull-4.c
+++ b/gcc/testsuite/gcc.dg/Wnonnull-4.c
@@ -27,9 +27,9 @@ void test_fca_n (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'char\\\[n]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'char\\\[n]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'char\\\[n]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'char\\\[n]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'char\\\[n]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'char\\\[n]' is null but the corresponding bound argument 1 value is \\d+" }
 }
 
 
@@ -55,9 +55,9 @@ void test_fsa_x_n (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'short int\\\[]\\\[n]' is null but the corresponding bound argument 1 value is \\d+" }
 }
 
 
@@ -83,9 +83,9 @@ void test_fia_1_n (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'int\\\[1]\\\[n]' is null but the corresponding bound argument 1 value is \\d+" }
 }
 
 
@@ -111,9 +111,9 @@ void test_fla_3_n (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'long int\\\[3]\\\[n]' is null but the corresponding bound argument 1 value is \\d+" }
 }
 
 
@@ -139,9 +139,9 @@ void test_fda_n_5 (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'double\\\[n]\\\[5]' is null but the corresponding bound argument 1 value is \\d+" }
 }
 
 
@@ -167,7 +167,7 @@ void test_fca_n_n (int r_m1)
   T (  0);
 
   // Verify positive bounds.
-  T (  1);          // { dg-warning "argument 1 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 2 value is 1" }
-  T (  9);          // { dg-warning "argument 1 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 2 value is 9" }
-  T (max);          // { dg-warning "argument 1 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 2 value is \\d+" }
+  T (  1);          // { dg-warning "argument 2 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 1 value is 1" }
+  T (  9);          // { dg-warning "argument 2 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 1 value is 9" }
+  T (max);          // { dg-warning "argument 2 of variable length array 'char\\\[n]\\\[n]' is null but the corresponding bound argument 1 value is \\d+" }
 }
diff --git a/gcc/testsuite/gdc.dg/pr101127a.d b/gcc/testsuite/gdc.dg/pr101127a.d
new file mode 100644
index 00000000000..b56398e1929
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127a.d
@@ -0,0 +1,8 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+// { dg-additional-options "-mavx" }
+
+import gcc.builtins;
+
+static assert(__traits(compiles, __builtin_ia32_andps256));
+static assert(__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101127b.d b/gcc/testsuite/gdc.dg/pr101127b.d
new file mode 100644
index 00000000000..b462d75c424
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127b.d
@@ -0,0 +1,7 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+
+import gcc.builtins;
+
+static assert(!__traits(compiles, __builtin_ia32_andps256));
+static assert(!__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101490.d b/gcc/testsuite/gdc.dg/pr101490.d
new file mode 100644
index 00000000000..6929d406863
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101490.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101490
+// { dg-do compile }
+
+struct S101490
+{
+    int[0] arr;
+}
+
+void main()
+{
+    S101490* t;
+    auto a = cast(typeof(t.arr)[0])t.arr;
+    write(a);
+}
+
+void write(S)(S args)
+{
+    foreach (arg; args)
+    {
+    }
+}
diff --git a/gcc/testsuite/gdc.dg/pr101640.d b/gcc/testsuite/gdc.dg/pr101640.d
new file mode 100644
index 00000000000..68de4088512
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101640.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101640
+// { dg-do compile }
+// { dg-options "-fdump-tree-original" }
+
+int fun101640(ref int);
+
+int test101640(int val)
+{
+    // { dg-final { scan-tree-dump "= val \\\+ fun101640 \\\(\\\(int &\\\) &val\\\);" "original" } }
+    return val + fun101640(val);
+}
diff --git a/gcc/testsuite/gdc.dg/pr96429.d b/gcc/testsuite/gdc.dg/pr96429.d
index af096e26b5a..9940a03e0ec 100644
--- a/gcc/testsuite/gdc.dg/pr96429.d
+++ b/gcc/testsuite/gdc.dg/pr96429.d
@@ -3,7 +3,7 @@
 // { dg-options "-fdump-tree-original" }
 ptrdiff_t subbyte(byte* bp1, byte* bp2)
 {
-    // { dg-final { scan-tree-dump "bp1 - bp2;" "original" } }
+    // { dg-final { scan-tree-dump "\\\(bp1 - bp2\\\) /\\\[ex\\\] 1;" "original" } }
     return bp1 - bp2;
 }
 
diff --git a/gcc/testsuite/gdc.test/compilable/b19002.d b/gcc/testsuite/gdc.test/compilable/b19002.d
new file mode 100644
index 00000000000..fd8e6d18b37
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/b19002.d
@@ -0,0 +1,12 @@
+module b19002;
+
+void printf(scope const char* format){}
+
+void main()
+{
+    printf(__FILE__);
+    printf(__FILE_FULL_PATH__);
+    printf(__FUNCTION__);
+    printf(__PRETTY_FUNCTION__);
+    printf(__MODULE__);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/test22133.d b/gcc/testsuite/gdc.test/compilable/test22133.d
new file mode 100644
index 00000000000..aff762c7180
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/test22133.d
@@ -0,0 +1,16 @@
+// https://issues.dlang.org/show_bug.cgi?id=22133
+
+struct Slice
+{
+    bool empty() const;
+    int front() const;
+    void popFront()() // note: requires a mutable Slice
+    {}
+}
+
+enum isInputRange1(R) = is(typeof((R r) => r.popFront));
+enum isInputRange2(R) = __traits(compiles, (R r) => r.popFront);
+static assert(isInputRange1!(      Slice) == true);
+static assert(isInputRange1!(const Slice) == false);
+static assert(isInputRange2!(      Slice) == true);
+static assert(isInputRange2!(const Slice) == false);
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22133.d b/gcc/testsuite/gdc.test/fail_compilation/fail22133.d
new file mode 100644
index 00000000000..338d96dc7e1
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22133.d
@@ -0,0 +1,24 @@
+// https://issues.dlang.org/show_bug.cgi?id=22133
+/*
+TEST_OUTPUT
+---
+fail_compilation/fail22133.d(16): Error: `s.popFront()()` has no effect
+fail_compilation/fail22133.d(17): Error: template `s.popFront()()` has no type
+---
+*/
+struct Slice
+{
+    void popFront()() {}
+}
+
+auto fail22133(const Slice s)
+{
+    s.popFront;
+    return s.popFront;
+}
+
+auto ok22133(Slice s)
+{
+    s.popFront;
+    return s.popFront;
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22144.d b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
new file mode 100644
index 00000000000..e0fd5b19225
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
@@ -0,0 +1,14 @@
+// https://issues.dlang.org/show_bug.cgi?id=22144
+/* TEST_OUTPUT
+---
+fail_compilation/fail22144.d(12): Error: cannot cast expression `zarray1` of type `int[0]` to `int[0][]` since sizes don't line up
+---
+*/
+void main()
+{
+  int[0] zarray1;
+  int[0][0] zarray2;
+
+  auto zslice1 = cast(int[0][])zarray1; // ICE -> Error
+  auto zslice2 = cast(int[0][])zarray2; // ICE -> OK
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
index 737958ca6a3..c3fc3116939 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424b.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424b.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424b.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424b
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
index e804d72100b..220c995eedd 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424c.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424c.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424c.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424c
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
index 5ef9463aeb2..669c9ff6314 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424d.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424d.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424d.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424d
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
index ddf4ded953a..18bf414ed3a 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424e.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424e.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424e.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424e
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
index 751b6259d31..29e0ecc9771 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424f.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424f.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424f.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424f
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
index d4fa4635d8d..b4670de3624 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424g.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424g.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424g.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424g
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
index 56184a5f5a1..b76f5b352e1 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424h.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424h.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424h.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424g
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d b/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
index 37042f741f3..887c85970b8 100644
--- a/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail7424i.d
@@ -1,7 +1,7 @@
 /*
 TEST_OUTPUT:
 ---
-fail_compilation/fail7424i.d(10): Error: expression `this.g()()` is `void` and has no value
+fail_compilation/fail7424i.d(10): Error: template `this.g()()` has no value
 ---
 */
 struct S7424g
diff --git a/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90 b/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90
new file mode 100644
index 00000000000..3b3c260ef7f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_nonchar_3.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/101084
+
+program p
+  integer, parameter :: a(0) = 1
+  print int(a) ! { dg-error "Non-character non-Hollerith in FORMAT tag" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101514.f90 b/gcc/testsuite/gfortran.dg/pr101514.f90
new file mode 100644
index 00000000000..51fbf8a7e85
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101514.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+! PR fortran/101514 - ICE: out of memory allocating ... bytes
+
+subroutine s
+  type t1
+     integer :: a(..) ! { dg-error "must have an explicit shape" }
+  end type
+  type t2
+     integer :: a(*)  ! { dg-error "must have an explicit shape" }
+  end type
+  type t3
+     integer :: a(:)  ! { dg-error "must have an explicit shape" }
+  end type
+  type t4
+     integer :: a(0:) ! { dg-error "must have an explicit shape" }
+  end type
+  type t5
+     integer, allocatable :: a(:)
+  end type
+  type t6
+     integer, pointer     :: a(:)
+  end type
+  type(t1) :: a1
+  type(t2) :: a2
+  type(t3) :: a3
+  type(t4) :: a4
+  type(t5) :: a5
+  type(t6) :: a6
+  a1 = transfer(1, a1)
+  a2 = transfer(1, a2)
+  a3 = transfer(1, a3)
+  a4 = transfer(1, a4)
+  a5 = transfer(1, a5)
+  a6 = transfer(1, a6)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101536.f90 b/gcc/testsuite/gfortran.dg/pr101536.f90
new file mode 100644
index 00000000000..b16af00d919
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101536.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! PR fortran/101536 - ICE in gfc_conv_expr_descriptor
+
+program p
+  type s
+     class(*), allocatable :: c
+  end type
+  type t
+     class(*), allocatable :: c(:)
+  end type t
+  type u
+     integer :: c(2)
+  end type
+  type(t) :: x
+  x%c = [1,2,3,4]
+!  print *, size (x)
+  print *, size (x%c)
+  print *, size (x%c(1)) ! { dg-error "must be an array" }
+contains
+  integer function f(x, y, z)
+    class(t), allocatable :: x(:)
+    class(u)              :: y(:)
+    class(s)              :: z
+    f = size (x)
+    f = size (x(1))      ! { dg-error "must be an array" }
+    f = size (y)
+    f = size (y%c(1))
+    f = size (y(2)%c)
+    f = size (y(2)%c(1)) ! { dg-error "must be an array" }
+    f = size (z)         ! { dg-error "must be an array" }
+    f = size (z% c)      ! { dg-error "must be an array" }
+  end
+end
