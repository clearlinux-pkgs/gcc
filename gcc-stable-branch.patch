Andrew Stubbs (3):
      amdgcn: HardFP divide
      amdgcn: update target-supports.exp
      amdgcn: bug fix ldexp insn

Eric Botcazou (1):
      Remove obsolete configure code in gnattools

GCC Administrator (1):
      Daily bump.

Jakub Jelinek (6):
      Bump BASE-VER
      c: Avoid -Wenum-int-mismatch warning for redeclaration of builtin acc_on_device [PR107041]
      testsuite: Fix up ext-floating15.C tests on powerpc64-linux [PR109278]
      testsuite: Fix up ext-floating2.C on powerpc64-linux
      c: Fix up error-recovery on functions initialized as variables [PR109412]
      c: Fix up error-recovery on non-empty VLA initializers [PR109409]

Jonathan Wakely (2):
      libstdc++: Reduce Doxygen output for PDF
      libstdc++: Fix typos in doxygen comments

Richard Biener (3):
      tree-optimization/109573 - avoid ICEing on unexpected live def
      rtl-optimization/109585 - alias analysis typo
      tree-optimization/109609 - correctly interpret arg size in fnspec

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index e9362593c88..ca754d92152 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,10 @@
+2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* gennews (files): Add files for GCC 13.
+
 2023-04-26  Release Manager
 
 	* GCC 13.1.0 released.
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index e6ba351366d..21b80e995f7 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-13.1.0
+13.1.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index be07b08a516..4151c5366fa 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,59 @@
+2023-04-26  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backported from master:
+	2023-04-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	* config/gcn/gcn-valu.md (vnsi, VnSI): Add scalar modes.
+	(ldexp<mode>3): Delete.
+	(ldexp<mode>3<exec>): Change "B" to "A".
+
+2023-04-26  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backported from master:
+	2023-04-18  Andrew Stubbs  <ams@codesourcery.com>
+
+	* config/gcn/gcn-valu.md (SV_SFDF): New iterator.
+	(SV_FP): New iterator.
+	(scalar_mode, SCALAR_MODE): Add identity mappings for scalar modes.
+	(recip<mode>2): Unify the two patterns using SV_FP.
+	(div_scale<mode><exec_vcc>): New insn.
+	(div_fmas<mode><exec>): New insn.
+	(div_fixup<mode><exec>): New insn.
+	(div<mode>3): Unify the two expanders and rewrite using hardfp.
+	* config/gcn/gcn.cc (gcn_md_reorg): Support "vccwait" attribute.
+	* config/gcn/gcn.md (unspec): Add UNSPEC_DIV_SCALE, UNSPEC_DIV_FMAS,
+	and UNSPEC_DIV_FIXUP.
+	(vccwait): New attribute.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109609
+	* attr-fnspec.h (arg_max_access_size_given_by_arg_p):
+	Clarify semantics.
+	* tree-ssa-alias.cc (check_fnspec): Correctly interpret
+	the size given by arg_max_access_size_given_by_arg_p as
+	maximum, not exact, size.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/109585
+	* tree-ssa-alias.cc (aliasing_component_refs_p): Fix typo.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109573
+	* tree-vect-loop.cc (vectorizable_live_operation): Allow
+	unhandled SSA copy as well.  Demote assert to checking only.
+
 2023-04-26  Release Manager
 
 	* GCC 13.1.0 released.
diff --git a/gcc/attr-fnspec.h b/gcc/attr-fnspec.h
index acf1c5f6be7..99d5f896e8b 100644
--- a/gcc/attr-fnspec.h
+++ b/gcc/attr-fnspec.h
@@ -54,7 +54,7 @@
      ' '        nothing is known
      't'	the size of value written/read corresponds to the size of
 		of the pointed-to type of the argument type
-     '1'...'9'  specifies the size of value written/read is given by the
+     '1'...'9'  specifies the size of value written/read is bound by the
 		specified argument
  */
 
@@ -169,7 +169,7 @@ public:
 	   && str[idx] != 'x' && str[idx] != 'X';
   }
 
-  /* Return true if load of memory pointed to by argument I is specified
+  /* Return true if load of memory pointed to by argument I is bound
      by another argument.  In this case set ARG.  */
   bool
   arg_max_access_size_given_by_arg_p (unsigned int i, unsigned int *arg)
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 7e98008a65d..2f8b8d7b0e8 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,12 @@
+2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107041
+	* c-decl.cc (diagnose_mismatched_decls): Avoid -Wenum-int-mismatch
+	warning on acc_on_device declaration.
+
 2023-04-26  Release Manager
 
 	* GCC 13.1.0 released.
diff --git a/gcc/c/c-decl.cc b/gcc/c/c-decl.cc
index e537d33f398..1b53f2d0785 100644
--- a/gcc/c/c-decl.cc
+++ b/gcc/c/c-decl.cc
@@ -2219,7 +2219,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
     }
   /* Warn about enum/integer type mismatches.  They are compatible types
      (C2X 6.7.2.2/5), but may pose portability problems.  */
-  else if (enum_and_int_p && TREE_CODE (newdecl) != TYPE_DECL)
+  else if (enum_and_int_p
+	   && TREE_CODE (newdecl) != TYPE_DECL
+	   /* Don't warn about about acc_on_device built-in redeclaration,
+	      the built-in is declared with int rather than enum because
+	      the enum isn't intrinsic.  */
+	   && !(TREE_CODE (olddecl) == FUNCTION_DECL
+		&& fndecl_built_in_p (olddecl, BUILT_IN_ACC_ON_DEVICE)
+		&& !C_DECL_DECLARED_BUILTIN (olddecl)))
     warned = warning_at (DECL_SOURCE_LOCATION (newdecl),
 			 OPT_Wenum_int_mismatch,
 			 "conflicting types for %q+D due to enum/integer "
diff --git a/gcc/c/c-parser.cc b/gcc/c/c-parser.cc
index 21bc3167ce2..3627a3fbdc7 100644
--- a/gcc/c/c-parser.cc
+++ b/gcc/c/c-parser.cc
@@ -5677,11 +5677,14 @@ c_parser_initializer (c_parser *parser, tree decl)
     {
       struct c_expr ret;
       location_t loc = c_parser_peek_token (parser)->location;
-      if (decl != error_mark_node && C_DECL_VARIABLE_SIZE (decl))
-	error_at (loc,
-		  "variable-sized object may not be initialized except "
-		  "with an empty initializer");
       ret = c_parser_expr_no_commas (parser, NULL);
+      if (decl != error_mark_node && C_DECL_VARIABLE_SIZE (decl))
+	{
+	  error_at (loc,
+		    "variable-sized object may not be initialized except "
+		    "with an empty initializer");
+	  ret.set_error ();
+	}
       /* This is handled mostly by gimplify.cc, but we have to deal with
 	 not warning about int x = x; as it is a GCC extension to turn off
 	 this warning but only if warn_init_self is zero.  */
diff --git a/gcc/c/c-typeck.cc b/gcc/c/c-typeck.cc
index 7079d4ee145..a17879698ec 100644
--- a/gcc/c/c-typeck.cc
+++ b/gcc/c/c-typeck.cc
@@ -9374,6 +9374,11 @@ pop_init_level (location_t loc, int implicit,
 	{
 	  if (constructor_erroneous || constructor_type == error_mark_node)
 	    ret.value = error_mark_node;
+	  else if (TREE_CODE (constructor_type) == FUNCTION_TYPE)
+	    {
+	      error_init (loc, "invalid initializer");
+	      ret.value = error_mark_node;
+	    }
 	  else if (TREE_CODE (constructor_type) == POINTER_TYPE)
 	    /* Ensure this is a null pointer constant in the case of a
 	       'constexpr' object initialized with {}.  */
diff --git a/gcc/config/gcn/gcn-valu.md b/gcc/config/gcn/gcn-valu.md
index e3d6d65e9a9..44c48468dd6 100644
--- a/gcc/config/gcn/gcn-valu.md
+++ b/gcc/config/gcn/gcn-valu.md
@@ -15,6 +15,7 @@
 ;; <http://www.gnu.org/licenses/>.
 
 ;; {{{ Vector iterators
+; SV iterators include both scalar and vector modes.
 
 ; Vector modes for specific types
 (define_mode_iterator V_QI
@@ -126,6 +127,15 @@
 		       V32SI V32DI
 		       V64SI V64DI])
 
+(define_mode_iterator SV_SFDF
+		      [SF DF
+		       V2SF V2DF
+		       V4SF V4DF
+		       V8SF V8DF
+		       V16SF V16DF
+		       V32SF V32DF
+		       V64SF V64DF])
+
 ; All of above
 (define_mode_iterator V_ALL
 		      [V2QI V2HI V2HF V2SI V2SF V2DI V2DF
@@ -156,9 +166,19 @@
 		       V16HF V16SF V16DF
 		       V32HF V32SF V32DF
 		       V64HF V64SF V64DF])
+(define_mode_iterator SV_FP
+		      [HF SF DF
+		       V2HF V2SF V2DF
+		       V4HF V4SF V4DF
+		       V8HF V8SF V8DF
+		       V16HF V16SF V16DF
+		       V32HF V32SF V32DF
+		       V64HF V64SF V64DF])
 
 (define_mode_attr scalar_mode
-  [(V2QI "qi") (V2HI "hi") (V2SI "si")
+  [(QI "qi") (HI "hi") (SI "si")
+   (HF "hf") (SF "sf") (DI "di") (DF "df")
+   (V2QI "qi") (V2HI "hi") (V2SI "si")
    (V2HF "hf") (V2SF "sf") (V2DI "di") (V2DF "df")
    (V4QI "qi") (V4HI "hi") (V4SI "si")
    (V4HF "hf") (V4SF "sf") (V4DI "di") (V4DF "df")
@@ -172,7 +192,9 @@
    (V64HF "hf") (V64SF "sf") (V64DI "di") (V64DF "df")])
 
 (define_mode_attr SCALAR_MODE
-  [(V2QI "QI") (V2HI "HI") (V2SI "SI")
+  [(QI "QI") (HI "HI") (SI "SI")
+   (HF "HF") (SF "SF") (DI "DI") (DF "DF")
+   (V2QI "QI") (V2HI "HI") (V2SI "SI")
    (V2HF "HF") (V2SF "SF") (V2DI "DI") (V2DF "DF")
    (V4QI "QI") (V4HI "HI") (V4SI "SI")
    (V4HF "HF") (V4SF "SF") (V4DI "DI") (V4DF "DF")
@@ -186,7 +208,9 @@
    (V64HF "HF") (V64SF "SF") (V64DI "DI") (V64DF "DF")])
 
 (define_mode_attr vnsi
-  [(V2QI "v2si") (V2HI "v2si") (V2HF "v2si") (V2SI "v2si")
+  [(QI "si") (HI "si") (SI "si")
+   (HF "si") (SF "si") (DI "si") (DF "si")
+   (V2QI "v2si") (V2HI "v2si") (V2HF "v2si") (V2SI "v2si")
    (V2SF "v2si") (V2DI "v2si") (V2DF "v2si")
    (V4QI "v4si") (V4HI "v4si") (V4HF "v4si") (V4SI "v4si")
    (V4SF "v4si") (V4DI "v4si") (V4DF "v4si")
@@ -200,7 +224,9 @@
    (V64SF "v64si") (V64DI "v64si") (V64DF "v64si")])
 
 (define_mode_attr VnSI
-  [(V2QI "V2SI") (V2HI "V2SI") (V2HF "V2SI") (V2SI "V2SI")
+  [(QI "SI") (HI "SI") (SI "SI")
+   (HF "SI") (SF "SI") (DI "SI") (DF "SI")
+   (V2QI "V2SI") (V2HI "V2SI") (V2HF "V2SI") (V2SI "V2SI")
    (V2SF "V2SI") (V2DI "V2SI") (V2DF "V2SI")
    (V4QI "V4SI") (V4HI "V4SI") (V4HF "V4SI") (V4SI "V4SI")
    (V4SF "V4SI") (V4DI "V4SI") (V4DF "V4SI")
@@ -3021,21 +3047,10 @@
 
 ; Implement ldexp pattern
 
-(define_insn "ldexp<mode>3"
-  [(set (match_operand:FP 0 "register_operand"  "=v")
-	(unspec:FP
-	  [(match_operand:FP 1 "gcn_alu_operand" "vB")
-	   (match_operand:SI 2 "gcn_alu_operand" "vSvA")]
-	  UNSPEC_LDEXP))]
-  ""
-  "v_ldexp%i0\t%0, %1, %2"
-  [(set_attr "type" "vop3a")
-   (set_attr "length" "8")])
-
 (define_insn "ldexp<mode>3<exec>"
-  [(set (match_operand:V_FP 0 "register_operand"     "=  v")
-	(unspec:V_FP
-	  [(match_operand:V_FP 1 "gcn_alu_operand"   "  vB")
+  [(set (match_operand:SV_FP 0 "register_operand"     "=  v")
+	(unspec:SV_FP
+	  [(match_operand:SV_FP 1 "gcn_alu_operand"   "  vA")
 	   (match_operand:<VnSI> 2 "gcn_alu_operand" "vSvA")]
 	  UNSPEC_LDEXP))]
   ""
@@ -3188,113 +3203,124 @@
 ;; {{{ FP division
 
 (define_insn "recip<mode>2<exec>"
-  [(set (match_operand:V_FP 0 "register_operand"  "=  v")
-	(unspec:V_FP
-	  [(match_operand:V_FP 1 "gcn_alu_operand" "vSvB")]
+  [(set (match_operand:SV_FP 0 "register_operand"  "=  v")
+	(unspec:SV_FP
+	  [(match_operand:SV_FP 1 "gcn_alu_operand" "vSvB")]
 	  UNSPEC_RCP))]
   ""
   "v_rcp%i0\t%0, %1"
   [(set_attr "type" "vop1")
    (set_attr "length" "8")])
 
-(define_insn "recip<mode>2"
-  [(set (match_operand:FP 0 "register_operand"	 "=  v")
-	(unspec:FP
-	  [(match_operand:FP 1 "gcn_alu_operand" "vSvB")]
-	  UNSPEC_RCP))]
+;; v_div_scale takes a numerator (op2) and denominator (op1) and returns the
+;; one that matches op3 adjusted for best results in reciprocal division.
+;; It also emits a VCC mask that is intended for input to v_div_fmas.
+;; The caller is expected to call this twice, once for each input.  The output
+;; VCC is the same in both cases, so the caller may discard one.
+(define_insn "div_scale<mode><exec_vcc>"
+  [(set (match_operand:SV_SFDF 0 "register_operand"   "=v")
+	(unspec:SV_SFDF
+	  [(match_operand:SV_SFDF 1 "gcn_alu_operand" "v")
+	   (match_operand:SV_SFDF 2 "gcn_alu_operand" "v")
+	   (match_operand:SV_SFDF 3 "gcn_alu_operand" "v")]
+	  UNSPEC_DIV_SCALE))
+   (set (match_operand:DI 4 "register_operand"        "=SvcV")
+	(unspec:DI
+	  [(match_dup 1) (match_dup 2) (match_dup 3)]
+	  UNSPEC_DIV_SCALE))]
   ""
-  "v_rcp%i0\t%0, %1"
-  [(set_attr "type" "vop1")
+  "v_div_scale%i0\t%0, %4, %3, %1, %2"
+  [(set_attr "type" "vop3b")
    (set_attr "length" "8")])
 
-;; Do division via a = b * 1/c
-;; The v_rcp_* instructions are not sufficiently accurate on their own,
-;; so we use 2 v_fma_* instructions to do one round of Newton-Raphson
-;; which the ISA manual says is enough to improve the reciprocal accuracy.
-;;
-;; FIXME: This does not handle denormals, NaNs, division-by-zero etc.
+;; v_div_fmas is "FMA and Scale" that uses the VCC output from v_div_scale
+;; to conditionally scale the output of the whole division operation.
+;; This is necessary to counter the adjustments made by v_div_scale and
+;; replaces the last FMA instruction of the Newton Raphson algorithm.
+(define_insn "div_fmas<mode><exec>"
+  [(set (match_operand:SV_SFDF 0 "register_operand"       "=v")
+	(unspec:SV_SFDF
+	  [(plus:SV_SFDF
+	     (mult:SV_SFDF
+	       (match_operand:SV_SFDF 1 "gcn_alu_operand" "v")
+	       (match_operand:SV_SFDF 2 "gcn_alu_operand" "v"))
+	     (match_operand:SV_SFDF 3 "gcn_alu_operand"   "v"))
+	   (match_operand:DI 4 "register_operand"         "cV")]
+	  UNSPEC_DIV_FMAS))]
+  ""
+  "v_div_fmas%i0\t%0, %1, %2, %3; %4"
+  [(set_attr "type" "vop3a")
+   (set_attr "length" "8")
+   (set_attr "vccwait" "5")])
+
+;; v_div_fixup takes the inputs and outputs of a division operation already
+;; completed and cleans up the floating-point sign bit, infinity, underflow,
+;; overflow, and NaN status.  It will also emit any FP exceptions.
+;; op1: quotient,  op2: denominator,  op3: numerator
+(define_insn "div_fixup<mode><exec>"
+  [(set (match_operand:SV_FP 0 "register_operand"    "=v")
+	(unspec:SV_FP
+	  [(match_operand:SV_FP 1 "register_operand" "v")
+	   (match_operand:SV_FP 2 "gcn_alu_operand"  "v")
+	   (match_operand:SV_FP 3 "gcn_alu_operand"  "v")]
+	  UNSPEC_DIV_FIXUP))]
+  ""
+  "v_div_fixup%i0\t%0, %1, %2, %3"
+  [(set_attr "type" "vop3a")
+   (set_attr "length" "8")])
 
 (define_expand "div<mode>3"
-  [(match_operand:V_FP 0 "gcn_valu_dst_operand")
-   (match_operand:V_FP 1 "gcn_valu_src0_operand")
-   (match_operand:V_FP 2 "gcn_valu_src0_operand")]
-  "flag_reciprocal_math"
+  [(match_operand:SV_SFDF 0 "register_operand")
+   (match_operand:SV_SFDF 1 "gcn_alu_operand")
+   (match_operand:SV_SFDF 2 "gcn_alu_operand")]
+  ""
   {
+    rtx numerator = operands[1];
+    rtx denominator = operands[2];
+
+    /* Scale the inputs if they are close to the FP limits.
+       This will be reversed later.  */
+    rtx vcc = gen_reg_rtx (DImode);
+    rtx discardedvcc = gen_reg_rtx (DImode);
+    rtx scaled_numerator = gen_reg_rtx (<MODE>mode);
+    rtx scaled_denominator = gen_reg_rtx (<MODE>mode);
+    emit_insn (gen_div_scale<mode> (scaled_denominator,
+				    denominator, numerator,
+				    denominator, discardedvcc));
+    emit_insn (gen_div_scale<mode> (scaled_numerator,
+				    denominator, numerator,
+				    numerator, vcc));
+
+    /* Find the reciprocal of the denominator, and use Newton-Raphson to
+       improve the accuracy over the basic hardware instruction.  */
     rtx one = gcn_vec_constant (<MODE>mode,
 		  const_double_from_real_value (dconst1, <SCALAR_MODE>mode));
     rtx initrcp = gen_reg_rtx (<MODE>mode);
-    rtx fma = gen_reg_rtx (<MODE>mode);
-    rtx rcp;
-    rtx num = operands[1], denom = operands[2];
-
-    bool is_rcp = (GET_CODE (num) == CONST_VECTOR
-		   && real_identical
-		        (CONST_DOUBLE_REAL_VALUE
-			  (CONST_VECTOR_ELT (num, 0)), &dconstm1));
-
-    if (is_rcp)
-      rcp = operands[0];
-    else
-      rcp = gen_reg_rtx (<MODE>mode);
-
-    emit_insn (gen_recip<mode>2 (initrcp, denom));
-    emit_insn (gen_fma<mode>4_negop2 (fma, initrcp, denom, one));
-    emit_insn (gen_fma<mode>4 (rcp, fma, initrcp, initrcp));
-
-    if (!is_rcp)
-      {
-	rtx div_est = gen_reg_rtx (<MODE>mode);
-	rtx fma2 = gen_reg_rtx (<MODE>mode);
-	rtx fma3 = gen_reg_rtx (<MODE>mode);
-	rtx fma4 = gen_reg_rtx (<MODE>mode);
-	emit_insn (gen_mul<mode>3 (div_est, num, rcp));
-	emit_insn (gen_fma<mode>4_negop2 (fma2, div_est, denom, num));
-	emit_insn (gen_fma<mode>4 (fma3, fma2, rcp, div_est));
-	emit_insn (gen_fma<mode>4_negop2 (fma4, fma3, denom, num));
-	emit_insn (gen_fma<mode>4 (operands[0], fma4, rcp, fma3));
-      }
-
-    DONE;
-  })
-
-(define_expand "div<mode>3"
-  [(match_operand:FP 0 "gcn_valu_dst_operand")
-   (match_operand:FP 1 "gcn_valu_src0_operand")
-   (match_operand:FP 2 "gcn_valu_src0_operand")]
-  "flag_reciprocal_math"
-  {
-    rtx one = const_double_from_real_value (dconst1, <MODE>mode);
-    rtx initrcp = gen_reg_rtx (<MODE>mode);
-    rtx fma = gen_reg_rtx (<MODE>mode);
-    rtx rcp;
-    rtx num = operands[1], denom = operands[2];
-
-    bool is_rcp = (GET_CODE (operands[1]) == CONST_DOUBLE
-		   && real_identical (CONST_DOUBLE_REAL_VALUE (operands[1]),
-				      &dconstm1));
-
-    if (is_rcp)
-      rcp = operands[0];
-    else
-      rcp = gen_reg_rtx (<MODE>mode);
-
-    emit_insn (gen_recip<mode>2 (initrcp, denom));
-    emit_insn (gen_fma<mode>4_negop2 (fma, initrcp, denom, one));
-    emit_insn (gen_fma<mode>4 (rcp, fma, initrcp, initrcp));
-
-    if (!is_rcp)
-      {
-	rtx div_est = gen_reg_rtx (<MODE>mode);
-	rtx fma2 = gen_reg_rtx (<MODE>mode);
-	rtx fma3 = gen_reg_rtx (<MODE>mode);
-	rtx fma4 = gen_reg_rtx (<MODE>mode);
-	emit_insn (gen_mul<mode>3 (div_est, num, rcp));
-	emit_insn (gen_fma<mode>4_negop2 (fma2, div_est, denom, num));
-	emit_insn (gen_fma<mode>4 (fma3, fma2, rcp, div_est));
-	emit_insn (gen_fma<mode>4_negop2 (fma4, fma3, denom, num));
-	emit_insn (gen_fma<mode>4 (operands[0], fma4, rcp, fma3));
-      }
-
+    rtx fma1 = gen_reg_rtx (<MODE>mode);
+    rtx rcp = gen_reg_rtx (<MODE>mode);
+    emit_insn (gen_recip<mode>2 (initrcp, scaled_denominator));
+    emit_insn (gen_fma<mode>4_negop2 (fma1, initrcp, scaled_denominator, one));
+    emit_insn (gen_fma<mode>4 (rcp, fma1, initrcp, initrcp));
+
+    /* Do the division "a/b" via "a*1/b" and use Newton-Raphson to improve
+       the accuracy.  The "div_fmas" instruction reverses any scaling
+       performed by "div_scale", above.  */
+    rtx div_est = gen_reg_rtx (<MODE>mode);
+    rtx fma2 = gen_reg_rtx (<MODE>mode);
+    rtx fma3 = gen_reg_rtx (<MODE>mode);
+    rtx fma4 = gen_reg_rtx (<MODE>mode);
+    rtx fmas = gen_reg_rtx (<MODE>mode);
+    emit_insn (gen_mul<mode>3 (div_est, scaled_numerator, rcp));
+    emit_insn (gen_fma<mode>4_negop2 (fma2, div_est, scaled_denominator,
+				      scaled_numerator));
+    emit_insn (gen_fma<mode>4 (fma3, fma2, rcp, div_est));
+    emit_insn (gen_fma<mode>4_negop2 (fma4, fma3, scaled_denominator,
+				      scaled_numerator));
+    emit_insn (gen_div_fmas<mode> (fmas, fma4, rcp, fma3, vcc));
+
+    /* Finally, use "div_fixup" to get the details right and find errors.  */
+    emit_insn (gen_div_fixup<mode> (operands[0], fmas, denominator,
+				    numerator));
     DONE;
   })
 
diff --git a/gcc/config/gcn/gcn.cc b/gcc/config/gcn/gcn.cc
index a7d278cd2f8..5608d85a1a0 100644
--- a/gcc/config/gcn/gcn.cc
+++ b/gcc/config/gcn/gcn.cc
@@ -5840,6 +5840,7 @@ gcn_md_reorg (void)
       attr_type itype = get_attr_type (insn);
       attr_unit iunit = get_attr_unit (insn);
       attr_delayeduse idelayeduse = get_attr_delayeduse (insn);
+      int ivccwait = get_attr_vccwait (insn);
       HARD_REG_SET ireads, iwrites;
       CLEAR_HARD_REG_SET (ireads);
       CLEAR_HARD_REG_SET (iwrites);
@@ -5917,6 +5918,14 @@ gcn_md_reorg (void)
 	      && ((hard_reg_set_intersect_p
 		   (prev_insn->reads, iwrites))))
 	    nops_rqd = 1 - prev_insn->age;
+
+	  /* Instruction that requires VCC is not written too close before
+	     using it.  */
+	  if (prev_insn->age < ivccwait
+	      && (hard_reg_set_intersect_p
+		  (prev_insn->writes,
+		   reg_class_contents[(int)VCC_CONDITIONAL_REG])))
+	    nops_rqd = ivccwait - prev_insn->age;
 	}
 
       /* Insert the required number of NOPs.  */
diff --git a/gcc/config/gcn/gcn.md b/gcc/config/gcn/gcn.md
index c90303c54b5..7065acf402b 100644
--- a/gcc/config/gcn/gcn.md
+++ b/gcc/config/gcn/gcn.md
@@ -90,7 +90,8 @@
   UNSPEC_RCP
   UNSPEC_FLBIT_INT
   UNSPEC_FLOOR UNSPEC_CEIL UNSPEC_SIN UNSPEC_COS UNSPEC_EXP2 UNSPEC_LOG2
-  UNSPEC_LDEXP UNSPEC_FREXP_EXP UNSPEC_FREXP_MANT])
+  UNSPEC_LDEXP UNSPEC_FREXP_EXP UNSPEC_FREXP_MANT
+  UNSPEC_DIV_SCALE UNSPEC_DIV_FMAS UNSPEC_DIV_FIXUP])
 
 ;; }}}
 ;; {{{ Attributes
@@ -302,6 +303,11 @@
 
 (define_attr "delayeduse" "yes,no" (const_string "no"))
 
+; Identify instructions that require "Manually Inserted Wait State" if
+; a previous instruction writes to VCC.  The number gives the number of NOPs.
+
+(define_attr "vccwait" "" (const_int 0))
+
 ;; }}}
 ;; {{{ Iterators useful across the wole machine description
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 4badb39132c..4f603cb8f3f 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,70 @@
+2023-04-26  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backported from master:
+	2023-04-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	* lib/target-supports.exp
+	(check_effective_target_vect_call_copysignf): Add amdgcn.
+	(check_effective_target_vect_call_sqrtf): Add amdgcn.
+	(check_effective_target_vect_call_ceilf): Add amdgcn.
+	(check_effective_target_vect_call_floor): Add amdgcn.
+	(check_effective_target_vect_logical_reduc): Add amdgcn.
+
+2023-04-26  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backported from master:
+	2023-04-18  Andrew Stubbs  <ams@codesourcery.com>
+
+	* gcc.target/gcn/fpdiv.c: Remove the -ffast-math requirement.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109609
+	* gcc.dg/torture/pr109609.c: New testcase.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/109585
+	* gcc.dg/torture/pr109585.c: New testcase.
+
+2023-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109573
+	* g++.dg/vect/pr109573.cc: New testcase.
+
+2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-25  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp23/ext-floating2.C: Add dg-add-options for
+	float16, float32, float64 and float128.
+
+2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/109278
+	* g++.dg/cpp23/ext-floating15.C: Add dg-add-options float128.
+
+2023-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107041
+	* gcc.dg/goacc/pr107041.c: New test.
+
 2023-04-26  Release Manager
 
 	* GCC 13.1.0 released.
diff --git a/gcc/testsuite/g++.dg/cpp23/ext-floating15.C b/gcc/testsuite/g++.dg/cpp23/ext-floating15.C
index 316dd5abacd..6d7dc6ad682 100644
--- a/gcc/testsuite/g++.dg/cpp23/ext-floating15.C
+++ b/gcc/testsuite/g++.dg/cpp23/ext-floating15.C
@@ -1,6 +1,7 @@
 // PR c++/109278
 // { dg-do compile { target float128 } }
 // { dg-options "-w" }
+// { dg-add-options float128 }
 
 void foo (long double);	// { dg-bogus "initializing argument 1 of" }
 
diff --git a/gcc/testsuite/g++.dg/cpp23/ext-floating2.C b/gcc/testsuite/g++.dg/cpp23/ext-floating2.C
index 41e9a54ada5..6ae5c6cd247 100644
--- a/gcc/testsuite/g++.dg/cpp23/ext-floating2.C
+++ b/gcc/testsuite/g++.dg/cpp23/ext-floating2.C
@@ -1,6 +1,10 @@
 // P1467R9 - Extended floating-point types and standard names.
 // { dg-do compile { target c++23 } }
 // { dg-options "" }
+// { dg-add-options float16 }
+// { dg-add-options float32 }
+// { dg-add-options float64 }
+// { dg-add-options float128 }
 
 #include "ext-floating.h"
 
diff --git a/gcc/testsuite/g++.dg/vect/pr109573.cc b/gcc/testsuite/g++.dg/vect/pr109573.cc
new file mode 100644
index 00000000000..d96f86f9579
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr109573.cc
@@ -0,0 +1,91 @@
+// { dg-do compile }
+// { dg-require-effective-target c++20 }
+
+void *operator new(__SIZE_TYPE__, void *__p) { return __p; }
+template <typename _Head> struct _Head_base {
+  _Head _M_head_impl;
+};
+template <unsigned long, typename...> struct _Tuple_impl;
+template <unsigned long _Idx, typename _Head, typename... _Tail>
+struct _Tuple_impl<_Idx, _Head, _Tail...> : _Tuple_impl<_Idx + 1, _Tail...>,
+                                            _Head_base<_Head> {
+  template <typename _UHead, typename... _UTail>
+  _Tuple_impl(_UHead __head, _UTail... __tail)
+      : _Tuple_impl<_Idx + 1, _Tail...>(__tail...), _Head_base<_Head>(__head) {}
+};
+template <unsigned long _Idx, typename _Head> struct _Tuple_impl<_Idx, _Head> {
+  template <typename _UHead> _Tuple_impl(_UHead);
+};
+template <typename... _Elements> struct tuple : _Tuple_impl<0, _Elements...> {
+  template <typename... _UElements>
+  tuple(_UElements... __elements)
+      : _Tuple_impl<0, _Elements...>(__elements...) {}
+};
+unsigned long position_;
+struct Zone {
+  template <typename T, typename... Args> T *New(Args... args) {
+    return new (reinterpret_cast<void *>(position_)) T(args...);
+  }
+};
+struct Label {
+  int pos_;
+  int near_link_pos_;
+};
+enum Condition { below_equal };
+void bind(Label *);
+Zone *zone();
+unsigned long deopt_info_address();
+int MakeDeferredCode___trans_tmp_2, MakeDeferredCode___trans_tmp_3,
+    Prologue___trans_tmp_6, MakeDeferredCode___trans_tmp_1;
+struct MaglevAssembler {
+  template <typename Function, typename... Args>
+  void MakeDeferredCode(Function &&, Args &&...);
+  template <typename Function, typename... Args>
+  void JumpToDeferredIf(Condition, Function, Args... args) {
+    MakeDeferredCode(Function(), args...);
+  }
+  void Prologue();
+};
+struct ZoneLabelRef {
+  ZoneLabelRef(Zone *zone) : label_(zone->New<Label>()) {}
+  ZoneLabelRef(MaglevAssembler *) : ZoneLabelRef(zone()) {}
+  Label *operator*() { return label_; }
+  Label *label_;
+};
+template <typename Function>
+struct FunctionArgumentsTupleHelper
+    : FunctionArgumentsTupleHelper<decltype(&Function::operator())> {};
+template <typename C, typename R, typename... A>
+struct FunctionArgumentsTupleHelper<R (C::*)(A...) const> {
+  using Tuple = tuple<A...>;
+};
+template <typename> struct StripFirstTupleArg;
+template <typename T1, typename... T>
+struct StripFirstTupleArg<tuple<T1, T...>> {
+  using Stripped = tuple<T...>;
+};
+template <typename Function> struct DeferredCodeInfoImpl {
+  template <typename... InArgs>
+  DeferredCodeInfoImpl(int *, int, int, Function, InArgs... args)
+      : args(args...) {}
+  StripFirstTupleArg<
+      typename FunctionArgumentsTupleHelper<Function>::Tuple>::Stripped args;
+};
+template <typename Function, typename... Args>
+void MaglevAssembler::MakeDeferredCode(Function &&deferred_code_gen,
+                                       Args &&...args) {
+  zone()->New<DeferredCodeInfoImpl<Function>>(
+      &MakeDeferredCode___trans_tmp_1, MakeDeferredCode___trans_tmp_2,
+      MakeDeferredCode___trans_tmp_3, deferred_code_gen, args...);
+}
+void MaglevAssembler::Prologue() {
+  int *__trans_tmp_9;
+  ZoneLabelRef deferred_call_stack_guard_return(this);
+  __trans_tmp_9 = reinterpret_cast<int *>(deopt_info_address());
+  JumpToDeferredIf(
+      below_equal, [](MaglevAssembler, int *, ZoneLabelRef, int, int) {},
+      __trans_tmp_9, deferred_call_stack_guard_return, Prologue___trans_tmp_6,
+      0);
+  Label __trans_tmp_7 = **deferred_call_stack_guard_return;
+  bind(&__trans_tmp_7);
+}
diff --git a/gcc/testsuite/gcc.dg/goacc/pr107041.c b/gcc/testsuite/gcc.dg/goacc/pr107041.c
new file mode 100644
index 00000000000..ed7fb5a5b5d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/goacc/pr107041.c
@@ -0,0 +1,23 @@
+/* PR c/107041 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wenum-int-mismatch" } */
+
+typedef enum acc_device_t {
+  acc_device_current = -1,
+  acc_device_none = 0,
+  acc_device_default = 1,
+  acc_device_host = 2,
+  acc_device_not_host = 4,
+  acc_device_nvidia = 5,
+  acc_device_radeon = 8,
+  _ACC_highest = __INT_MAX__
+} acc_device_t;
+
+int acc_on_device (acc_device_t);		/* { dg-bogus "conflicting types for 'acc_on_device' due to enum/integer mismatch; have 'int\\\(acc_device_t\\\)'" } */
+int acc_on_device (acc_device_t);
+
+int
+foo (void)
+{
+  return acc_on_device (acc_device_host);
+}
diff --git a/gcc/testsuite/gcc.dg/pr109409.c b/gcc/testsuite/gcc.dg/pr109409.c
new file mode 100644
index 00000000000..097a511c07e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr109409.c
@@ -0,0 +1,10 @@
+/* PR c/109409 */
+/* { dg-do compile } */
+/* { dg-options "-Wall" } */
+
+void
+foo (int n)
+{
+  const char c[n] = "1";	/* { dg-error "variable-sized object may not be initialized except with an empty initializer" } */
+  __builtin_printf (c);
+}
diff --git a/gcc/testsuite/gcc.dg/pr109412.c b/gcc/testsuite/gcc.dg/pr109412.c
new file mode 100644
index 00000000000..11adce52509
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr109412.c
@@ -0,0 +1,20 @@
+/* PR c/107682 */
+/* PR c/109412 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+char bar () = {};	/* { dg-error "function 'bar' is initialized like a variable" } */
+			/* { dg-error "invalid initializer" "" { target *-*-* } .-1 } */
+			/* { dg-message "near initialization for 'bar'" "" { target *-*-* } .-2 } */
+char baz () = { 1 };	/* { dg-error "function 'baz' is initialized like a variable" } */
+			/* { dg-error "invalid initializer" "" { target *-*-* } .-1 } */
+			/* { dg-message "near initialization for 'baz'" "" { target *-*-* } .-2 } */
+void
+foo ()
+{
+  int qux () = {};	/* { dg-error "function 'qux' is initialized like a variable" } */
+			/* { dg-error "invalid initializer" "" { target *-*-* } .-1 } */
+			/* { dg-message "near initialization for 'qux'" "" { target *-*-* } .-2 } */
+  int corge () = { 1 };	/* { dg-error "function 'corge' is initialized like a variable" } */
+			/* { dg-error "invalid initializer" "" { target *-*-* } .-1 } */
+}			/* { dg-message "near initialization for 'corge'" "" { target *-*-* } .-2 } */
diff --git a/gcc/testsuite/gcc.dg/torture/pr109585.c b/gcc/testsuite/gcc.dg/torture/pr109585.c
new file mode 100644
index 00000000000..f92de7c1f2e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr109585.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+struct P {
+    long v;
+    struct P *n;
+};
+
+struct F {
+    long x;
+    struct P fam[];
+};
+
+int __attribute__((noipa))
+f(struct F *f, int i)
+{
+  struct P *p = f->fam;
+  asm("" : "+r"(f): "r"(p));
+  p->v = 0;
+  p->n = 0;
+  return f->fam->n != 0;
+}
+
+int
+main()
+{
+  struct F *m = malloc (sizeof (long) + 2 * sizeof (struct P));
+  m->fam[0].n = &m->fam[1];
+  if (f (m, 0))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr109609.c b/gcc/testsuite/gcc.dg/torture/pr109609.c
new file mode 100644
index 00000000000..0e191cd1ee8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr109609.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+#define N 23
+#define MAX_LEN 13
+char dst[N + 1];
+
+void __attribute__((noipa))
+invert(const char *id)
+{
+  char buf[MAX_LEN];
+  char *ptr = buf + sizeof(buf);  // start from the end of buf
+  *(--ptr) = '\0';                // terminate string
+  while (*id && ptr > buf) {
+    *(--ptr) = *(id++);           // copy id backwards
+  }
+  __builtin_strncpy(dst, ptr, N);           // copy ptr/buf to dst
+}
+
+
+int main()
+{
+  invert("abcde");
+  if (__builtin_strcmp(dst, "edcba"))
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/gcn/fpdiv.c b/gcc/testsuite/gcc.target/gcn/fpdiv.c
index 7125b6f6ba0..936d39cf98e 100644
--- a/gcc/testsuite/gcc.target/gcn/fpdiv.c
+++ b/gcc/testsuite/gcc.target/gcn/fpdiv.c
@@ -1,5 +1,4 @@
 /* { dg-do run } */
-/* { dg-options "-ffast-math" } */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index ad68af51f91..868e2c4f092 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -8555,7 +8555,8 @@ proc check_effective_target_vect_call_copysignf { } {
     return [check_cached_effective_target_indexed vect_call_copysignf {
       expr { [istarget i?86-*-*] || [istarget x86_64-*-*]
 	     || [istarget powerpc*-*-*]
-	     || [istarget aarch64*-*-*] }}]
+	     || [istarget aarch64*-*-*]
+             || [istarget amdgcn-*-*] }}]
 }
 
 # Return 1 if the target supports hardware square root instructions.
@@ -8591,7 +8592,8 @@ proc check_effective_target_vect_call_sqrtf { } {
 	     || [istarget i?86-*-*] || [istarget x86_64-*-*]
 	     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])
 	     || ([istarget s390*-*-*]
-		 && [check_effective_target_s390_vx]) }}]
+		 && [check_effective_target_s390_vx])
+             || [istarget amdgcn-*-*] }}]
 }
 
 # Return 1 if the target supports vector lrint calls.
@@ -8636,14 +8638,16 @@ proc check_effective_target_vect_call_ceil { } {
 
 proc check_effective_target_vect_call_ceilf { } {
     return [check_cached_effective_target_indexed vect_call_ceilf {
-      expr { [istarget aarch64*-*-*] }}]
+      expr { [istarget aarch64*-*-*]
+	     || [istarget amdgcn-*-*] }}]
 }
 
 # Return 1 if the target supports vector floor calls.
 
 proc check_effective_target_vect_call_floor { } {
     return [check_cached_effective_target_indexed vect_call_floor {
-      expr { [istarget aarch64*-*-*] }}]
+      expr { [istarget aarch64*-*-*]
+	     || [istarget amdgcn-*-*] }}]
 }
 
 # Return 1 if the target supports vector floorf calls.
@@ -8699,7 +8703,8 @@ proc check_effective_target_vect_call_roundf { } {
 # Return 1 if the target supports AND, OR and XOR reduction.
 
 proc check_effective_target_vect_logical_reduc { } {
-    return [check_effective_target_aarch64_sve]
+    return [expr { [check_effective_target_aarch64_sve]
+	           || [istarget amdgcn-*-*] }]
 }
 
 # Return 1 if the target supports the fold_extract_last optab.
diff --git a/gcc/tree-ssa-alias.cc b/gcc/tree-ssa-alias.cc
index 81bc51ed4ad..e0693e146bf 100644
--- a/gcc/tree-ssa-alias.cc
+++ b/gcc/tree-ssa-alias.cc
@@ -1330,7 +1330,7 @@ aliasing_component_refs_p (tree ref1,
   /* If we didn't find a common base, try the other way around.  */
   if (cmp_outer <= 0 
       || (end_struct_ref1
-	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))
+	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type2) <= 0))
     {
       int res = aliasing_component_refs_walk (ref2, type2, base2,
 					      offset2, max_size2,
@@ -2726,9 +2726,21 @@ check_fnspec (gcall *call, ao_ref *ref, bool clobber)
 		      t = TREE_CHAIN (t);
 		    size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_VALUE (t)));
 		  }
-		ao_ref_init_from_ptr_and_size (&dref,
-					       gimple_call_arg (call, i),
-					       size);
+		poly_int64 size_hwi;
+		if (size
+		    && poly_int_tree_p (size, &size_hwi)
+		    && coeffs_in_range_p (size_hwi, 0,
+					  HOST_WIDE_INT_MAX / BITS_PER_UNIT))
+		  {
+		    size_hwi = size_hwi * BITS_PER_UNIT;
+		    ao_ref_init_from_ptr_and_range (&dref,
+						    gimple_call_arg (call, i),
+						    true, 0, -1, size_hwi);
+		  }
+		else
+		  ao_ref_init_from_ptr_and_range (&dref,
+						  gimple_call_arg (call, i),
+						  false, 0, -1, -1);
 		if (refs_may_alias_p_1 (&dref, ref, false))
 		  return 1;
 	      }
diff --git a/gcc/tree-vect-loop.cc b/gcc/tree-vect-loop.cc
index ba28214f09a..6ea0f21fd13 100644
--- a/gcc/tree-vect-loop.cc
+++ b/gcc/tree-vect-loop.cc
@@ -10114,9 +10114,10 @@ vectorizable_live_operation (vec_info *vinfo,
 						use_stmt))
 	      {
 		enum tree_code code = gimple_assign_rhs_code (use_stmt);
-		gcc_assert (code == CONSTRUCTOR
-			    || code == VIEW_CONVERT_EXPR
-			    || CONVERT_EXPR_CODE_P (code));
+		gcc_checking_assert (code == SSA_NAME
+				     || code == CONSTRUCTOR
+				     || code == VIEW_CONVERT_EXPR
+				     || CONVERT_EXPR_CODE_P (code));
 		if (dump_enabled_p ())
 		  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
 				   "Using original scalar computation for "
diff --git a/gnattools/ChangeLog b/gnattools/ChangeLog
index 97676c998c1..529ecd9b163 100644
--- a/gnattools/ChangeLog
+++ b/gnattools/ChangeLog
@@ -1,3 +1,9 @@
+2023-04-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* configure.ac (TOOLS_TARGET_PAIRS): Remove obsolete settings.
+	(EXTRA_GNATTOOLS): Likewise.
+	* configure: Regenerate.
+
 2023-04-26  Release Manager
 
 	* GCC 13.1.0 released.
diff --git a/gnattools/configure b/gnattools/configure
index 423527da1b6..6cdfbe67af2 100755
--- a/gnattools/configure
+++ b/gnattools/configure
@@ -2052,74 +2052,38 @@ fi
 
 # Target-specific stuff (defaults)
 TOOLS_TARGET_PAIRS=
-
 EXTRA_GNATTOOLS=
 
-
 # Per-target case statement
 # -------------------------
 case "${target}" in
   *-*-aix*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \
-    indepsw.adb<indepsw-aix.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-aix.adb"
     ;;
   *-*-darwin*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
-    indepsw.adb<indepsw-darwin.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-darwin.adb"
     ;;
   *-*-dragonfly*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-freebsd*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-linux*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  *-*-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-vxworks*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb"
-    ;;
-  ia64-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-ia64-hpux.adb"
-    ;;
-  alpha*-*-vms* | alpha*-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-alpha.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
-    ;;
-  ia64-*-vms* | ia64-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-ia64.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \
-    indepsw.adb<indepsw-mingw.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
 esac
 
+
+
+
 # From user or toplevel makefile.
 
 
diff --git a/gnattools/configure.ac b/gnattools/configure.ac
index 5b6f34ed9f4..38a28b6ee62 100644
--- a/gnattools/configure.ac
+++ b/gnattools/configure.ac
@@ -53,74 +53,38 @@ AC_PROG_LN_S
 
 # Target-specific stuff (defaults)
 TOOLS_TARGET_PAIRS=
-AC_SUBST(TOOLS_TARGET_PAIRS)
 EXTRA_GNATTOOLS=
-AC_SUBST(EXTRA_GNATTOOLS)
 
 # Per-target case statement
 # -------------------------
 case "${target}" in
   *-*-aix*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \
-    indepsw.adb<indepsw-aix.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-aix.adb"
     ;;
   *-*-darwin*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
-    indepsw.adb<indepsw-darwin.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-darwin.adb"
     ;;
   *-*-dragonfly*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-freebsd*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-linux*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  *-*-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-vxworks*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb"
-    ;;
-  ia64-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-ia64-hpux.adb"
-    ;;
-  alpha*-*-vms* | alpha*-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-alpha.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
-    ;;
-  ia64-*-vms* | ia64-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-ia64.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \
-    indepsw.adb<indepsw-mingw.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
 esac
 
+AC_SUBST(TOOLS_TARGET_PAIRS)
+AC_SUBST(EXTRA_GNATTOOLS)
+
 # From user or toplevel makefile.
 AC_SUBST(ADA_CFLAGS)
 
diff --git a/libstdc++-v3/doc/doxygen/user.cfg.in b/libstdc++-v3/doc/doxygen/user.cfg.in
index 31613f51517..9d814af8614 100644
--- a/libstdc++-v3/doc/doxygen/user.cfg.in
+++ b/libstdc++-v3/doc/doxygen/user.cfg.in
@@ -1217,7 +1217,7 @@ USE_MDFILE_AS_MAINPAGE =
 # also VERBATIM_HEADERS is set to NO.
 # The default value is: NO.
 
-SOURCE_BROWSER         = YES
+SOURCE_BROWSER         = @do_html@
 
 # Setting the INLINE_SOURCES tag to YES will include the body of functions,
 # classes and enums directly into the documentation.
diff --git a/libstdc++-v3/include/bits/gslice_array.h b/libstdc++-v3/include/bits/gslice_array.h
index f117a172678..6a48d418477 100644
--- a/libstdc++-v3/include/bits/gslice_array.h
+++ b/libstdc++-v3/include/bits/gslice_array.h
@@ -183,6 +183,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Array<size_t>(_M_index));
       }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -214,6 +215,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/indirect_array.h b/libstdc++-v3/include/bits/indirect_array.h
index deeed99893c..8d34a365799 100644
--- a/libstdc++-v3/include/bits/indirect_array.h
+++ b/libstdc++-v3/include/bits/indirect_array.h
@@ -174,6 +174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       indirect_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
       { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -203,6 +204,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/mask_array.h b/libstdc++-v3/include/bits/mask_array.h
index d4112a9d0a3..a3174dd7074 100644
--- a/libstdc++-v3/include/bits/mask_array.h
+++ b/libstdc++-v3/include/bits/mask_array.h
@@ -181,6 +181,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	std::__valarray_copy(__e, __e.size(), _M_array, _M_mask);
       }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -213,6 +214,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/mofunc_impl.h b/libstdc++-v3/include/bits/mofunc_impl.h
index 47e1e506306..318a55e618f 100644
--- a/libstdc++-v3/include/bits/mofunc_impl.h
+++ b/libstdc++-v3/include/bits/mofunc_impl.h
@@ -51,14 +51,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @headerfile functional
    *
    *  The `std::move_only_function` class template is a call wrapper similar
-   *  to *  `std::function`, but does not require the stored target function
+   *  to `std::function`, but does not require the stored target function
    *  to be copyable.
    *
    *  It also supports const-qualification, ref-qualification, and
    *  no-throw guarantees. The qualifications and exception-specification
    *  of the `move_only_function::operator()` member function are respected
    *  when invoking the target function.
-   *
    */
   template<typename _Res, typename... _ArgTypes, bool _Noex>
     class move_only_function<_Res(_ArgTypes...) _GLIBCXX_MOF_CV
diff --git a/libstdc++-v3/include/bits/slice_array.h b/libstdc++-v3/include/bits/slice_array.h
index 571e372c292..42b136d7dce 100644
--- a/libstdc++-v3/include/bits/slice_array.h
+++ b/libstdc++-v3/include/bits/slice_array.h
@@ -245,6 +245,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     slice_array<_Tp>::operator=(const _Expr<_Dom,_Tp>& __e) const
     { std::__valarray_copy(__e, _M_sz, _M_array, _M_stride); }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op,_Name)				\
   template<typename _Tp>						\
@@ -275,6 +276,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/std/format b/libstdc++-v3/include/std/format
index e4ef4f9b6d9..6edc3208afa 100644
--- a/libstdc++-v3/include/std/format
+++ b/libstdc++-v3/include/std/format
@@ -185,7 +185,7 @@ namespace __format
   __failed_to_parse_format_spec()
   { __throw_format_error("format error: failed to parse format-spec"); }
 } // namespace __format
-/// @endcond
+  /// @endcond
 
   // [format.parse.ctx], class template basic_format_parse_context
   template<typename _CharT> class basic_format_parse_context;
@@ -3870,7 +3870,7 @@ namespace __format
     };
 #endif
 } // namespace __format
-/// @@endcond
+/// @endcond
 
   template<typename... _Args>
     [[nodiscard]]
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index 504d02b7359..6bd23e0914b 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -1080,6 +1080,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return _Expr<_Closure, _Tp>(_Closure(*this, __func));
     }
 
+  /// @cond undocumented
 #define _DEFINE_VALARRAY_UNARY_OPERATOR(_Op, _Name)                     \
   template<typename _Tp>						\
     inline typename valarray<_Tp>::template _UnaryOp<_Name>::_Rt	\
@@ -1206,6 +1207,7 @@ _DEFINE_BINARY_OPERATOR(<=, __less_equal)
 _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
 
 #undef _DEFINE_BINARY_OPERATOR
+  /// @endcond
 
 #if __cplusplus >= 201103L
   /**
