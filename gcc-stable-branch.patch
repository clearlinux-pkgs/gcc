Harald Anlauf (2):
      PR fortran/100154 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
      Fortran - allow target of pointer from evaluation of function-reference

Jakub Jelinek (8):
      Bump BASE-VER
      cprop: Fix -fcompare-debug bug in constprop_register [PR100148]
      testsuite: Add -fchecking to dg-ice tests
      vmsdbgout: Remove useless register keywords
      cfgcleanup: Fix -fcompare-debug issue in outgoing_edges_match [PR100254]
      veclower: Fix up vec_shl matching of VEC_PERM_EXPR [PR100239]
      aarch64: Fix UB in the compiler [PR100200]
      aarch64: Fix up last commit [PR100200]

Marek Polacek (2):
      c++: Don't allow defining types in enum-base [PR96380]
      c++: Prevent bogus -Wtype-limits warning with NTTP [PR100161]

Michael Meissner (1):
      Backport fix for PR target/98952

Patrick Palka (2):
      c++: do_class_deduction and dependent init [PR93383]
      libstdc++: Fix up lambda in join_view::_Iterator::operator++ [PR100290]

Tobias Burnus (1):
      libgomp/testsuite: Fix checks for dg-excess-errors

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 68d8f15e23c..668182d21a4 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.1.0
+11.1.1
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 8650fb7f264..260a896ac48 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -1885,8 +1885,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)
 
   /* Ensure the same EH region.  */
   {
-    rtx n1 = find_reg_note (BB_END (bb1), REG_EH_REGION, 0);
-    rtx n2 = find_reg_note (BB_END (bb2), REG_EH_REGION, 0);
+    rtx n1 = find_reg_note (last1, REG_EH_REGION, 0);
+    rtx n2 = find_reg_note (last2, REG_EH_REGION, 0);
 
     if (!n1 && n2)
       return false;
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 12625a4bee3..e979a51f3af 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -10778,7 +10778,7 @@ aarch64_print_operand (FILE *f, rtx x, int code)
 	}
 
       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)
-	asm_fprintf (f, "%wd", -INTVAL (elt));
+	asm_fprintf (f, "%wd", (HOST_WIDE_INT) -UINTVAL (elt));
       else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_FLOAT
 	       && aarch64_print_vector_float_operand (f, x, true))
 	;
@@ -21598,7 +21598,7 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
     case MINUS:
       if (CONST_INT_P (value))
 	{
-	  value = GEN_INT (-INTVAL (value));
+	  value = GEN_INT (-UINTVAL (value));
 	  code = PLUS;
 	}
       /* Fall through.  */
@@ -23514,7 +23514,7 @@ aarch64_expand_subvti (rtx op0, rtx low_dest, rtx low_in1,
     {
       if (aarch64_plus_immediate (low_in2, DImode))
 	emit_insn (gen_subdi3_compare1_imm (low_dest, low_in1, low_in2,
-					    GEN_INT (-INTVAL (low_in2))));
+					    GEN_INT (-UINTVAL (low_in2))));
       else
 	{
 	  low_in2 = force_reg (DImode, low_in2);
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index abfd8452674..aef6da9732d 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -747,7 +747,8 @@
 	   constant can be represented in SImode, this is important
 	   for the corner case where operand[1] is INT_MIN.  */
 
-	operands[1] = GEN_INT (trunc_int_for_mode (-INTVAL (operands[1]), SImode));
+	operands[1]
+	  = GEN_INT (trunc_int_for_mode (-UINTVAL (operands[1]), SImode));
 
 	if (!(*insn_data[CODE_FOR_addsi3].operand[2].predicate)
 	      (operands[1], SImode))
@@ -5008,7 +5009,7 @@
     /* (SZ - cnt) % SZ == -cnt % SZ */
     if (CONST_INT_P (operands[2]))
       {
-        operands[2] = GEN_INT ((-INTVAL (operands[2]))
+        operands[2] = GEN_INT ((-UINTVAL (operands[2]))
 			       & (GET_MODE_BITSIZE (<MODE>mode) - 1));
         if (operands[2] == const0_rtx)
           {
diff --git a/gcc/config/aarch64/predicates.md b/gcc/config/aarch64/predicates.md
index c55842b9c74..49f02ae0381 100644
--- a/gcc/config/aarch64/predicates.md
+++ b/gcc/config/aarch64/predicates.md
@@ -121,12 +121,12 @@
 
 (define_predicate "aarch64_sub_immediate"
   (and (match_code "const_int")
-       (match_test "aarch64_uimm12_shift (-INTVAL (op))")))
+       (match_test "aarch64_uimm12_shift (-UINTVAL (op))")))
 
 (define_predicate "aarch64_plus_immediate"
   (and (match_code "const_int")
        (ior (match_test "aarch64_uimm12_shift (INTVAL (op))")
-	    (match_test "aarch64_uimm12_shift (-INTVAL (op))"))))
+	    (match_test "aarch64_uimm12_shift (-UINTVAL (op))"))))
 
 (define_predicate "aarch64_plus_operand"
   (ior (match_operand 0 "register_operand")
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 99eccf0c5e4..fba516efa23 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -19942,6 +19942,10 @@ cp_parser_enum_specifier (cp_parser* parser)
       /* Consume the `:'.  */
       cp_lexer_consume_token (parser->lexer);
 
+      auto tdf
+	= make_temp_override (parser->type_definition_forbidden_message,
+			      G_("types may not be defined in enum-base"));
+
       /* Parse the type-specifier-seq.  */
       cp_parser_type_specifier_seq (parser, CP_PARSER_FLAGS_NONE,
 				    /*is_declaration=*/false,
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 19fdafa4c43..d30876ced9c 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -19900,15 +19900,21 @@ tsubst_copy_and_build (tree t,
     case MEMBER_REF:
     case DOTSTAR_EXPR:
       {
-	/* If T was type-dependent, suppress warnings that depend on the range
-	   of the types involved.  */
-	++processing_template_decl;
-	const bool was_dep = (potential_constant_expression (t)
-			      ? value_dependent_expression_p (t)
-			      : type_dependent_expression_p (t));
-	--processing_template_decl;
-	tree op0 = RECUR (TREE_OPERAND (t, 0));
-	tree op1 = RECUR (TREE_OPERAND (t, 1));
+	/* If either OP0 or OP1 was value- or type-dependent, suppress
+	   warnings that depend on the range of the types involved.  */
+	tree op0 = TREE_OPERAND (t, 0);
+	tree op1 = TREE_OPERAND (t, 1);
+	auto dep_p = [](tree t) {
+	  ++processing_template_decl;
+	  bool r = (potential_constant_expression (t)
+		    ? value_dependent_expression_p (t)
+		    : type_dependent_expression_p (t));
+	  --processing_template_decl;
+	  return r;
+	};
+	const bool was_dep = dep_p (op0) || dep_p (op1);
+	op0 = RECUR (op0);
+	op1 = RECUR (op1);
 
 	warning_sentinel s1(warn_type_limits, was_dep);
 	warning_sentinel s2(warn_div_by_zero, was_dep);
@@ -29356,6 +29362,10 @@ do_class_deduction (tree ptype, tree tmpl, tree init,
       return error_mark_node;
     }
 
+  /* Wait until the initializer is non-dependent.  */
+  if (type_dependent_expression_p (init))
+    return ptype;
+
   tree type = TREE_TYPE (tmpl);
 
   bool try_list_ctor = false;
diff --git a/gcc/cprop.c b/gcc/cprop.c
index 73034ce72d0..6f34f6b2418 100644
--- a/gcc/cprop.c
+++ b/gcc/cprop.c
@@ -1007,16 +1007,18 @@ static int
 constprop_register (rtx from, rtx src, rtx_insn *insn)
 {
   rtx sset;
+  rtx_insn *next_insn;
 
   /* Check for reg or cc0 setting instructions followed by
      conditional branch instructions first.  */
   if ((sset = single_set (insn)) != NULL
-      && NEXT_INSN (insn)
-      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))
+      && (next_insn = next_nondebug_insn (insn)) != NULL
+      && any_condjump_p (next_insn)
+      && onlyjump_p (next_insn))
     {
       rtx dest = SET_DEST (sset);
       if ((REG_P (dest) || CC0_P (dest))
-	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn),
+	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, next_insn,
 			 from, src))
 	return 1;
     }
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 82db8e4e1b2..27bf3a7eafe 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -1055,6 +1055,13 @@ variable_check (gfc_expr *e, int n, bool allow_proc)
 	  return true;
     }
 
+  /* F2018:R902: function reference having a data pointer result.  */
+  if (e->expr_type == EXPR_FUNCTION
+      && e->symtree->n.sym->attr.flavor == FL_PROCEDURE
+      && e->symtree->n.sym->attr.function
+      && e->symtree->n.sym->attr.pointer)
+    return true;
+
   gfc_error ("%qs argument of %qs intrinsic at %L must be a variable",
 	     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic, &e->where);
 
@@ -5689,6 +5696,19 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)
 /* Functions for checking FGETC, FPUTC, FGET and FPUT (subroutines and
    functions).  */
 
+bool
+arg_strlen_is_zero (gfc_expr *c, int n)
+{
+  if (gfc_var_strlen (c) == 0)
+    {
+      gfc_error ("%qs argument of %qs intrinsic at %L must have "
+		 "length at least 1", gfc_current_intrinsic_arg[n]->name,
+		 gfc_current_intrinsic, &c->where);
+      return true;
+    }
+  return false;
+}
+
 bool
 gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)
 {
@@ -5702,13 +5722,19 @@ gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)
     return false;
   if (!kind_value_check (c, 1, gfc_default_character_kind))
     return false;
+  if (strcmp (gfc_current_intrinsic, "fgetc") == 0
+      && !variable_check (c, 1, false))
+    return false;
+  if (arg_strlen_is_zero (c, 1))
+    return false;
 
   if (status == NULL)
     return true;
 
   if (!type_check (status, 2, BT_INTEGER)
       || !kind_value_check (status, 2, gfc_default_integer_kind)
-      || !scalar_check (status, 2))
+      || !scalar_check (status, 2)
+      || !variable_check (status, 2, false))
     return false;
 
   return true;
@@ -5729,13 +5755,19 @@ gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)
     return false;
   if (!kind_value_check (c, 0, gfc_default_character_kind))
     return false;
+  if (strcmp (gfc_current_intrinsic, "fget") == 0
+      && !variable_check (c, 0, false))
+    return false;
+  if (arg_strlen_is_zero (c, 0))
+    return false;
 
   if (status == NULL)
     return true;
 
   if (!type_check (status, 1, BT_INTEGER)
       || !kind_value_check (status, 1, gfc_default_integer_kind)
-      || !scalar_check (status, 1))
+      || !scalar_check (status, 1)
+      || !variable_check (status, 1, false))
     return false;
 
   return true;
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 92a6700568d..956003ec605 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -6121,7 +6121,9 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,
     }
   if (!pointer && sym->attr.flavor != FL_VARIABLE
       && !(sym->attr.flavor == FL_PROCEDURE && sym == sym->result)
-      && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.proc_pointer))
+      && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.proc_pointer)
+      && !(sym->attr.flavor == FL_PROCEDURE
+	   && sym->attr.function && sym->attr.pointer))
     {
       if (context)
 	gfc_error ("%qs in variable definition context (%s) at %L is not"
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 17fd92eb462..219f04f2317 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -3460,7 +3460,7 @@ add_subroutines (void)
   /* Argument names.  These are used as argument keywords and so need to
      match the documentation.  Please keep this list in sorted order.  */
   static const char
-    *a = "a", *c = "count", *cm = "count_max", *com = "command",
+    *a = "a", *c_ = "c", *c = "count", *cm = "count_max", *com = "command",
     *cr = "count_rate", *dt = "date", *errmsg = "errmsg", *f = "from",
     *fp = "frompos", *gt = "get", *h = "harvest", *han = "handler",
     *length = "length", *ln = "len", *md = "mode", *msk = "mask",
@@ -3840,12 +3840,12 @@ add_subroutines (void)
   add_sym_3s ("fgetc", GFC_ISYM_FGETC, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetputc_sub, NULL, gfc_resolve_fgetc_sub,
 	      ut, BT_INTEGER, di, REQUIRED, INTENT_IN,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_2s ("fget", GFC_ISYM_FGET, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetput_sub, NULL, gfc_resolve_fget_sub,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_OUT,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_1s ("flush", GFC_ISYM_FLUSH, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
@@ -3855,12 +3855,12 @@ add_subroutines (void)
   add_sym_3s ("fputc", GFC_ISYM_FPUTC, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetputc_sub, NULL, gfc_resolve_fputc_sub,
 	      ut, BT_INTEGER, di, REQUIRED, INTENT_IN,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_2s ("fput", GFC_ISYM_FPUT, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
 	      gfc_check_fgetput_sub, NULL, gfc_resolve_fput_sub,
-	      c, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
+	      c_, BT_CHARACTER, dc, REQUIRED, INTENT_IN,
 	      st, BT_INTEGER, di, OPTIONAL, INTENT_OUT);
 
   add_sym_1s ("free", GFC_ISYM_FREE, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,
diff --git a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
index d770b91dd09..8c3884bdc00 100644
--- a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
+++ b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c
@@ -1,7 +1,7 @@
 /* Test OpenACC 'kernels' construct decomposition.  */
 
 /* { dg-additional-options "-fopt-info-omp-all" } */
-/* { dg-additional-options "--param=openacc-kernels=decompose" } */
+/* { dg-additional-options "-fchecking --param=openacc-kernels=decompose" } */
 /* { dg-ice "TODO" }
    { dg-prune-output "during GIMPLE pass: omplower" } */
 
diff --git a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
index ae059eb354b..8bf60a9a509 100644
--- a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
+++ b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c
@@ -1,6 +1,6 @@
 /* Test OpenACC 'kernels' construct decomposition.  */
 
-/* { dg-additional-options "--param=openacc-kernels=decompose" } */
+/* { dg-additional-options "-fchecking --param=openacc-kernels=decompose" } */
 /* { dg-ice "TODO" }
    { dg-prune-output "during GIMPLE pass: omplower" } */
 
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
index 2c9d2f9b329..eae0d8c377b 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-52830.C
@@ -1,5 +1,6 @@
 // PR c++/52830
 // { dg-do compile { target c++11 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "comptypes" }
 
 template<bool b> struct eif { typedef void type; };
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum_base4.C b/gcc/testsuite/g++.dg/cpp0x/enum_base4.C
new file mode 100644
index 00000000000..b3015256386
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum_base4.C
@@ -0,0 +1,8 @@
+// PR c++/96380
+// { dg-do compile { target c++11 } }
+
+extern const int a, b;
+enum struct c;
+template <class>
+enum struct c : union enum struct c { e = b, f = a };  // { dg-error "types may not be defined|expected|elaborated-type-specifier" }
+enum class c {};
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum_base5.C b/gcc/testsuite/g++.dg/cpp0x/enum_base5.C
new file mode 100644
index 00000000000..c01e857e612
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum_base5.C
@@ -0,0 +1,7 @@
+// PR c++/96380
+// { dg-do compile { target c++11 } }
+
+extern const int a, b;
+enum struct c;
+template <class>
+enum struct c : union enum struct c { e = b, f = a }; // { dg-error "types may not be defined|expected|elaborated-type-specifier" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/vt-88982.C b/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
index cb9530dcee1..7a868233d73 100644
--- a/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
+++ b/gcc/testsuite/g++.dg/cpp0x/vt-88982.C
@@ -1,5 +1,6 @@
 // PR c++/88982
 // { dg-do compile { target c++11 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "tsubst_pack_expansion" }
 
 template<typename...Ts> struct A {
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
index c24c3b85d78..bed5ea0cfc0 100644
--- a/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn61.C
@@ -1,5 +1,6 @@
 // PR c++/88003
 // { dg-do compile { target c++14 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "poplevel_class" }
 
 auto test() {
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
index d6c8bae525f..0cdb400d21c 100644
--- a/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C
@@ -1,5 +1,6 @@
 // PR c++/87765
 // { dg-do compile { target c++17 } }
+// { dg-additional-options "-fchecking" }
 // { dg-ice "cxx_eval_constant_expression" }
 
 template <int N>
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
index f5f79a71ec2..9b4da4f02ea 100644
--- a/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class39.C
@@ -1,6 +1,5 @@
 // PR c++/89565
 // { dg-do compile { target c++20 } }
-// { dg-ice "resolve_args" }
 
 template <auto>
 struct N{};
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class45.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class45.C
new file mode 100644
index 00000000000..e7addf5f291
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class45.C
@@ -0,0 +1,32 @@
+// PR c++/99200
+// { dg-do compile { target c++20 } }
+
+template <int N>
+struct A
+{
+  constexpr A (const char (&s)[N]) { for (int i = 0; i < N; i++) v[i] = s[i]; v[N] = 0; }
+  char v[N + 1];
+};
+
+template <A s>
+struct B
+{
+  constexpr operator const char *() { return s.v; }
+};
+
+template <typename T>
+const char *
+foo ()
+{ 
+  return B<__PRETTY_FUNCTION__>{};
+}
+
+template <typename T>
+const char *
+bar ()
+{ 
+  return B<__FUNCTION__>{};
+}
+
+auto a = foo <int> ();
+auto b = bar <double> ();
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class46.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class46.C
new file mode 100644
index 00000000000..d91e800424f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class46.C
@@ -0,0 +1,11 @@
+// PR c++/93383
+// { dg-do compile { target c++20 } }
+
+template <int> struct A {};
+
+template <A a> struct B {
+  void foo(B<+a>);
+  void bar(B<a.x>);
+  template <class T> using type = B<T{}>;
+  template <class> static inline auto y = A{0}; // { dg-error "deduction|no match" }
+};
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class47.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class47.C
new file mode 100644
index 00000000000..1f31b9bd530
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class47.C
@@ -0,0 +1,11 @@
+// PR c++/95291
+// { dg-do compile { target c++20 } }
+
+template <typename T = int>
+class xy { };
+
+template <xy _size>
+struct window_root { };
+
+template <typename minion>
+struct flip_horizontally : window_root<minion::size> { };
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class48.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class48.C
new file mode 100644
index 00000000000..9024436cad8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class48.C
@@ -0,0 +1,36 @@
+// PR c++/99683
+// { dg-do compile { target c++20 } }
+
+template<auto V>
+struct nttp_tag {};
+
+template<typename T>
+struct type_tag {};
+
+
+/************************************************/
+template<bool is_type>
+struct use_ctad
+{
+    template<auto V> requires (!is_type)
+    constexpr use_ctad(nttp_tag<V>) {}
+};
+
+template<auto V>
+use_ctad(nttp_tag<V>) -> use_ctad<false>;
+
+/**********************************************/
+template<use_ctad t>
+struct wrapper 
+{
+    template<typename Tag>
+    wrapper(Tag);
+};
+
+template<typename Tag>
+wrapper(Tag) -> wrapper<use_ctad{Tag()}>;
+
+int main()
+{
+    wrapper t{nttp_tag<42>{}};
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100148.C b/gcc/testsuite/g++.dg/opt/pr100148.C
new file mode 100644
index 00000000000..d038879b6b8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100148.C
@@ -0,0 +1,27 @@
+// PR rtl-optimization/100148
+// { dg-do compile }
+// { dg-options "-O2 -fno-dce -fno-tree-dce -fno-tree-dominator-opts -fno-tree-sink -fcompare-debug" }
+
+int i;
+enum E { } e, ee;
+
+bool
+baz (int)
+{
+  return ee;
+}
+
+bool bar ();
+bool a, b;
+
+void
+foo ()
+{
+  switch (ee)
+    {
+    case 0:
+      e = E (a ? : i);
+    case 1:
+      !(b || baz (0) && bar ());
+    }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100254.C b/gcc/testsuite/g++.dg/opt/pr100254.C
new file mode 100644
index 00000000000..dbdac1638c7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100254.C
@@ -0,0 +1,101 @@
+// PR rtl-optimization/100254
+// { dg-do compile }
+// { dg-options "-O2 -fno-guess-branch-probability -fipa-pta -fnon-call-exceptions -fcompare-debug" }
+// { dg-additional-options "-mtune=goldmont" { target i?86-*-* x86_64-*-* } }
+
+struct _Rb_tree_node_base {
+  typedef _Rb_tree_node_base *_Base_ptr;
+  typedef _Rb_tree_node_base *_Const_Base_ptr;
+  _Base_ptr _M_left;
+};
+template <typename _Key_compare> struct _Rb_tree_key_compare {
+  _Key_compare _M_key_compare;
+};
+struct _Rb_tree_header {
+  _Rb_tree_node_base _M_header;
+};
+struct _Rb_tree_iterator {
+  _Rb_tree_iterator(_Rb_tree_node_base::_Base_ptr);
+  friend bool operator==(_Rb_tree_iterator, _Rb_tree_iterator);
+};
+template <typename _Tp> struct _Rb_tree_const_iterator {
+  typedef _Rb_tree_const_iterator _Self;
+  _Rb_tree_const_iterator(_Rb_tree_node_base::_Const_Base_ptr) {}
+  _Tp operator*();
+  template <typename _Up>
+  friend bool operator!=(_Rb_tree_const_iterator<_Up>, _Rb_tree_const_iterator<_Up>);
+};
+template <typename _Key, typename _Val, typename _Compare> struct _Rb_tree {
+  template <typename _Key_compare>
+  struct _Rb_tree_impl : _Rb_tree_key_compare<_Key_compare>, _Rb_tree_header {};
+  _Rb_tree_impl<_Compare> _M_impl;
+  _Key _S_key();
+  typedef _Rb_tree_const_iterator<_Val> const_iterator;
+  const_iterator begin() { return _M_impl._M_header._M_left; }
+  _Rb_tree_iterator find(const _Key &);
+};
+template <typename _Key, typename _Val, typename _Compare>
+_Rb_tree_iterator _Rb_tree<_Key, _Val, _Compare>::find(const _Key &__k) {
+  _Rb_tree_iterator __j = 0;
+  return __j == 0 || _M_impl._M_key_compare(__k, _S_key()) ? 0 : __j;
+}
+template <typename _Key, typename _Compare = _Key> struct set {
+  typedef _Key key_type;
+  typedef _Rb_tree<key_type, _Key, _Compare> _Rep_type;
+  _Rep_type _M_t;
+  typedef typename _Rep_type::const_iterator iterator;
+  iterator begin() { return _M_t.begin(); }
+  iterator end();
+  void find(key_type __x) { _M_t.find(__x); }
+};
+struct WindowDesc {
+  WindowDesc(short);
+} _station_view_desc(0);
+struct Window {
+  void IsWidgetLowered();
+  virtual void OnClick(int, int, int);
+};
+int AllocateWindowDescFront_window_number;
+template <typename Wcls> void AllocateWindowDescFront(WindowDesc *desc, bool) {
+  Wcls(desc, AllocateWindowDescFront_window_number);
+}
+class CargoDataEntry;
+struct CargoSorter {
+  bool operator()(const CargoDataEntry *, const CargoDataEntry *) const;
+};
+struct CargoDataEntry {
+  ~CargoDataEntry();
+  char Retrieve_cargo;
+  void Retrieve() {
+    CargoDataEntry t(Retrieve_cargo);
+    children->find(&t);
+  }
+  CargoDataEntry(char);
+  set<CargoDataEntry *, CargoSorter> *children;
+};
+CargoDataEntry::CargoDataEntry(char) : children() {}
+CargoDataEntry::~CargoDataEntry() {
+  if (children)
+    for (set<CargoDataEntry *>::iterator i = children->begin();
+         i != children->end();)
+      delete *i;
+}
+bool CargoSorter::operator()(const CargoDataEntry *,
+                             const CargoDataEntry *) const { return false; }
+struct StationViewWindow : Window {
+  StationViewWindow(WindowDesc *, int);
+  CargoDataEntry HandleCargoWaitingClick_filter;
+  void OnClick(int, int widget, int) {
+    switch (widget) {
+    case 0:
+      HandleCargoWaitingClick_filter.Retrieve();
+      HandleCargoWaitingClick_filter.Retrieve();
+    case 1:
+      IsWidgetLowered();
+    }
+  }
+};
+void ShowStationViewWindow_station() {
+  AllocateWindowDescFront<StationViewWindow>(&_station_view_desc,
+                                             ShowStationViewWindow_station);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wtype-limits6.C b/gcc/testsuite/g++.dg/warn/Wtype-limits6.C
new file mode 100644
index 00000000000..9d5886d5323
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wtype-limits6.C
@@ -0,0 +1,17 @@
+// PR c++/100161
+// { dg-additional-options "-Wtype-limits" }
+
+void f(unsigned);
+
+template<unsigned n>
+void g()
+{
+    for (unsigned i = 0; i < n; i++) { // { dg-bogus "always false" }
+        f(i);
+    }
+}
+
+void h()
+{
+    g<0>();
+}
diff --git a/gcc/testsuite/gcc.dg/pr100239.c b/gcc/testsuite/gcc.dg/pr100239.c
new file mode 100644
index 00000000000..1ade810c52b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100239.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/100239 */
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+typedef short __attribute__((__vector_size__ (8 * sizeof (short)))) V;
+V v, w;
+
+void
+foo (void)
+{
+  w = __builtin_shuffle (v != v, 0 < (V) {}, (V) {192} >> 5);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr98952.c b/gcc/testsuite/gcc.target/powerpc/pr98952.c
new file mode 100644
index 00000000000..c487fbc403e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr98952.c
@@ -0,0 +1,28 @@
+/* { dg-do run { target { powerpc*-*-linux* && ilp32 } } } */
+/* { dg-options "-O2" } */
+
+/* PR 96983 reported that the test in libgcc's tramp.S was backwards and it
+   would abort if the trampoline size passed to the function was greater than
+   the size the runtime was expecting (40).  It should abort if the size is less
+   than 40, not greater than 40.  This test creates a call to __trampoline_setup
+   with a much larger buffer to make sure the function does not abort.
+
+   We do not run this test on 64-bit since __trampoline_setup is not present in
+   64-bit systems.
+
+   We only run the test under Linux in case the other systems have some
+   different variant for __trampoline_setup.  */
+
+#ifndef SIZE
+#define SIZE 100
+#endif
+
+extern void __trampoline_setup (int *, unsigned, void *, void *);
+
+int main (void)
+{
+  int tramp[SIZE / sizeof (int)];
+
+  __trampoline_setup (tramp, SIZE, 0, 0);
+  return 0;
+}
diff --git a/gcc/testsuite/gfortran.dg/pr100154.f90 b/gcc/testsuite/gfortran.dg/pr100154.f90
new file mode 100644
index 00000000000..3a1489aaab8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100154.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! PR100154 - ICE in gfc_conv_procedure_call, at fortran/trans-expr.c:6131
+
+program p
+  implicit none
+  integer           :: n
+  character, target :: c
+  character(len=0)  :: c0
+  character(len=:), allocatable :: cc
+  n = fget(cc)
+  n = fget('a')       ! { dg-error "must be a variable" }
+  n = fget(c0)        ! { dg-error "must have length at least 1" }
+  call fget('x')      ! { dg-error "must be a variable" }
+  n = fgetc(5,'a')    ! { dg-error "must be a variable" }
+  call fgetc(5,c0)    ! { dg-error "must have length at least 1" }
+  call fgetc(5,c,1)   ! { dg-error "must be a variable" }
+  call fputc(5,'x',1) ! { dg-error "must be a variable" }
+  n = fget (ptr_returning_func())
+  print *, c
+contains
+  function ptr_returning_func () result (res)
+    character, pointer :: res
+    res => c
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/ptr-func-4.f90 b/gcc/testsuite/gfortran.dg/ptr-func-4.f90
new file mode 100644
index 00000000000..62b18f6a935
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ptr-func-4.f90
@@ -0,0 +1,19 @@
+! { dg-do run }
+! { dg-options "-O2 -std=f2008" }
+! PR fortran/100218 - target of pointer from evaluation of function-reference
+
+program p
+  implicit none
+  integer, target :: z = 0
+  call g (f ())
+  if (z /= 1) stop 1
+contains
+  function f () result (r)
+    integer, pointer :: r
+    r => z
+  end function f
+  subroutine g (x)
+    integer, intent(out) :: x
+    x = 1
+  end subroutine g
+end program p
diff --git a/gcc/tree-vect-generic.c b/gcc/tree-vect-generic.c
index c8d8493e6ea..3348545d18b 100644
--- a/gcc/tree-vect-generic.c
+++ b/gcc/tree-vect-generic.c
@@ -1515,7 +1515,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)
 					      elements + i - first)
 		     : maybe_ge (poly_uint64 (indices[i]), elements))
 	      break;
-	  if (i == elements)
+	  if (first && i == elements)
 	    {
 	      gimple_assign_set_rhs3 (stmt, mask);
 	      update_stmt (stmt);
diff --git a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
index a7640004b87..c226bc69c85 100644
--- a/gcc/vmsdbgout.c
+++ b/gcc/vmsdbgout.c
@@ -365,13 +365,13 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];
 #define ASM_OUTPUT_DEBUG_STRING(FILE,P)		\
   do						\
     {						\
-      register int slen = strlen (P);		\
-      register const char *p = (P);		\
-      register int i;				\
+      int slen = strlen (P);			\
+      const char *p = (P);			\
+      int i;					\
       fprintf (FILE, "\t.ascii \"");		\
       for (i = 0; i < slen; i++)		\
 	{					\
-	  register int c = p[i];		\
+	  int c = p[i];				\
 	  if (c == '\"' || c == '\\')		\
 	    putc ('\\', FILE);			\
 	  if (c >= ' ' && c < 0177)		\
@@ -1229,7 +1229,7 @@ vmsdbgout_end_epilogue (unsigned int line, const char *file)
    a lexical block.  */
 
 static void
-vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_begin_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.begin_block) (line, blocknum);
@@ -1242,7 +1242,7 @@ vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)
    lexical block.  */
 
 static void
-vmsdbgout_end_block (register unsigned line, register unsigned blocknum)
+vmsdbgout_end_block (unsigned line, unsigned blocknum)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.end_block) (line, blocknum);
@@ -1315,8 +1315,8 @@ static unsigned int
 lookup_filename (const char *file_name)
 {
   static unsigned int last_file_lookup_index = 0;
-  register char *fn;
-  register unsigned i;
+  char *fn;
+  unsigned i;
   const char *fnam;
   long long cdt = 0;
   long ebk = 0;
@@ -1405,8 +1405,8 @@ vmsdbgout_write_source_line (unsigned line, const char *filename,
 }
 
 static void
-vmsdbgout_source_line (register unsigned line, unsigned int column,
-		       register const char *filename,
+vmsdbgout_source_line (unsigned line, unsigned int column,
+		       const char *filename,
                        int discriminator, bool is_stmt)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
diff --git a/libgcc/config/rs6000/tramp.S b/libgcc/config/rs6000/tramp.S
index 4236a82b402..68baf16de9f 100644
--- a/libgcc/config/rs6000/tramp.S
+++ b/libgcc/config/rs6000/tramp.S
@@ -64,8 +64,7 @@ FUNC_START(__trampoline_setup)
         mflr	r11
         addi	r7,r11,trampoline_initial-4-.LCF0 /* trampoline address -4 */
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,2		/* # words to move */
 	addi	r9,r3,-4	/* adjust pointer for lwzu */
 	mtctr	r4
@@ -156,8 +155,7 @@ FUNC_START(__trampoline_setup)
 	ld 7,.LC0@toc@l(7)	/* trampoline address -8 */
 #endif
 
-	li	r8,trampoline_size	/* verify that the trampoline is big enough */
-	cmpw	cr1,r8,r4
+	cmpwi	cr1,r4,trampoline_size	/* verify that the trampoline is big enough */
 	srwi	r4,r4,3		/* # doublewords to move */
 	addi	r9,r3,-8	/* adjust pointer for stdu */
 	mtctr	r4
diff --git a/libgomp/testsuite/lib/libgomp.exp b/libgomp/testsuite/lib/libgomp.exp
index 14dcfdfd00a..46cce9b8445 100644
--- a/libgomp/testsuite/lib/libgomp.exp
+++ b/libgomp/testsuite/lib/libgomp.exp
@@ -340,8 +340,10 @@ proc offload_target_to_openacc_device_type { offload_target } {
     }
 }
 
-# Return 1 if compiling for offload target nvptx.
-proc check_effective_target_offload_target_nvptx { } {
+# Return 1 if compiling for the specified offload target
+# Takes -foffload=... into account by checking OFFLOAD_TARGET_NAMES=
+# in the -v compiler output.
+proc libgomp_check_effective_target_offload_target { target_name } {
     # Consider all actual options, including the flags passed to
     # 'gcc-dg-runtest', or 'gfortran-dg-runtest' (see the 'libgomp.*/*.exp'
     # files; in particular, '-foffload', 'libgomp.oacc-*/*.exp'), which don't
@@ -354,13 +356,23 @@ proc check_effective_target_offload_target_nvptx { } {
     set gcc_output [libgomp_target_compile "" "" "none" $options]
     if [regexp "(?n)^OFFLOAD_TARGET_NAMES=(.*)" $gcc_output dummy offload_targets] {
 	verbose "compiling for offload targets: $offload_targets"
-	return [string match "*:nvptx*:*" ":$offload_targets:"]
+	return [string match "*:$target_name*:*" ":$offload_targets:"]
     }
 
-    verbose "not compiling for any offload targets"
+    verbose "not compiling for $target_name offload target"
     return 0
 }
 
+# Return 1 if compiling for offload target nvptx.
+proc check_effective_target_offload_target_nvptx { } {
+    return [libgomp_check_effective_target_offload_target "nvptx"]
+}
+
+# Return 1 if compiling for offload target amdgcn
+proc check_effective_target_offload_target_amdgcn { } {
+    return [libgomp_check_effective_target_offload_target "amdgcn"]
+}
+
 # Return 1 if offload device is available.
 proc check_effective_target_offload_device { } {
     return [check_runtime_nocache offload_device_available_ {
diff --git a/libgomp/testsuite/libgomp.c-c++-common/function-not-offloaded.c b/libgomp/testsuite/libgomp.c-c++-common/function-not-offloaded.c
index 9e59ef8864e..bc1ae68941a 100644
--- a/libgomp/testsuite/libgomp.c-c++-common/function-not-offloaded.c
+++ b/libgomp/testsuite/libgomp.c-c++-common/function-not-offloaded.c
@@ -1,5 +1,5 @@
 /* { dg-do link } */
-/* { dg-excess-errors "unresolved symbol foo, lto1, mkoffload and lto-wrapper fatal errors" { target offload_device_nonshared_as } } */
+/* { dg-excess-errors "unresolved symbol foo, lto1, mkoffload and lto-wrapper fatal errors" { target { offload_target_nvptx || offload_target_amdgcn } } } */
 /* { dg-additional-sources "function-not-offloaded-aux.c" } */
 
 #pragma omp declare target
diff --git a/libgomp/testsuite/libgomp.c-c++-common/variable-not-offloaded.c b/libgomp/testsuite/libgomp.c-c++-common/variable-not-offloaded.c
index bc4b916e9a4..fe2a8b26242 100644
--- a/libgomp/testsuite/libgomp.c-c++-common/variable-not-offloaded.c
+++ b/libgomp/testsuite/libgomp.c-c++-common/variable-not-offloaded.c
@@ -1,7 +1,7 @@
 /* { dg-do link } */
-/* { dg-excess-errors "lto1, mkoffload and lto-wrapper fatal errors" { target offload_device_nonshared_as } } */
+/* { dg-excess-errors "lto1, mkoffload and lto-wrapper fatal errors" { target { offload_target_nvptx || offload_target_amdgcn } } } */
 
-int var; /* { dg-error "variable 'var' has been referenced in offloaded code but hasn't been marked to be included in the offloaded code" "" { target offload_device_nonshared_as } } */
+int var; /* { dg-error "variable 'var' has been referenced in offloaded code but hasn't been marked to be included in the offloaded code" "" { target { offload_target_nvptx || offload_target_amdgcn } } } */
 
 #pragma omp declare target
 void  __attribute__((noinline, noclone))
diff --git a/libgomp/testsuite/libgomp.c/pr86416-1.c b/libgomp/testsuite/libgomp.c/pr86416-1.c
index ad9370f78f3..6d3869264fd 100644
--- a/libgomp/testsuite/libgomp.c/pr86416-1.c
+++ b/libgomp/testsuite/libgomp.c/pr86416-1.c
@@ -2,8 +2,8 @@
 /* { dg-require-effective-target large_long_double } */
 
 /* PR middle-end/86416  */
-/* { dg-error "bit-precision floating-point numbers unsupported .mode '.F'." "" { target offload_device } 0 }  */
-/* { dg-excess-errors "Follow-up errors from mkoffload and lto-wrapper" { target offload_device } }  */
+/* { dg-error "bit-precision floating-point numbers unsupported .mode '.F'." "" { target { offload_target_nvptx || offload_target_amdgcn } } 0 }  */
+/* { dg-excess-errors "Follow-up errors from mkoffload and lto-wrapper" { target { offload_target_nvptx || offload_target_amdgcn } } }  */
 
 #include <stdlib.h>  /* For abort. */
 
diff --git a/libgomp/testsuite/libgomp.c/pr86416-2.c b/libgomp/testsuite/libgomp.c/pr86416-2.c
index ec45e400f95..cffeb3f7107 100644
--- a/libgomp/testsuite/libgomp.c/pr86416-2.c
+++ b/libgomp/testsuite/libgomp.c/pr86416-2.c
@@ -2,8 +2,8 @@
 /* { dg-add-options __float128 } */
 
 /* PR middle-end/86416  */
-/* { dg-error "bit-precision floating-point numbers unsupported .mode '.F'." "" { target offload_device } 0 }  */
-/* { dg-excess-errors "Follow-up errors from mkoffload and lto-wrapper" { target offload_device } }  */
+/* { dg-error "bit-precision floating-point numbers unsupported .mode '.F'." "" { target { offload_target_nvptx || offload_target_amdgcn } } 0 }  */
+/* { dg-excess-errors "Follow-up errors from mkoffload and lto-wrapper" { target { offload_target_nvptx || offload_target_amdgcn } } }  */
 
 #include <stdlib.h>  /* For abort. */
 
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index 74075a2d6d3..09115e9b45f 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -2389,7 +2389,7 @@ namespace views::__adaptor
 	  constexpr _Iterator&
 	  operator++()
 	  {
-	    auto&& __inner_range = [this] () -> decltype(auto) {
+	    auto&& __inner_range = [this] () -> auto&& {
 	      if constexpr (_S_ref_is_glvalue)
 		return *_M_outer;
 	      else
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
index fb06a7698af..e6c71d771de 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -160,6 +160,16 @@ test09()
   static_assert(!requires { 0 | join; });
 }
 
+void
+test10()
+{
+  // PR libstdc++/100290
+  auto v = views::single(0)
+    | views::transform([](const auto& s) { return views::single(s); })
+    | views::join;
+  VERIFY( ranges::next(v.begin()) == v.end() );
+}
+
 int
 main()
 {
@@ -172,4 +182,5 @@ main()
   test07();
   test08();
   test09();
+  test10();
 }
