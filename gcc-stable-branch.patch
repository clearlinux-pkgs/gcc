Alex Coplan (2):
      aarch64: Fix SVE ACLE builtins with LTO [PR99216]
      arm: Fix PCS for SFmode -> SImode libcalls [PR99748]

Bin Cheng (1):
      tree-optimization/98736 - use programing order preserved RPO in ldist

Eric Botcazou (3):
      Fix thinko in libcpp preparation patch for modules
      Further increase the limit on the size of accepted Ada files
      Fix another -freorder-blocks-and-partition glitch with Windows SEH

François Dumont (3):
      libstdc++: Fix [multi]map/[multi]set move constructors noexcept qualification
      libstdc++: Fix unordered containers move constructors noexcept qualification
      libstdc++: [_GLIBCXX_DEBUG] Fix management of __dp_sign_max_size [PR 99402]

GCC Administrator (17):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Hafiz Abid Qadeer (1):
      [OpenACC] Fix an ICE where a loop with GT condition is collapsed.

Harald Anlauf (1):
      PR fortran/63797 - Bogus ambiguous reference to 'sqrt'

Iain Buclaw (1):
      d: Fix ICE in when formating a string with '%' or '`' characters (PR98457)

Jakub Jelinek (14):
      rs6000: Fix up libgcc ABI when built with --with-long-double-format=ieee [PR97653]
      dse: Fix up hard reg conflict checking in replace_read [PR99863]
      c++: Don't cache constexpr functions which are passed pointers to heap or static vars being constructed [PR99859]
      rtlanal: Another fix for VOIDmode MEMs [PR98601]
      expand: Fix up LTO ICE with COMPOUND_LITERAL_EXPR [PR99849]
      c: Avoid clobbering TREE_TYPE (error_mark_node) [PR99990]
      combine: Don't fold away side-effects in simplify_and_const_int_1 [PR99830]
      combine: Fix up expand_compound_operation [PR99905]
      c++: Fix up handling of structured bindings in extract_locals_r [PR99833]
      vectorizer: Remove dead scalar .COND_* calls from vectorized loops [PR99767]
      c++: Fix empty base stores in cxx_eval_store_expression [PR100111]
      intl: Add --enable-host-shared support [PR100096]
      sanitizer: Fix asan against glibc 2.34 [PR100114]
      cprop: Fix -fcompare-debug bug in constprop_register [PR100148]

Jonathan Wakely (17):
      libstdc++: Fix Doxygen warning about ambiguous file name
      maintainer-scripts: Disable multilib when generating libstdc++ docs
      libstdc++: Fix doxygen markup for group close commands
      libstdc++: Fix Doxygen warnings
      libstdc++: Change URL for PSTL
      libstdc++: Fix filesystem::path construction from COW string [PR 99805]
      libstdc++: Fix tests using wrong allocator type
      libstdc++: Fix more doxygen markup for group close commands
      libstdc++: Remove spurious line break in doxygen comment
      libstdc++: Fix even more doxygen markup for group close commands
      libstdc++: Fix invalid constexpr function in C++11 mode [PR 99985]
      libstdc++: Fix bootstrap error due to inconsistent noexcept-specifier [PR 99983]
      libstdc++: Fix std::indirectly_readable ambiguity [LWG 3446]
      libstdc++: Implement LWG 3404 for C++20 subrange [PR 100044]
      libstdc++: Fix <bit> to work freestanding [PR 100060]
      libstdc++: Fix declarations of memalign etc. for freestanding [PR 97570]
      libstdc++: Disable test for non-gthreads targets [PR 100180]

Marek Polacek (12):
      c++: ICE when late parsing noexcept/NSDMI [PR98333]
      c++: ICE with delayed noexcept and attribute used [PR97966]
      c++: Fix bogus -Wvolatile warning in C++20 [PR98947]
      c++: Pointer-to-member fn conversion with noexcept [PR99374]
      c++: ICE with -Wshadow and enumerator in template [PR99120]
      c++: const_cast of null pointer in constant expr [PR99176]
      c++: -Wconversion vs value-dependent expressions [PR99331]
      c++: GC collects live data when synthesizing operator== [PR99831]
      c++: GC during late parsing collects live data [PR91416]
      c++: Fix two issues with auto function parameter [PR99806]
      c++: ICE with real-to-int conversion in template [PR97973]
      c++: Use FOR_EACH_VEC_ELT instead of range-based for loop.

Martin Liska (1):
      Sync gcc-changelog scripts.

Patrick Palka (9):
      c++: Fix deduction with reference NTTP [PR83476]
      c++: Fix tsubsting CLASS_PLACEHOLDER_TEMPLATE [PR95434]
      c++: ICE in dependent_type_p with constrained auto [PR97052]
      libstdc++: Don't initialize from *this inside some views [PR97600]
      libstdc++: Fix elements_view::operator* and operator[] [LWG 3502]
      libstdc++: Simplify copy-pasted algorithms in <ranges>
      libstdc++: Fix split_view::_OuterIter::operator++ [LWG 3505]
      c++: alias_ctad_tweaks and constrained dguide [PR95486]
      c++: std::is_constant_evaluated inside constraint [PR97051]

Richard Biener (5):
      Increment BASE-VER after release
      testsuite/100176 - fix struct-layout-1_generate.c compile
      middle-end/98726 - fix VECTOR_CST element access
      remove write-only array in rev_post_order_and_mark_dfs_back_seme
      Compute RPO with adjacent SCC members, expose toplevel SCC extents

Richard Sandiford (8):
      data-ref: Tighten index-based alias checks [PR99726]
      gimple-fold: Recompute ADDR_EXPR flags after folding a TMR [PR98268]
      aarch64: Tweak post-RA handling of CONST_INT moves [PR98136]
      Handle CONST_POLY_INTs in CONST_VECTORs [PR97141, PR98726]
      aarch64: Handle more SVE vector constants [PR99246]
      aarch64: Fix target alignment for SVE [PR98119]
      Check for matching CONST_VECTOR encodings [PR99929]
      lra: Avoid cycling on certain subreg reloads [PR96796]

Tamar Christina (1):
      SVE: Fix wrong sve predicate split (PR100048)

Thomas Schwinge (1):
      Add 'libgomp.oacc-c-c++-common/static-variable-1.c' [PR84991, PR84992, PR90779]

Tobias Burnus (2):
      Fortran: Fix fndecl with -fcoarray=lib [PR99817]
      OpenACC: Fix integer-type issue with collapse/tile [PR97880]

YiFei Zhu (2):
      bpf: align function entry point to 64 bits
      bpf: allow BSS symbols to be global symbols

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index cfcc8b12b53..977fcbcf1e8 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,12 @@
+2021-04-14  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Sync with master.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/setup.cfg: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py
index ee1973371be..b28f7deac23 100755
--- a/contrib/gcc-changelog/git_commit.py
+++ b/contrib/gcc-changelog/git_commit.py
@@ -214,6 +214,7 @@ class ChangeLogEntry:
         self.lines = []
         self.files = []
         self.file_patterns = []
+        self.opened_parentheses = 0
 
     def parse_file_names(self):
         # Whether the content currently processed is between a star prefix the
@@ -223,8 +224,14 @@ class ChangeLogEntry:
         for line in self.lines:
             # If this line matches the star prefix, start the location
             # processing on the information that follows the star.
+            # Note that we need to skip macro names that can be in form of:
+            #
+            # * config/i386/i386.md (*fix_trunc<mode>_i387_1,
+            # *add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0,
+            # *fist<mode>2_<rounding>_1, *<code><mode>3_1):
+            #
             m = star_prefix_regex.match(line)
-            if m:
+            if m and len(m.group('spaces')) == 1:
                 in_location = True
                 line = m.group('content')
 
@@ -307,8 +314,9 @@ class GitCommit:
         if self.revert_commit:
             self.info = self.commit_to_info_hook(self.revert_commit)
 
+        # Allow complete deletion of ChangeLog files in a commit
         project_files = [f for f in self.info.modified_files
-                         if self.is_changelog_filename(f[0])
+                         if (self.is_changelog_filename(f[0], allow_suffix=True) and f[1] != 'D')
                          or f[0] in misc_files]
         ignored_files = [f for f in self.info.modified_files
                          if self.in_ignored_location(f[0])]
@@ -328,6 +336,7 @@ class GitCommit:
             self.parse_changelog()
             self.parse_file_names()
             self.check_for_empty_description()
+            self.check_for_broken_parentheses()
             self.deduce_changelog_locations()
             self.check_file_patterns()
             if not self.errors:
@@ -343,8 +352,14 @@ class GitCommit:
         return [x[0] for x in self.info.modified_files if x[1] == 'A']
 
     @classmethod
-    def is_changelog_filename(cls, path):
-        return path.endswith('/ChangeLog') or path == 'ChangeLog'
+    def is_changelog_filename(cls, path, allow_suffix=False):
+        basename = os.path.basename(path)
+        if basename == 'ChangeLog':
+            return True
+        elif allow_suffix and basename.startswith('ChangeLog'):
+            return True
+        else:
+            return False
 
     @classmethod
     def find_changelog_location(cls, name):
@@ -400,8 +415,10 @@ class GitCommit:
             if line != line.rstrip():
                 self.errors.append(Error('trailing whitespace', line))
             if len(line.replace('\t', ' ' * TAB_WIDTH)) > LINE_LIMIT:
-                self.errors.append(Error('line exceeds %d character limit'
-                                         % LINE_LIMIT, line))
+                # support long filenames
+                if not line.startswith('\t* ') or not line.endswith(':') or ' ' in line[3:-1]:
+                    self.errors.append(Error('line exceeds %d character limit'
+                                             % LINE_LIMIT, line))
             m = changelog_regex.match(line)
             if m:
                 last_entry = ChangeLogEntry(m.group(1).rstrip('/'),
@@ -490,7 +507,8 @@ class GitCommit:
                 else:
                     m = star_prefix_regex.match(line)
                     if m:
-                        if len(m.group('spaces')) != 1:
+                        if (len(m.group('spaces')) != 1 and
+                                last_entry.opened_parentheses == 0):
                             msg = 'one space should follow asterisk'
                             self.errors.append(Error(msg, line))
                         else:
@@ -502,6 +520,7 @@ class GitCommit:
                                         msg = f'empty group "{needle}" found'
                                         self.errors.append(Error(msg, line))
                             last_entry.lines.append(line)
+                            self.process_parentheses(last_entry, line)
                     else:
                         if last_entry.is_empty:
                             msg = 'first line should start with a tab, ' \
@@ -509,6 +528,18 @@ class GitCommit:
                             self.errors.append(Error(msg, line))
                         else:
                             last_entry.lines.append(line)
+                            self.process_parentheses(last_entry, line)
+
+    def process_parentheses(self, last_entry, line):
+        for c in line:
+            if c == '(':
+                last_entry.opened_parentheses += 1
+            elif c == ')':
+                if last_entry.opened_parentheses == 0:
+                    msg = 'bad wrapping of parenthesis'
+                    self.errors.append(Error(msg, line))
+                else:
+                    last_entry.opened_parentheses -= 1
 
     def parse_file_names(self):
         for entry in self.changelog_entries:
@@ -532,6 +563,12 @@ class GitCommit:
                     msg = 'missing description of a change'
                     self.errors.append(Error(msg, line))
 
+    def check_for_broken_parentheses(self):
+        for entry in self.changelog_entries:
+            if entry.opened_parentheses != 0:
+                msg = 'bad parentheses wrapping'
+                self.errors.append(Error(msg, entry.lines[0]))
+
     def get_file_changelog_location(self, changelog_file):
         for file in self.info.modified_files:
             if file[0] == changelog_file:
diff --git a/contrib/gcc-changelog/git_email.py b/contrib/gcc-changelog/git_email.py
index 00ad00458f4..b0547b363aa 100755
--- a/contrib/gcc-changelog/git_email.py
+++ b/contrib/gcc-changelog/git_email.py
@@ -66,7 +66,7 @@ class GitEmail(GitCommit):
                 t = 'A'
             else:
                 t = 'M'
-            modified_files.append((target, t))
+            modified_files.append((target if t != 'D' else source, t))
         git_info = GitInfo(None, date, author, body, modified_files)
         super().__init__(git_info, strict=strict,
                          commit_to_info_hook=lambda x: None)
diff --git a/contrib/gcc-changelog/git_update_version.py b/contrib/gcc-changelog/git_update_version.py
index d2cadb8811c..1e2b22b008b 100755
--- a/contrib/gcc-changelog/git_update_version.py
+++ b/contrib/gcc-changelog/git_update_version.py
@@ -26,6 +26,9 @@ from git_repository import parse_git_revisions
 
 current_timestamp = datetime.datetime.now().strftime('%Y%m%d\n')
 
+# Skip the following commits, they cannot be correctly processed
+IGNORED_COMMITS = ('c2be82058fb40f3ae891c68d185ff53e07f14f45')
+
 
 def read_timestamp(path):
     with open(path) as f:
@@ -98,6 +101,7 @@ def update_current_branch():
             head = head.parents[1]
         commits = parse_git_revisions(args.git_path, '%s..%s'
                                       % (commit.hexsha, head.hexsha))
+        commits = [c for c in commits if c.info.hexsha not in IGNORED_COMMITS]
         for git_commit in reversed(commits):
             prepend_to_changelog_files(repo, args.git_path, git_commit,
                                        not args.dry_mode)
diff --git a/contrib/gcc-changelog/setup.cfg b/contrib/gcc-changelog/setup.cfg
index 9e4a0f6479c..efc313f6d52 100644
--- a/contrib/gcc-changelog/setup.cfg
+++ b/contrib/gcc-changelog/setup.cfg
@@ -1,2 +1,5 @@
+[flake8]
+max-line-length = 120
+
 [tool:pytest]
 addopts = -vv --flake8
diff --git a/contrib/gcc-changelog/test_email.py b/contrib/gcc-changelog/test_email.py
index 5db56caef9e..8abf5c37487 100755
--- a/contrib/gcc-changelog/test_email.py
+++ b/contrib/gcc-changelog/test_email.py
@@ -404,3 +404,23 @@ class TestGccChangelog(unittest.TestCase):
         email = self.from_patch_glob('0001-Add-horse2.patch')
         assert not email.errors
         assert email.changelog_entries[0].files == ['koníček.txt']
+
+    def test_modification_of_old_changelog(self):
+        email = self.from_patch_glob('0001-fix-old-ChangeLog.patch')
+        assert not email.errors
+
+    def test_multiline_parentheses(self):
+        email = self.from_patch_glob('0001-Add-macro.patch')
+        assert not email.errors
+
+    def test_multiline_bad_parentheses(self):
+        email = self.from_patch_glob('0002-Wrong-macro-changelog.patch')
+        assert email.errors[0].message == 'bad parentheses wrapping'
+
+    def test_changelog_removal(self):
+        email = self.from_patch_glob('0001-ChangeLog-removal.patch', strict=True)
+        assert not email.errors
+
+    def test_long_filenames(self):
+        email = self.from_patch_glob('0001-long-filenames')
+        assert not email.errors
diff --git a/contrib/gcc-changelog/test_patches.txt b/contrib/gcc-changelog/test_patches.txt
index ffd13682d5c..3f9806dc076 100644
--- a/contrib/gcc-changelog/test_patches.txt
+++ b/contrib/gcc-changelog/test_patches.txt
@@ -3398,4 +3398,151 @@ index 00000000000..56c67f58752
 -- 
 2.29.2
 
+=== 0001-fix-old-ChangeLog.patch ===
+From fd498465b2801203089616be9a0e3c1f4fc065a0 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 11:45:37 +0100
+Subject: [PATCH] Fix a changelog.
+
+---
+ gcc/ChangeLog-2020 | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/ChangeLog-2020 b/gcc/ChangeLog-2020
+index 6553720acad..2c170ef014a 100644
+--- a/gcc/ChangeLog-2020
++++ b/gcc/ChangeLog-2020
+@@ -1 +1,2 @@
+ 
++
+ 
+-- 
+2.29.2
+=== 0001-Add-macro.patch ===
+From 9b7eedc932fe594547fb060b36dfd9e4178c4f9b Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 16:26:45 +0100
+Subject: [PATCH 1/2] Add macro.
+
+gcc/ChangeLog:
+
+	* config/i386/i386.md (*fix_trunc<mode>_i387_1, *add<mode>3_eq,
+	*add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0, *add<mode>3_eq,
+	*fist<mode>2_<rounding>_1, *<code><mode>3_1, *<code>di3_doubleword):
+	Use ix86_pre_reload_split instead of can_create_pseudo_p in condition.
+	* config/i386/sse.md
+	(*fix_trunc<mode>_i387_1, *add<mode>3_eq,
+	*add<mode>3_ne, *add<mode>3_eq_0, *add<mode>3_ne_0, *add<mode>3_eq,
+	*fist<mode>2_<rounding>_1): This should also work.
+---
+ gcc/config/i386/i386.md | 1 +
+ gcc/config/i386/sse.md  | 1 +
+ 2 files changed, 2 insertions(+)
+
+diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
+index b60784a2908..ac63591b33f 100644
+--- a/gcc/config/i386/i386.md
++++ b/gcc/config/i386/i386.md
+@@ -1 +1,2 @@
+ 
++
+
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 7f03fc491c3..0e17997db26 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -1 +1,2 @@
+ 
++
+
+-- 
+2.29.2
+
+=== 0002-Wrong-macro-changelog.patch ===
+From 3542802111d4c6752ac7233ef96655b7fb78aae4 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Wed, 13 Jan 2021 16:54:58 +0100
+Subject: [PATCH 2/2] Wrong macro changelog
+
+gcc/ChangeLog:
 
+	* config/i386/i386.md (*fix_trunc<mode>_i387_1,
+	(foo): Change it.
+---
+ gcc/config/i386/i386.md | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
+index ac63591b33f..ff4d61764e7 100644
+--- a/gcc/config/i386/i386.md
++++ b/gcc/config/i386/i386.md
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.29.2
+
+=== 0001-ChangeLog-removal.patch ===
+From b39fadf9df1a9510afcab0a391182da7dc68de24 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Fri, 12 Mar 2021 09:10:55 +0100
+Subject: [PATCH] Test ChangeLog removal.
+
+gcc/ChangeLog:
+
+	* ipa-icf.c (make_pass_ipa_icf): Add line.
+---
+diff --git a/gcc/analyzer/ChangeLog b/gcc/analyzer/ChangeLog
+deleted file mode 100644
+index 94e87f6bcde..00000000000
+--- a/gcc/analyzer/ChangeLog
++++ /dev/null
+@@ -1,1 +0,0 @@
+- foo
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index 5dd33a75c3a..c4ce432cb98 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -3655,3 +3655,4 @@ make_pass_ipa_icf (gcc::context *ctxt)
+ {
+   return new ipa_icf::pass_ipa_icf (ctxt);
+ }
++
+-- 
+2.30.1
+
+=== 0001-long-filenames ===
+From 0a5b3f87bdac5e61f9a626c795d30f9e93198585 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 12 Apr 2021 13:10:14 +0200
+Subject: [PATCH] libstdc++: Fix some tests that fail in C++20 mode
+
+The linear_congruential_engine negative tests fail with a different
+error in C++20 mode, because double is no longer an invalid type for
+NTTP. Adjust the expected errors.
+
+libstdc++-v3/ChangeLog:
+
+	* testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc:
+	Adjust expected error for C++20 mode.
+	* testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc:
+	Likewise.
+---
+ .../linear_congruential_engine/requirements/non_uint_neg.cc   | 4 +++-
+ .../random/linear_congruential/requirements/non_uint_neg.cc   | 3 ++-
+ 2 files changed, 5 insertions(+), 2 deletions(-)
+
+diff --git a/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc b/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
+index e04e8ca6972..a36d63c6c7b 100644
+--- a/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
++++ b/libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/non_uint_neg.cc
+@@ -1 +1,2 @@
+ 
++
+diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
+index 5ad82db1def..53b15f32516 100644
+--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
++++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/random/linear_congruential/requirements/non_uint_neg.cc
+@@ -1 +1,2 @@
+ 
++
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 0719d810258..a9368325816 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-10.3.0
+10.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 3b1384e707f..db163c68238 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,293 @@
+2021-04-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/96796
+	* lra-constraints.c (in_class_p): Add a default-false
+	allow_all_reload_class_changes_p parameter.  Do not treat
+	reload moves specially when the parameter is true.
+	(get_reload_reg): Try to narrow the class of an existing OP_OUT
+	reload if we're reloading a reload pseudo in a reload instruction.
+
+2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	Backported from master:
+	2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	* config/bpf/bpf.h (ASM_OUTPUT_ALIGNED_BSS): Use .type and .lcomm.
+
+2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	Backported from master:
+	2021-04-23  YiFei Zhu  <zhuyifei1999@gmail.com>
+
+	* config/bpf/bpf.h (FUNCTION_BOUNDARY): Set to 64.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/99929
+	* rtl.h (same_vector_encodings_p): New function.
+	* cse.c (exp_equiv_p): Check that CONST_VECTORs have the same encoding.
+	* cselib.c (rtx_equal_for_cselib_1): Likewise.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+	* lra-constraints.c (operands_match_p): Likewise.
+	* reload.c (operands_match_p): Likewise.
+	* rtl.c (rtx_equal_p_cb, rtx_equal_p): Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98119
+	* config/aarch64/aarch64.c
+	(aarch64_vectorize_preferred_vector_alignment): Query the size
+	of the provided SVE vector; do not assume that all SVE vectors
+	have the same size.
+
+2021-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2021-04-07  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/98736
+	* tree-loop-distribution.c
+	* (loop_distribution::bb_top_order_init):
+	Compute RPO with programing order preserved by calling function
+	rev_post_order_and_mark_dfs_back_seme.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Adjust
+	prototype.
+	* cfganal.c (rpoamdbs_bb_data): New struct with pre BB data.
+	(tag_header): New helper.
+	(cmp_edge_dest_pre): Likewise.
+	(rev_post_order_and_mark_dfs_back_seme): Compute SCCs,
+	find SCC exits and perform a DFS walk with extra edges to
+	compute a RPO with adjacent SCC members when requesting an
+	iteration optimized order and populate the toplevel SCC array.
+	* tree-ssa-sccvn.c (do_rpo_vn): Remove ad-hoc computation
+	of max_rpo and fill it in from SCC extent info instead.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-20  Richard Biener  <rguenther@suse.de>
+
+	* cfganal.c (rev_post_order_and_mark_dfs_back_seme): Remove
+	write-only post array.
+
+2021-04-23  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2021-04-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99748
+	* config/arm/arm.c (arm_libcall_uses_aapcs_base): Also use base
+	PCS for [su]fix_optab.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/99249
+	* config/aarch64/aarch64.c (aarch64_expand_sve_const_vector_sel):
+	New function.
+	(aarch64_expand_sve_const_vector): Use it for nelts_per_pattern==2.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/97141
+	PR rtl-optimization/98726
+	* emit-rtl.c (valid_for_const_vector_p): Return true for
+	CONST_POLY_INT_P.
+	* rtx-vector-builder.h (rtx_vector_builder::step): Return a
+	poly_wide_int instead of a wide_int.
+	(rtx_vector_builder::apply_set): Take a poly_wide_int instead
+	of a wide_int.
+	* rtx-vector-builder.c (rtx_vector_builder::apply_set): Likewise.
+	* config/aarch64/aarch64.c (aarch64_legitimate_constant_p): Return
+	false for CONST_VECTORs that cannot be forced to memory.
+	* config/aarch64/aarch64-simd.md (mov<mode>): If a CONST_VECTOR
+	is too complex to force to memory, build it up from individual
+	elements instead.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/98726
+	* tree.h (vector_cst_int_elt): Remove.
+	* tree.c (vector_cst_int_elt): Use poly_wide_int for computations,
+	make static.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-30  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98136
+	* config/aarch64/aarch64.md (mov<mode>): Pass multi-instruction
+	CONST_INTs to aarch64_expand_mov_immediate when called after RA.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/98268
+	* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Call
+	recompute_tree_invariant_for_addr_expr after successfully
+	folding a TARGET_MEM_REF that occurs inside an ADDR_EXPR.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/99726
+	* tree-data-ref.c (create_intersect_range_checks_index): Bail
+	out if there is more than one access function SCEV for the loop
+	being versioned.
+
+2021-04-22  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99216
+	* config/aarch64/aarch64-sve-builtins.cc
+	(function_builder::add_function): Add placeholder_p argument, use
+	placeholder decls if this is set.
+	(function_builder::add_unique_function): Instead of conditionally adding
+	direct overloads, unconditionally add either a direct overload or a
+	placeholder.
+	(function_builder::add_overloaded_function): Set placeholder_p if we're
+	using C++ overloads. Use the obstack for string storage instead
+	of relying on the tree nodes.
+	(function_builder::add_overloaded_functions): Don't return early for
+	m_direct_overloads: we need to add placeholders.
+	* config/aarch64/aarch64-sve-builtins.h
+	(function_builder::add_function): Add placeholder_p argument.
+	* lto-streamer.h (LTO_minor_version): Bump.
+
+2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100148
+	* cprop.c (constprop_register): Use next_nondebug_insn instead of
+	NEXT_INSN.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/99767
+	* tree-vect-loop.c (vect_transform_loop): Don't remove just
+	dead scalar .MASK_LOAD calls, but also dead .COND_* calls - replace
+	them by their last argument.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99905
+	* combine.c (expand_compound_operation): If pos + len > modewidth,
+	perform the right shift by pos in inner_mode and then convert to mode,
+	instead of trying to simplify a shift of rtx with inner_mode by pos
+	as if it was a shift in mode.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/99830
+	* combine.c (simplify_and_const_int_1): Don't optimize varop
+	away if it has side-effects.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/99849
+	* expr.c (expand_expr_addr_expr_1): Test is_global_var rather than
+	just TREE_STATIC on COMPOUND_LITERAL_EXPR_DECLs.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/98601
+	* rtlanal.c (rtx_addr_can_trap_p_1): Allow in assert unknown size
+	not just for BLKmode, but also for VOIDmode.  For STRICT_ALIGNMENT
+	unaligned_mems handle VOIDmode like BLKmode.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99863
+	* dse.c (replace_read): Drop regs_live argument.  Instead of
+	regs_live, use store_insn->fixed_regs_live if non-NULL,
+	otherwise punt if insns sequence clobbers or sets any hard
+	registers.
+
+2021-04-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-27  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/97880
+	* omp-expand.c (expand_oacc_collapse_init, expand_oacc_collapse_vars):
+	Use now passed diff_type.
+	(expand_oacc_for): Take largest type for diff_type, taking tiling
+	and collapsing into account.
+
+2021-04-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/winnt.c (i386_pe_seh_cold_init): Properly deal with
+	frames larger than the SEH maximum frame size.
+
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* omp-expand.c (expand_oacc_collapse_init): Update condition in
+	a gcc_assert.
+
+2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/100048
+	* config/aarch64/aarch64-sve.md (@aarch64_sve_trn1_conv<mode>): New.
+	* config/aarch64/aarch64.c (aarch64_expand_sve_const_pred_trn): Use new
+	TRN optab.
+	* config/aarch64/iterators.md (UNSPEC_TRN1_CONV): New.
+
+2021-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR lto/99898
+	* lto-streamer.h (LTO_minor_version): Bump.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 86fd883487b..d0deb4bd622 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,12 @@
+2021-04-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_init): Set default range bits to 0.
+	* gcc-interface/trans.c (extract_encoding): Delete.
+	(decode_name): Likewise.
+	(File_Name_to_gnu): New function.
+	(gigi): Call it to translate file names.  Replace assertion on
+	1-1 mapping between files and line maps with conditional error.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
index d68b37384ff..775ab190515 100644
--- a/gcc/ada/gcc-interface/misc.c
+++ b/gcc/ada/gcc-interface/misc.c
@@ -366,6 +366,9 @@ gnat_init (void)
   sbitsize_one_node = sbitsize_int (1);
   sbitsize_unit_node = sbitsize_int (BITS_PER_UNIT);
 
+  /* In Ada, we do not use location ranges.  */
+  line_table->default_range_bits = 0;
+
   /* Register our internal error function.  */
   global_dc->internal_error = &internal_error_function;
 
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index 7ecf321c250..a2cbaae2326 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -252,17 +252,27 @@ static tree build_raise_check (int, enum exception_info_kind);
 static tree create_init_temporary (const char *, tree, tree *, Node_Id);
 static bool maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk);
 
-/* Hooks for debug info back-ends, only supported and used in a restricted set
-   of configurations.  */
-static const char *extract_encoding (const char *) ATTRIBUTE_UNUSED;
-static const char *decode_name (const char *) ATTRIBUTE_UNUSED;
-
 /* This makes gigi's file_info_ptr visible in this translation unit,
    so that Sloc_to_locus can look it up when deciding whether to map
    decls to instances.  */
 
 static struct File_Info_Type *file_map;
 
+/* Return the string of the identifier allocated for the file name Id.  */
+
+static const char*
+File_Name_to_gnu (Name_Id Id)
+{
+  /* __gnat_to_canonical_file_spec translates file names from pragmas
+     Source_Reference that contain host style syntax not understood by GDB.  */
+  const char *name = __gnat_to_canonical_file_spec (Get_Name_String (Id));
+
+  /* Use the identifier table to make a permanent copy of the file name as
+     the name table gets reallocated after Gigi returns but before all the
+     debugging information is output.  */
+  return IDENTIFIER_POINTER (get_identifier (name));
+}
+
 /* This is the main program of the back-end.  It sets up all the table
    structures and then generates code.  */
 
@@ -316,23 +326,18 @@ gigi (Node_Id gnat_root,
 
   for (i = 0; i < number_file; i++)
     {
-      /* Use the identifier table to make a permanent copy of the filename as
-	 the name table gets reallocated after Gigi returns but before all the
-	 debugging information is output.  The __gnat_to_canonical_file_spec
-	 call translates filenames from pragmas Source_Reference that contain
-	 host style syntax not understood by gdb.  */
-      const char *filename
-	= IDENTIFIER_POINTER
-	   (get_identifier
-	    (__gnat_to_canonical_file_spec
-	     (Get_Name_String (file_info_ptr[i].File_Name))));
-
       /* We rely on the order isomorphism between files and line maps.  */
-      gcc_assert ((int) LINEMAPS_ORDINARY_USED (line_table) == i);
+      if ((int) LINEMAPS_ORDINARY_USED (line_table) != i)
+	{
+	  gcc_assert (i > 0);
+	  error ("%s contains too many lines",
+		 File_Name_to_gnu (file_info_ptr[i - 1].File_Name));
+	}
 
       /* We create the line map for a source file at once, with a fixed number
 	 of columns chosen to avoid jumping over the next power of 2.  */
-      linemap_add (line_table, LC_ENTER, 0, filename, 1);
+      linemap_add (line_table, LC_ENTER, 0,
+		   File_Name_to_gnu (file_info_ptr[i].File_Name), 1);
       linemap_line_start (line_table, file_info_ptr[i].Num_Source_Lines, 252);
       linemap_position_for_column (line_table, 252 - 1);
       linemap_add (line_table, LC_LEAVE, 0, NULL, 0);
@@ -10976,28 +10981,7 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)
       return false;
     }
 }
-
-/* Return a colon-separated list of encodings contained in encoded Ada
-   name.  */
-
-static const char *
-extract_encoding (const char *name)
-{
-  char *encoding = (char *) ggc_alloc_atomic (strlen (name));
-  get_encoding (name, encoding);
-  return encoding;
-}
 
-/* Extract the Ada name from an encoded name.  */
-
-static const char *
-decode_name (const char *name)
-{
-  char *decoded = (char *) ggc_alloc_atomic (strlen (name) * 2 + 60);
-  __gnat_decode (name, decoded, 0);
-  return decoded;
-}
-
 /* Post an error message.  MSG is the error message, properly annotated.
    NODE is the node at which to post the error and the node to use for the
    '&' substitution.  */
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index ecd1741df24..8fd5fa92b1a 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,12 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/99990
+	* c-decl.c (finish_decl): Don't overwrite TREE_TYPE of
+	error_mark_node.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index b3e05be0af8..8e24b522ee4 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -5320,7 +5320,7 @@ finish_decl (tree decl, location_t init_loc, tree init,
 	  gcc_unreachable ();
 	}
 
-      if (DECL_INITIAL (decl))
+      if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node)
 	TREE_TYPE (DECL_INITIAL (decl)) = type;
 
       relayout_decl (decl);
diff --git a/gcc/cfganal.c b/gcc/cfganal.c
index 395b810262a..24ae41bcac5 100644
--- a/gcc/cfganal.c
+++ b/gcc/cfganal.c
@@ -1060,113 +1060,389 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,
   return pre_order_num;
 }
 
-/* Unlike pre_and_rev_post_order_compute we fill rev_post_order backwards
-   so iterating in RPO order needs to start with rev_post_order[n - 1]
-   going to rev_post_order[0].  If FOR_ITERATION is true then try to
-   make CFG cycles fit into small contiguous regions of the RPO order.
-   When FOR_ITERATION is true this requires up-to-date loop structures.  */
+
+/* Per basic-block data for rev_post_order_and_mark_dfs_back_seme,
+   element of a sparsely populated array indexed by basic-block number.  */
+typedef auto_vec<int, 2> scc_exit_vec_t;
+struct rpoamdbs_bb_data {
+    int depth;
+    int bb_to_pre;
+    /* The basic-block index of the SCC entry of the block visited first
+       (the SCC leader).  */
+    int scc;
+    /* The index into the RPO array where the blocks SCC entries end
+       (only valid for the SCC leader).  */
+    int scc_end;
+    /* The indexes of the exits destinations of this SCC (only valid
+       for the SCC leader).  Initialized upon discovery of SCC leaders.  */
+    scc_exit_vec_t scc_exits;
+};
+
+/* Tag H as a header of B, weaving H and its loop header list into the
+   current loop header list of B.  */
+
+static void
+tag_header (int b, int h, rpoamdbs_bb_data *bb_data)
+{
+  if (h == -1 || b == h)
+    return;
+  int cur1 = b;
+  int cur2 = h;
+  while (bb_data[cur1].scc != -1)
+    {
+      int ih = bb_data[cur1].scc;
+      if (ih == cur2)
+	return;
+      if (bb_data[ih].depth < bb_data[cur2].depth)
+	{
+	  bb_data[cur1].scc = cur2;
+	  cur1 = cur2;
+	  cur2 = ih;
+	}
+      else
+	cur1 = ih;
+    }
+  bb_data[cur1].scc = cur2;
+}
+
+/* Comparator for a sort of two edges destinations E1 and E2 after their index
+   in the PRE array as specified by BB_TO_PRE.  */
+
+static int
+cmp_edge_dest_pre (const void *e1_, const void *e2_, void *data_)
+{
+  const int *e1 = (const int *)e1_;
+  const int *e2 = (const int *)e2_;
+  rpoamdbs_bb_data *bb_data = (rpoamdbs_bb_data *)data_;
+  return (bb_data[*e1].bb_to_pre - bb_data[*e2].bb_to_pre);
+}
+
+/* Compute the reverse completion number of a depth first search
+   on the SEME region denoted by the ENTRY edge and the EXIT_BBS set of
+   exit block indexes and store it in the array REV_POST_ORDER.
+   Also sets the EDGE_DFS_BACK edge flags according to this visitation
+   order.
+   Returns the number of nodes visited.
+
+   In case the function has unreachable blocks the number of nodes
+   visited does not include them.
+
+   If FOR_ITERATION is true then compute an RPO where SCCs form a
+   contiguous region in the RPO array.
+   *TOPLEVEL_SCC_EXTENTS if not NULL is filled with pairs of
+   *REV_POST_ORDER indexes denoting extents of the toplevel SCCs in
+   this region.  */
 
 int
 rev_post_order_and_mark_dfs_back_seme (struct function *fn, edge entry,
 				       bitmap exit_bbs, bool for_iteration,
-				       int *rev_post_order)
+				       int *rev_post_order,
+				       vec<std::pair<int, int> >
+					 *toplevel_scc_extents)
 {
-  int pre_order_num = 0;
   int rev_post_order_num = 0;
 
-  /* Allocate stack for back-tracking up CFG.  Worst case we need
-     O(n^2) edges but the following should suffice in practice without
-     a need to re-allocate.  */
-  auto_vec<edge, 20> stack (2 * n_basic_blocks_for_fn (fn));
-
-  int *pre = XNEWVEC (int, 2 * last_basic_block_for_fn (fn));
-  int *post = pre + last_basic_block_for_fn (fn);
-
   /* BB flag to track nodes that have been visited.  */
   auto_bb_flag visited (fn);
-  /* BB flag to track which nodes have post[] assigned to avoid
-     zeroing post.  */
-  auto_bb_flag post_assigned (fn);
-
-  /* Push the first edge on to the stack.  */
-  stack.quick_push (entry);
 
-  while (!stack.is_empty ())
-    {
-      basic_block src;
-      basic_block dest;
+  /* Lazily initialized per-BB data for the two DFS walks below.  */
+  rpoamdbs_bb_data *bb_data
+    = XNEWVEC (rpoamdbs_bb_data, last_basic_block_for_fn (fn));
 
-      /* Look at the edge on the top of the stack.  */
-      int idx = stack.length () - 1;
-      edge e = stack[idx];
-      src = e->src;
-      dest = e->dest;
-      e->flags &= ~EDGE_DFS_BACK;
+  /* First DFS walk, loop discovery according to
+      A New Algorithm for Identifying Loops in Decompilation
+     by Tao Wei, Jian Mao, Wei Zou and You Chen of the Institute of
+     Computer Science and Technology of the Peking University.  */
+  auto_vec<edge_iterator, 20> ei_stack (n_basic_blocks_for_fn (fn) + 1);
+  auto_bb_flag is_header (fn);
+  int depth = 1;
+  unsigned n_sccs = 0;
 
-      /* Check if the edge destination has been visited yet.  */
-      if (! bitmap_bit_p (exit_bbs, dest->index)
-	  && ! (dest->flags & visited))
+  basic_block dest = entry->dest;
+  edge_iterator ei;
+  int pre_num = 0;
+
+  /* DFS process DEST.  */
+find_loops:
+  bb_data[dest->index].bb_to_pre = pre_num++;
+  bb_data[dest->index].depth = depth;
+  bb_data[dest->index].scc = -1;
+  depth++;
+  gcc_assert ((dest->flags & (is_header|visited)) == 0);
+  dest->flags |= visited;
+  ei = ei_start (dest->succs);
+  while (!ei_end_p (ei))
+    {
+      ei_edge (ei)->flags &= ~EDGE_DFS_BACK;
+      if (bitmap_bit_p (exit_bbs, ei_edge (ei)->dest->index))
+	;
+      else if (!(ei_edge (ei)->dest->flags & visited))
 	{
-	  /* Mark that we have visited the destination.  */
-	  dest->flags |= visited;
-
-	  pre[dest->index] = pre_order_num++;
-
-	  if (EDGE_COUNT (dest->succs) > 0)
+	  ei_stack.quick_push (ei);
+	  dest = ei_edge (ei)->dest;
+	  /* DFS recurse on DEST.  */
+	  goto find_loops;
+
+ret_from_find_loops:
+	  /* Return point of DFS recursion.  */
+	  ei = ei_stack.pop ();
+	  dest = ei_edge (ei)->src;
+	  int header = bb_data[ei_edge (ei)->dest->index].scc;
+	  tag_header (dest->index, header, bb_data);
+	  depth = bb_data[dest->index].depth + 1;
+	}
+      else
+	{
+	  if (bb_data[ei_edge (ei)->dest->index].depth > 0) /* on the stack */
 	    {
-	      /* Since the DEST node has been visited for the first
-		 time, check its successors.  */
-	      /* Push the edge vector in reverse to match previous behavior.  */
-	      stack.reserve (EDGE_COUNT (dest->succs));
-	      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
-		stack.quick_push (EDGE_SUCC (dest, i));
-	      /* Generalize to handle more successors?  */
-	      if (for_iteration
-		  && EDGE_COUNT (dest->succs) == 2)
-		{
-		  edge &e1 = stack[stack.length () - 2];
-		  if (loop_exit_edge_p (e1->src->loop_father, e1))
-		    std::swap (e1, stack.last ());
-		}
+	      ei_edge (ei)->flags |= EDGE_DFS_BACK;
+	      n_sccs++;
+	      ei_edge (ei)->dest->flags |= is_header;
+	      ::new (&bb_data[ei_edge (ei)->dest->index].scc_exits)
+		auto_vec<int, 2> ();
+	      tag_header (dest->index, ei_edge (ei)->dest->index, bb_data);
 	    }
+	  else if (bb_data[ei_edge (ei)->dest->index].scc == -1)
+	    ;
 	  else
 	    {
-	      /* There are no successors for the DEST node so assign
-		 its reverse completion number.  */
-	      post[dest->index] = rev_post_order_num;
-	      dest->flags |= post_assigned;
-	      rev_post_order[rev_post_order_num] = dest->index;
-	      rev_post_order_num++;
+	      int header = bb_data[ei_edge (ei)->dest->index].scc;
+	      if (bb_data[header].depth > 0)
+		tag_header (dest->index, header, bb_data);
+	      else
+		{
+		  /* A re-entry into an existing loop.  */
+		  /* ???  Need to mark is_header?  */
+		  while (bb_data[header].scc != -1)
+		    {
+		      header = bb_data[header].scc;
+		      if (bb_data[header].depth > 0)
+			{
+			  tag_header (dest->index, header, bb_data);
+			  break;
+			}
+		    }
+		}
 	    }
 	}
-      else
-	{
-	  if (dest->flags & visited
-	      && src != entry->src
-	      && pre[src->index] >= pre[dest->index]
-	      && !(dest->flags & post_assigned))
-	    e->flags |= EDGE_DFS_BACK;
+      ei_next (&ei);
+    }
+  rev_post_order[rev_post_order_num++] = dest->index;
+  /* not on the stack anymore */
+  bb_data[dest->index].depth = -bb_data[dest->index].depth;
+  if (!ei_stack.is_empty ())
+    /* Return from DFS recursion.  */
+    goto ret_from_find_loops;
+
+  /* Optimize for no SCCs found or !for_iteration.  */
+  if (n_sccs == 0 || !for_iteration)
+    {
+      /* Clear the temporarily allocated flags.  */
+      for (int i = 0; i < rev_post_order_num; ++i)
+	BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags
+	  &= ~(is_header|visited);
+      /* And swap elements.  */
+      for (int i = 0; i < rev_post_order_num/2; ++i)
+	std::swap (rev_post_order[i], rev_post_order[rev_post_order_num-i-1]);
+      XDELETEVEC (bb_data);
+
+      return rev_post_order_num;
+    }
 
-	  if (idx != 0 && stack[idx - 1]->src != src)
+  /* Next find SCC exits, clear the visited flag and compute an upper bound
+     for the edge stack below.  */
+  unsigned edge_count = 0;
+  for (int i = 0; i < rev_post_order_num; ++i)
+    {
+      int bb = rev_post_order[i];
+      BASIC_BLOCK_FOR_FN (fn, bb)->flags &= ~visited;
+      edge e;
+      FOR_EACH_EDGE (e, ei, BASIC_BLOCK_FOR_FN (fn, bb)->succs)
+	{
+	  if (bitmap_bit_p (exit_bbs, e->dest->index))
+	    continue;
+	  edge_count++;
+	  /* if e is an exit from e->src, record it for
+	     bb_data[e->src].scc.  */
+	  int src_scc = e->src->index;
+	  if (!(e->src->flags & is_header))
+	    src_scc = bb_data[src_scc].scc;
+	  if (src_scc == -1)
+	    continue;
+	  int dest_scc = e->dest->index;
+	  if (!(e->dest->flags & is_header))
+	    dest_scc = bb_data[dest_scc].scc;
+	  if (src_scc == dest_scc)
+	    continue;
+	  /* When dest_scc is nested insde src_scc it's not an
+	     exit.  */
+	  int tem_dest_scc = dest_scc;
+	  unsigned dest_scc_depth = 0;
+	  while (tem_dest_scc != -1)
 	    {
-	      /* There are no more successors for the SRC node
-		 so assign its reverse completion number.  */
-	      post[src->index] = rev_post_order_num;
-	      src->flags |= post_assigned;
-	      rev_post_order[rev_post_order_num] = src->index;
-	      rev_post_order_num++;
+	      dest_scc_depth++;
+	      if ((tem_dest_scc = bb_data[tem_dest_scc].scc) == src_scc)
+		break;
+	    }
+	  if (tem_dest_scc != -1)
+	    continue;
+	  /* When src_scc is nested inside dest_scc record an
+	     exit from the outermost SCC this edge exits.  */
+	  int tem_src_scc = src_scc;
+	  unsigned src_scc_depth = 0;
+	  while (tem_src_scc != -1)
+	    {
+	      if (bb_data[tem_src_scc].scc == dest_scc)
+		{
+		  edge_count++;
+		  bb_data[tem_src_scc].scc_exits.safe_push (e->dest->index);
+		  break;
+		}
+	      tem_src_scc = bb_data[tem_src_scc].scc;
+	      src_scc_depth++;
+	    }
+	  /* Else find the outermost SCC this edge exits (exits
+	     from the inner SCCs are not important for the DFS
+	     walk adjustment).  Do so by computing the common
+	     ancestor SCC where the immediate child it to the source
+	     SCC is the exited SCC.  */
+	  if (tem_src_scc == -1)
+	    {
+	      edge_count++;
+	      while (src_scc_depth > dest_scc_depth)
+		{
+		  src_scc = bb_data[src_scc].scc;
+		  src_scc_depth--;
+		}
+	      while (dest_scc_depth > src_scc_depth)
+		{
+		  dest_scc = bb_data[dest_scc].scc;
+		  dest_scc_depth--;
+		}
+	      while (bb_data[src_scc].scc != bb_data[dest_scc].scc)
+		{
+		  src_scc = bb_data[src_scc].scc;
+		  dest_scc = bb_data[dest_scc].scc;
+		}
+	      bb_data[src_scc].scc_exits.safe_push (e->dest->index);
 	    }
-
-	  stack.pop ();
 	}
     }
 
-  XDELETEVEC (pre);
+  /* Now the second DFS walk to compute a RPO where the extent of SCCs
+     is minimized thus SCC members are adjacent in the RPO array.
+     This is done by performing a DFS walk computing RPO with first visiting
+     extra direct edges from SCC entry to its exits.
+     That simulates a DFS walk over the graph with SCCs collapsed and
+     walking the SCCs themselves only when all outgoing edges from the
+     SCCs have been visited.
+     SCC_END[scc-header-index] is the position in the RPO array of the
+     last member of the SCC.  */
+  auto_vec<std::pair<basic_block, basic_block>, 20> estack (edge_count + 1);
+  int idx = rev_post_order_num;
+  basic_block edest;
+  dest = entry->dest;
+
+  /* DFS process DEST.  */
+dfs_rpo:
+  gcc_checking_assert ((dest->flags & visited) == 0);
+  /* Verify we enter SCCs through the same header and SCC nesting appears
+     the same.  */
+  gcc_assert (bb_data[dest->index].scc == -1
+	      || (BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc)->flags
+		  & visited));
+  dest->flags |= visited;
+  bb_data[dest->index].scc_end = -1;
+  if ((dest->flags & is_header)
+      && !bb_data[dest->index].scc_exits.is_empty ())
+    {
+      /* Push the all SCC exits as outgoing edges from its header to
+	 be visited first.
+	 To process exits in the same relative order as in the first
+	 DFS walk sort them after their destination PRE order index.  */
+      gcc_sort_r (&bb_data[dest->index].scc_exits[0],
+		  bb_data[dest->index].scc_exits.length (),
+		  sizeof (int), cmp_edge_dest_pre, bb_data);
+      /* Process edges in reverse to match previous DFS walk order.  */
+      for (int i = bb_data[dest->index].scc_exits.length () - 1; i >= 0; --i)
+	estack.quick_push (std::make_pair
+	  (dest, BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc_exits[i])));
+    }
+  else
+    {
+      if (dest->flags & is_header)
+	bb_data[dest->index].scc_end = idx - 1;
+      /* Push the edge vector in reverse to match the iteration order
+	 from the DFS walk above.  */
+      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
+	if (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))
+	  estack.quick_push (std::make_pair (dest,
+					     EDGE_SUCC (dest, i)->dest));
+    }
+  while (!estack.is_empty ()
+	 && estack.last ().first == dest)
+    {
+      edest = estack.last ().second;
+      if (!(edest->flags & visited))
+	{
+	  dest = edest;
+	  /* DFS recurse on DEST.  */
+	  goto dfs_rpo;
 
-  /* Clear the temporarily allocated flags.  */
+ret_from_dfs_rpo:
+	  /* Return point of DFS recursion.  */
+	  dest = estack.last ().first;
+	}
+      estack.pop ();
+      /* If we processed all SCC exits from DEST mark the SCC end
+	 since all RPO entries up to DEST itself will now belong
+	 to its SCC.  The special-case of no SCC exits is already
+	 dealt with above.  */
+      if (dest->flags & is_header
+	  /* When the last exit edge was processed mark the SCC end
+	     and push the regular edges.  */
+	  && bb_data[dest->index].scc_end == -1
+	  && (estack.is_empty ()
+	      || estack.last ().first != dest))
+	{
+	  bb_data[dest->index].scc_end = idx - 1;
+	  /* Push the edge vector in reverse to match the iteration order
+	     from the DFS walk above.  */
+	  for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)
+	    if (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))
+	      estack.quick_push (std::make_pair (dest,
+						 EDGE_SUCC (dest, i)->dest));
+	}
+    }
+  rev_post_order[--idx] = dest->index;
+  if (!estack.is_empty ())
+    /* Return from DFS recursion.  */
+    goto ret_from_dfs_rpo;
+
+  /* Each SCC extends are from the position of the header inside
+     the RPO array up to RPO array index scc_end[header-index].  */
+  if (toplevel_scc_extents)
+    for (int i = 0; i < rev_post_order_num; i++)
+      {
+	basic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);
+	if (bb->flags & is_header)
+	  {
+	    toplevel_scc_extents->safe_push
+	      (std::make_pair (i, bb_data[bb->index].scc_end));
+	    i = bb_data[bb->index].scc_end;
+	  }
+      }
+
+  /* Clear the temporarily allocated flags and free memory.  */
   for (int i = 0; i < rev_post_order_num; ++i)
-    BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags
-      &= ~(post_assigned|visited);
+    {
+      basic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);
+      if (bb->flags & is_header)
+	bb_data[bb->index].scc_exits.~scc_exit_vec_t ();
+      bb->flags &= ~(visited|is_header);
+    }
+
+  XDELETEVEC (bb_data);
 
   return rev_post_order_num;
 }
diff --git a/gcc/cfganal.h b/gcc/cfganal.h
index 849e537eddb..06830b7f469 100644
--- a/gcc/cfganal.h
+++ b/gcc/cfganal.h
@@ -68,7 +68,8 @@ extern int pre_and_rev_post_order_compute_fn (struct function *,
 					      int *, int *, bool);
 extern int pre_and_rev_post_order_compute (int *, int *, bool);
 extern int rev_post_order_and_mark_dfs_back_seme (struct function *, edge,
-						  bitmap, bool, int *);
+						  bitmap, bool, int *,
+						  vec<std::pair<int, int> > *);
 extern int dfs_enumerate_from (basic_block, int,
 			       bool (*)(const_basic_block, const void *),
 			       basic_block *, int, const void *);
diff --git a/gcc/combine.c b/gcc/combine.c
index 35505cc5311..bc3f5166669 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7444,11 +7444,15 @@ expand_compound_operation (rtx x)
 				  mode, tem, modewidth - len);
     }
   else if (unsignedp && len < HOST_BITS_PER_WIDE_INT)
-    tem = simplify_and_const_int (NULL_RTX, mode,
-				  simplify_shift_const (NULL_RTX, LSHIFTRT,
-							mode, XEXP (x, 0),
-							pos),
-				  (HOST_WIDE_INT_1U << len) - 1);
+    {
+      tem = simplify_shift_const (NULL_RTX, LSHIFTRT, inner_mode,
+				  XEXP (x, 0), pos);
+      tem = gen_lowpart (mode, tem);
+      if (!tem || GET_CODE (tem) == CLOBBER)
+	return x;
+      tem = simplify_and_const_int (NULL_RTX, mode, tem,
+				    (HOST_WIDE_INT_1U << len) - 1);
+    }
   else
     /* Any other cases we can't handle.  */
     return x;
@@ -10170,7 +10174,7 @@ simplify_and_const_int_1 (scalar_int_mode mode, rtx varop,
   constop &= nonzero;
 
   /* If we don't have any bits left, return zero.  */
-  if (constop == 0)
+  if (constop == 0 && !side_effects_p (varop))
     return const0_rtx;
 
   /* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index 6049adc3f3b..e16bc784bb4 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -35,6 +35,17 @@
 		&& aarch64_mem_pair_operand (operands[0], DImode))
 	       || known_eq (GET_MODE_SIZE (<MODE>mode), 8))))
       operands[1] = force_reg (<MODE>mode, operands[1]);
+
+  /* If a constant is too complex to force to memory (e.g. because it
+     contains CONST_POLY_INTs), build it up from individual elements instead.
+     We should only need to do this before RA; aarch64_legitimate_constant_p
+     should ensure that we don't try to rematerialize the constant later.  */
+  if (GET_CODE (operands[1]) == CONST_VECTOR
+      && targetm.cannot_force_const_mem (<MODE>mode, operands[1]))
+    {
+      aarch64_expand_vector_init (operands[0], operands[1]);
+      DONE;
+    }
   "
 )
 
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.cc b/gcc/config/aarch64/aarch64-sve-builtins.cc
index d534ca923d9..336a1db662b 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -995,12 +995,29 @@ registered_function &
 function_builder::add_function (const function_instance &instance,
 				const char *name, tree fntype, tree attrs,
 				uint64_t required_extensions,
-				bool overloaded_p)
+				bool overloaded_p,
+				bool placeholder_p)
 {
   unsigned int code = vec_safe_length (registered_functions);
   code = (code << AARCH64_BUILTIN_SHIFT) | AARCH64_BUILTIN_SVE;
-  tree decl = simulate_builtin_function_decl (input_location, name, fntype,
-					      code, NULL, attrs);
+
+  /* We need to be able to generate placeholders to enusre that we have a
+     consistent numbering scheme for function codes between the C and C++
+     frontends, so that everything ties up in LTO.
+
+     Currently, tree-streamer-in.c:unpack_ts_function_decl_value_fields
+     validates that tree nodes returned by TARGET_BUILTIN_DECL are non-NULL and
+     some node other than error_mark_node. This is a holdover from when builtin
+     decls were streamed by code rather than by value.
+
+     Ultimately, we should be able to remove this validation of BUILT_IN_MD
+     nodes and remove the target hook. For now, however, we need to appease the
+     validation and return a non-NULL, non-error_mark_node node, so we
+     arbitrarily choose integer_zero_node.  */
+  tree decl = placeholder_p
+    ? integer_zero_node
+    : simulate_builtin_function_decl (input_location, name, fntype,
+				      code, NULL, attrs);
 
   registered_function &rfn = *ggc_alloc <registered_function> ();
   rfn.instance = instance;
@@ -1032,7 +1049,7 @@ function_builder::add_unique_function (const function_instance &instance,
 					   argument_types.address ());
   tree attrs = get_attributes (instance);
   registered_function &rfn = add_function (instance, name, fntype, attrs,
-					   required_extensions, false);
+					   required_extensions, false, false);
 
   /* Enter the function into the hash table.  */
   hashval_t hash = instance.hash ();
@@ -1043,16 +1060,14 @@ function_builder::add_unique_function (const function_instance &instance,
 
   /* Also add the function under its overloaded alias, if we want
      a separate decl for each instance of an overloaded function.  */
-  if (m_direct_overloads || force_direct_overloads)
+  char *overload_name = get_name (instance, true);
+  if (strcmp (name, overload_name) != 0)
     {
-      char *overload_name = get_name (instance, true);
-      if (strcmp (name, overload_name) != 0)
-	{
-	  /* Attribute lists shouldn't be shared.  */
-	  tree attrs = get_attributes (instance);
-	  add_function (instance, overload_name, fntype, attrs,
-			required_extensions, false);
-	}
+      /* Attribute lists shouldn't be shared.  */
+      tree attrs = get_attributes (instance);
+      bool placeholder_p = !(m_direct_overloads || force_direct_overloads);
+      add_function (instance, overload_name, fntype, attrs,
+		    required_extensions, false, placeholder_p);
     }
 
   obstack_free (&m_string_obstack, name);
@@ -1073,18 +1088,19 @@ function_builder::add_overloaded_function (const function_instance &instance,
 {
   char *name = get_name (instance, true);
   if (registered_function **map_value = m_overload_names.get (name))
-    gcc_assert ((*map_value)->instance == instance
-		&& ((*map_value)->required_extensions
-		    & ~required_extensions) == 0);
+    {
+      gcc_assert ((*map_value)->instance == instance
+		  && ((*map_value)->required_extensions
+		      & ~required_extensions) == 0);
+      obstack_free (&m_string_obstack, name);
+    }
   else
     {
       registered_function &rfn
 	= add_function (instance, name, m_overload_type, NULL_TREE,
-			required_extensions, true);
-      const char *permanent_name = IDENTIFIER_POINTER (DECL_NAME (rfn.decl));
-      m_overload_names.put (permanent_name, &rfn);
+			required_extensions, true, m_direct_overloads);
+      m_overload_names.put (name, &rfn);
     }
-  obstack_free (&m_string_obstack, name);
 }
 
 /* If we are using manual overload resolution, add one function decl
@@ -1094,9 +1110,6 @@ void
 function_builder::add_overloaded_functions (const function_group_info &group,
 					    mode_suffix_index mode)
 {
-  if (m_direct_overloads)
-    return;
-
   unsigned int explicit_type0 = (*group.shape)->explicit_type_suffix_p (0);
   unsigned int explicit_type1 = (*group.shape)->explicit_type_suffix_p (1);
   for (unsigned int pi = 0; group.preds[pi] != NUM_PREDS; ++pi)
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.h b/gcc/config/aarch64/aarch64-sve-builtins.h
index 526d9f55e7b..5ffc58cab0a 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.h
+++ b/gcc/config/aarch64/aarch64-sve-builtins.h
@@ -337,7 +337,8 @@ private:
   tree get_attributes (const function_instance &);
 
   registered_function &add_function (const function_instance &,
-				     const char *, tree, tree, uint64_t, bool);
+				     const char *, tree, tree,
+				     uint64_t, bool, bool);
 
   /* The function type to use for functions that are resolved by
      function_resolver.  */
diff --git a/gcc/config/aarch64/aarch64-sve.md b/gcc/config/aarch64/aarch64-sve.md
index d17a7770690..bd51323e57d 100644
--- a/gcc/config/aarch64/aarch64-sve.md
+++ b/gcc/config/aarch64/aarch64-sve.md
@@ -8455,6 +8455,20 @@
   "<perm_insn>\t%0.<Vetype>, %1.<Vetype>, %2.<Vetype>"
 )
 
+;; Special purpose permute used by the predicate generation instructions.
+;; Unlike the normal permute patterns, these instructions operate on VNx16BI
+;; regardless of the element size, so that all input and output bits are
+;; well-defined.  Operand 3 then indicates the size of the permute.
+(define_insn "@aarch64_sve_trn1_conv<mode>"
+  [(set (match_operand:VNx16BI 0 "register_operand" "=Upa")
+	(unspec:VNx16BI [(match_operand:VNx16BI 1 "register_operand" "Upa")
+			 (match_operand:VNx16BI 2 "register_operand" "Upa")
+			 (match_operand:PRED_ALL 3 "aarch64_simd_imm_zero")]
+			UNSPEC_TRN1_CONV))]
+  "TARGET_SVE"
+  "trn1\t%0.<PRED_ALL:Vetype>, %1.<PRED_ALL:Vetype>, %2.<PRED_ALL:Vetype>"
+)
+
 ;; =========================================================================
 ;; == Conversions
 ;; =========================================================================
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 9b400c49ac6..9fb2b4e5cf1 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -4752,6 +4752,56 @@ aarch64_expand_sve_ld1rq (rtx dest, rtx src)
   return true;
 }
 
+/* SRC is an SVE CONST_VECTOR that contains N "foreground" values followed
+   by N "background" values.  Try to move it into TARGET using:
+
+      PTRUE PRED.<T>, VL<N>
+      MOV TRUE.<T>, #<foreground>
+      MOV FALSE.<T>, #<background>
+      SEL TARGET.<T>, PRED.<T>, TRUE.<T>, FALSE.<T>
+
+   The PTRUE is always a single instruction but the MOVs might need a
+   longer sequence.  If the background value is zero (as it often is),
+   the sequence can sometimes collapse to a PTRUE followed by a
+   zero-predicated move.
+
+   Return the target on success, otherwise return null.  */
+
+static rtx
+aarch64_expand_sve_const_vector_sel (rtx target, rtx src)
+{
+  gcc_assert (CONST_VECTOR_NELTS_PER_PATTERN (src) == 2);
+
+  /* Make sure that the PTRUE is valid.  */
+  machine_mode mode = GET_MODE (src);
+  machine_mode pred_mode = aarch64_sve_pred_mode (mode);
+  unsigned int npatterns = CONST_VECTOR_NPATTERNS (src);
+  if (aarch64_svpattern_for_vl (pred_mode, npatterns)
+      == AARCH64_NUM_SVPATTERNS)
+    return NULL_RTX;
+
+  rtx_vector_builder pred_builder (pred_mode, npatterns, 2);
+  rtx_vector_builder true_builder (mode, npatterns, 1);
+  rtx_vector_builder false_builder (mode, npatterns, 1);
+  for (unsigned int i = 0; i < npatterns; ++i)
+    {
+      true_builder.quick_push (CONST_VECTOR_ENCODED_ELT (src, i));
+      pred_builder.quick_push (CONST1_RTX (BImode));
+    }
+  for (unsigned int i = 0; i < npatterns; ++i)
+    {
+      false_builder.quick_push (CONST_VECTOR_ENCODED_ELT (src, i + npatterns));
+      pred_builder.quick_push (CONST0_RTX (BImode));
+    }
+  expand_operand ops[4];
+  create_output_operand (&ops[0], target, mode);
+  create_input_operand (&ops[1], true_builder.build (), mode);
+  create_input_operand (&ops[2], false_builder.build (), mode);
+  create_input_operand (&ops[3], pred_builder.build (), pred_mode);
+  expand_insn (code_for_vcond_mask (mode, mode), 4, ops);
+  return target;
+}
+
 /* Return a register containing CONST_VECTOR SRC, given that SRC has an
    SVE data mode and isn't a legitimate constant.  Use TARGET for the
    result if convenient.
@@ -4886,6 +4936,10 @@ aarch64_expand_sve_const_vector (rtx target, rtx src)
   if (GET_MODE_NUNITS (mode).is_constant ())
     return NULL_RTX;
 
+  if (nelts_per_pattern == 2)
+    if (rtx res = aarch64_expand_sve_const_vector_sel (target, src))
+      return res;
+
   /* Expand each pattern individually.  */
   gcc_assert (npatterns > 1);
   rtx_vector_builder builder;
@@ -5067,12 +5121,12 @@ aarch64_expand_sve_const_pred_trn (rtx target, rtx_vector_builder &builder,
 	}
     }
 
-  /* Emit the TRN1 itself.  */
+  /* Emit the TRN1 itself.  We emit a TRN that operates on VNx16BI
+     operands but permutes them as though they had mode MODE.  */
   machine_mode mode = aarch64_sve_pred_mode (permute_size).require ();
-  target = aarch64_target_reg (target, mode);
-  emit_insn (gen_aarch64_sve (UNSPEC_TRN1, mode, target,
-			      gen_lowpart (mode, a),
-			      gen_lowpart (mode, b)));
+  target = aarch64_target_reg (target, GET_MODE (a));
+  rtx type_reg = CONST0_RTX (mode);
+  emit_insn (gen_aarch64_sve_trn1_conv (mode, target, a, b, type_reg));
   return target;
 }
 
@@ -16271,10 +16325,22 @@ aarch64_legitimate_constant_p (machine_mode mode, rtx x)
 {
   /* Support CSE and rematerialization of common constants.  */
   if (CONST_INT_P (x)
-      || (CONST_DOUBLE_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT)
-      || GET_CODE (x) == CONST_VECTOR)
+      || (CONST_DOUBLE_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT))
     return true;
 
+  /* Only accept variable-length vector constants if they can be
+     handled directly.
+
+     ??? It would be possible (but complex) to handle rematerialization
+     of other constants via secondary reloads.  */
+  if (!GET_MODE_SIZE (mode).is_constant ())
+    return aarch64_simd_valid_immediate (x, NULL);
+
+  /* Otherwise, accept any CONST_VECTOR that, if all else fails, can at
+     least be forced to memory and loaded from there.  */
+  if (GET_CODE (x) == CONST_VECTOR)
+    return !targetm.cannot_force_const_mem (mode, x);
+
   /* Do not allow vector struct mode constants for Advanced SIMD.
      We could support 0 and -1 easily, but they need support in
      aarch64-simd.md.  */
@@ -16282,14 +16348,6 @@ aarch64_legitimate_constant_p (machine_mode mode, rtx x)
   if (vec_flags == (VEC_ADVSIMD | VEC_STRUCT))
     return false;
 
-  /* Only accept variable-length vector constants if they can be
-     handled directly.
-
-     ??? It would be possible to handle rematerialization of other
-     constants via secondary reloads.  */
-  if (vec_flags & VEC_ANY_SVE)
-    return aarch64_simd_valid_immediate (x, NULL);
-
   if (GET_CODE (x) == HIGH)
     x = XEXP (x, 0);
 
@@ -18621,10 +18679,11 @@ aarch64_vectorize_preferred_vector_alignment (const_tree type)
 {
   if (aarch64_sve_data_mode_p (TYPE_MODE (type)))
     {
-      /* If the length of the vector is fixed, try to align to that length,
-	 otherwise don't try to align at all.  */
+      /* If the length of the vector is a fixed power of 2, try to align
+	 to that length, otherwise don't try to align at all.  */
       HOST_WIDE_INT result;
-      if (!BITS_PER_SVE_VECTOR.is_constant (&result))
+      if (!GET_MODE_BITSIZE (TYPE_MODE (type)).is_constant (&result)
+	  || !pow2p_hwi (result))
 	result = TYPE_ALIGN (TREE_TYPE (type));
       return result;
     }
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 58445dea941..552aed3ce89 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1229,10 +1229,19 @@
     if (GET_CODE (operands[0]) == MEM && operands[1] != const0_rtx)
       operands[1] = force_reg (<MODE>mode, operands[1]);
 
-    /* FIXME: RR we still need to fix up what we are doing with
-       symbol_refs and other types of constants.  */
-    if (CONSTANT_P (operands[1])
-        && !CONST_INT_P (operands[1]))
+    /* Lower moves of symbolic constants into individual instructions.
+       Doing this now is sometimes necessary for correctness, since some
+       sequences require temporary pseudo registers.  Lowering now is also
+       often better for optimization, since more RTL passes get the
+       chance to optimize the individual instructions.
+
+       When called after RA, also split multi-instruction moves into
+       smaller pieces now, since we can't be sure that sure that there
+       will be a following split pass.  */
+    if (CONST_INT_P (operands[1])
+	? (reload_completed
+	   && !aarch64_mov_imm_operand (operands[1], <MODE>mode))
+	: CONSTANT_P (operands[1]))
      {
        aarch64_expand_mov_immediate (operands[0], operands[1]);
        DONE;
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 0a7145281fa..ff5b23d71b1 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -633,6 +633,7 @@
     UNSPEC_UZP2Q	; Used in aarch64-sve.md.
     UNSPEC_ZIP1Q	; Used in aarch64-sve.md.
     UNSPEC_ZIP2Q	; Used in aarch64-sve.md.
+    UNSPEC_TRN1_CONV	; Used in aarch64-sve.md.
     UNSPEC_COND_CMPEQ_WIDE ; Used in aarch64-sve.md.
     UNSPEC_COND_CMPGE_WIDE ; Used in aarch64-sve.md.
     UNSPEC_COND_CMPGT_WIDE ; Used in aarch64-sve.md.
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index db37e2b8e71..132ecc5d7e3 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -5786,6 +5786,10 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)
 		   convert_optab_libfunc (sfix_optab, DImode, SFmode));
       add_libcall (libcall_htab,
 		   convert_optab_libfunc (ufix_optab, DImode, SFmode));
+      add_libcall (libcall_htab,
+		   convert_optab_libfunc (sfix_optab, SImode, SFmode));
+      add_libcall (libcall_htab,
+		   convert_optab_libfunc (ufix_optab, SImode, SFmode));
 
       /* Values from double-precision helper functions are returned in core
 	 registers if the selected core only supports single-precision
diff --git a/gcc/config/bpf/bpf.h b/gcc/config/bpf/bpf.h
index 359f389a134..88183e69564 100644
--- a/gcc/config/bpf/bpf.h
+++ b/gcc/config/bpf/bpf.h
@@ -57,8 +57,8 @@
    64-bit at any time.  */
 #define STACK_BOUNDARY 64
 
-/* Function entry points are aligned to 128 bits.  */
-#define FUNCTION_BOUNDARY 128
+/* Function entry points are aligned to 64 bits.  */
+#define FUNCTION_BOUNDARY 64
 
 /* Maximum alignment required by data of any type.  */
 #define BIGGEST_ALIGNMENT 64
@@ -422,9 +422,15 @@ enum reg_class
    Try to use asm_output_aligned_bss to implement this macro.  */
 
 #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)	\
-  do {								\
-    ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);		\
-  } while (0)
+  do									\
+    {									\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");			\
+      fprintf ((FILE), "%s", "\t.lcomm\t");				\
+      assemble_name ((FILE), (NAME));					\
+      fprintf ((FILE), "," HOST_WIDE_INT_PRINT_UNSIGNED ",%u\n",	\
+	       (SIZE), (ALIGN) / BITS_PER_UNIT);			\
+    }									\
+  while (0)
 
 /*** Output and Generation of Labels.  */
 
diff --git a/gcc/config/i386/winnt.c b/gcc/config/i386/winnt.c
index 201f69e74c4..a39d09f06da 100644
--- a/gcc/config/i386/winnt.c
+++ b/gcc/config/i386/winnt.c
@@ -921,15 +921,17 @@ i386_pe_seh_cold_init (FILE *f, const char *name)
 
   /* In the normal case, the frame pointer is near the bottom of the frame
      so we can do the full stack allocation and set it afterwards.  There
-     is an exception when the function accesses prior frames so, in this
-     case, we need to pre-allocate a small chunk before setting it.  */
-  if (crtl->accesses_prior_frames)
-    alloc_offset = seh->cfa_offset;
-  else
+     is an exception if the function overflows the SEH maximum frame size
+     or accesses prior frames so, in this case, we need to pre-allocate a
+     small chunk of stack before setting it.  */
+  offset = seh->sp_offset - INCOMING_FRAME_SP_OFFSET;
+  if (offset < SEH_MAX_FRAME_SIZE && !crtl->accesses_prior_frames)
     alloc_offset = seh->sp_offset;
+  else
+    alloc_offset = MIN (seh->cfa_offset + 240, seh->sp_offset);
 
   offset = alloc_offset - INCOMING_FRAME_SP_OFFSET;
-  if (offset > 0 && offset < SEH_MAX_FRAME_SIZE)
+  if (offset > 0)
     fprintf (f, "\t.seh_stackalloc\t" HOST_WIDE_INT_PRINT_DEC "\n", offset);
 
   for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
@@ -958,7 +960,7 @@ i386_pe_seh_cold_init (FILE *f, const char *name)
       fprintf (f, ", " HOST_WIDE_INT_PRINT_DEC "\n", offset);
     }
 
-  if (crtl->accesses_prior_frames)
+  if (alloc_offset != seh->sp_offset)
     {
       offset = seh->sp_offset - alloc_offset;
       if (offset > 0 && offset < SEH_MAX_FRAME_SIZE)
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index b576f9a3678..77fcd8988a8 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,189 @@
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-09-19  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97051
+	* constraint.cc (satisfy_atom): Pass true as the
+	manifestly_const_eval argument to maybe_constant_value.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-07-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95486
+	* pt.c (alias_ctad_tweaks): Call remove_constraints before
+	calling set_constraints.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-08  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97052
+	* constraint.cc (build_type_constraint): Temporarily increment
+	processing_template_decl before calling build_concept_check.
+	* pt.c (make_constrained_placeholder_type): Likewise.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-01-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95434
+	* pt.c (tsubst) <case TEMPLATE_TYPE_PARM>: If tsubsting
+	CLASS_PLACEHOLDER_TEMPLATE yields a TEMPLATE_TEMPLATE_PARM,
+	adjust to its TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* pt.c (deducible_expression): Look through implicit
+	INDIRECT_REFs as well.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100111
+	* constexpr.c (cxx_eval_store_expression): Don't add CONSTRUCTORs
+	for empty classes into *valp when types don't match even when *valp
+	is NULL.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99833
+	* pt.c (extract_locals_r): When handling DECL_EXPR of a structured
+	binding, add to data.internal also all corresponding structured
+	binding decls.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99859
+	* constexpr.c (addr_of_non_const_var): New function.
+	(cxx_bind_parameters_in_call): Set *non_constant_args to true
+	even if cp_walk_tree on arg with addr_of_non_const_var callback
+	returns true.
+
+2021-04-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* pt.c (instantiate_class_template_1): Use FOR_EACH_VEC_ELT instead
+	of range-based for loop.
+
+2021-04-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97973
+	* call.c (conv_unsafe_in_template_p): New.
+	(convert_like): Use it.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99806
+	* parser.c (cp_parser_member_declaration): Call
+	cp_parser_save_default_args even for function templates.  Use
+	STRIP_TEMPLATE on the declaration we're passing.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91416
+	* parser.c: Create a GC root for attributes in a decl specifier.
+	(cp_parser_type_specifier): Push/pop ->attributes onto/from it.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99831
+	* method.c (defaulted_late_check): ++ and -- function_depth around
+	the call to synthesize_method.
+	* pt.c: Remove the saved_trees global.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99331
+	* call.c (build_converted_constant_expr_internal): Don't emit
+	-Wconversion warnings.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	DR 1312
+	PR c++/99176
+	* constexpr.c (is_std_construct_at): New overload.
+	(is_std_allocator_allocate): New overload.
+	(cxx_eval_call_expression): Use the new overloads.
+	(cxx_eval_constant_expression): Reject casting
+	from void * as per DR 1312.  Don't check can_convert.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99120
+	* name-lookup.c (check_local_shadow): Check if the type of decl
+	is non-null before checking TYPE_PTR*.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99374
+	* call.c (standard_conversion): When converting pointers to
+	member, don't return NULL when the bases are equivalent but
+	incomplete.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-02-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98947
+	* call.c (build_conditional_expr_1): Don't call mark_lvalue_use
+	on arg2/arg3.
+	* expr.c (mark_use) <case MODIFY_EXPR>: Don't check read_p when
+	issuing the -Wvolatile warning.  Only set TREE_THIS_VOLATILE if
+	a warning was emitted.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* pt.c (instantiate_class_template_1): Instantiate members
+	marked with attribute used only after we're done instantiating
+	the class.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98333
+	* parser.c (cp_parser_class_specifier_1): Perform late-parsing
+	of NSDMIs before late-parsing of noexcept-specifiers.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index aa8d84fa90c..d4515f21e04 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1434,7 +1434,9 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
       tree fbase = class_of_this_parm (fromfn);
       tree tbase = class_of_this_parm (tofn);
 
-      if (!DERIVED_FROM_P (fbase, tbase))
+      /* If FBASE and TBASE are equivalent but incomplete, DERIVED_FROM_P
+	 yields false.  But a pointer to member of incomplete class is OK.  */
+      if (!same_type_p (fbase, tbase) && !DERIVED_FROM_P (fbase, tbase))
 	return NULL;
 
       tree fstat = static_fn_type (fromfn);
@@ -4392,6 +4394,9 @@ build_converted_constant_expr_internal (tree type, tree expr,
 	  && processing_template_decl)
 	conv = next_conversion (conv);
 
+      /* Issuing conversion warnings for value-dependent expressions is
+	 likely too noisy.  */
+      warning_sentinel w (warn_conversion);
       conv->check_narrowing = true;
       conv->check_narrowing_const_only = true;
       expr = convert_like (conv, expr, complain);
@@ -5474,8 +5479,6 @@ build_conditional_expr_1 (const op_location_t &loc,
       && same_type_p (arg2_type, arg3_type))
     {
       result_type = arg2_type;
-      arg2 = mark_lvalue_use (arg2);
-      arg3 = mark_lvalue_use (arg3);
       goto valid_operands;
     }
 
@@ -7302,6 +7305,27 @@ maybe_warn_array_conv (location_t loc, conversion *c, tree expr)
 	     "are only available with %<-std=c++2a%> or %<-std=gnu++2a%>");
 }
 
+/* Return true if converting FROM to TO is unsafe in a template.  */
+
+static bool
+conv_unsafe_in_template_p (tree to, tree from)
+{
+  /* Converting classes involves TARGET_EXPR.  */
+  if (CLASS_TYPE_P (to) || CLASS_TYPE_P (from))
+    return true;
+
+  /* Converting real to integer produces FIX_TRUNC_EXPR which tsubst
+     doesn't handle.  */
+  if (SCALAR_FLOAT_TYPE_P (from) && INTEGRAL_OR_ENUMERATION_TYPE_P (to))
+    return true;
+
+  /* Converting integer to real isn't a trivial conversion, either.  */
+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (from) && SCALAR_FLOAT_TYPE_P (to))
+    return true;
+
+  return false;
+}
+
 /* Wrapper for convert_like_real_1 that handles creating IMPLICIT_CONV_EXPR.  */
 
 static tree
@@ -7317,7 +7341,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,
   tree conv_expr = NULL_TREE;
   if (processing_template_decl
       && convs->kind != ck_identity
-      && (CLASS_TYPE_P (convs->type) || CLASS_TYPE_P (TREE_TYPE (expr))))
+      && conv_unsafe_in_template_p (convs->type, TREE_TYPE (expr)))
     {
       conv_expr = build1 (IMPLICIT_CONV_EXPR, convs->type, expr);
       if (convs->kind != ck_ref_bind)
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index ad3853940ff..d6fda8b96ee 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -1495,6 +1495,30 @@ free_constructor (tree t)
     }
 }
 
+/* Helper function of cxx_bind_parameters_in_call.  Return non-NULL
+   if *TP is address of a static variable (or part of it) currently being
+   constructed or of a heap artificial variable.  */
+
+static tree
+addr_of_non_const_var (tree *tp, int *walk_subtrees, void *data)
+{
+  if (TREE_CODE (*tp) == ADDR_EXPR)
+    if (tree var = get_base_address (TREE_OPERAND (*tp, 0)))
+      if (VAR_P (var) && TREE_STATIC (var))
+	{
+	  if (DECL_NAME (var) == heap_uninit_identifier
+	      || DECL_NAME (var) == heap_identifier)
+	    return var;
+
+	  constexpr_global_ctx *global = (constexpr_global_ctx *) data;
+	  if (global->values.get (var))
+	    return var;
+	}
+  if (TYPE_P (*tp))
+    *walk_subtrees = false;
+  return NULL_TREE;
+}
+
 /* Subroutine of cxx_eval_call_expression.
    We are processing a call expression (either CALL_EXPR or
    AGGR_INIT_EXPR) in the context of CTX.  Evaluate
@@ -1549,6 +1573,16 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,
 	    arg = adjust_temp_type (type, arg);
 	  if (!TREE_CONSTANT (arg))
 	    *non_constant_args = true;
+	    /* If arg is or contains address of a heap artificial variable or
+	       of a static variable being constructed, avoid caching the
+	       function call, as those variables might be modified by the
+	       function, or might be modified by the callers in between
+	       the cached function and just read by the function.  */
+	  else if (!*non_constant_args
+		   && cp_walk_tree (&arg, addr_of_non_const_var, ctx->global,
+				    NULL))
+	    *non_constant_args = true;
+
 	  /* For virtual calls, adjust the this argument, so that it is
 	     the object on which the method is called, rather than
 	     one of its bases.  */
@@ -1769,6 +1803,16 @@ is_std_construct_at (tree fndecl)
   return name && id_equal (name, "construct_at");
 }
 
+/* Overload for the above taking constexpr_call*.  */
+
+static inline bool
+is_std_construct_at (const constexpr_call *call)
+{
+  return (call
+	  && call->fundef
+	  && is_std_construct_at (call->fundef->decl));
+}
+
 /* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */
 
 static inline bool
@@ -1791,6 +1835,16 @@ is_std_allocator_allocate (tree fndecl)
   return decl_in_std_namespace_p (decl);
 }
 
+/* Overload for the above taking constexpr_call*.  */
+
+static inline bool
+is_std_allocator_allocate (const constexpr_call *call)
+{
+  return (call
+	  && call->fundef
+	  && is_std_allocator_allocate (call->fundef->decl));
+}
+
 /* Return true if FNDECL is __dynamic_cast.  */
 
 static inline bool
@@ -2197,9 +2251,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,
       if (TREE_CODE (t) == CALL_EXPR
 	  && cxx_replaceable_global_alloc_fn (fun)
 	  && (CALL_FROM_NEW_OR_DELETE_P (t)
-	      || (ctx->call
-		  && ctx->call->fundef
-		  && is_std_allocator_allocate (ctx->call->fundef->decl))))
+	      || is_std_allocator_allocate (ctx->call)))
 	{
 	  const int nargs = call_expr_nargs (t);
 	  tree arg0 = NULL_TREE;
@@ -2267,9 +2319,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,
 	 argument.  */
       if (TREE_CODE (t) == CALL_EXPR
 	  && cxx_placement_new_fn (fun)
-	  && ctx->call
-	  && ctx->call->fundef
-	  && is_std_construct_at (ctx->call->fundef->decl))
+	  && is_std_construct_at (ctx->call))
 	{
 	  const int nargs = call_expr_nargs (t);
 	  tree arg1 = NULL_TREE;
@@ -5096,6 +5146,14 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
       CONSTRUCTOR_NO_CLEARING (*valp)
 	= CONSTRUCTOR_NO_CLEARING (init);
     }
+  else if (TREE_CODE (init) == CONSTRUCTOR
+	   && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),
+							  type))
+    {
+      /* See above on initialization of empty bases.  */
+      gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);
+      return init;
+    }
   else
     *valp = init;
 
@@ -6270,6 +6328,36 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	if (VOID_TYPE_P (type))
 	  return void_node;
 
+	/* [expr.const]: a conversion from type cv void* to a pointer-to-object
+	   type cannot be part of a core constant expression as a resolution to
+	   DR 1312.  */
+	if (integer_zerop (op) /* FIXME: Remove in GCC 12.  */
+	    && TYPE_PTROB_P (type)
+	    && TYPE_PTR_P (TREE_TYPE (op))
+	    && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (op)))
+	    /* Inside a call to std::construct_at or to
+	       std::allocator<T>::{,de}allocate, we permit casting from void*
+	       because that is compiler-generated code.  */
+	    && !is_std_construct_at (ctx->call)
+	    && !is_std_allocator_allocate (ctx->call))
+	  {
+	    /* Likewise, don't error when casting from void* when OP is
+	       &heap uninit and similar.  */
+	    tree sop = tree_strip_nop_conversions (op);
+	    if (TREE_CODE (sop) == ADDR_EXPR
+		&& VAR_P (TREE_OPERAND (sop, 0))
+		&& DECL_ARTIFICIAL (TREE_OPERAND (sop, 0)))
+	      /* OK */;
+	    else
+	      {
+		if (!ctx->quiet)
+		  error_at (loc, "cast from %qT is not allowed",
+			    TREE_TYPE (op));
+		*non_constant_p = true;
+		return t;
+	      }
+	  }
+
 	if (TREE_CODE (op) == PTRMEM_CST && !TYPE_PTRMEM_P (type))
 	  op = cplus_expand_constant (op);
 
@@ -6288,26 +6376,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 		if (TYPE_REF_P (type))
 		  {
 		    if (!ctx->quiet)
-		      error_at (loc,
-				"dereferencing a null pointer");
+		      error_at (loc, "dereferencing a null pointer");
 		    *non_constant_p = true;
 		    return t;
 		  }
-		else if (TYPE_PTR_P (TREE_TYPE (op)))
-		  {
-		    tree from = TREE_TYPE (op);
-
-		    if (!can_convert (type, from, tf_none))
-		      {
-			if (!ctx->quiet)
-			  error_at (loc,
-				    "conversion of %qT null pointer to %qT "
-				    "is not a constant expression",
-				    from, type);
-			*non_constant_p = true;
-			return t;
-		      }
-		  }
 	      }
 	    else
 	      {
diff --git a/gcc/cp/constraint.cc b/gcc/cp/constraint.cc
index 5f6488e514f..f28239a35d6 100644
--- a/gcc/cp/constraint.cc
+++ b/gcc/cp/constraint.cc
@@ -1420,7 +1420,9 @@ tree
 build_type_constraint (tree decl, tree args, tsubst_flags_t complain)
 {
   tree wildcard = build_nt (WILDCARD_DECL);
+  ++processing_template_decl;
   tree check = build_concept_check (decl, wildcard, args, complain);
+  --processing_template_decl;
   if (check == error_mark_node)
     return error_mark_node;
   return unpack_concept_check (check);
@@ -2628,7 +2630,8 @@ satisfy_atom (tree t, tree args, subst_info info)
     result = cxx_constant_value (result);
   else
     {
-      result = maybe_constant_value (result);
+      result = maybe_constant_value (result, NULL_TREE,
+				     /*manifestly_const_eval=*/true);
       if (!TREE_CONSTANT (result))
 	result = error_mark_node;
     }
diff --git a/gcc/cp/expr.c b/gcc/cp/expr.c
index 9b535708c57..6a7569418b1 100644
--- a/gcc/cp/expr.c
+++ b/gcc/cp/expr.c
@@ -226,17 +226,17 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
 	     a volatile-qualified type is deprecated unless the assignment
 	     is either a discarded-value expression or appears in an
 	     unevaluated context."  */
-	  if (read_p
-	      && !cp_unevaluated_operand
+	  if (!cp_unevaluated_operand
 	      && (TREE_THIS_VOLATILE (lhs)
 		  || CP_TYPE_VOLATILE_P (TREE_TYPE (lhs)))
 	      && !TREE_THIS_VOLATILE (expr))
 	    {
-	      warning_at (location_of (expr), OPT_Wvolatile,
-			  "using value of simple assignment with %<volatile%>-"
-			  "qualified left operand is deprecated");
-	      /* Make sure not to warn about this assignment again.  */
-	      TREE_THIS_VOLATILE (expr) = true;
+	      if (warning_at (location_of (expr), OPT_Wvolatile,
+			      "using value of simple assignment with "
+			      "%<volatile%>-qualified left operand is "
+			      "deprecated"))
+		/* Make sure not to warn about this assignment again.  */
+		TREE_THIS_VOLATILE (expr) = true;
 	    }
 	  break;
 	}
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index 3a3e060843e..bfd1004dcaa 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -2934,7 +2934,12 @@ defaulted_late_check (tree fn)
       /* If the function was declared constexpr, check that the definition
 	 qualifies.  Otherwise we can define the function lazily.  */
       if (DECL_DECLARED_CONSTEXPR_P (fn) && !DECL_INITIAL (fn))
-	synthesize_method (fn);
+	{
+	  /* Prevent GC.  */
+	  function_depth++;
+	  synthesize_method (fn);
+	  function_depth--;
+	}
       return;
     }
 
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 76f3edb04c8..533d79542c9 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -2802,7 +2802,7 @@ check_local_shadow (tree decl)
   /* Don't warn for artificial things that are not implicit typedefs.  */
   if (DECL_ARTIFICIAL (decl) && !DECL_IMPLICIT_TYPEDEF_P (decl))
     return;
-  
+
   if (nonlambda_method_basetype ())
     if (tree member = lookup_member (current_nonlambda_class_type (),
 				     DECL_NAME (decl), /*protect=*/0,
@@ -2814,8 +2814,9 @@ check_local_shadow (tree decl)
 	   is a function or a pointer-to-function.  */
 	if (!OVL_P (member)
 	    || TREE_CODE (decl) == FUNCTION_DECL
-	    || TYPE_PTRFN_P (TREE_TYPE (decl))
-	    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))
+	    || (TREE_TYPE (decl)
+		&& (TYPE_PTRFN_P (TREE_TYPE (decl))
+		    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))))
 	  {
 	    auto_diagnostic_group d;
 	    if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wshadow,
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 1f4a28ff7c0..d486cf5998f 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -17631,6 +17631,11 @@ cp_parser_explicit_specialization (cp_parser* parser)
   --parser->num_template_parameter_lists;
 }
 
+/* Preserve the attributes across a garbage collect (by making it a GC
+   root), which can occur when parsing a member function.  */
+
+static GTY(()) vec<tree, va_gc> *cp_parser_decl_specs_attrs;
+
 /* Parse a type-specifier.
 
    type-specifier:
@@ -17723,8 +17728,12 @@ cp_parser_type_specifier (cp_parser* parser,
       /* Parse tentatively so that we can back up if we don't find a
 	 class-specifier.  */
       cp_parser_parse_tentatively (parser);
+      if (decl_specs->attributes)
+	vec_safe_push (cp_parser_decl_specs_attrs, decl_specs->attributes);
       /* Look for the class-specifier.  */
       type_spec = cp_parser_class_specifier (parser);
+      if (decl_specs->attributes)
+	cp_parser_decl_specs_attrs->pop ();
       invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, type_spec);
       /* If that worked, we're done.  */
       if (cp_parser_parse_definitely (parser))
@@ -24091,31 +24100,10 @@ cp_parser_class_specifier_1 (cp_parser* parser)
 	  maybe_end_member_template_processing ();
 	}
       vec_safe_truncate (unparsed_funs_with_default_args, 0);
-      /* Now parse any NSDMIs.  */
-      save_ccp = current_class_ptr;
-      save_ccr = current_class_ref;
-      FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)
-	{
-	  if (class_type != DECL_CONTEXT (decl))
-	    {
-	      if (pushed_scope)
-		pop_scope (pushed_scope);
-	      class_type = DECL_CONTEXT (decl);
-	      pushed_scope = push_scope (class_type);
-	    }
-	  inject_this_parameter (class_type, TYPE_UNQUALIFIED);
-	  cp_parser_late_parsing_nsdmi (parser, decl);
-	}
-      vec_safe_truncate (unparsed_nsdmis, 0);
-      current_class_ptr = save_ccp;
-      current_class_ref = save_ccr;
-      if (pushed_scope)
-	pop_scope (pushed_scope);
 
       /* If there are noexcept-specifiers that have not yet been processed,
-	 take care of them now.  */
-      class_type = NULL_TREE;
-      pushed_scope = NULL_TREE;
+	 take care of them now.  Do this before processing NSDMIs as they
+	 may depend on noexcept-specifiers already having been processed.  */
       FOR_EACH_VEC_SAFE_ELT (unparsed_noexcepts, ix, decl)
 	{
 	  tree ctx = DECL_CONTEXT (decl);
@@ -24163,6 +24151,25 @@ cp_parser_class_specifier_1 (cp_parser* parser)
 	  maybe_end_member_template_processing ();
 	}
       vec_safe_truncate (unparsed_noexcepts, 0);
+
+      /* Now parse any NSDMIs.  */
+      save_ccp = current_class_ptr;
+      save_ccr = current_class_ref;
+      FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)
+	{
+	  if (class_type != DECL_CONTEXT (decl))
+	    {
+	      if (pushed_scope)
+		pop_scope (pushed_scope);
+	      class_type = DECL_CONTEXT (decl);
+	      pushed_scope = push_scope (class_type);
+	    }
+	  inject_this_parameter (class_type, TYPE_UNQUALIFIED);
+	  cp_parser_late_parsing_nsdmi (parser, decl);
+	}
+      vec_safe_truncate (unparsed_nsdmis, 0);
+      current_class_ptr = save_ccp;
+      current_class_ref = save_ccr;
       if (pushed_scope)
 	pop_scope (pushed_scope);
 
@@ -25430,8 +25437,8 @@ cp_parser_member_declaration (cp_parser* parser)
 		  || !DECL_DECLARES_FUNCTION_P (decl))
 		finish_member_declaration (decl);
 
-	      if (TREE_CODE (decl) == FUNCTION_DECL)
-		cp_parser_save_default_args (parser, decl);
+	      if (DECL_DECLARES_FUNCTION_P (decl))
+		cp_parser_save_default_args (parser, STRIP_TEMPLATE (decl));
 	      else if (TREE_CODE (decl) == FIELD_DECL
 		       && DECL_INITIAL (decl))
 		/* Add DECL to the queue of NSDMI to be parsed later.  */
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index d329c0128ba..ae396e056c5 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -63,7 +63,6 @@ static GTY(()) struct pending_template *last_pending_template;
 int processing_template_parmlist;
 static int template_header_count;
 
-static GTY(()) tree saved_trees;
 static vec<int> inline_parm_levels;
 
 static GTY(()) struct tinst_level *current_tinst_level;
@@ -11762,6 +11761,9 @@ instantiate_class_template_1 (tree type)
      class, except we also need to push the enclosing classes.  */
   push_nested_class (type);
 
+  /* A vector to hold members marked with attribute used. */
+  auto_vec<tree> used;
+
   /* Now members are processed in the order of declaration.  */
   for (member = CLASSTYPE_DECL_LIST (pattern);
        member; member = TREE_CHAIN (member))
@@ -11839,7 +11841,7 @@ instantiate_class_template_1 (tree type)
 	      finish_member_declaration (r);
 	      /* Instantiate members marked with attribute used.  */
 	      if (r != error_mark_node && DECL_PRESERVE_P (r))
-		mark_used (r);
+		used.safe_push (r);
 	      if (TREE_CODE (r) == FUNCTION_DECL
 		  && DECL_OMP_DECLARE_REDUCTION_P (r))
 		cp_check_omp_declare_reduction (r);
@@ -11917,7 +11919,7 @@ instantiate_class_template_1 (tree type)
 			     /*flags=*/0);
 			  /* Instantiate members marked with attribute used. */
 			  if (r != error_mark_node && DECL_PRESERVE_P (r))
-			    mark_used (r);
+			    used.safe_push (r);
 			}
 		      else if (TREE_CODE (r) == FIELD_DECL)
 			{
@@ -12130,6 +12132,13 @@ instantiate_class_template_1 (tree type)
   if (TYPE_CONTAINS_VPTR_P (type) && CLASSTYPE_KEY_METHOD (type))
     vec_safe_push (keyed_classes, type);
 
+  /* Now that we've gone through all the members, instantiate those
+     marked with attribute used.  */
+  unsigned int i;
+  tree x;
+  FOR_EACH_VEC_ELT (used, i, x)
+    mark_used (x);
+
   return type;
 }
 
@@ -12682,7 +12691,27 @@ extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)
     tp = &TYPE_NAME (*tp);
 
   if (TREE_CODE (*tp) == DECL_EXPR)
-    data.internal.add (DECL_EXPR_DECL (*tp));
+    {
+      tree decl = DECL_EXPR_DECL (*tp);
+      data.internal.add (decl);
+      if (VAR_P (decl)
+	  && DECL_DECOMPOSITION_P (decl)
+	  && TREE_TYPE (decl) != error_mark_node)
+	{
+	  gcc_assert (DECL_NAME (decl) == NULL_TREE);
+	  for (tree decl2 = DECL_CHAIN (decl);
+	       decl2
+	       && VAR_P (decl2)
+	       && DECL_DECOMPOSITION_P (decl2)
+	       && DECL_NAME (decl2)
+	       && TREE_TYPE (decl2) != error_mark_node;
+	       decl2 = DECL_CHAIN (decl2))
+	    {
+	      gcc_assert (DECL_DECOMP_BASE (decl2) == decl);
+	      data.internal.add (decl2);
+	    }
+	}
+    }
   else if (tree spec = retrieve_local_specialization (*tp))
     {
       if (data.internal.contains (*tp))
@@ -15486,6 +15515,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 		    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))
 		      {
 			pl = tsubst_copy (pl, args, complain, in_decl);
+			if (TREE_CODE (pl) == TEMPLATE_TEMPLATE_PARM)
+			  pl = TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (pl);
 			CLASS_PLACEHOLDER_TEMPLATE (r) = pl;
 		      }
 		  }
@@ -21670,8 +21701,10 @@ static bool uses_deducible_template_parms (tree type);
 static bool
 deducible_expression (tree expr)
 {
-  /* Strip implicit conversions.  */
-  while (CONVERT_EXPR_P (expr) || TREE_CODE (expr) == VIEW_CONVERT_EXPR)
+  /* Strip implicit conversions and implicit INDIRECT_REFs.  */
+  while (CONVERT_EXPR_P (expr)
+	 || TREE_CODE (expr) == VIEW_CONVERT_EXPR
+	 || REFERENCE_REF_P (expr))
     expr = TREE_OPERAND (expr, 0);
   return (TREE_CODE (expr) == TEMPLATE_PARM_INDEX);
 }
@@ -27964,7 +27997,9 @@ make_constrained_placeholder_type (tree type, tree con, tree args)
   tree expr = tmpl;
   if (TREE_CODE (con) == FUNCTION_DECL)
     expr = ovl_make (tmpl);
+  ++processing_template_decl;
   expr = build_concept_check (expr, type, args, tf_warning_or_error);
+  --processing_template_decl;
 
   PLACEHOLDER_TYPE_CONSTRAINTS (type) = expr;
 
@@ -28788,7 +28823,10 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	    }
 
 	  if (ci)
-	    set_constraints (fprime, ci);
+	    {
+	      remove_constraints (fprime);
+	      set_constraints (fprime, ci);
+	    }
 	}
       else
 	{
diff --git a/gcc/cprop.c b/gcc/cprop.c
index 169ca804e33..e084250380c 100644
--- a/gcc/cprop.c
+++ b/gcc/cprop.c
@@ -1007,16 +1007,18 @@ static int
 constprop_register (rtx from, rtx src, rtx_insn *insn)
 {
   rtx sset;
+  rtx_insn *next_insn;
 
   /* Check for reg or cc0 setting instructions followed by
      conditional branch instructions first.  */
   if ((sset = single_set (insn)) != NULL
-      && NEXT_INSN (insn)
-      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))
+      && (next_insn = next_nondebug_insn (insn)) != NULL
+      && any_condjump_p (next_insn)
+      && onlyjump_p (next_insn))
     {
       rtx dest = SET_DEST (sset);
       if ((REG_P (dest) || CC0_P (dest))
-	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn),
+	  && cprop_jump (BLOCK_FOR_INSN (insn), insn, next_insn,
 			 from, src))
 	return 1;
     }
diff --git a/gcc/cse.c b/gcc/cse.c
index 36bcfc354d8..f69a33a82e0 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -2637,6 +2637,11 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)
     CASE_CONST_UNIQUE:
       return x == y;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
 
diff --git a/gcc/cselib.c b/gcc/cselib.c
index 53e9603868d..5ecedef0bb4 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -1048,6 +1048,11 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)
     case DEBUG_EXPR:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index 8bc729ae32d..afe5976027b 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,14 @@
+2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98457
+	* d-diagnostic.cc (expand_d_format): Handle escaped backticks.
+	(escape_d_format): New funtion.
+	(verror): Call escape_d_format on prefixing strings.
+	(vdeprecation): Likewise.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/d/d-diagnostic.cc b/gcc/d/d-diagnostic.cc
index 6af35f71c31..dbe6bc1bb7b 100644
--- a/gcc/d/d-diagnostic.cc
+++ b/gcc/d/d-diagnostic.cc
@@ -48,7 +48,7 @@ expand_d_format (const char *format)
 
   for (const char *p = format; *p;)
     {
-      while (*p != '\0' && *p != '%' && *p != '`')
+      while (*p != '\0' && *p != '\\' && *p != '%' && *p != '`')
 	{
 	  buf.writeByte (*p);
 	  p++;
@@ -57,6 +57,21 @@ expand_d_format (const char *format)
       if (*p == '\0')
 	break;
 
+      if (*p == '\\')
+	{
+	  if (p[1] == '`')
+	    {
+	      /* Escaped backtick, don't expand it as a quoted string.  */
+	      buf.writeByte ('`');
+	      p++;;
+	    }
+	  else
+	    buf.writeByte (*p);
+
+	  p++;
+	  continue;
+	}
+
       if (*p == '`')
 	{
 	  /* Text enclosed by `...` are translated as a quoted string.  */
@@ -113,6 +128,43 @@ expand_d_format (const char *format)
   return buf.extractString ();
 }
 
+/* Rewrite the format string FORMAT to deal with any characters that require
+   escaping before expand_d_format expands it.  */
+
+static char *
+escape_d_format (const char *format)
+{
+  obstack buf;
+
+  gcc_obstack_init (&buf);
+
+  for (const char *p = format; *p; p++)
+    {
+      switch (*p)
+	{
+	case '%':
+	  /* Escape `%' characters so that pp_format does not confuse them
+	     for actual format specifiers.  */
+	  obstack_1grow (&buf, '%');
+	  break;
+
+	case '`':
+	  /* Escape '`' characters so that expand_d_format does not confuse them
+	     for a quoted string.  */
+	  obstack_1grow (&buf, '\\');
+	  break;
+
+	default:
+	  break;
+	}
+
+      obstack_1grow (&buf, *p);
+    }
+
+  obstack_1grow (&buf, '\0');
+  return (char *) obstack_finish (&buf);
+}
+
 /* Helper routine for all error routines.  Reports a diagnostic specified by
    KIND at the explicit location LOC.  The message FORMAT comes from the dmd
    front-end, which does not get translated by the gcc diagnostic routines.  */
@@ -177,9 +229,10 @@ verror (const Loc& loc, const char *format, va_list ap,
 
       /* Build string and emit.  */
       if (prefix2 != NULL)
-	xformat = xasprintf ("%s %s %s", prefix1, prefix2, format);
+	xformat = xasprintf ("%s %s %s", escape_d_format (prefix1),
+			     escape_d_format (prefix2), format);
       else if (prefix1 != NULL)
-	xformat = xasprintf ("%s %s", prefix1, format);
+	xformat = xasprintf ("%s %s", escape_d_format (prefix1), format);
       else
 	xformat = xasprintf ("%s", format);
 
@@ -287,9 +340,10 @@ vdeprecation (const Loc& loc, const char *format, va_list ap,
 
       /* Build string and emit.  */
       if (prefix2 != NULL)
-	xformat = xasprintf ("%s %s %s", prefix1, prefix2, format);
+	xformat = xasprintf ("%s %s %s", escape_d_format (prefix1),
+			     escape_d_format (prefix2), format);
       else if (prefix1 != NULL)
-	xformat = xasprintf ("%s %s", prefix1, format);
+	xformat = xasprintf ("%s %s", escape_d_format (prefix1), format);
       else
 	xformat = xasprintf ("%s", format);
 
diff --git a/gcc/dse.c b/gcc/dse.c
index c8dcf46ed29..68ab4383d50 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1950,8 +1950,7 @@ get_stored_val (store_info *store_info, machine_mode read_mode,
 
 static bool
 replace_read (store_info *store_info, insn_info_t store_insn,
-	      read_info_t read_info, insn_info_t read_insn, rtx *loc,
-	      bitmap regs_live)
+	      read_info_t read_info, insn_info_t read_insn, rtx *loc)
 {
   machine_mode store_mode = GET_MODE (store_info->mem);
   machine_mode read_mode = GET_MODE (read_info->mem);
@@ -2020,7 +2019,8 @@ replace_read (store_info *store_info, insn_info_t store_insn,
 	  note_stores (this_insn, look_for_hardregs, regs_set);
 	}
 
-      bitmap_and_into (regs_set, regs_live);
+      if (store_insn->fixed_regs_live)
+	bitmap_and_into (regs_set, store_insn->fixed_regs_live);
       if (!bitmap_empty_p (regs_set))
 	{
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2261,7 +2261,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
 						 offset - store_info->offset,
 						 width)
 		      && replace_read (store_info, i_ptr, read_info,
-				       insn_info, loc, bb_info->regs_live))
+				       insn_info, loc))
 		    return;
 
 		  /* The bases are the same, just see if the offsets
@@ -2327,8 +2327,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)
 				   store_info->width)
 	      && all_positions_needed_p (store_info,
 					 offset - store_info->offset, width)
-	      && replace_read (store_info, i_ptr,  read_info, insn_info, loc,
-			       bb_info->regs_live))
+	      && replace_read (store_info, i_ptr,  read_info, insn_info, loc))
 	    return;
 
 	  remove = canon_true_dependence (store_info->mem,
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 972512e8115..9dbde16989e 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -5936,6 +5936,7 @@ bool
 valid_for_const_vector_p (machine_mode, rtx x)
 {
   return (CONST_SCALAR_INT_P (x)
+	  || CONST_POLY_INT_P (x)
 	  || CONST_DOUBLE_AS_FLOAT_P (x)
 	  || CONST_FIXED_P (x));
 }
diff --git a/gcc/expr.c b/gcc/expr.c
index 991b26f3341..c4bffd0f199 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -8050,7 +8050,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, scalar_int_mode tmode,
 	 array with address of COMPOUND_LITERAL_EXPR in DECL_INITIAL;
 	 the initializers aren't gimplified.  */
       if (COMPOUND_LITERAL_EXPR_DECL (exp)
-	  && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))
+	  && is_global_var (COMPOUND_LITERAL_EXPR_DECL (exp)))
 	return expand_expr_addr_expr_1 (COMPOUND_LITERAL_EXPR_DECL (exp),
 					target, tmode, modifier, as);
       /* FALLTHRU */
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index aa5932be872..39bab1f2b2d 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,22 @@
+2021-04-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-16  Harald Anlauf  <anlauf@gmx.de>
+		    Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/63797
+	* module.c (write_symtree): Do not write interface of intrinsic
+	procedure to module file for F2003 and newer.
+
+2021-04-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/99817
+	* trans-types.c (gfc_get_function_type): Also generate hidden
+	coarray argument for character arguments.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 9a5b1cb7625..0c14f2a8105 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -6078,6 +6078,17 @@ write_symtree (gfc_symtree *st)
   if (check_unique_name (st->name))
     return;
 
+  /* From F2003 onwards, intrinsic procedures are no longer subject to
+     the restriction, "that an elemental intrinsic function here be of
+     type integer or character and each argument must be an initialization
+     expr of type integer or character" is lifted so that intrinsic
+     procedures can be over-ridden. This requires that the intrinsic
+     symbol not appear in the module file, thereby preventing ambiguity
+     when USEd.  */
+  if (strcmp (sym->module, "(intrinsic)") == 0
+      && (gfc_option.allow_std & GFC_STD_F2003))
+    return;
+
   p = find_pointer (sym);
   if (p == NULL)
     gfc_internal_error ("write_symtree(): Symbol not written");
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d3fef08b4b9..68d903d47ae 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -3115,14 +3115,14 @@ gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 	vec_safe_push (typelist, boolean_type_node);
       /* Coarrays which are descriptorless or assumed-shape pass with
 	 -fcoarray=lib the token and the offset as hidden arguments.  */
-      else if (arg
-	       && flag_coarray == GFC_FCOARRAY_LIB
-	       && ((arg->ts.type != BT_CLASS
-		    && arg->attr.codimension
-		    && !arg->attr.allocatable)
-		   || (arg->ts.type == BT_CLASS
-		       && CLASS_DATA (arg)->attr.codimension
-		       && !CLASS_DATA (arg)->attr.allocatable)))
+      if (arg
+	  && flag_coarray == GFC_FCOARRAY_LIB
+	  && ((arg->ts.type != BT_CLASS
+	       && arg->attr.codimension
+	       && !arg->attr.allocatable)
+	      || (arg->ts.type == BT_CLASS
+		  && CLASS_DATA (arg)->attr.codimension
+		  && !CLASS_DATA (arg)->attr.allocatable)))
 	{
 	  vec_safe_push (typelist, pvoid_type_node);  /* caf_token.  */
 	  vec_safe_push (typelist, gfc_array_index_type);  /* caf_offset.  */
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index da3536ecd4e..b8754dcc105 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -4840,6 +4840,7 @@ static bool
 maybe_canonicalize_mem_ref_addr (tree *t, bool is_debug = false)
 {
   bool res = false;
+  tree *orig_t = t;
 
   if (TREE_CODE (*t) == ADDR_EXPR)
     t = &TREE_OPERAND (*t, 0);
@@ -4952,6 +4953,8 @@ maybe_canonicalize_mem_ref_addr (tree *t, bool is_debug = false)
       if (tem)
 	{
 	  *t = tem;
+	  if (TREE_CODE (*orig_t) == ADDR_EXPR)
+	    recompute_tree_invariant_for_addr_expr (*orig_t);
 	  res = true;
 	}
     }
diff --git a/gcc/jump.c b/gcc/jump.c
index 34a8f209e20..803c297b0fc 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -1767,6 +1767,11 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       /* We can't assume nonlocal labels have their following insns yet.  */
       if (LABEL_REF_NONLOCAL_P (x) || LABEL_REF_NONLOCAL_P (y))
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index 7cc479b3042..f390c9ffed1 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -235,12 +235,17 @@ get_reg_class (int regno)
    CL.  Use elimination first if REG is a hard register.  If REG is a
    reload pseudo created by this constraints pass, assume that it will
    be allocated a hard register from its allocno class, but allow that
-   class to be narrowed to CL if it is currently a superset of CL.
+   class to be narrowed to CL if it is currently a superset of CL and
+   if either:
+
+   - ALLOW_ALL_RELOAD_CLASS_CHANGES_P is true or
+   - the instruction we're processing is not a reload move.
 
    If NEW_CLASS is nonnull, set *NEW_CLASS to the new allocno class of
    REGNO (reg), or NO_REGS if no change in its class was needed.  */
 static bool
-in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)
+in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class,
+	    bool allow_all_reload_class_changes_p = false)
 {
   enum reg_class rclass, common_class;
   machine_mode reg_mode;
@@ -267,7 +272,8 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)
 	 typically moves that have many alternatives, and restricting
 	 reload pseudos for one alternative may lead to situations
 	 where other reload pseudos are no longer allocatable.  */
-      || (INSN_UID (curr_insn) >= new_insn_uid_start
+      || (!allow_all_reload_class_changes_p
+	  && INSN_UID (curr_insn) >= new_insn_uid_start
 	  && src != NULL
 	  && ((REG_P (src) || MEM_P (src))
 	      || (GET_CODE (src) == SUBREG
@@ -570,13 +576,12 @@ init_curr_insn_input_reloads (void)
   curr_insn_input_reloads_num = 0;
 }
 
-/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse already
-   created input reload pseudo (only if TYPE is not OP_OUT).  Don't
-   reuse pseudo if IN_SUBREG_P is true and the reused pseudo should be
-   wrapped up in SUBREG.  The result pseudo is returned through
-   RESULT_REG.  Return TRUE if we created a new pseudo, FALSE if we
-   reused the already created input reload pseudo.  Use TITLE to
-   describe new registers for debug purposes.  */
+/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse an existing
+   reload pseudo.  Don't reuse an existing reload pseudo if IN_SUBREG_P
+   is true and the reused pseudo should be wrapped up in a SUBREG.
+   The result pseudo is returned through RESULT_REG.  Return TRUE if we
+   created a new pseudo, FALSE if we reused an existing reload pseudo.
+   Use TITLE to describe new registers for debug purposes.  */
 static bool
 get_reload_reg (enum op_type type, machine_mode mode, rtx original,
 		enum reg_class rclass, bool in_subreg_p,
@@ -588,6 +593,40 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,
 
   if (type == OP_OUT)
     {
+      /* Output reload registers tend to start out with a conservative
+	 choice of register class.  Usually this is ALL_REGS, although
+	 a target might narrow it (for performance reasons) through
+	 targetm.preferred_reload_class.  It's therefore quite common
+	 for a reload instruction to require a more restrictive class
+	 than the class that was originally assigned to the reload register.
+
+	 In these situations, it's more efficient to refine the choice
+	 of register class rather than create a second reload register.
+	 This also helps to avoid cycling for registers that are only
+	 used by reload instructions.  */
+      rtx src = curr_insn_set != NULL ? SET_SRC (curr_insn_set) : NULL;
+      if (REG_P (original)
+	  && (int) REGNO (original) >= new_regno_start
+	  && INSN_UID (curr_insn) >= new_insn_uid_start
+	  && in_class_p (original, rclass, &new_class, true)
+	  && src != NULL
+	  && ((REG_P (src) || MEM_P (src))
+	      || (GET_CODE (src) == SUBREG
+		  && (REG_P (SUBREG_REG (src)) || MEM_P (SUBREG_REG (src))))))
+	{
+	  unsigned int regno = REGNO (original);
+	  if (lra_dump_file != NULL)
+	    {
+	      fprintf (lra_dump_file, "	 Reuse r%d for output ", regno);
+	      dump_value_slim (lra_dump_file, original, 1);
+	    }
+	  if (new_class != lra_get_allocno_class (regno))
+	    lra_change_class (regno, new_class, ", change to", false);
+	  if (lra_dump_file != NULL)
+	    fprintf (lra_dump_file, "\n");
+	  *result_reg = original;
+	  return false;
+	}
       *result_reg
 	= lra_create_new_reg_with_unique_value (mode, original, rclass, title);
       return true;
@@ -751,6 +790,11 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)
     CASE_CONST_UNIQUE:
       return false;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
     case SYMBOL_REF:
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
index 03440f0254c..7ac3b63fd33 100644
--- a/gcc/lto-streamer.h
+++ b/gcc/lto-streamer.h
@@ -121,7 +121,7 @@ along with GCC; see the file COPYING3.  If not see
      form followed by the data for the string.  */
 
 #define LTO_major_version 9
-#define LTO_minor_version 3
+#define LTO_minor_version 4
 
 typedef unsigned char	lto_decl_flags_t;
 
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
index 90df5c90547..af4059cc2ab 100644
--- a/gcc/omp-expand.c
+++ b/gcc/omp-expand.c
@@ -1548,8 +1548,8 @@ struct oacc_collapse
 static tree
 expand_oacc_collapse_init (const struct omp_for_data *fd,
 			   gimple_stmt_iterator *gsi,
-			   oacc_collapse *counts, tree bound_type,
-			   location_t loc)
+			   oacc_collapse *counts, tree diff_type,
+			   tree bound_type, location_t loc)
 {
   tree tiling = fd->tiling;
   tree total = build_int_cst (bound_type, 1);
@@ -1566,17 +1566,12 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,
       const omp_for_data_loop *loop = &fd->loops[ix];
 
       tree iter_type = TREE_TYPE (loop->v);
-      tree diff_type = iter_type;
       tree plus_type = iter_type;
 
-      gcc_assert (loop->cond_code == fd->loop.cond_code);
+      gcc_assert (loop->cond_code == LT_EXPR || loop->cond_code == GT_EXPR);
 
       if (POINTER_TYPE_P (iter_type))
 	plus_type = sizetype;
-      if (POINTER_TYPE_P (diff_type) || TYPE_UNSIGNED (diff_type))
-	diff_type = signed_type_for (diff_type);
-      if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (integer_type_node))
-	diff_type = integer_type_node;
 
       if (tiling)
 	{
@@ -1664,7 +1659,8 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,
 static void
 expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
 			   gimple_stmt_iterator *gsi,
-			   const oacc_collapse *counts, tree ivar)
+			   const oacc_collapse *counts, tree ivar,
+			   tree diff_type)
 {
   tree ivar_type = TREE_TYPE (ivar);
 
@@ -1676,7 +1672,6 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
       const oacc_collapse *collapse = &counts[ix];
       tree v = inner ? loop->v : collapse->outer;
       tree iter_type = TREE_TYPE (v);
-      tree diff_type = TREE_TYPE (collapse->step);
       tree plus_type = iter_type;
       enum tree_code plus_code = PLUS_EXPR;
       tree expr;
@@ -1698,7 +1693,7 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,
 	}
 
       expr = fold_build2 (MULT_EXPR, diff_type, fold_convert (diff_type, expr),
-			  collapse->step);
+			  fold_convert (diff_type, collapse->step));
       expr = fold_build2 (plus_code, iter_type,
 			  inner ? collapse->outer : collapse->base,
 			  fold_convert (plus_type, expr));
@@ -6039,6 +6034,12 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
       plus_code = POINTER_PLUS_EXPR;
       plus_type = sizetype;
     }
+  for (int ix = fd->collapse; ix--;)
+    {
+      tree diff_type2 = TREE_TYPE (fd->loops[ix].step);
+      if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (diff_type2))
+	diff_type = diff_type2;
+    }
   if (POINTER_TYPE_P (diff_type) || TYPE_UNSIGNED (diff_type))
     diff_type = signed_type_for (diff_type);
   if (TYPE_PRECISION (diff_type) < TYPE_PRECISION (integer_type_node))
@@ -6122,7 +6123,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
     {
       gcc_assert (!gimple_in_ssa_p (cfun) && up);
       counts = XALLOCAVEC (struct oacc_collapse, fd->collapse);
-      tree total = expand_oacc_collapse_init (fd, &gsi, counts,
+      tree total = expand_oacc_collapse_init (fd, &gsi, counts, diff_type,
 					      TREE_TYPE (fd->loop.n2), loc);
 
       if (SSA_VAR_P (fd->loop.n2))
@@ -6284,7 +6285,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
       gsi_insert_before (&gsi, ass, GSI_SAME_STMT);
 
       if (fd->collapse > 1 || fd->tiling)
-	expand_oacc_collapse_vars (fd, false, &gsi, counts, v);
+	expand_oacc_collapse_vars (fd, false, &gsi, counts, v, diff_type);
 
       if (fd->tiling)
 	{
@@ -6354,7 +6355,8 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
 
 	  /* Initialize the user's loop vars.  */
 	  gsi = gsi_start_bb (elem_body_bb);
-	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);
+	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset,
+				     diff_type);
 	}
     }
 
diff --git a/gcc/reload.c b/gcc/reload.c
index 78b4049f465..5f099be43b3 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -2291,6 +2291,11 @@ operands_match_p (rtx x, rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case LABEL_REF:
       return label_ref_label (x) == label_ref_label (y);
     case SYMBOL_REF:
diff --git a/gcc/rtl.c b/gcc/rtl.c
index 4411e067ba8..63f0a26c912 100644
--- a/gcc/rtl.c
+++ b/gcc/rtl.c
@@ -466,6 +466,11 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
@@ -608,6 +613,11 @@ rtx_equal_p (const_rtx x, const_rtx y)
     CASE_CONST_UNIQUE:
       return 0;
 
+    case CONST_VECTOR:
+      if (!same_vector_encodings_p (x, y))
+	return false;
+      break;
+
     case DEBUG_IMPLICIT_PTR:
       return DEBUG_IMPLICIT_PTR_DECL (x)
 	     == DEBUG_IMPLICIT_PTR_DECL (y);
diff --git a/gcc/rtl.h b/gcc/rtl.h
index b29afca8d6b..5d57ac6bc5f 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -3087,6 +3087,23 @@ vec_series_p (const_rtx x, rtx *base_out, rtx *step_out)
   return const_vec_series_p (x, base_out, step_out);
 }
 
+/* Return true if CONST_VECTORs X and Y, which are known to have the same mode,
+   also have the same encoding.  This means that they are equal whenever their
+   operands are equal.  */
+
+inline bool
+same_vector_encodings_p (const_rtx x, const_rtx y)
+{
+  /* Don't be fussy about the encoding of constant-length vectors,
+     since XVECEXP (X, 0) and XVECEXP (Y, 0) list all the elements anyway.  */
+  if (poly_uint64 (CONST_VECTOR_NUNITS (x)).is_constant ())
+    return true;
+
+  return (CONST_VECTOR_NPATTERNS (x) == CONST_VECTOR_NPATTERNS (y)
+	  && (CONST_VECTOR_NELTS_PER_PATTERN (x)
+	      == CONST_VECTOR_NELTS_PER_PATTERN (y)));
+}
+
 /* Return the unpromoted (outer) mode of SUBREG_PROMOTED_VAR_P subreg X.  */
 
 inline scalar_int_mode
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 0ebde7622db..e65d06d5bca 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -463,12 +463,17 @@ rtx_addr_can_trap_p_1 (const_rtx x, poly_int64 offset, poly_int64 size,
 		       machine_mode mode, bool unaligned_mems)
 {
   enum rtx_code code = GET_CODE (x);
-  gcc_checking_assert (mode == BLKmode || known_size_p (size));
+  gcc_checking_assert (mode == BLKmode
+		       || mode == VOIDmode
+		       || known_size_p (size));
   poly_int64 const_x1;
 
   /* The offset must be a multiple of the mode size if we are considering
      unaligned memory references on strict alignment machines.  */
-  if (STRICT_ALIGNMENT && unaligned_mems && mode != BLKmode)
+  if (STRICT_ALIGNMENT
+      && unaligned_mems
+      && mode != BLKmode
+      && mode != VOIDmode)
     {
       poly_int64 actual_offset = offset;
 
diff --git a/gcc/rtx-vector-builder.c b/gcc/rtx-vector-builder.c
index 90a8a1a2ef9..2468cdc5816 100644
--- a/gcc/rtx-vector-builder.c
+++ b/gcc/rtx-vector-builder.c
@@ -46,11 +46,11 @@ rtx_vector_builder::build (rtvec v)
 
 rtx
 rtx_vector_builder::apply_step (rtx base, unsigned int factor,
-				const wide_int &step) const
+				const poly_wide_int &step) const
 {
   scalar_int_mode int_mode = as_a <scalar_int_mode> (GET_MODE_INNER (m_mode));
-  return immed_wide_int_const (wi::add (rtx_mode_t (base, int_mode),
-					factor * step),
+  return immed_wide_int_const (wi::to_poly_wide (base, int_mode)
+			       + factor * step,
 			       int_mode);
 }
 
diff --git a/gcc/rtx-vector-builder.h b/gcc/rtx-vector-builder.h
index 99edad8a950..f33489286a9 100644
--- a/gcc/rtx-vector-builder.h
+++ b/gcc/rtx-vector-builder.h
@@ -44,8 +44,8 @@ private:
   bool equal_p (rtx, rtx) const;
   bool allow_steps_p () const;
   bool integral_p (rtx) const;
-  wide_int step (rtx, rtx) const;
-  rtx apply_step (rtx, unsigned int, const wide_int &) const;
+  poly_wide_int step (rtx, rtx) const;
+  rtx apply_step (rtx, unsigned int, const poly_wide_int &) const;
   bool can_elide_p (rtx) const { return true; }
   void note_representative (rtx *, rtx) {}
 
@@ -115,11 +115,11 @@ rtx_vector_builder::integral_p (rtx elt) const
 /* Return the value of element ELT2 minus the value of element ELT1.
    Both elements are known to be CONST_SCALAR_INT_Ps.  */
 
-inline wide_int
+inline poly_wide_int
 rtx_vector_builder::step (rtx elt1, rtx elt2) const
 {
-  return wi::sub (rtx_mode_t (elt2, GET_MODE_INNER (m_mode)),
-		  rtx_mode_t (elt1, GET_MODE_INNER (m_mode)));
+  return (wi::to_poly_wide (elt2, GET_MODE_INNER (m_mode))
+	  - wi::to_poly_wide (elt1, GET_MODE_INNER (m_mode)));
 }
 
 #endif
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 2913065bf31..a5a8e84f87b 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,368 @@
+2021-04-24  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/96796
+	* gcc.c-torture/compile/pr96796.c: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/pr99929_1.c: New file.
+	* gcc.target/aarch64/sve/pr99929_2.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98119
+	* gcc.target/aarch64/sve/pr98119.c: New test.
+
+2021-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2021-04-07  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/98736
+	* gcc.c-torture/execute/pr98736.c: New test.
+
+2021-04-23  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/20200727-0.c: New testcase.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-04-14  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/99249
+	* gcc.target/aarch64/sve/acle/general/pr99246.c: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/97141
+	PR rtl-optimization/98726
+	* gcc.c-torture/compile/pr97141.c: New test.
+	* gcc.c-torture/compile/pr98726.c: Likewise.
+	* gcc.target/aarch64/sve/pr97141.c: Likewise.
+	* gcc.target/aarch64/sve/pr98726.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-30  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/98136
+	* g++.dg/pr98136.C: New test.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/98268
+	* gcc.target/aarch64/sve/pr98268-1.c: New test.
+	* gcc.target/aarch64/sve/pr98268-2.c: Likewise.
+
+2021-04-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-03-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR tree-optimization/99726
+	* gcc.target/i386/pr99726.c: New test.
+
+2021-04-22  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99216
+	* g++.target/aarch64/sve/pr99216.C: New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-09-19  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97051
+	* g++.dg/cpp2a/is-constant-evaluated11.C: New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-07-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95486
+	* g++.dg/cpp2a/class-deduction-alias3.C: New test.
+
+2021-04-21  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/100176
+	* g++.dg/compat/struct-layout-1_generate.c: Add missing return.
+	* gcc.dg/compat/struct-layout-1_generate.c: Likewise.
+
+2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/100148
+	* g++.dg/opt/pr100148.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-08  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/97052
+	* g++.dg/cpp2a/concepts-defarg2.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-01-20  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95434
+	* g++.dg/cpp2a/lambda-generic9.C: New test.
+
+2021-04-20  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* g++.dg/cpp1z/class-deduction85.C: New test.
+	* g++.dg/template/ref11.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100111
+	* g++.dg/cpp0x/constexpr-100111.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/99767
+	* gcc.target/aarch64/pr99767.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99833
+	* g++.dg/cpp1z/pr99833.C: New test.
+	* g++.dg/cpp2a/pr99833.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99905
+	* gcc.target/i386/pr99905.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/99830
+	* gcc.dg/pr99830.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/99990
+	* gcc.dg/pr99990.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/99849
+	* gcc.dg/lto/pr99849_0.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/98601
+	* gcc.dg/torture/pr98601.c: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/99859
+	* g++.dg/cpp1y/constexpr-99859-1.C: New test.
+	* g++.dg/cpp1y/constexpr-99859-2.C: New test.
+	* g++.dg/cpp2a/constexpr-new18.C: New test.
+	* g++.dg/cpp2a/constexpr-new19.C: New test.
+
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/99863
+	* gcc.target/i386/pr99863.c: New test.
+
+2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-04-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98457
+	* gdc.dg/pr98457.d: New test.
+
+2021-04-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-27  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/97880
+	* gcc.dg/goacc/tile-1.c: New test.
+
+2021-04-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt92.adb: New test.
+
+2021-04-18  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-16  Harald Anlauf  <anlauf@gmx.de>
+		    Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/63797
+	* gfortran.dg/pr63797.f90: New test.
+
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* c-c++-common/goacc/collapse-2.c: New.
+
+2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2021-04-16  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/100048
+	* gcc.target/aarch64/sve/pr100048.c: New test.
+
+2021-04-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/99817
+	* gfortran.dg/coarray/dummy_2.f90: New test.
+
+2021-04-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97973
+	* g++.dg/conversion/real-to-int1.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99806
+	* g++.dg/concepts/abbrev10.C: New test.
+	* g++.dg/concepts/abbrev11.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91416
+	* g++.dg/other/gc7.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-04-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99831
+	* g++.dg/other/gc6.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99331
+	* g++.dg/warn/Wconversion5.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	DR 1312
+	PR c++/99176
+	* g++.dg/cpp0x/constexpr-nullptr-2.C: Adjust dg-error.
+	* g++.dg/cpp0x/constexpr-cast2.C: New test.
+	* g++.dg/cpp0x/constexpr-cast3.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99120
+	* g++.dg/warn/Wshadow-17.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/99374
+	* g++.dg/cpp1z/noexcept-type23.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-02-05  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98947
+	* g++.dg/cpp2a/volatile5.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97966
+	* g++.dg/cpp0x/noexcept63.C: New test.
+
+2021-04-09  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2021-01-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/98333
+	* g++.dg/cpp0x/noexcept62.C: New test.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/goacc/collapse-2.c b/gcc/testsuite/c-c++-common/goacc/collapse-2.c
new file mode 100644
index 00000000000..e46028cd5c4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/collapse-2.c
@@ -0,0 +1,56 @@
+/* Test for ICE as reported in PR98088.  */
+
+int i, j;
+
+void
+f1 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 5; i > 5; i--)
+	for (j = 5; j > 0; j--)
+	  ;
+}
+
+void
+f2 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 0; i < 5; i++)
+	for (j = 5; j > 0; j--)
+	  ;
+}
+
+void
+f3 (void)
+{
+  #pragma acc parallel
+  #pragma acc loop collapse (2)
+  for (i = 5; i >= 0; i--)
+	for (j = 5; j >= 0; j--)
+	  ;
+}
+
+void f4 ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i > 8; i++)
+    for (int j = 0; j > 8; j++);
+}
+
+void f5 ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i > 8; i++)
+    for (long j = 0; j > 8; j++);
+}
+
+void
+f6 (int a[32][32])
+{
+  #pragma acc parallel loop collapse(2)
+  for (int i = 16; i > 8; i--)
+    for (int j = 16; j > 8; j--)
+      a[i][j] = i + j;
+}
diff --git a/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
index 990e6f439e5..e9ece645cd0 100644
--- a/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
+++ b/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
@@ -983,6 +983,8 @@ subvalues (struct entry *e, char *p, char *letter)
       if (e[0].len != 0)
 	output_FNB ('B', e);
       return 1;
+    default:
+      return 0;
     }
 }
 
diff --git a/gcc/testsuite/g++.dg/concepts/abbrev10.C b/gcc/testsuite/g++.dg/concepts/abbrev10.C
new file mode 100644
index 00000000000..b611346e926
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/abbrev10.C
@@ -0,0 +1,18 @@
+// PR c++/99806
+// { dg-do compile { target c++14 } }
+// { dg-additional-options "-fconcepts" }
+
+struct S {
+  void f(auto, auto, int = 3);
+  void f2(auto, auto, int = 3) { }
+  template<typename T> static T g(T, auto, int = 3);
+};
+
+void
+g ()
+{
+  S::g(1, 2);
+  S s;
+  s.f(1, 2);
+  s.f2(1, 2);
+}
diff --git a/gcc/testsuite/g++.dg/concepts/abbrev11.C b/gcc/testsuite/g++.dg/concepts/abbrev11.C
new file mode 100644
index 00000000000..ddb479313df
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/abbrev11.C
@@ -0,0 +1,10 @@
+// PR c++/99806
+// { dg-do compile { target c++14 } }
+// { dg-additional-options "-fconcepts" }
+
+template <typename T> concept C = requires (T a) { a.f(0); };
+struct S {
+  void f(auto) noexcept(B);
+  static constexpr bool B = true;
+};
+static_assert(C<S>, "");
diff --git a/gcc/testsuite/g++.dg/conversion/real-to-int1.C b/gcc/testsuite/g++.dg/conversion/real-to-int1.C
new file mode 100644
index 00000000000..f7b990b3f4b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/conversion/real-to-int1.C
@@ -0,0 +1,17 @@
+// PR c++/97973
+
+void (*foo[1])(const int &);
+void (*foo2[1])(const double &);
+
+template<typename>
+void f ()
+{
+  (foo[0])(1.1);
+  (foo2[0])(1);
+}
+
+void
+g ()
+{
+  f<char> ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C
new file mode 100644
index 00000000000..446d21d03c5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-100111.C
@@ -0,0 +1,7 @@
+// PR c++/100111
+// { dg-do compile { target c++11 } }
+// { dg-options "-fno-elide-constructors" }
+
+struct A {};
+struct B : A { int b; constexpr B (A x) : A(x), b() {} };
+struct C { B c; constexpr C () : c({}) {} } d;
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C
new file mode 100644
index 00000000000..7c37f6a3f5a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast2.C
@@ -0,0 +1,16 @@
+// DR 1312 - Simulated reinterpret_cast in constant expressions.
+// PR c++/99176
+// { dg-do compile { target c++11 } }
+
+static int i;
+constexpr void *vp0 = nullptr;
+constexpr void *vpi = &i;
+constexpr int *p1 = (int *) vp0; // { dg-error "cast from .void\\*. is not allowed" }
+constexpr int *p2 = (int *) vpi; // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
+constexpr int *p3 = static_cast<int *>(vp0); // { dg-error "cast from .void\\*. is not allowed" }
+constexpr int *p4 = static_cast<int *>(vpi); // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
+constexpr void *p5 = vp0;
+constexpr void *p6 = vpi;
+
+constexpr int *pi = &i;
+constexpr bool b = ((int *)(void *) pi == pi); // { dg-error "cast from .void\\*. is not allowed" "integer_zerop" { xfail *-*-* } }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C
new file mode 100644
index 00000000000..a330a99f7de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-cast3.C
@@ -0,0 +1,14 @@
+// PR c++/99176
+// { dg-do compile { target c++11 } }
+
+constexpr const int *p = nullptr;
+constexpr int *q1 = const_cast<int*>(p);
+constexpr int *q2 = (int *)(const int *) nullptr;
+
+struct B { };
+struct D : B { };
+constexpr B *q3 = static_cast<B*>(nullptr);
+constexpr D *pd = nullptr;
+constexpr B *pb = nullptr;
+constexpr B *q4 = static_cast<B*>(pd);
+constexpr D *q5 = static_cast<D*>(pb);
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
index afb4b37be5a..92f3bbdc0a6 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
@@ -163,7 +163,7 @@ constexpr const void *pv2 = pv0;
 constexpr void *pv3 = pv2;      // { dg-error "invalid conversion|not a constant expression" }
 constexpr const void *pv4 = pv2;
 
-constexpr X *px4 = pv0;	 // { dg-error "invalid conversion|not a constant expression" }
+constexpr X *px4 = pv0;	 // { dg-error "cast from|invalid conversion|not a constant expression" }
 
 }
 
@@ -226,7 +226,7 @@ constexpr A *pa3 = pd0;		   // { dg-error "ambiguous base" }
 constexpr A *pa4 = static_cast<A*>(pd0);  // { dg-error "ambiguous base" }
 
 constexpr B *pb1 = pa0;		   // { dg-error "invalid conversion|not a constant expression" }
-constexpr B *pb2 = static_cast<B*>(pa0);  // { dg-error "not a constant expression" }
+constexpr B *pb2 = static_cast<B*>(pa0);
 
 constexpr C *pc1 = pa0;		   // { dg-error "invalid conversion|not a constant expression" }
 constexpr D *pd1 = pa0;		   // { dg-error "ambiguous base|invalid conversion" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept62.C b/gcc/testsuite/g++.dg/cpp0x/noexcept62.C
new file mode 100644
index 00000000000..53606c79142
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept62.C
@@ -0,0 +1,10 @@
+// PR c++/98333
+// { dg-do compile { target c++11 } }
+
+struct T {
+  template <bool N>
+  struct S {
+    S () noexcept (N) {}
+  };
+  int a = __has_nothrow_constructor (S<true>);
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept63.C b/gcc/testsuite/g++.dg/cpp0x/noexcept63.C
new file mode 100644
index 00000000000..cf048f56c2a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept63.C
@@ -0,0 +1,63 @@
+// PR c++/97966
+// { dg-do compile { target c++11 } }
+
+template <int>
+struct S1 {
+  __attribute__((used)) S1() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S2 {
+  __attribute__((used)) void bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S3 {
+  void __attribute__((used)) bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S4 {
+  [[gnu::used]] void bar() noexcept(noexcept(this->foo())) { }
+  void foo();
+};
+
+template <int>
+struct S5 {
+  void bar() noexcept(noexcept(this->foo())) __attribute__((used)) { }
+  void foo();
+};
+
+template <int>
+struct S6 {
+  template <int>
+  struct N {
+    [[gnu::used]] void bar() noexcept(noexcept(this->foo())) { }
+    void foo();
+  };
+};
+
+void
+g ()
+{
+  S1<1> s1;
+  S2<1> s2;
+  S3<1> s3;
+  S4<1> s4;
+  S5<1> s5;
+  S6<1>::N<1> n;
+}
+
+// Make sure that we did emit the functions marked with attribute used
+// even though they're not referenced in this TU.  (Well, the S1()
+// constructor is.)
+// { dg-final { scan-assembler "_ZN2S1ILi1EEC1Ev" } }
+// { dg-final { scan-assembler "_ZN2S1ILi1EEC2Ev" } }
+// { dg-final { scan-assembler "_ZN2S2ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S3ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S4ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S5ILi1EE3barEv" } }
+// { dg-final { scan-assembler "_ZN2S6ILi1EE1NILi1EE3barEv" } }
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C
new file mode 100644
index 00000000000..dea5a5b56f8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-1.C
@@ -0,0 +1,24 @@
+// PR c++/99859
+// { dg-do compile { target c++14 } }
+
+constexpr int
+foo (int *x)
+{
+  return ++*x;
+}
+
+struct S { constexpr S () : a(0) { foo (&a); foo (&a); } int a; };
+constexpr S s = S ();
+static_assert (s.a == 2, "");
+
+struct R { int *p; };
+
+constexpr int
+bar (R x)
+{
+  return ++*x.p;
+}
+
+struct T { int a = 0; constexpr T () { bar (R{&a}); bar (R{&a}); } };
+constexpr T t = T ();
+static_assert (t.a == 2, "");
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C
new file mode 100644
index 00000000000..a249f474666
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-99859-2.C
@@ -0,0 +1,12 @@
+// PR c++/99859
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int i;
+  constexpr int f() { return i; }
+  constexpr A() : i(0) { i = f(); i = 1; i = f(); }
+};
+
+constexpr A a = A();
+static_assert (a.i == 1, "");
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
new file mode 100644
index 00000000000..0b22f8eb982
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
@@ -0,0 +1,16 @@
+// PR c++/99885
+// { dg-do compile { target c++17 } }
+
+template <auto const& A>
+struct Foo {};
+
+template <auto const& A>
+struct Bar {
+    constexpr auto foo() const -> Foo<A> {
+        return {};
+    }
+};
+
+constexpr int a = 1;
+constexpr Bar<a> bar;
+Foo foo = bar.foo(); // <-- CTAD failure
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C
new file mode 100644
index 00000000000..612dd6ceb5e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type23.C
@@ -0,0 +1,14 @@
+// PR c++/99374
+// { dg-do compile { target c++17 } }
+
+struct S;
+struct R;
+using F1 = int (S::*)();
+using F2 = int (S::*)() noexcept;
+using F3 = int (R::*)() noexcept;
+using T = S;
+using F4 = int (T::*)() noexcept;
+F1 f21 = F2();
+F1 f41 = F4();
+F2 f12 = F1(); // { dg-error "cannot convert" }
+F1 f31 = F3(); // { dg-error "cannot convert" }
diff --git a/gcc/testsuite/g++.dg/cpp1z/pr99833.C b/gcc/testsuite/g++.dg/cpp1z/pr99833.C
new file mode 100644
index 00000000000..f7c995887f8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/pr99833.C
@@ -0,0 +1,11 @@
+// PR c++/99833
+// { dg-do compile { target c++17 } }
+
+struct S { int a, b; };
+template <class>
+void
+foo ()
+{
+  [](auto d) { if constexpr (auto [a, b]{d}; sizeof (a) > 0) a++; } (S{});
+}
+template void foo<S> ();
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C
new file mode 100644
index 00000000000..318d4c942ce
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-alias3.C
@@ -0,0 +1,11 @@
+// PR c++/95486
+// { dg-do compile { target c++20 } }
+
+template<class T, class U>
+struct X { X(U) requires __is_same(U, int) {} };
+
+template<class U>
+using Y = X<void, U>;
+
+Y y{1};
+Y z{'a'}; // { dg-error "failed|no match" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C b/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C
new file mode 100644
index 00000000000..a63ca4e133d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-defarg2.C
@@ -0,0 +1,13 @@
+// PR c++/97052
+// { dg-do compile { target c++20 } }
+
+template<typename T, typename U = typename T::type>
+concept C = true;
+
+constexpr bool f(C auto) {
+  return true;
+}
+
+static_assert(f(0));
+
+C auto x = 0;
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C
new file mode 100644
index 00000000000..24b298aafd4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-new18.C
@@ -0,0 +1,45 @@
+// PR c++/99859
+// { dg-do compile { target c++20 } }
+
+template <class T>
+struct intrusive_ptr
+{
+  T *ptr = nullptr;
+  constexpr explicit intrusive_ptr(T* p) : ptr(p) {
+    ++ptr->count_;
+  }
+  constexpr ~intrusive_ptr() {
+    if (ptr->dec() == 0)
+      delete ptr;
+  }
+  constexpr intrusive_ptr(intrusive_ptr const& a) : ptr(a.ptr) {
+    ++ptr->count_;
+  }
+};
+
+struct Foo {
+  int count_ = 0;
+  constexpr int dec() {
+    return --count_;
+  }
+};
+
+constexpr bool baz() {
+  Foo f { 4 };
+  intrusive_ptr a(&f);
+  return true;
+}
+constexpr bool x = baz();
+
+constexpr void bar(intrusive_ptr<Foo> a) 
+{
+  if (a.ptr->count_ != 2) throw 1;
+}
+
+constexpr bool foo() {
+  intrusive_ptr a(new Foo());
+  bar(a);
+  return true;
+}
+
+static_assert(foo());
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C
new file mode 100644
index 00000000000..7a73deed693
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-new19.C
@@ -0,0 +1,43 @@
+// PR c++/99859
+// { dg-do compile { target c++20 } }
+
+constexpr void
+foo (int *x)
+{
+  ++*x;
+}
+
+constexpr int
+bar ()
+{
+  int *x = new int (0);
+  foo (x);
+  foo (x);
+  int y = *x;
+  delete x;
+  return y;
+}
+
+static_assert (bar () == 2);
+
+struct R { int a, *b; };
+
+constexpr void
+baz (R x)
+{
+  ++*x.b;
+}
+
+constexpr int
+qux ()
+{
+  int *x = new int (0);
+  R r{1, x};
+  baz (r);
+  baz (r);
+  int y = *x;
+  delete x;
+  return y;
+}
+
+static_assert (qux () == 2);
diff --git a/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C b/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C
new file mode 100644
index 00000000000..a31867f74fb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated11.C
@@ -0,0 +1,16 @@
+// PR c++/97051
+// { dg-do compile { target c++20 } }
+
+namespace std {
+  constexpr inline bool
+  is_constant_evaluated () noexcept
+  {
+    return __builtin_is_constant_evaluated ();
+  }
+}
+
+template<typename>
+  requires (std::is_constant_evaluated())
+constexpr int a = 0;
+
+constexpr int b = a<int>;
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C
new file mode 100644
index 00000000000..043301ba015
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic9.C
@@ -0,0 +1,9 @@
+// PR c++/95434
+// { dg-do compile { target c++20 } }
+
+template <class>
+void f() {
+  [] <template <class> class U> () { U{0}; };
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.dg/cpp2a/pr99833.C b/gcc/testsuite/g++.dg/cpp2a/pr99833.C
new file mode 100644
index 00000000000..33230535e10
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/pr99833.C
@@ -0,0 +1,18 @@
+// PR c++/99833
+// { dg-do compile { target c++20 } }
+
+#include <tuple>
+
+auto f(auto&& x)
+{
+  [&](auto...) {
+    auto y = std::tuple{ "what's happening here?", x };
+    if constexpr (auto [_, z] = y; requires { z; })
+      return;
+  }();
+}
+
+int main()
+{
+  f(42);
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile5.C b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
new file mode 100644
index 00000000000..1f9d23845b4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
@@ -0,0 +1,15 @@
+// PR c++/98947
+// { dg-do compile }
+
+volatile int x, y, z;
+
+void
+f (bool b)
+{
+  (b ? x : y) = 1;
+  (b ? x : y) += 1; // { dg-warning "compound assignment" "" { target c++20 } }
+  z = (b ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  ((z = 2) ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  (b ? (x = 2) : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  (b ? x : (y = 5)) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr100148.C b/gcc/testsuite/g++.dg/opt/pr100148.C
new file mode 100644
index 00000000000..d038879b6b8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr100148.C
@@ -0,0 +1,27 @@
+// PR rtl-optimization/100148
+// { dg-do compile }
+// { dg-options "-O2 -fno-dce -fno-tree-dce -fno-tree-dominator-opts -fno-tree-sink -fcompare-debug" }
+
+int i;
+enum E { } e, ee;
+
+bool
+baz (int)
+{
+  return ee;
+}
+
+bool bar ();
+bool a, b;
+
+void
+foo ()
+{
+  switch (ee)
+    {
+    case 0:
+      e = E (a ? : i);
+    case 1:
+      !(b || baz (0) && bar ());
+    }
+}
diff --git a/gcc/testsuite/g++.dg/other/gc6.C b/gcc/testsuite/g++.dg/other/gc6.C
new file mode 100644
index 00000000000..ff45dd313d6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/gc6.C
@@ -0,0 +1,16 @@
+// PR c++/99831
+// { dg-do compile { target c++20 } }
+// { dg-options "--param ggc-min-heapsize=0 --param ggc-min-expand=0" }
+
+template <int N> struct S {
+  constexpr S(const char (&str)[N]) : value{} { }
+  char value[N];
+};
+template <S> struct string {
+  constexpr bool operator==(const string &) const = default;
+};
+template <S L2> void operator+(string<L2>) {
+  char value[1];
+  S{value};
+}
+static_assert(string<"a">{} == string<"a">{});
diff --git a/gcc/testsuite/g++.dg/other/gc7.C b/gcc/testsuite/g++.dg/other/gc7.C
new file mode 100644
index 00000000000..ab436bac72f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/gc7.C
@@ -0,0 +1,16 @@
+// PR c++/91416 - GC during late parsing collects live data.
+// { dg-do compile }
+// { dg-options "--param ggc-min-heapsize=0 --param ggc-min-expand=0" }
+
+__attribute__ ((unused)) struct S {
+  S() { }
+} s;
+
+__attribute__ ((unused)) struct X {
+  void fn ()
+  {
+    __attribute__ ((unused)) struct N {
+	N() { }
+    } n;
+  }
+} x;
diff --git a/gcc/testsuite/g++.dg/pr98136.C b/gcc/testsuite/g++.dg/pr98136.C
new file mode 100644
index 00000000000..f3c27f6b09f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr98136.C
@@ -0,0 +1,26 @@
+// { dg-do compile { target { ilp32 || lp64 } } }
+
+struct AddIn
+{
+    virtual ~AddIn() {}
+    virtual void AddInCall()=0;
+};
+
+struct Base
+{
+    char b[32*1024*1024];   // Anything bigger than 16mb causes internal compiler error
+    virtual ~Base() {}
+};
+
+struct Deriv : public Base,
+                    public AddIn
+{
+    void AddInCall() {}
+};
+
+int main (int argc, char **argv)
+{
+    Deriv deriv;
+    deriv.AddInCall();
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/ref11.C b/gcc/testsuite/g++.dg/template/ref11.C
new file mode 100644
index 00000000000..c43c67edf70
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/ref11.C
@@ -0,0 +1,9 @@
+// PR c++/83476
+
+int n;
+template <int& V> struct A {};
+template <int& V> void f(A<V>);
+int main() {
+  A<n> a;
+  f(a);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wconversion5.C b/gcc/testsuite/g++.dg/warn/Wconversion5.C
new file mode 100644
index 00000000000..f5ae6312bc5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wconversion5.C
@@ -0,0 +1,19 @@
+// PR c++/99331
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wconversion" }
+// Don't issue -Wconversion warnings for value-dependent expressions.
+
+template <int> struct X {};
+template <signed char> struct Y {};
+template <typename T> X<sizeof(T)> foo();
+template <typename T> X<alignof(T)> foo2();
+template<int I> Y<I> foo3();
+template<int> Y<1024> foo4(); // { dg-error "narrowing conversion" }
+template<int> Y<1u> foo5();
+template<int> X<__INT_MAX__ + 1U> foo6(); // { dg-error "narrowing conversion" }
+
+template <typename T>
+struct S {
+  using t = X<sizeof(T)>;
+  using u = X<alignof(T)>;
+};
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-17.C b/gcc/testsuite/g++.dg/warn/Wshadow-17.C
new file mode 100644
index 00000000000..0dee397796f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-17.C
@@ -0,0 +1,11 @@
+// PR c++/99120
+// { dg-options "-Wshadow" }
+
+struct S {
+  void X();
+
+  template<typename T>
+  void fn () {
+    enum { X };
+  }
+};
diff --git a/gcc/testsuite/g++.target/aarch64/sve/pr99216.C b/gcc/testsuite/g++.target/aarch64/sve/pr99216.C
new file mode 100644
index 00000000000..61a58a7fcf4
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/sve/pr99216.C
@@ -0,0 +1,5 @@
+/* { dg-do link { target aarch64_asm_sve_ok } } */
+/* { dg-additional-options "-flto" } */
+#include <arm_sve.h>
+bool a;
+int main() { a = svaddv(svptrue_b8(), svdup_s8(0)); }
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr96796.c b/gcc/testsuite/gcc.c-torture/compile/pr96796.c
new file mode 100644
index 00000000000..8808e62fe77
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr96796.c
@@ -0,0 +1,55 @@
+/* { dg-additional-options "-fcommon" } */
+
+struct S0 {
+  signed f0 : 8;
+  unsigned f1;
+  unsigned f4;
+};
+struct S1 {
+  long f3;
+  char f4;
+} g_3_4;
+
+int g_5, func_1_l_32, func_50___trans_tmp_31;
+static struct S0 g_144, g_834, g_1255, g_1261;
+
+int g_273[120] = {};
+int *g_555;
+char **g_979;
+static int g_1092_0;
+static int g_1193;
+int safe_mul_func_int16_t_s_s(int si1, int si2) { return si1 * si2; }
+static struct S0 *func_50();
+int func_1() { func_50(g_3_4, g_5, func_1_l_32, 8, 3); }
+void safe_div_func_int64_t_s_s(int *);
+void safe_mod_func_uint32_t_u_u(struct S0);
+struct S0 *func_50(int p_51, struct S0 p_52, struct S1 p_53, int p_54,
+                   int p_55) {
+  int __trans_tmp_30;
+  char __trans_tmp_22;
+  short __trans_tmp_19;
+  long l_985_1;
+  long l_1191[8];
+  safe_div_func_int64_t_s_s(g_273);
+  __builtin_printf((char*)g_1261.f4);
+  safe_mod_func_uint32_t_u_u(g_834);
+  g_144.f0 += 1;
+  for (;;) {
+    struct S1 l_1350 = {&l_1350};
+    for (; p_53.f3; p_53.f3 -= 1)
+      for (; g_1193 <= 2; g_1193 += 1) {
+        __trans_tmp_19 = safe_mul_func_int16_t_s_s(l_1191[l_985_1 + p_53.f3],
+                                                   p_55 % (**g_979 = 10));
+        __trans_tmp_22 = g_1255.f1 * p_53.f4;
+        __trans_tmp_30 = __trans_tmp_19 + __trans_tmp_22;
+        if (__trans_tmp_30)
+          g_1261.f0 = p_51;
+        else {
+          g_1255.f0 = p_53.f3;
+          int *l_1422 = g_834.f0 = g_144.f4 != (*l_1422)++ > 0 < 0 ^ 51;
+          g_555 = ~0;
+          g_1092_0 |= func_50___trans_tmp_31;
+        }
+      }
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr97141.c b/gcc/testsuite/gcc.c-torture/compile/pr97141.c
new file mode 100644
index 00000000000..1a9ff830a22
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr97141.c
@@ -0,0 +1,8 @@
+int a;
+short b, c;
+short d(short e, short f) { return e + f; }
+void g(void) {
+  a = -9;
+  for (; a != 51; a = d(a, 5))
+    b |= c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr98726.c b/gcc/testsuite/gcc.c-torture/compile/pr98726.c
new file mode 100644
index 00000000000..ce24b18ce55
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr98726.c
@@ -0,0 +1,7 @@
+int a, c;
+char b;
+int d() {
+  a = 0;
+  for (; a <= 21; a = (short)a + 1)
+    b &= c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr98736.c b/gcc/testsuite/gcc.c-torture/execute/pr98736.c
new file mode 100644
index 00000000000..c066abcd86a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr98736.c
@@ -0,0 +1,14 @@
+/* PR tree-optimization/98736 */
+
+int a[6];
+char b, c;
+int main() {
+  int d[4] = {0, 0, 0, 0};
+  for (c = 0; c <= 5; c++) {
+    for (b = 2; b != 0; b++)
+      a[c] = 8;
+    a[c] = d[3];
+  }
+  if (a[0] != 0)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
index 75e902cd1f4..35dff89c377 100644
--- a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
+++ b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
@@ -1280,6 +1280,8 @@ subvalues (struct entry *e, char *p, char *letter)
       if (e[0].len != 0)
 	output_FNB ('B', e);
       return 1;
+    default:
+      return 0;
     }
 }
 
diff --git a/gcc/testsuite/gcc.dg/goacc/tile-1.c b/gcc/testsuite/gcc.dg/goacc/tile-1.c
new file mode 100644
index 00000000000..6898397ad5e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/goacc/tile-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+/* PR c/97880 */
+
+void f ()
+{
+  #pragma acc parallel loop tile(2, 3)
+  for (int i = 0; i < 8; i++)
+    for (long j = 0; j < 8; j++);
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr99849_0.c b/gcc/testsuite/gcc.dg/lto/pr99849_0.c
new file mode 100644
index 00000000000..d489cee0f52
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr99849_0.c
@@ -0,0 +1,23 @@
+/* PR lto/99849 */
+/* { dg-lto-do link } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target shared } */
+/* { dg-extra-ld-options { -shared } } */
+/* { dg-lto-options { { -flto -flto-partition=1to1 -O2 -Wno-incompatible-pointer-types -Wno-discarded-qualifiers -fPIC } } } */
+
+struct { struct A *a; } *b;
+struct B { int *b; };
+struct C { int *c; };
+const struct D { struct C d; } d;
+struct A { struct { struct C e; }; };
+struct E { void *e; } e = { &( &(const struct D) { (void *) &d })->d };
+struct C f = { &( &(const struct D) { (void *) &d })->d };
+struct A g[] = { &e, &f };
+void foo () { b->a = g; }
+struct E h = { foo };
+void bar ();
+int baz () { bar (h); }
+struct B i = { (int *) baz };
+void qux ();
+void corge () { qux (i); }
+void *j __attribute__((__used__)) = corge;
diff --git a/gcc/testsuite/gcc.dg/pr99830.c b/gcc/testsuite/gcc.dg/pr99830.c
new file mode 100644
index 00000000000..75226f5c3a9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr99830.c
@@ -0,0 +1,10 @@
+/* PR debug/99830 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2 -fno-expensive-optimizations -fno-split-wide-types -g" } */
+
+int foo (long a, __int128 b, short c, int d, unsigned e, __int128 f)
+{
+  __builtin_memmove (2 + (char *) &f, foo, 1);
+  c >>= (char) f;
+  return c;
+}
diff --git a/gcc/testsuite/gcc.dg/pr99990.c b/gcc/testsuite/gcc.dg/pr99990.c
new file mode 100644
index 00000000000..6878b00ce0d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr99990.c
@@ -0,0 +1,12 @@
+/* PR c/99990 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include <stdarg.h>
+
+void
+foo ()
+{
+  va_arg (0, long);	/* { dg-error "first argument to 'va_arg' not of type 'va_list'" } */
+  void *b[] = 0;	/* { dg-error "invalid initializer" } */
+}
diff --git a/gcc/testsuite/gcc.dg/torture/20200727-0.c b/gcc/testsuite/gcc.dg/torture/20200727-0.c
new file mode 100644
index 00000000000..ab915687b30
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/20200727-0.c
@@ -0,0 +1,82 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-g" } */
+
+typedef long unsigned int size_t;
+typedef signed int __int32_t;
+typedef __int32_t int32_t;
+typedef long int ptrdiff_t;
+typedef enum {
+  BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,   BT_ASSUMED, BT_UNION, BT_BOZ } bt;
+typedef int32_t GFC_INTEGER_4;
+typedef ptrdiff_t index_type;
+typedef size_t gfc_charlen_type;
+typedef struct descriptor_dimension {
+    index_type _stride;
+    index_type lower_bound;
+  } descriptor_dimension;
+typedef struct {
+  descriptor_dimension dim[15];
+ } gfc_full_array_i4;
+typedef void (*formatted_dtio)(void *, GFC_INTEGER_4 *, char *,           gfc_full_array_i4 *,           GFC_INTEGER_4 *, char *,           gfc_charlen_type, gfc_charlen_type);
+typedef enum { DECIMAL_POINT, DECIMAL_COMMA, DECIMAL_UNSPECIFIED } unit_decimal;
+typedef struct st_parameter_dt {
+      union     {
+	  struct  {
+	      struct gfc_unit *current_unit;
+	      unsigned namelist_mode : 1;
+	      unsigned unit_is_internal : 1;
+	      formatted_dtio fdtio_ptr;
+	  } p;
+      } u;
+  } st_parameter_dt;
+typedef struct gfc_unit {
+    int unit_number;
+    unit_decimal decimal_status;
+    int (*next_char_fn_ptr) (st_parameter_dt *);
+    void (*push_char_fn_ptr) (st_parameter_dt *, int);
+  } gfc_unit;
+void read_real (st_parameter_dt *dtp)
+{
+  int c;
+  int seen_dp;
+  seen_dp = 0;
+  for (;;)
+    {
+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));
+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)
+	c = '.';
+      switch (c)  {
+	case '.':
+	  if (seen_dp)      goto bad_real;
+	  seen_dp = 1;
+	  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));
+	  goto real_loop;
+	case 'E':
+	case 'e':
+	case 'D':
+	case 'd':
+	case 'Q':
+	case 'q':
+	     goto exp1;
+	case '+':
+	case '-':
+	     ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, 'e'));
+	     goto got_repeat;
+      }
+    }
+got_repeat:
+real_loop:
+  for (;;)
+    {
+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));
+      switch (c)  {
+	case '.':
+	  if (seen_dp)      goto bad_real;
+	  seen_dp = 1;
+	  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));
+      }
+    }
+exp1:
+bad_real:
+  return;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr98601.c b/gcc/testsuite/gcc.dg/torture/pr98601.c
new file mode 100644
index 00000000000..ee9d076c02d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr98601.c
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/98601 */
+/* { dg-do compile } */
+
+void
+foo (void *p)
+{
+  asm ("" : "=m" (*p));			/* { dg-warning "dereferencing 'void \\*' pointer" } */
+}
+
+void
+bar (void *p)
+{
+  asm volatile ("" : : "m" (*p));	/* { dg-warning "dereferencing 'void \\*' pointer" } */
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr99767.c b/gcc/testsuite/gcc.target/aarch64/pr99767.c
new file mode 100644
index 00000000000..5bbfcbdcd69
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr99767.c
@@ -0,0 +1,16 @@
+/* PR target/99767 */
+/* { dg-do compile } */
+/* { dg-options " -O1 -fopenmp-simd -fno-tree-dce -march=armv8-a+sve" } */
+
+int a[1024], b[1024];
+
+void
+foo (void)
+{
+  #pragma omp simd
+  for (int i = 0; i < 1024; i++)
+    if (b[i] > 23) {
+      a[i] = b[i] + 1;
+      int v = 1 / 0;	/* { dg-warning "division by zero" } */
+    }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c
new file mode 100644
index 00000000000..7f1079c1bd6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr99246.c
@@ -0,0 +1,17 @@
+/* { dg-options "-Os" } */
+
+#include <arm_sve.h>
+extern char b[];
+int x;
+void f() {
+  while (x) {
+    x = svaddv(
+        svnot_z(svnot_z(svptrue_pat_b8(SV_VL6),
+                        svmov_z(svptrue_pat_b8(SV_VL1),
+                                svptrue_pat_b16(SV_VL3))),
+                svptrue_pat_b64(SV_VL2)),
+        svdup_s32(8193));
+    for (int j = x; j; j++)
+      b[j] = 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c b/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c
new file mode 100644
index 00000000000..525933863f7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr100048.c
@@ -0,0 +1,25 @@
+/* { dg-additional-options "-O2 -fno-schedule-insns" } */
+/* { dg-final { check-function-bodies "**" "" "-DCHECK_ASM" } } */
+
+#include "arm_sve.h"
+
+/*
+** foo:
+**        ptrue   (p[0-7])\.d, all
+**        pfalse  (p[0-7])\.b
+**        ptrue   (p[0-7])\.s, all
+**        trn1    (p[0-7])\.d, \2\.d, \3\.d
+**        trn1    \2\.d, \1\.d, \3\.d
+**        faddv   (h[0-31]), \4\, (z[0-31]).h
+**        faddv   (h[0-31]), \2\, \6\.h
+**        str     \5, [x0]
+**        str     \7, [x0, 2]
+**        ret
+*/
+void foo(svfloat16_t in, float16_t *dst) {
+  const svbool_t pg_q0 = svdupq_n_b16(1, 0, 1, 0, 0, 0, 0, 0);
+  const svbool_t pg_f0 = svdupq_n_b16(1, 0, 0, 0, 0, 0, 0, 0);
+  dst[0] = svaddv_f16(pg_f0, in);
+  dst[1] = svaddv_f16(pg_q0, in);
+}
+
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c b/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c
new file mode 100644
index 00000000000..942e4a48d91
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr97141.c
@@ -0,0 +1,10 @@
+/* { dg-options "-O3" } */
+
+int a;
+short b, c;
+short d(short e, short f) { return e + f; }
+void g(void) {
+  a = -9;
+  for (; a != 51; a = d(a, 5))
+    b |= c;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c
new file mode 100644
index 00000000000..da6208c2ce3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98119.c
@@ -0,0 +1,13 @@
+/* { dg-options "-O3 -msve-vector-bits=512 -mtune=thunderx" } */
+
+void
+f (unsigned short *x)
+{
+  for (int i = 0; i < 1000; ++i)
+    x[i] += x[i - 16];
+}
+
+/* { dg-final { scan-assembler-not {\tubfx\t[wx][0-9]+, [wx][0-9]+, #?1, #?5\n} } } */
+/* { dg-final { scan-assembler-not {\tand\tx[0-9]+, x[0-9]+, #?-63\n} } } */
+/* { dg-final { scan-assembler {\tubfx\t[wx][0-9]+, [wx][0-9]+, #?1, #?4\n} } } */
+/* { dg-final { scan-assembler {\tand\tx[0-9]+, x[0-9]+, #?-31\n} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c
new file mode 100644
index 00000000000..fdbe55e0b4e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-1.c
@@ -0,0 +1,11 @@
+/* { dg-do link } */
+/* { dg-options "-flto -O -ftree-vectorize --param=aarch64-autovec-preference=3" } */
+/* { dg-additional-sources "pr98268-2.c" } */
+
+short d, e;
+void f(char, long*);
+int main() {
+  long x;
+  f(-114, &x);
+  return d == e;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c
new file mode 100644
index 00000000000..de3b05d5e15
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98268-2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ftree-vectorize --param=aarch64-autovec-preference=3" } */
+
+extern short d[], e[];
+void f(char a, long *b) {
+  for (int c = 0; c < a - 12; c++) {
+    d[c] = b[c];
+    e[c] = 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c b/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c
new file mode 100644
index 00000000000..2395cab57e5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr98726.c
@@ -0,0 +1,9 @@
+/* { dg-options "-O3" } */
+
+int a, c;
+char b;
+int d() {
+  a = 0;
+  for (; a <= 21; a = (short)a + 1)
+    b &= c;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c
new file mode 100644
index 00000000000..1fe18136e28
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_1.c
@@ -0,0 +1,16 @@
+/* { dg-do run { target aarch64_sve_hw } } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+#include <arm_sve.h>
+
+static void e(short *g, short p2) { *g ^= p2; }
+static short m[23];
+int main() {
+  for (unsigned i = 0; i < 23; ++i)
+    m[i] = 4;
+  if (svaddv(svptrue_pat_b32(SV_VL1), svdup_u32(1)) != 1)
+    __builtin_abort();
+  for (unsigned i = 0; i < 3; ++i)
+    e(m, m[i]);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c
new file mode 100644
index 00000000000..50d432db9b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr99929_2.c
@@ -0,0 +1,5 @@
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+#include "pr99929_1.c"
+
+/* { dg-final { scan-assembler {\tptrue\tp[0-7].[bhsd], vl1\n} } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr99726.c b/gcc/testsuite/gcc.target/i386/pr99726.c
new file mode 100644
index 00000000000..98ccce6a979
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99726.c
@@ -0,0 +1,16 @@
+/* { dg-options "-flive-patching=inline-clone -mavx512f -O2 -ftree-loop-vectorize -ftrapv" } */
+/* { dg-additional-options "-floop-nest-optimize" { target fgraphite } } */
+
+extern int a[256][1024];
+int b;
+long c, d;
+unsigned int e;
+
+int
+main ()
+{
+  for (; e < d; e++)
+    for (unsigned j = 1; j < c; j++)
+      a[e][j] = b * a[e - 1][j + 1];
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr99863.c b/gcc/testsuite/gcc.target/i386/pr99863.c
new file mode 100644
index 00000000000..3d9d405391e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99863.c
@@ -0,0 +1,33 @@
+/* PR rtl-optimization/99863 */
+/* { dg-do run } */
+/* { dg-options "-O -fno-tree-forwprop -mno-sse2 -Wno-psabi" } */
+
+typedef unsigned char __attribute__((__vector_size__ (8))) A;
+typedef unsigned char __attribute__((__vector_size__ (32))) B;
+typedef unsigned char __attribute__((__vector_size__ (64))) C;
+typedef unsigned int __attribute__((__vector_size__ (32))) D;
+typedef unsigned int __attribute__((__vector_size__ (64))) E;
+typedef unsigned long long F;
+
+D a;
+A b;
+
+A
+foo (E x, F y)
+{
+  D c = (y <= 0) * a;
+  x *= (0 < y);
+  C d = (C) x;
+  B e = ((union { C a; B b[2];}) d).b[0] + (B) c;
+  A f = ((union { B a; A b[4];}) e).b[0] + (A) b;
+  return f;
+}
+
+int
+main ()
+{
+  F x = (F) foo ((E) { 3 }, 5);
+  if (x != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr99905.c b/gcc/testsuite/gcc.target/i386/pr99905.c
new file mode 100644
index 00000000000..6d1b2305a76
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr99905.c
@@ -0,0 +1,33 @@
+/* PR rtl-optimization/99905 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-Os -mno-mmx -mno-sse" } */
+
+typedef unsigned char U;
+typedef unsigned char __attribute__((__vector_size__ (8))) A;
+typedef unsigned char __attribute__((__vector_size__ (16))) B;
+typedef unsigned char __attribute__((__vector_size__ (32))) C;
+typedef unsigned int __attribute__((__vector_size__ (8))) D;
+typedef unsigned long long __attribute__((__vector_size__ (8))) E;
+typedef unsigned __int128 I;
+typedef unsigned long long L;
+
+D gv;
+I gi;
+
+L __attribute__((__noipa__))
+foo (int ua, int ub, int uc, int ud, E ue, I i)
+{
+  D d = (U) __builtin_bswap16 (i >> 63) + gv;
+  B y = ((union { C a; B b[2];}) (C){ }).b[0] + (B) gi;
+  A z = ((union { B a; A b[2];}) y).b[0] + (A) d;
+  return (L)z;
+}
+
+int
+main ()
+{
+  L x = foo (0, 0, 0, 0, (E) { }, (I) 0x100 << 63);
+  if (x != 0x100000001)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gdc.dg/pr98457.d b/gcc/testsuite/gdc.dg/pr98457.d
new file mode 100644
index 00000000000..bc0d8af5d4a
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr98457.d
@@ -0,0 +1,9 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98457
+// { dg-do compile }
+
+void main()
+{
+    writef!"%s";    // { dg-error "template instance writef!\"%s\" template .writef. is not defined" }
+    writef!"`%s";   // { dg-error "template instance writef!\"`%s\" template .writef. is not defined" }
+    writef!"%%s`";  // { dg-error "template instance writef!\"%%s`\" template .writef. is not defined" }
+}
diff --git a/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90 b/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90
new file mode 100644
index 00000000000..35263745bb8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/dummy_2.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+!
+! PR fortran/99817
+!
+! Contributed by G. Steinmetz
+!
+subroutine s1 (x)
+   character(*) :: x(*)[*]
+end
+
+subroutine s2 (x)
+   character(*), dimension(*), codimension[*] :: x
+   integer :: i
+   i = len(x)
+end
+
+subroutine s3 (x, y)
+   character(*), dimension(:) :: x[*]
+   character(*) :: y
+end
+
+subroutine s4 (x, y, z)
+   character(*), dimension(:) :: x[2, *]
+   character(*), dimension(*) :: y
+   character(*) :: z
+end
diff --git a/gcc/testsuite/gfortran.dg/pr63797.f90 b/gcc/testsuite/gfortran.dg/pr63797.f90
new file mode 100644
index 00000000000..1131e8167b1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr63797.f90
@@ -0,0 +1,60 @@
+! { dg-do compile }
+! PR63797 - Bogus ambiguous reference to 'sqrt'
+
+module mod1
+  implicit none
+  real, parameter :: z = sqrt (0.0)
+  real            :: w = sqrt (1.0)
+  interface
+     pure real function sqrt_ifc (x)
+       real, intent(in) :: x
+     end function sqrt_ifc
+  end interface
+contains
+  pure function myroot () result (f)
+    procedure(sqrt_ifc), pointer :: f
+    intrinsic :: sqrt
+    f => sqrt
+  end function myroot
+end module mod1
+
+module mod2
+  implicit none
+  type t
+     real :: a = 0.
+  end type
+  interface sqrt
+     module procedure sqrt
+  end interface
+contains
+  elemental function sqrt (a)
+    type(t), intent(in) :: a
+    type(t)             :: sqrt
+    sqrt% a = a% a
+  end function sqrt
+end module mod2
+
+module mod3
+  implicit none
+  abstract interface
+     function real_func (x)
+       real              :: real_func
+       real, intent (in) :: x
+     end function real_func
+  end interface
+  intrinsic :: sqrt
+  procedure(real_func), pointer :: real_root => sqrt
+end module mod3
+
+program test
+  use mod1
+  use mod2
+  use mod3
+  implicit none
+  type(t) :: x, y
+  procedure(sqrt_ifc), pointer :: root
+  root => myroot ()
+  y    = sqrt (x)
+  y% a = sqrt (x% a) + z - w + root (x% a)
+  y% a = real_root (x% a)
+end program test
diff --git a/gcc/testsuite/gnat.dg/opt92.adb b/gcc/testsuite/gnat.dg/opt92.adb
new file mode 100644
index 00000000000..f6eb6a034ec
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt92.adb
@@ -0,0 +1,38 @@
+-- { dg-do compile { target { lp64 || llp64 } } }
+-- { dg-options "-O2 -gnatws" }
+
+procedure Main is
+
+   subtype Int64 is Long_Long_Integer;
+
+   type Arr is array (Int64 range <>) of Boolean;
+
+   Pow : constant := 10;
+
+   procedure Compute (B : in out Arr) is
+      Factor : Int64 := 3;
+      Num    : Int64;
+   begin
+      while Factor <= 10 ** (Pow / 2) loop
+         Num := Factor;
+         while Num < 10 ** Pow loop
+            if B (Num) then
+               Factor := Num;
+               exit;
+            end if;
+            Num := Num + 2;
+         end loop;
+         Num := Factor * Factor;
+         while Num < 10 ** Pow loop
+            B (Num) := False;
+            Num        := Num + Factor * 2;
+         end loop;
+         Factor := Factor + 2;
+      end loop;
+   end;
+
+   B : Arr (1 .. 10 ** Pow) := (others => True);
+
+begin
+   Compute (B);   
+end;
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 2cb54def860..2a4da7a7a18 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -1891,8 +1891,8 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,
 
   bool waw_or_war_p = (alias_pair.flags & ~(DR_ALIAS_WAR | DR_ALIAS_WAW)) == 0;
 
-  unsigned int i;
-  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)
+  int found = -1;
+  for (unsigned int i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)
     {
       tree access1 = DR_ACCESS_FN (dr_a.dr, i);
       tree access2 = DR_ACCESS_FN (dr_b.dr, i);
@@ -1908,155 +1908,166 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,
 
 	  return false;
 	}
-      /* The two indices must have the same step.  */
-      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))
+      if (found >= 0)
 	return false;
+      found = i;
+    }
 
-      tree idx_step = CHREC_RIGHT (access1);
-      /* Index must have const step, otherwise DR_STEP won't be constant.  */
-      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);
-      /* Index must evaluate in the same direction as DR.  */
-      gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);
+  /* Ought not to happen in practice, since if all accesses are equal then the
+     alias should be decidable at compile time.  */
+  if (found < 0)
+    return false;
 
-      tree min1 = CHREC_LEFT (access1);
-      tree min2 = CHREC_LEFT (access2);
-      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))
-	return false;
+  /* The two indices must have the same step.  */
+  tree access1 = DR_ACCESS_FN (dr_a.dr, found);
+  tree access2 = DR_ACCESS_FN (dr_b.dr, found);
+  if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))
+    return false;
 
-      /* Ideally, alias can be checked against loop's control IV, but we
-	 need to prove linear mapping between control IV and reference
-	 index.  Although that should be true, we check against (array)
-	 index of data reference.  Like segment length, index length is
-	 linear function of the number of iterations with index_step as
-	 the coefficient, i.e, niter_len * idx_step.  */
-      offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),
-						  SIGNED);
-      if (neg_step)
-	abs_idx_step = -abs_idx_step;
-      poly_offset_int idx_len1 = abs_idx_step * niter_len1;
-      poly_offset_int idx_len2 = abs_idx_step * niter_len2;
-      poly_offset_int idx_access1 = abs_idx_step * niter_access1;
-      poly_offset_int idx_access2 = abs_idx_step * niter_access2;
+  tree idx_step = CHREC_RIGHT (access1);
+  /* Index must have const step, otherwise DR_STEP won't be constant.  */
+  gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);
+  /* Index must evaluate in the same direction as DR.  */
+  gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);
 
-      gcc_assert (known_ge (idx_len1, 0)
-		  && known_ge (idx_len2, 0)
-		  && known_ge (idx_access1, 0)
-		  && known_ge (idx_access2, 0));
+  tree min1 = CHREC_LEFT (access1);
+  tree min2 = CHREC_LEFT (access2);
+  if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))
+    return false;
 
-      /* Each access has the following pattern, with lengths measured
-	 in units of INDEX:
+  /* Ideally, alias can be checked against loop's control IV, but we
+     need to prove linear mapping between control IV and reference
+     index.  Although that should be true, we check against (array)
+     index of data reference.  Like segment length, index length is
+     linear function of the number of iterations with index_step as
+     the coefficient, i.e, niter_len * idx_step.  */
+  offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),
+					      SIGNED);
+  if (neg_step)
+    abs_idx_step = -abs_idx_step;
+  poly_offset_int idx_len1 = abs_idx_step * niter_len1;
+  poly_offset_int idx_len2 = abs_idx_step * niter_len2;
+  poly_offset_int idx_access1 = abs_idx_step * niter_access1;
+  poly_offset_int idx_access2 = abs_idx_step * niter_access2;
 
-	      <-- idx_len -->
-	      <--- A: -ve step --->
-	      +-----+-------+-----+-------+-----+
-	      | n-1 | ..... |  0  | ..... | n-1 |
-	      +-----+-------+-----+-------+-----+
-			    <--- B: +ve step --->
-			    <-- idx_len -->
-			    |
-			   min
+  gcc_assert (known_ge (idx_len1, 0)
+	      && known_ge (idx_len2, 0)
+	      && known_ge (idx_access1, 0)
+	      && known_ge (idx_access2, 0));
 
-	 where "n" is the number of scalar iterations covered by the segment
-	 and where each access spans idx_access units.
+  /* Each access has the following pattern, with lengths measured
+     in units of INDEX:
 
-	 A is the range of bytes accessed when the step is negative,
-	 B is the range when the step is positive.
+	  <-- idx_len -->
+	  <--- A: -ve step --->
+	  +-----+-------+-----+-------+-----+
+	  | n-1 | ..... |  0  | ..... | n-1 |
+	  +-----+-------+-----+-------+-----+
+			<--- B: +ve step --->
+			<-- idx_len -->
+			|
+		       min
 
-	 When checking for general overlap, we need to test whether
-	 the range:
+     where "n" is the number of scalar iterations covered by the segment
+     and where each access spans idx_access units.
 
-	   [min1 + low_offset1, min2 + high_offset1 + idx_access1 - 1]
+     A is the range of bytes accessed when the step is negative,
+     B is the range when the step is positive.
 
-	 overlaps:
+     When checking for general overlap, we need to test whether
+     the range:
 
-	   [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]
+       [min1 + low_offset1, min1 + high_offset1 + idx_access1 - 1]
 
-	 where:
+     overlaps:
+
+       [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]
 
-	    low_offsetN = +ve step ? 0 : -idx_lenN;
-	   high_offsetN = +ve step ? idx_lenN : 0;
+     where:
 
-	 This is equivalent to testing whether:
+	low_offsetN = +ve step ? 0 : -idx_lenN;
+       high_offsetN = +ve step ? idx_lenN : 0;
+
+     This is equivalent to testing whether:
 
-	   min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1
-	   && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1
+       min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1
+       && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1
 
-	 Converting this into a single test, there is an overlap if:
+     Converting this into a single test, there is an overlap if:
 
-	   0 <= min2 - min1 + bias <= limit
+       0 <= min2 - min1 + bias <= limit
 
-	 where  bias = high_offset2 + idx_access2 - 1 - low_offset1
-	       limit = (high_offset1 - low_offset1 + idx_access1 - 1)
-		     + (high_offset2 - low_offset2 + idx_access2 - 1)
-	  i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1
+     where  bias = high_offset2 + idx_access2 - 1 - low_offset1
+	   limit = (high_offset1 - low_offset1 + idx_access1 - 1)
+		 + (high_offset2 - low_offset2 + idx_access2 - 1)
+      i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1
 
-	 Combining the tests requires limit to be computable in an unsigned
-	 form of the index type; if it isn't, we fall back to the usual
-	 pointer-based checks.
+     Combining the tests requires limit to be computable in an unsigned
+     form of the index type; if it isn't, we fall back to the usual
+     pointer-based checks.
 
-	 We can do better if DR_B is a write and if DR_A and DR_B are
-	 well-ordered in both the original and the new code (see the
-	 comment above the DR_ALIAS_* flags for details).  In this case
-	 we know that for each i in [0, n-1], the write performed by
-	 access i of DR_B occurs after access numbers j<=i of DR_A in
-	 both the original and the new code.  Any write or anti
-	 dependencies wrt those DR_A accesses are therefore maintained.
+     We can do better if DR_B is a write and if DR_A and DR_B are
+     well-ordered in both the original and the new code (see the
+     comment above the DR_ALIAS_* flags for details).  In this case
+     we know that for each i in [0, n-1], the write performed by
+     access i of DR_B occurs after access numbers j<=i of DR_A in
+     both the original and the new code.  Any write or anti
+     dependencies wrt those DR_A accesses are therefore maintained.
 
-	 We just need to make sure that each individual write in DR_B does not
-	 overlap any higher-indexed access in DR_A; such DR_A accesses happen
-	 after the DR_B access in the original code but happen before it in
-	 the new code.
+     We just need to make sure that each individual write in DR_B does not
+     overlap any higher-indexed access in DR_A; such DR_A accesses happen
+     after the DR_B access in the original code but happen before it in
+     the new code.
 
-	 We know the steps for both accesses are equal, so by induction, we
-	 just need to test whether the first write of DR_B overlaps a later
-	 access of DR_A.  In other words, we need to move min1 along by
-	 one iteration:
+     We know the steps for both accesses are equal, so by induction, we
+     just need to test whether the first write of DR_B overlaps a later
+     access of DR_A.  In other words, we need to move min1 along by
+     one iteration:
 
-	   min1' = min1 + idx_step
+       min1' = min1 + idx_step
 
-	 and use the ranges:
+     and use the ranges:
 
-	   [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]
+       [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]
 
-	 and:
+     and:
 
-	   [min2, min2 + idx_access2 - 1]
+       [min2, min2 + idx_access2 - 1]
 
-	 where:
+     where:
 
-	    low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)
-	   high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */
-      if (waw_or_war_p)
-	idx_len1 -= abs_idx_step;
+	low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)
+       high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */
+  if (waw_or_war_p)
+    idx_len1 -= abs_idx_step;
 
-      poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;
-      if (!waw_or_war_p)
-	limit += idx_len2;
+  poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;
+  if (!waw_or_war_p)
+    limit += idx_len2;
 
-      tree utype = unsigned_type_for (TREE_TYPE (min1));
-      if (!wi::fits_to_tree_p (limit, utype))
-	return false;
+  tree utype = unsigned_type_for (TREE_TYPE (min1));
+  if (!wi::fits_to_tree_p (limit, utype))
+    return false;
 
-      poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;
-      poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;
-      poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;
-      /* Equivalent to adding IDX_STEP to MIN1.  */
-      if (waw_or_war_p)
-	bias -= wi::to_offset (idx_step);
-
-      tree subject = fold_build2 (MINUS_EXPR, utype,
-				  fold_convert (utype, min2),
-				  fold_convert (utype, min1));
-      subject = fold_build2 (PLUS_EXPR, utype, subject,
-			     wide_int_to_tree (utype, bias));
-      tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,
-					 wide_int_to_tree (utype, limit));
-      if (*cond_expr)
-	*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
-				  *cond_expr, part_cond_expr);
-      else
-	*cond_expr = part_cond_expr;
-    }
+  poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;
+  poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;
+  poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;
+  /* Equivalent to adding IDX_STEP to MIN1.  */
+  if (waw_or_war_p)
+    bias -= wi::to_offset (idx_step);
+
+  tree subject = fold_build2 (MINUS_EXPR, utype,
+			      fold_convert (utype, min2),
+			      fold_convert (utype, min1));
+  subject = fold_build2 (PLUS_EXPR, utype, subject,
+			 wide_int_to_tree (utype, bias));
+  tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,
+				     wide_int_to_tree (utype, limit));
+  if (*cond_expr)
+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
+			      *cond_expr, part_cond_expr);
+  else
+    *cond_expr = part_cond_expr;
   if (dump_enabled_p ())
     {
       if (waw_or_war_p)
diff --git a/gcc/tree-loop-distribution.c b/gcc/tree-loop-distribution.c
index 888af48946f..fc48120f1b5 100644
--- a/gcc/tree-loop-distribution.c
+++ b/gcc/tree-loop-distribution.c
@@ -3151,11 +3151,19 @@ loop_distribution::distribute_loop (class loop *loop, vec<gimple *> stmts,
 void loop_distribution::bb_top_order_init (void)
 {
   int rpo_num;
-  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));
+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);
+  edge entry = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));
+  bitmap exit_bbs = BITMAP_ALLOC (NULL);
 
   bb_top_order_index = XNEWVEC (int, last_basic_block_for_fn (cfun));
   bb_top_order_index_size = last_basic_block_for_fn (cfun);
-  rpo_num = pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, true);
+
+  entry->flags &= ~EDGE_DFS_BACK;
+  bitmap_set_bit (exit_bbs, EXIT_BLOCK);
+  rpo_num = rev_post_order_and_mark_dfs_back_seme (cfun, entry, exit_bbs, true,
+						   rpo, NULL);
+  BITMAP_FREE (exit_bbs);
+
   for (int i = 0; i < rpo_num; i++)
     bb_top_order_index[rpo[i]] = i;
 
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 926b4a976ae..9628fe67fba 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -7351,11 +7351,9 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
     e->flags &= ~EDGE_DFS_BACK;
 
   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);
+  auto_vec<std::pair<int, int> > toplevel_scc_extents;
   int n = rev_post_order_and_mark_dfs_back_seme
-    (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);
-  /* rev_post_order_and_mark_dfs_back_seme fills RPO in reverse order.  */
-  for (int i = 0; i < n / 2; ++i)
-    std::swap (rpo[i], rpo[n-i-1]);
+    (fn, entry, exit_bbs, true, rpo, !iterate ? &toplevel_scc_extents : NULL);
 
   if (!do_region)
     BITMAP_FREE (exit_bbs);
@@ -7433,12 +7431,20 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
   vn_valueize = rpo_vn_valueize;
 
   /* Initialize the unwind state and edge/BB executable state.  */
-  bool need_max_rpo_iterate = false;
+  unsigned curr_scc = 0;
   for (int i = 0; i < n; ++i)
     {
       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);
       rpo_state[i].visited = 0;
       rpo_state[i].max_rpo = i;
+      if (!iterate && curr_scc < toplevel_scc_extents.length ())
+	{
+	  if (i >= toplevel_scc_extents[curr_scc].first
+	      && i <= toplevel_scc_extents[curr_scc].second)
+	    rpo_state[i].max_rpo = toplevel_scc_extents[curr_scc].second;
+	  if (i == toplevel_scc_extents[curr_scc].second)
+	    curr_scc++;
+	}
       bb->flags &= ~BB_EXECUTABLE;
       bool has_backedges = false;
       edge e;
@@ -7450,51 +7456,12 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
 	  e->flags &= ~EDGE_EXECUTABLE;
 	  if (iterate || e == entry || (skip_entry_phis && bb == entry->dest))
 	    continue;
-	  if (bb_to_rpo[e->src->index] > i)
-	    {
-	      rpo_state[i].max_rpo = MAX (rpo_state[i].max_rpo,
-					  bb_to_rpo[e->src->index]);
-	      need_max_rpo_iterate = true;
-	    }
-	  else
-	    rpo_state[i].max_rpo
-	      = MAX (rpo_state[i].max_rpo,
-		     rpo_state[bb_to_rpo[e->src->index]].max_rpo);
 	}
       rpo_state[i].iterate = iterate && has_backedges;
     }
   entry->flags |= EDGE_EXECUTABLE;
   entry->dest->flags |= BB_EXECUTABLE;
 
-  /* When there are irreducible regions the simplistic max_rpo computation
-     above for the case of backedges doesn't work and we need to iterate
-     until there are no more changes.  */
-  unsigned nit = 0;
-  while (need_max_rpo_iterate)
-    {
-      nit++;
-      need_max_rpo_iterate = false;
-      for (int i = 0; i < n; ++i)
-	{
-	  basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);
-	  edge e;
-	  edge_iterator ei;
-	  FOR_EACH_EDGE (e, ei, bb->preds)
-	    {
-	      if (e == entry || (skip_entry_phis && bb == entry->dest))
-		continue;
-	      int max_rpo = MAX (rpo_state[i].max_rpo,
-				 rpo_state[bb_to_rpo[e->src->index]].max_rpo);
-	      if (rpo_state[i].max_rpo != max_rpo)
-		{
-		  rpo_state[i].max_rpo = max_rpo;
-		  need_max_rpo_iterate = true;
-		}
-	    }
-	}
-    }
-  statistics_histogram_event (cfun, "RPO max_rpo iterations", nit);
-
   /* As heuristic to improve compile-time we handle only the N innermost
      loops and the outermost one optimistically.  */
   if (iterate)
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 899b5608745..60d7b74a57e 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -8936,7 +8936,10 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)
 	   !gsi_end_p (gsi); gsi_next (&gsi))
 	{
 	  gcall *call = dyn_cast <gcall *> (gsi_stmt (gsi));
-	  if (call && gimple_call_internal_p (call, IFN_MASK_LOAD))
+	  if (!call || !gimple_call_internal_p (call))
+	    continue;
+	  internal_fn ifn = gimple_call_internal_fn (call);
+	  if (ifn == IFN_MASK_LOAD)
 	    {
 	      tree lhs = gimple_get_lhs (call);
 	      if (!VECTOR_TYPE_P (TREE_TYPE (lhs)))
@@ -8946,6 +8949,17 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)
 		  gsi_replace (&gsi, new_stmt, true);
 		}
 	    }
+	  else if (conditional_internal_fn_code (ifn) != ERROR_MARK)
+	    {
+	      tree lhs = gimple_get_lhs (call);
+	      if (!VECTOR_TYPE_P (TREE_TYPE (lhs)))
+		{
+		  tree else_arg
+		    = gimple_call_arg (call, gimple_call_num_args (call) - 1);
+		  gimple *new_stmt = gimple_build_assign (lhs, else_arg);
+		  gsi_replace (&gsi, new_stmt, true);
+		}
+	    }
 	}
     }				/* BBs in loop */
 
diff --git a/gcc/tree.c b/gcc/tree.c
index 3c17694c703..b43bc809823 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -10982,13 +10982,13 @@ build_opaque_vector_type (tree innertype, poly_int64 nunits)
 
 /* Return the value of element I of VECTOR_CST T as a wide_int.  */
 
-wide_int
+static poly_wide_int
 vector_cst_int_elt (const_tree t, unsigned int i)
 {
   /* First handle elements that are directly encoded.  */
   unsigned int encoded_nelts = vector_cst_encoded_nelts (t);
   if (i < encoded_nelts)
-    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, i));
+    return wi::to_poly_wide (VECTOR_CST_ENCODED_ELT (t, i));
 
   /* Identify the pattern that contains element I and work out the index of
      the last encoded element for that pattern.  */
@@ -10999,13 +10999,13 @@ vector_cst_int_elt (const_tree t, unsigned int i)
 
   /* If there are no steps, the final encoded value is the right one.  */
   if (!VECTOR_CST_STEPPED_P (t))
-    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, final_i));
+    return wi::to_poly_wide (VECTOR_CST_ENCODED_ELT (t, final_i));
 
   /* Otherwise work out the value from the last two encoded elements.  */
   tree v1 = VECTOR_CST_ENCODED_ELT (t, final_i - npatterns);
   tree v2 = VECTOR_CST_ENCODED_ELT (t, final_i);
-  wide_int diff = wi::to_wide (v2) - wi::to_wide (v1);
-  return wi::to_wide (v2) + (count - 2) * diff;
+  poly_wide_int diff = wi::to_poly_wide (v2) - wi::to_poly_wide (v1);
+  return wi::to_poly_wide (v2) + (count - 2) * diff;
 }
 
 /* Return the value of element I of VECTOR_CST T.  */
diff --git a/gcc/tree.h b/gcc/tree.h
index 328a2d5d226..bb80e81d389 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -4714,7 +4714,6 @@ extern tree first_field (const_tree);
 extern bool initializer_zerop (const_tree, bool * = NULL);
 extern bool initializer_each_zero_or_onep (const_tree);
 
-extern wide_int vector_cst_int_elt (const_tree, unsigned int);
 extern tree vector_cst_elt (const_tree, unsigned int);
 
 /* Given a vector VEC, return its first element if all elements are
diff --git a/intl/ChangeLog b/intl/ChangeLog
index e45e393b790..3c50c7bc259 100644
--- a/intl/ChangeLog
+++ b/intl/ChangeLog
@@ -1,3 +1,13 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR jit/100096
+	* configure.ac: Add --enable-host-shared support.
+	* Makefile.in: Update copyright.  Add @PICFLAG@ to CFLAGS.
+	* configure: Regenerated.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/intl/Makefile.in b/intl/Makefile.in
index 356c8ab9b65..ec8c648b7a9 100644
--- a/intl/Makefile.in
+++ b/intl/Makefile.in
@@ -1,5 +1,5 @@
 # Makefile for directory with message catalog handling library of GNU gettext
-# Copyright (C) 1995-1998, 2000-2003 Free Software Foundation, Inc.
+# Copyright (C) 1995-2021 Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU Library General Public License as published
@@ -45,7 +45,7 @@ RANLIB = @RANLIB@
 YACC = @INTLBISON@ -y -d
 YFLAGS = --name-prefix=__gettext
 CPPFLAGS = @CPPFLAGS@
-CFLAGS = @CFLAGS@
+CFLAGS = @CFLAGS@ @PICFLAG@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 DEFS = -DHAVE_CONFIG_H
diff --git a/intl/configure b/intl/configure
index d69767b7d21..1e100395369 100755
--- a/intl/configure
+++ b/intl/configure
@@ -622,6 +622,7 @@ ac_unique_file="gettext.c"
 ac_header_list=
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+PICFLAG
 BISON3_NO
 BISON3_YES
 INCINTL
@@ -726,6 +727,7 @@ with_included_gettext
 with_libintl_prefix
 with_libintl_type
 enable_maintainer_mode
+enable_host_shared
 '
       ac_precious_vars='build_alias
 host_alias
@@ -1350,6 +1352,7 @@ Optional Features:
   --disable-nls           do not use Native Language Support
   --disable-rpath         do not hardcode runtime library paths
   --enable-maintainer-mode enable rules only needed by maintainers
+  --enable-host-shared    build host code as shared libraries
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -6815,6 +6818,15 @@ fi
 
 
 
+# Check whether --enable-host-shared was given.
+if test "${enable_host_shared+set}" = set; then :
+  enableval=$enable_host_shared; PICFLAG=-fPIC
+else
+  PICFLAG=
+fi
+
+
+
 ac_config_files="$ac_config_files Makefile config.intl"
 
 cat >confcache <<\_ACEOF
diff --git a/intl/configure.ac b/intl/configure.ac
index 6363e55e68a..72b145958cf 100644
--- a/intl/configure.ac
+++ b/intl/configure.ac
@@ -69,5 +69,11 @@ fi
 AC_SUBST(BISON3_YES)
 AC_SUBST(BISON3_NO)
 
+AC_ARG_ENABLE(host-shared,
+[AS_HELP_STRING([--enable-host-shared],
+		[build host code as shared libraries])],
+[PICFLAG=-fPIC], [PICFLAG=])
+AC_SUBST(PICFLAG)
+
 AC_CONFIG_FILES(Makefile config.intl)
 AC_OUTPUT
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 0d1120a6dd9..34065338294 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,9 @@
+2021-04-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* include/line-map.h (IS_MACRO_LOC): Delete.
+	* line-map.c (linemap_location_from_macro_expansion_p): Test
+	LINEMAPS_MACRO_LOWEST_LOCATION of the linemap.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libcpp/include/line-map.h b/libcpp/include/line-map.h
index dbbc13762e3..916cdebcd6a 100644
--- a/libcpp/include/line-map.h
+++ b/libcpp/include/line-map.h
@@ -561,7 +561,7 @@ struct GTY((tag ("2"))) line_map_macro : public line_map {
 #define linemap_assert_fails(EXPR) (! (EXPR))
 #endif
 
-/* Get whether location LOC is an ad-hoc, ordinary or macro location.  */
+/* Get whether location LOC is an ordinary location.  */
 
 inline bool
 IS_ORDINARY_LOC (location_t loc)
@@ -569,18 +569,14 @@ IS_ORDINARY_LOC (location_t loc)
   return loc < LINE_MAP_MAX_LOCATION;
 }
 
+/* Get whether location LOC is an ad-hoc location.  */
+
 inline bool
 IS_ADHOC_LOC (location_t loc)
 {
   return loc > MAX_LOCATION_T;
 }
 
-inline bool
-IS_MACRO_LOC (location_t loc)
-{
-  return !IS_ORDINARY_LOC (loc) && !IS_ADHOC_LOC (loc);
-}
-
 /* Categorize line map kinds.  */
 
 inline bool
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index 8a390d0857b..1dce2292522 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -1244,7 +1244,7 @@ linemap_location_from_macro_expansion_p (const class line_maps *set,
   if (IS_ADHOC_LOC (location))
     location = get_location_from_adhoc_loc (set, location);
 
-  return IS_MACRO_LOC (location);
+  return location >= LINEMAPS_MACRO_LOWEST_LOCATION (set);
 }
 
 /* Given two virtual locations *LOC0 and *LOC1, return the first
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 1f9de3d5091..f208dfc2042 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,14 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97653
+	* config/rs6000/t-linux (IBM128_STATIC_OBJS): Fix spelling, use
+	$(objext) instead of $(object).  Use _floatunditf instead of
+	_floatunsditf.  Add tf <-> ti conversion objects.
+	(IBM128_SHARED_OBJS): Use proper substitution reference syntax.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libgcc/config/rs6000/t-linux b/libgcc/config/rs6000/t-linux
index 72e9c2770a6..500210ddaf2 100644
--- a/libgcc/config/rs6000/t-linux
+++ b/libgcc/config/rs6000/t-linux
@@ -11,10 +11,12 @@ HOST_LIBGCC2_CFLAGS += -mno-minimal-toc
 # the IBM extended double format.  Also turn off gnu attributes on the static
 # modules.
 IBM128_STATIC_OBJS	= ibm-ldouble$(objext) _powitf2$(objext) \
-			  ppc64-fp$(objext) _divtc3$(object) _multc3$(object) \
-			  _fixtfdi$(object) _fixunstfdi$(object) \
-	                  _floatditf$(objext) _floatunsditf$(objext)
-IBM128_SHARED_OBJS	= $(IBM128_STATIC_OBJS:$(objext):_s$(objext))
+			  ppc64-fp$(objext) _divtc3$(objext) _multc3$(objext) \
+			  _fixtfdi$(objext) _fixunstfdi$(objext) \
+	                  _floatditf$(objext) _floatunditf$(objext) \
+			  _fixtfti$(objext) _fixunstfti$(objext) \
+	                  _floattitf$(objext) _floatuntitf$(objext)
+IBM128_SHARED_OBJS	= $(IBM128_STATIC_OBJS:$(objext)=_s$(objext))
 IBM128_OBJS		= $(IBM128_STATIC_OBJS) $(IBM128_SHARED_OBJS)
 
 IBM128_CFLAGS		= -Wno-psabi -mabi=ibmlongdouble -mno-gnu-attribute
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index f76d32e398c..9bd9c3d2c56 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,23 @@
+2021-04-18  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	Backported from master:
+	2021-04-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
+
+	PR middle-end/98088
+	* testsuite/libgomp.oacc-c-c++-common/collapse-2.c: Add check
+	for loop with GT/GE condition.
+	* testsuite/libgomp.oacc-c-c++-common/collapse-3.c: Likewise.
+
+2021-04-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-04-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/84991
+	PR middle-end/84992
+	PR middle-end/90779
+	* testsuite/libgomp.oacc-c-c++-common/static-variable-1.c: New.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
index 1ea0a6b846d..7a8cfd2f3d4 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c
@@ -5,7 +5,7 @@
 int
 main (void)
 {
-  int i, j, k, l = 0, f = 0, x = 0;
+  int i, j, k, l = 0, f = 0, x = 0, l2 = 0;
   int m1 = 4, m2 = -5, m3 = 17;
 
 #pragma acc parallel
@@ -20,6 +20,19 @@ main (void)
 	    }
 	}
 
+  /*  Test loop with > condition.  */
+#pragma acc parallel
+  #pragma acc loop seq collapse(3) reduction(+:l2)
+    for (i = -2; i < m1; i++)
+      for (j = -3; j > (m2 - 1); j--)
+	{
+	  for (k = 13; k < m3; k++)
+	    {
+	      if ((i + 2) * 12 + (j + 5) * 4 + (k - 13) !=  9 + f++)
+		l2++;
+	    }
+	}
+
     for (i = -2; i < m1; i++)
       for (j = m2; j < -2; j++)
 	{
@@ -30,7 +43,7 @@ main (void)
 	    }
 	}
 
-  if (l != x)
+  if (l != x || l2 != x)
     abort ();
 
   return 0;
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
index 680042892e4..50f538d0a32 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c
@@ -7,7 +7,7 @@
 int
 main (void)
 {
-  int i2, l = 0, r = 0;
+  int i2, l = 0, r = 0, l2 = 0;
   int a[3][3][3];
 
   memset (a, '\0', sizeof (a));
@@ -27,13 +27,24 @@ main (void)
 		l += 1;
     }
 
+  /*  Test loop with >= condition.  */
+#pragma acc parallel
+    {
+      #pragma acc loop collapse(2) reduction(|:l2)
+	for (i2 = 0; i2 < 2; i2++)
+	  for (int j = 1; j >= 0; j--)
+	    for (int k = 0; k < 2; k++)
+	      if (a[i2][j][k] != i2 + j * 4 + k * 16)
+		l2 += 1;
+    }
+
     for (i2 = 0; i2 < 2; i2++)
       for (int j = 0; j < 2; j++)
 	for (int k = 0; k < 2; k++)
 	  if (a[i2][j][k] != i2 + j * 4 + k * 16)
 	    r += 1;
 
-  if (l != r)
+  if (l != r || l2 != r)
     abort ();
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c
new file mode 100644
index 00000000000..1d415cdcf76
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c
@@ -0,0 +1,460 @@
+/* "Function scope" (top-level block scope) 'static' variables
+
+   ... inside OpenACC compute construct regions as well as OpenACC 'routine'.
+
+   This is to document/verify aspects of GCC's observed behavior, not
+   necessarily as it's (intended to be?) restricted by the OpenACC
+   specification.  See also PR84991, PR84992, PR90779 etc., and
+   <https://github.com/OpenACC/openacc-spec/issues/372> "C/C++ 'static'
+   variables" (only visible to members of the GitHub OpenACC organization).
+*/
+
+
+#undef NDEBUG
+#include <assert.h>
+#include <string.h>
+#include <openacc.h>
+#include <gomp-constants.h>
+
+
+#define IF_DEBUG if (0)
+
+
+/* Without explicit 'num_gangs'.  */
+
+static void t0_c(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 11;
+  const int var_init = 16;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	static int var = var_init;
+
+#pragma acc atomic capture
+	result = ++var;
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      /* Without an explicit 'num_gangs' clause GCC assigns 'num_gangs(1)'
+	 because it doesn't see any use of gang-level parallelism inside the
+	 region.  */
+      assert(num_gangs_actual == 1);
+      assert(result == var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Call a gang-level routine.  */
+
+static const int t0_r_var_init = 61;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t0_r_r(void)
+{
+  static int var = t0_r_var_init;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t0_r(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 11;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	result = t0_r_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      /* The number of gangs selected by the implemention ought to but must not
+	 be bigger than one.  */
+      IF_DEBUG
+	__builtin_printf ("%d: num_gangs_actual: %d\n", i, num_gangs_actual);
+      assert(num_gangs_actual >= 1);
+      assert(result == t0_r_var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Explicit 'num_gangs'.  */
+
+static void t1_c(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 22;
+  const int num_gangs_request = 444;
+  const int var_init = 5;
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result = 0;
+      int num_gangs_actual = -1;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:num_gangs_actual) \
+  reduction(max:result)
+      {
+	num_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);
+
+	static int var = var_init;
+
+#pragma acc atomic capture
+	result = ++var;
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result'.  */
+      }
+      if (acc_get_device_type() == acc_device_host)
+	assert(num_gangs_actual == 1);
+      else
+	assert(num_gangs_actual == num_gangs_request);
+      assert(result == var_init + num_gangs_actual * (1 + i));
+    }
+}
+
+
+/* Check the same routine called from two compute constructs.  */
+
+static const int t1_r2_var_init = 166;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t1_r2_r(void)
+{
+  static int var = t1_r2_var_init;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t1_r2(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 71;
+  /* The checking assumes the same 'num_gangs' for all compute constructs.  */
+  const int num_gangs_request = 333;
+  int num_gangs_actual = -1;
+  if (acc_get_device_type() == acc_device_host)
+    num_gangs_actual = 1;
+  else
+    {
+      /* We're assuming that the implementation is able to accomodate the
+	 'num_gangs' requested (which really ought to be true for
+	 'num_gangs').  */
+      num_gangs_actual = num_gangs_request;
+    }
+
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result_1 = 0;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:result_1)
+      {
+	result_1 = t1_r2_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented 'num_gangs_actual' times, and
+	   the final value captured as 'result_1'.  */
+      }
+      IF_DEBUG
+	__builtin_printf ("%d: result_1: %d\n", i, result_1);
+      assert(result_1 == t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 0)));
+
+      int result_2 = 0;
+#pragma acc parallel \
+  num_gangs(num_gangs_request) \
+  reduction(max:result_2)
+      {
+	result_2 = t1_r2_r() + t1_r2_r();
+
+	/* Irrespective of the order in which the gang-redundant threads
+	   execute, 'var' has now been incremented '2 * num_gangs_actual' times.
+	   However, the order of the two 't1_r2_r' function calls is not
+	   synchronized (between different gang-redundant threads).  We thus
+	   cannot verify the actual 'result_2' values in this case.  */
+      }
+      IF_DEBUG
+	__builtin_printf ("%d: result_2: %d\n", i, result_2);
+      if (num_gangs_actual == 1)
+	/* Per the rationale above, only in this case we can check the actual
+	   result.  */
+	assert(result_2 == (t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 1))
+			    + t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 2))));
+      /* But we can generally check low and high limits.  */
+      {
+	/* Must be bigger than '2 * result_1'.  */
+	int c = 2 * result_1;
+	IF_DEBUG
+	  __builtin_printf ("  > %d\n", c);
+	assert(result_2 > c);
+      }
+      {
+	/* ..., but limited by the base value for next 'i'.  */
+	int c = 2 * (t1_r2_var_init + num_gangs_actual * (0 + ((i + 1) * 3 + 0)));
+	IF_DEBUG
+	  __builtin_printf ("  < %d\n", c);
+	assert(result_2 < c);
+      }
+    }
+}
+
+
+/* Asynchronous execution.  */
+
+static const int t2_var_init_2 = -55;
+
+#pragma acc routine gang
+__attribute__((noinline))
+static int t2_r(void)
+{
+  static int var = t2_var_init_2;
+
+  int tmp;
+#pragma acc atomic capture
+  tmp = ++var;
+
+  return tmp;
+}
+
+static void t2(void)
+{
+  IF_DEBUG
+    __builtin_printf ("%s\n", __FUNCTION__);
+
+  const int i_limit = 12;
+  const int num_gangs_request_1 = 14;
+  const int var_init_1 = 5;
+  int results_1[i_limit][num_gangs_request_1];
+  memset (results_1, 0, sizeof results_1);
+  const int num_gangs_request_2 = 5;
+  int results_2[i_limit][num_gangs_request_2];
+  memset (results_2, 0, sizeof results_2);
+  const int num_gangs_request_3 = 34;
+  const int var_init_3 = 1250;
+  int results_3[i_limit][num_gangs_request_3];
+  memset (results_3, 0, sizeof results_3);
+
+#pragma acc data \
+  copy(results_1, results_2, results_3)
+  {
+    for (int i = 0; i < i_limit; ++i)
+      {
+	/* The following 'async' clauses effect asynchronous execution, but
+	   using the same async-argument for each compute construct implies that
+	   the respective compute constructs' execution is synchronized with
+	   itself, meaning that all 'i = 0' execution has finished (on the
+	   device) before 'i = 1' is started (on the device), etc.  */
+
+#pragma acc parallel \
+  present(results_1) \
+  num_gangs(num_gangs_request_1) \
+  async(1)
+	{
+	  static int var = var_init_1;
+
+	  int tmp;
+#pragma acc atomic capture
+	  tmp = ++var;
+
+	  results_1[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;
+	}
+
+#pragma acc parallel \
+  present(results_2) \
+  num_gangs(num_gangs_request_2) \
+  async(2)
+	{
+	  results_2[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += t2_r();
+	}
+
+#pragma acc parallel \
+  present(results_3) \
+  num_gangs(num_gangs_request_3) \
+  async(3)
+	{
+	  static int var = var_init_3;
+
+	  int tmp;
+#pragma acc atomic capture
+	  tmp = ++var;
+
+	  results_3[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;
+	}
+      }
+#pragma acc wait
+  }
+  int num_gangs_actual_1;
+  int num_gangs_actual_2;
+  int num_gangs_actual_3;
+  if (acc_get_device_type() == acc_device_host)
+    {
+      num_gangs_actual_1 = 1;
+      num_gangs_actual_2 = 1;
+      num_gangs_actual_3 = 1;
+    }
+  else
+    {
+      /* We're assuming that the implementation is able to accomodate the
+	 'num_gangs' requested (which really ought to be true for
+	 'num_gangs').  */
+      num_gangs_actual_1 = num_gangs_request_1;
+      num_gangs_actual_2 = num_gangs_request_2;
+      num_gangs_actual_3 = num_gangs_request_3;
+    }
+
+  /* For 'i = 0', 'results_*[i][0..num_gangs_actual_*]' are expected to each
+     contain one value of '(1 + var_init_*)..(var_init_* + num_gangs_actual_*)',
+     and so on for increasing 'i'.  Their order however is unspecified due to
+     the gang-redundant execution.  (Thus checking that their sums match.)  */
+
+  int result_1 = 0;
+  int result_2 = 0;
+  int result_3 = 0;
+  for (int i = 0; i < i_limit; ++i)
+    {
+      int result_1_ = 0;
+      for (int g = 0; g < num_gangs_actual_1; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_1[%d][%d]: %d\n", i, g, results_1[i][g]);
+	  result_1_ += results_1[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_1_: %d\n", i, result_1_);
+      assert (result_1_ == (((var_init_1 + num_gangs_actual_1 * (1 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (1 + i)) / 2)
+			    - ((var_init_1 + num_gangs_actual_1 * (0 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (0 + i)) / 2)));
+      result_1 += result_1_;
+
+      int result_2_ = 0;
+      for (int g = 0; g < num_gangs_actual_2; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_2[%d][%d]: %d\n", i, g, results_2[i][g]);
+	  result_2_ += results_2[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_2_: %d\n", i, result_2_);
+      assert (result_2_ == (((t2_var_init_2 + num_gangs_actual_2 * (1 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (1 + i)) / 2)
+			    - ((t2_var_init_2 + num_gangs_actual_2 * (0 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (0 + i)) / 2)));
+      result_2 += result_2_;
+
+      int result_3_ = 0;
+      for (int g = 0; g < num_gangs_actual_3; ++g)
+	{
+	  IF_DEBUG
+	    __builtin_printf ("results_3[%d][%d]: %d\n", i, g, results_3[i][g]);
+	  result_3_ += results_3[i][g];
+	}
+      IF_DEBUG
+	__builtin_printf ("%d result_3_: %d\n", i, result_3_);
+      assert (result_3_ == (((var_init_3 + num_gangs_actual_3 * (1 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (1 + i)) / 2)
+			    - ((var_init_3 + num_gangs_actual_3 * (0 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (0 + i)) / 2)));
+      result_3 += result_3_;
+    }
+  IF_DEBUG
+    __builtin_printf ("result_1: %d\n", result_1);
+  assert (result_1 == (((var_init_1 + num_gangs_actual_1 * i_limit) * (1 + var_init_1 + num_gangs_actual_1 * i_limit) / 2)
+		       - (var_init_1 * (var_init_1 + 1) / 2)));
+  IF_DEBUG
+    __builtin_printf ("result_2: %d\n", result_2);
+  assert (result_2 == (((t2_var_init_2 + num_gangs_actual_2 * i_limit) * (1 + t2_var_init_2 + num_gangs_actual_2 * i_limit) / 2)
+		       - (t2_var_init_2 * (t2_var_init_2 + 1) / 2)));
+  IF_DEBUG
+    __builtin_printf ("result_3: %d\n", result_3);
+  assert (result_3 == (((var_init_3 + num_gangs_actual_3 * i_limit) * (1 + var_init_3 + num_gangs_actual_3 * i_limit) / 2)
+		       - (var_init_3 * (var_init_3 + 1) / 2)));
+}
+
+
+#pragma acc routine seq
+__attribute__((noinline))
+static int pr84991_1_r_s(int n)
+{
+  static const int test[] = {1,2,3,4};
+  return test[n];
+}
+
+static void pr84991_1(void)
+{
+  int n[1];
+  n[0] = 3;
+#pragma acc parallel copy(n)
+  {
+    n[0] = pr84991_1_r_s(n[0]);
+  }
+  assert(n[0] == 4);
+}
+
+
+static void pr84992_1(void)
+{
+  int n[1];
+  n[0] = 3;
+#pragma acc parallel copy(n)
+  {
+    static const int test[] = {1,2,3,4};
+    n[0] = test[n[0]];
+  }
+  assert(n[0] == 4);
+}
+
+
+int main(void)
+{
+  t0_c();
+
+  t0_r();
+
+  t1_c();
+
+  t1_r2();
+
+  t2();
+
+  pr84991_1();
+
+  pr84992_1();
+
+  return 0;
+}
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index ceea82c4f70..fc4371afad5 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,13 @@
+2021-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/100114
+	* sanitizer_common/sanitizer_posix_libcdep.cpp: Cherry-pick
+	llvm-project revisions 82150606fb11d28813ae6da1101f5bda638165fe
+	and b93629dd335ffee2fc4b9b619bf86c3f9e6b0023.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
index 304b3a01a08..ac88fbe074e 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp
@@ -169,7 +169,11 @@ bool SupportsColoredOutput(fd_t fd) {
 
 #if !SANITIZER_GO
 // TODO(glider): different tools may require different altstack size.
-static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.
+static uptr GetAltStackSize() {
+  // SIGSTKSZ is not enough.
+  static const uptr kAltStackSize = SIGSTKSZ * 4;
+  return kAltStackSize;
+}
 
 void SetAlternateSignalStack() {
   stack_t altstack, oldstack;
@@ -180,10 +184,9 @@ void SetAlternateSignalStack() {
   // TODO(glider): the mapped stack should have the MAP_STACK flag in the
   // future. It is not required by man 2 sigaltstack now (they're using
   // malloc()).
-  void* base = MmapOrDie(kAltStackSize, __func__);
-  altstack.ss_sp = (char*) base;
+  altstack.ss_size = GetAltStackSize();
+  altstack.ss_sp = (char *)MmapOrDie(altstack.ss_size, __func__);
   altstack.ss_flags = 0;
-  altstack.ss_size = kAltStackSize;
   CHECK_EQ(0, sigaltstack(&altstack, nullptr));
 }
 
@@ -191,7 +194,7 @@ void UnsetAlternateSignalStack() {
   stack_t altstack, oldstack;
   altstack.ss_sp = nullptr;
   altstack.ss_flags = SS_DISABLE;
-  altstack.ss_size = kAltStackSize;  // Some sane value required on Darwin.
+  altstack.ss_size = GetAltStackSize();  // Some sane value required on Darwin.
   CHECK_EQ(0, sigaltstack(&altstack, &oldstack));
   UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);
 }
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index fdd63cbff1a..2e7efeb6ccd 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,413 @@
+2021-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100180
+	* testsuite/experimental/net/internet/address/v6/members.cc:
+	Require gthreads.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::find): Define.
+	(split_view::_OuterIter::operator++): Apply proposed resolution
+	of LWG 3505.
+	* testsuite/std/ranges/adaptors/split.cc (test10): New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::find_if): Simplify.
+	(__detail::find_if_not): Likewise.
+	(__detail::min): Remove.
+	(__detail::mismatch): Simplify.
+	(take_view::size): Use std::min instead of __detail::min.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-08  Patrick Palka  <ppalka@redhat.com>
+
+	* include/std/ranges (__detail::__returnable_element): New
+	concept.
+	(elements_view): Use this concept in its constraints.  Add
+	missing private access specifier.
+	(elements_view::_S_get_element): Define as per LWG 3502.
+	(elements_view::operator*, elements_view::operator[]): Use
+	_S_get_element.
+	(elements_view::operator++): Remove unnecessary constraint
+	as per LWG 3492.
+	* testsuite/std/ranges/adaptors/elements.cc (test05): New test.
+
+2021-04-21  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-31  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/97600
+	* include/std/ranges (basic_istream_view::begin): Initialize
+	_Iterator from 'this' instead of '*this'.
+	(basic_istream_view::_Iterator::_Iterator): Adjust constructor
+	accordingly.
+	(filter_view::_Iterator::_Iterator): Take a filter_view*
+	argument instead of a filter_view& argument.
+	(filter_view::_Sentinel::_Sentinel): Likewise.
+	(filter_view::begin): Initialize _Iterator from 'this' instead
+	of '*this'.
+	(filter_view::end): Likewise.
+	(transform_view::_Iterator::_Iterator): Take a _Parent* instead
+	of a _Parent&.
+	(filter_view::_Iterator::operator+): Adjust accordingly.
+	(filter_view::_Iterator::operator-): Likewise.
+	(filter_view::begin): Initialize _Iterator from 'this' instead
+	of '*this'.
+	(filter_view::end): Likewise.
+	(join_view::_Iterator): Take a _Parent* instead of a _Parent&.
+	(join_view::_Sentinel): Likewise.
+	(join_view::begin): Initialize _Iterator from 'this' instead of
+	'*this'.
+	(join_view::end): Initialize _Sentinel from 'this' instead of
+	'*this'.
+	(split_view::_OuterIter): Take a _Parent& instead of a _Parent*.
+	(split_view::begin): Initialize _OuterIter from 'this' instead
+	of '*this'.
+	(split_view::end): Likewise.
+	* testsuite/std/ranges/97600.cc: New test.
+
+2021-04-19  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/99402
+	* include/debug/helper_functions.h (__can_advance(_InputIterator,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	(__can_advance(const _Safe_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* include/debug/macros.h (__glibcxx_check_can_increment_dist): New,
+	use latter.
+	(__glibcxx_check_can_increment_range): Adapt to use latter.
+	(__glibcxx_check_can_decrement_range): Likewise.
+	* include/debug/safe_iterator.h
+	(_Safe_iterator<>::_M_can_advance(const std::pair<_Diff, _Distance_precision>&,
+	int)): New.
+	(__can_advance(const _Safe_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* include/debug/safe_iterator.tcc
+	(_Safe_iterator<>::_M_can_advance(const std::pair<_Diff, _Distance_precision>&,
+	int)): New.
+	(_Safe_iterator<>::_M_valid_range(const _Safe_iterator<>&,
+	std::pair<difference_type, _Distance_precision>&, bool)): Adapt for
+	__dp_sign_max_size.
+	(__copy_move_a): Adapt to use __glibcxx_check_can_increment_dist.
+	(__copy_move_backward_a): Likewise.
+	(__equal_aux): Likewise.
+	* include/debug/stl_iterator.h (__can_advance(const std::reverse_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	(__can_advance(const std::move_iterator<>&,
+	const std::pair<_Diff, _Distance_precision>&, int)): New.
+	* testsuite/25_algorithms/copy/debug/99402.cc: New test.
+
+2021-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-10-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97570
+	* libsupc++/new_opa.cc: Declare size_t in global namespace.
+	Remove unused header.
+
+2021-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100060
+	* include/std/bit: Only include <ext/numeric_traits.h> for
+	hosted build, use <limits> otherwise.
+
+2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100044
+	* include/std/ranges (__detail::__iterator_sentinel_pair):
+	Remove helper concept.
+	(subrange(_Pr), subrange(Pr, __make_unsigned_like<...>)): Remove
+	deduction guides, as per LWG 3404.
+	* testsuite/std/ranges/subrange/lwg3282_neg.cc: Check that class
+	template argument deduction fails.
+
+2021-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/iterator_concepts.h (indirectly_readable): Add
+	partial specializations to resolve ambiguities (LWG 3446).
+	* testsuite/24_iterators/associated_types/readable.traits.cc:
+	Check types with both value_type and element_type.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR bootstrap/99983
+	* include/bits/hashtable.h (_Hashtable): Fix noexcept-speciofier
+	on definition to match the one on the declaration.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99985
+	* include/bits/hashtable.h (_Hashtable::_S_nothrow_move()): Fix
+	to be a valid constexpr function in C++11.
+	* testsuite/23_containers/unordered_set/cons/99985.cc: New test.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_fwd.h: Fix doxygen group command.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/std/chrono: Likewise.
+	* include/std/memory: Likewise.
+	* include/std/thread: Likewise.
+	* include/tr1/complex: Likewise.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h: Tweak doxygen comment.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h: Fix doxygen group commands.
+	* include/bits/regex_constants.h: Likewise.
+	* include/tr1/random.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:
+	Use allocator with the correct value type.
+	* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:
+	Likewise.
+
+2021-04-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-29  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/hashtable.h
+	(_Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a, true_type)):
+	Add noexcept qualification.
+	(_Hashtable(_Hashtable&&)): Fix noexcept qualification.
+	(_Hashtable(_Hashtable&&, const allocator_type&)): Add noexcept
+	qualification.
+	* include/bits/unordered_map.h
+	(unordered_map(unordered_map&&, const allocator_type&)): Add noexcept
+	qualification.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/bits/unordered_set.h
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_map
+	(unordered_map(unordered_map&&, const allocator_type&)): Likewise.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_set
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* testsuite/23_containers/unordered_map/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/modifiers/move_assign.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc:
+	New test.
+
+2021-04-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/stl_tree.h (_Rb_tree_impl(_Rb_tree_impl&&)): Add noexcept
+	qualification based only on _Compare one.
+	* testsuite/23_containers/map/cons/noexcept_move_construct.cc: Add
+	static asserts.
+	* testsuite/23_containers/multimap/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/multiset/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/set/cons/noexcept_move_construct.cc: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99805
+	* src/c++17/fs_path.cc (path::_M_split_cmpts): Do not call
+	non-const member on _M_pathname, to avoid copy-on-write.
+	* testsuite/27_io/filesystem/path/decompose/parent_path.cc:
+	Check construction from strings that might be shared.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Replace Intel parallelstl
+	link with LLVM repo for PSTL.
+	* doc/html/manual/status.html: Regenerate.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/alloc_traits.h: Use markdown for code font.
+	* include/bits/basic_string.h: Fix @param names.
+	* include/bits/regex.h: Fix duplicate @retval names, and rename.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp: Add
+	group open to match existing group close.
+	* include/ext/pb_ds/priority_queue.hpp: Add blank line before group
+	open.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/atomic_base.h: Fix doxygen group close.
+	* include/bits/basic_ios.h: Likewise.
+	* include/bits/forward_list.h: Likewise.
+	* include/bits/fs_dir.h: Likewise.
+	* include/bits/fs_ops.h: Likewise.
+	* include/bits/fs_path.h: Likewise.
+	* include/bits/functional_hash.h: Likewise.
+	* include/bits/gslice.h: Likewise.
+	* include/bits/gslice_array.h: Likewise.
+	* include/bits/hashtable_policy.h: Likewise.
+	* include/bits/indirect_array.h: Likewise.
+	* include/bits/locale_classes.h: Likewise.
+	* include/bits/locale_facets.h: Likewise.
+	* include/bits/locale_facets_nonio.h: Likewise.
+	* include/bits/mask_array.h: Likewise.
+	* include/bits/refwrap.h: Likewise.
+	* include/bits/regex.h: Likewise.
+	* include/bits/regex_automaton.h: Likewise.
+	* include/bits/regex_compiler.h: Likewise.
+	* include/bits/regex_constants.h: Likewise.
+	* include/bits/regex_error.h: Likewise.
+	* include/bits/regex_executor.h: Likewise.
+	* include/bits/regex_scanner.h: Likewise.
+	* include/bits/shared_ptr.h: Likewise.
+	* include/bits/shared_ptr_atomic.h: Likewise.
+	* include/bits/shared_ptr_base.h: Likewise.
+	* include/bits/slice_array.h: Likewise.
+	* include/bits/specfun.h: Likewise.
+	* include/bits/std_function.h: Likewise.
+	* include/bits/std_mutex.h: Likewise.
+	* include/bits/stl_deque.h: Likewise.
+	* include/bits/stl_iterator.h: Likewise.
+	* include/bits/stl_iterator_base_types.h: Likewise.
+	* include/bits/stl_map.h: Likewise.
+	* include/bits/stl_multimap.h: Likewise.
+	* include/bits/stl_multiset.h: Likewise.
+	* include/bits/stl_numeric.h: Likewise.
+	* include/bits/stl_pair.h: Likewise.
+	* include/bits/stl_set.h: Likewise.
+	* include/bits/stl_uninitialized.h: Likewise.
+	* include/bits/stream_iterator.h: Likewise.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/bits/unique_ptr.h: Likewise.
+	* include/bits/unordered_map.h: Likewise.
+	* include/bits/unordered_set.h: Likewise.
+	* include/decimal/decimal: Likewise.
+	* include/experimental/any: Likewise.
+	* include/experimental/array: Likewise.
+	* include/experimental/bits/fs_dir.h: Likewise.
+	* include/experimental/bits/fs_fwd.h: Likewise.
+	* include/experimental/bits/fs_ops.h: Likewise.
+	* include/experimental/bits/fs_path.h: Likewise.
+	* include/experimental/buffer: Likewise.
+	* include/experimental/internet: Likewise.
+	* include/experimental/optional: Likewise.
+	* include/experimental/propagate_const: Likewise.
+	* include/experimental/socket: Likewise.
+	* include/ext/pb_ds/assoc_container.hpp: Likewise.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp:
+	Likewise.
+	* include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/types_traits.hpp: Likewise.
+	* include/ext/pb_ds/exception.hpp: Likewise.
+	* include/ext/pb_ds/priority_queue.hpp: Likewise.
+	* include/ext/pb_ds/tag_and_trait.hpp: Likewise.
+	* include/ext/random: Likewise.
+	* include/std/any: Likewise.
+	* include/std/atomic: Likewise.
+	* include/std/bitset: Likewise.
+	* include/std/chrono: Likewise.
+	* include/std/complex: Likewise.
+	* include/std/condition_variable: Likewise.
+	* include/std/fstream: Likewise.
+	* include/std/future: Likewise.
+	* include/std/istream: Likewise.
+	* include/std/iostream: Likewise.
+	* include/std/mutex: Likewise.
+	* include/std/numeric: Likewise.
+	* include/std/ostream: Likewise.
+	* include/std/ratio: Likewise.
+	* include/std/shared_mutex: Likewise.
+	* include/std/stdexcept: Likewise.
+	* include/std/streambuf: Likewise.
+	* include/std/system_error: Likewise.
+	* include/std/valarray: Likewise.
+	* include/std/variant: Likewise.
+	* include/tr1/cmath: Likewise.
+	* include/tr1/regex: Likewise.
+	* include/tr2/dynamic_bitset: Likewise.
+	* libsupc++/atomic_lockfree_defines.h: Likewise.
+	* libsupc++/exception: Likewise.
+	* libsupc++/exception.h: Likewise.
+	* libsupc++/exception_ptr.h: Likewise.
+	* libsupc++/nested_exception.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/string_view: Adjust Doxygen @file comment.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index a956ac2721d..1cb14d9b3ff 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -932,7 +932,7 @@ since C++14 and the implementation is complete.
 	<span class="emphasis"><em>28</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Algorithms</em></span>
-      </td></tr><tr><td align="left">28.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.2</td><td align="left">Header <code class="code">&lt;algorithm&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.3</td><td align="left">Algorithms requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.4</td><td align="left">Parallel algorithms</td><td align="left"> </td><td align="left">Using <a class="link" href="https://github.com/intel/parallelstl" target="_top">PSTL</a></td></tr><tr><td align="left">28.5</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.6</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.7</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.8</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">28.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.2</td><td align="left">Header <code class="code">&lt;algorithm&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.3</td><td align="left">Algorithms requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">28.4</td><td align="left">Parallel algorithms</td><td align="left"> </td><td align="left">Using <a class="link" href="https://github.com/llvm/llvm-project/tree/main/pstl" target="_top">PSTL</a></td></tr><tr><td align="left">28.5</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.6</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.7</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.8</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
       <span class="emphasis"><em>29</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Numerics</em></span>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
index 0c3c23b4b31..148e3d452a4 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
@@ -1885,7 +1885,7 @@ since C++14 and the implementation is complete.
       <entry>28.4</entry>
       <entry>Parallel algorithms</entry>
       <entry/>
-      <entry>Using <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/intel/parallelstl">PSTL</link></entry>
+      <entry>Using <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/llvm/llvm-project/tree/main/pstl">PSTL</link></entry>
     </row>
     <row>
       <entry>28.5</entry>
diff --git a/libstdc++-v3/include/bits/alloc_traits.h b/libstdc++-v3/include/bits/alloc_traits.h
index 86d8ed221ff..4fcaa533f46 100644
--- a/libstdc++-v3/include/bits/alloc_traits.h
+++ b/libstdc++-v3/include/bits/alloc_traits.h
@@ -341,7 +341,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { __a.deallocate(__p, __n); }
 
       /**
-       *  @brief  Construct an object of type @a _Tp
+       *  @brief  Construct an object of type `_Tp`
        *  @param  __a  An allocator.
        *  @param  __p  Pointer to memory of suitable size and alignment for Tp
        *  @param  __args Constructor arguments.
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 41d5928e482..fe2a2453265 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -1695,7 +1695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #endif // C++2a
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/basic_ios.h b/libstdc++-v3/include/bits/basic_ios.h
index 2771756bbc9..5b23240573f 100644
--- a/libstdc++-v3/include/bits/basic_ios.h
+++ b/libstdc++-v3/include/bits/basic_ios.h
@@ -67,7 +67,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_ios : public ios_base
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -78,9 +78,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename _Traits::pos_type             pos_type;
       typedef typename _Traits::off_type             off_type;
       typedef _Traits                                traits_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These are non-standard types.
       */
@@ -89,7 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 						     __num_put_type;
       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 						     __num_get_type;
-      //@}
+      ///@}
 
       // Data members:
     protected:
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       const __num_get_type*                          _M_num_get;
 
     public:
-      //@{
+      ///@{
       /**
        *  @brief  The quick-and-easy status check.
        *
@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       operator!() const
       { return this->fail(); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns the error state of the stream buffer.
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 0b893bcea85..f36bd6a4fe6 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -4672,10 +4672,9 @@ _GLIBCXX_END_NAMESPACE_CXX11
 
       /**
        *  @brief  Insert a string_view.
-       *  @param __pos  Position in string to insert at.
-       *  @param __svt  The object convertible to string_view to insert from.
-       *  @param __pos  Position in string_view to insert
-       *  from.
+       *  @param __pos1  Position in string to insert at.
+       *  @param __svt   The object convertible to string_view to insert from.
+       *  @param __pos2  Position in string_view to insert from.
        *  @param __n    The number of characters to insert.
        *  @return  Reference to this string.
       */
diff --git a/libstdc++-v3/include/bits/forward_list.h b/libstdc++-v3/include/bits/forward_list.h
index 49b2a973718..fd08bb83f51 100644
--- a/libstdc++-v3/include/bits/forward_list.h
+++ b/libstdc++-v3/include/bits/forward_list.h
@@ -1152,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       splice_after(const_iterator __pos, forward_list&,
 		   const_iterator __before, const_iterator __last) noexcept
       { _M_splice_after(__pos, __before, __last); }
-      // @}
+      /// @}
 
     private:
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/include/bits/fs_dir.h b/libstdc++-v3/include/bits/fs_dir.h
index 686dfce6e5f..36a50c109c1 100644
--- a/libstdc++-v3/include/bits/fs_dir.h
+++ b/libstdc++-v3/include/bits/fs_dir.h
@@ -455,7 +455,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   inline directory_iterator
   end(directory_iterator) noexcept
   { return directory_iterator(); }
-  // @}
+  /// @}
 
   /// Iterator type for recursively traversing a directory hierarchy.
   class recursive_directory_iterator
@@ -553,11 +553,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   inline recursive_directory_iterator
   end(recursive_directory_iterator) noexcept
   { return recursive_directory_iterator(); }
-  // @}
+  /// @}
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
   // Use explicit instantiations of these types. Any inconsistency in the
diff --git a/libstdc++-v3/include/bits/fs_fwd.h b/libstdc++-v3/include/bits/fs_fwd.h
index d94cc414906..0f8fa92a39a 100644
--- a/libstdc++-v3/include/bits/fs_fwd.h
+++ b/libstdc++-v3/include/bits/fs_fwd.h
@@ -339,7 +339,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_symlink(file_status) noexcept;
 
 } // namespace filesystem
-// @}
+/// @}
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 #endif // C++17
diff --git a/libstdc++-v3/include/bits/fs_ops.h b/libstdc++-v3/include/bits/fs_ops.h
index 11efdcbb5ba..26a29b25de5 100644
--- a/libstdc++-v3/include/bits/fs_ops.h
+++ b/libstdc++-v3/include/bits/fs_ops.h
@@ -302,7 +302,7 @@ namespace filesystem
   path weakly_canonical(const path& __p);
   path weakly_canonical(const path& __p, error_code& __ec);
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 0b9911e638a..3d341916db5 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -1340,7 +1340,7 @@ namespace __detail
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem
+  /// @} group filesystem
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace filesystem
 
diff --git a/libstdc++-v3/include/bits/functional_hash.h b/libstdc++-v3/include/bits/functional_hash.h
index 6ca79154fe0..61dd9cc0c84 100644
--- a/libstdc++-v3/include/bits/functional_hash.h
+++ b/libstdc++-v3/include/bits/functional_hash.h
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #endif
 
-  // @} group hashes
+  /// @} group hashes
 
   // Hint about performance of hash functor. If not fast the hash-based
   // containers will cache the hash code.
diff --git a/libstdc++-v3/include/bits/gslice.h b/libstdc++-v3/include/bits/gslice.h
index b252c3c1f0f..a793ea774df 100644
--- a/libstdc++-v3/include/bits/gslice.h
+++ b/libstdc++-v3/include/bits/gslice.h
@@ -177,7 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     return *this;
   }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/gslice_array.h b/libstdc++-v3/include/bits/gslice_array.h
index 89fdda537a4..da60e3bf3c7 100644
--- a/libstdc++-v3/include/bits/gslice_array.h
+++ b/libstdc++-v3/include/bits/gslice_array.h
@@ -215,7 +215,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/hashtable.h b/libstdc++-v3/include/bits/hashtable.h
index b00319a668b..310eb52dd51 100644
--- a/libstdc++-v3/include/bits/hashtable.h
+++ b/libstdc++-v3/include/bits/hashtable.h
@@ -446,6 +446,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__hashtable_alloc(__node_alloc_type(__a))
       { }
 
+      template<bool _No_realloc = true>
+	static constexpr bool
+	_S_nothrow_move()
+	{
+#if __cplusplus <= 201402L
+	  return __and_<__bool_constant<_No_realloc>,
+			is_nothrow_copy_constructible<_H1>,
+			is_nothrow_copy_constructible<_Equal>>::value;
+#else
+	  if constexpr (_No_realloc)
+	    if constexpr (is_nothrow_copy_constructible<_H1>())
+	      return is_nothrow_copy_constructible<_Equal>();
+	  return false;
+#endif
+	}
+
+      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+		 true_type /* alloc always equal */)
+	noexcept(_S_nothrow_move());
+
+      _Hashtable(_Hashtable&&, __node_alloc_type&&,
+		 false_type /* alloc always equal */);
+
+
     public:
       // Constructor, destructor, assignment, swap
       _Hashtable() = default;
@@ -463,11 +487,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _Hashtable(const _Hashtable&);
 
-      _Hashtable(_Hashtable&&) noexcept;
+      _Hashtable(_Hashtable&& __ht)
+	noexcept(_S_nothrow_move())
+      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
+		   true_type{})
+      { }
 
       _Hashtable(const _Hashtable&, const allocator_type&);
 
-      _Hashtable(_Hashtable&&, const allocator_type&);
+      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+	noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
+      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
+		   typename __node_alloc_traits::is_always_equal{})
+      { }
 
       // Use delegating constructors.
       explicit
@@ -1285,18 +1317,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht) noexcept
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       true_type /* alloc always equal */)
+    noexcept(_S_nothrow_move())
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(std::move(__ht._M_base_alloc())),
+      __hashtable_alloc(std::move(__a)),
       _M_buckets(__ht._M_buckets),
       _M_bucket_count(__ht._M_bucket_count),
       _M_before_begin(__ht._M_before_begin._M_nxt),
       _M_element_count(__ht._M_element_count),
       _M_rehash_policy(__ht._M_rehash_policy)
     {
-      // Update, if necessary, buckets if __ht is using its single bucket.
+      // Update buckets if __ht is using its single bucket.
       if (__ht._M_uses_single_bucket())
 	{
 	  _M_buckets = &_M_single_bucket;
@@ -1337,11 +1371,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       false_type /* alloc always equal */)
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(__node_alloc_type(__a)),
+      __hashtable_alloc(std::move(__a)),
       _M_buckets(nullptr),
       _M_bucket_count(__ht._M_bucket_count),
       _M_element_count(__ht._M_element_count),
diff --git a/libstdc++-v3/include/bits/hashtable_policy.h b/libstdc++-v3/include/bits/hashtable_policy.h
index ef120134914..d34fc39a973 100644
--- a/libstdc++-v3/include/bits/hashtable_policy.h
+++ b/libstdc++-v3/include/bits/hashtable_policy.h
@@ -2099,7 +2099,7 @@ namespace __detail
       __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
     }
 
- //@} hashtable-detail
+ ///@} hashtable-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/indirect_array.h b/libstdc++-v3/include/bits/indirect_array.h
index 11fac329036..9d75219a741 100644
--- a/libstdc++-v3/include/bits/indirect_array.h
+++ b/libstdc++-v3/include/bits/indirect_array.h
@@ -204,7 +204,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/iterator_concepts.h b/libstdc++-v3/include/bits/iterator_concepts.h
index e2ad37179be..4f118df6b02 100644
--- a/libstdc++-v3/include/bits/iterator_concepts.h
+++ b/libstdc++-v3/include/bits/iterator_concepts.h
@@ -220,6 +220,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Tp> requires is_object_v<_Tp>
       struct __cond_value_type<_Tp>
       { using value_type = remove_cv_t<_Tp>; };
+
+    template<typename _Tp>
+      concept __has_member_value_type
+	= requires { typename _Tp::value_type; };
+
+    template<typename _Tp>
+      concept __has_member_element_type
+	= requires { typename _Tp::element_type; };
+
   } // namespace __detail
 
   template<typename> struct indirectly_readable_traits { };
@@ -238,16 +247,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : indirectly_readable_traits<_Iter>
     { };
 
-  template<typename _Tp> requires requires { typename _Tp::value_type; }
+  template<__detail::__has_member_value_type _Tp>
     struct indirectly_readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::value_type>
     { };
 
-  template<typename _Tp> requires requires { typename _Tp::element_type; }
+  template<__detail::__has_member_element_type _Tp>
     struct indirectly_readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::element_type>
     { };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3446. indirectly_readable_traits ambiguity for types with both [...]
+  template<__detail::__has_member_value_type _Tp>
+    requires __detail::__has_member_element_type<_Tp>
+    && same_as<remove_cv_t<typename _Tp::element_type>,
+	       remove_cv_t<typename _Tp::value_type>>
+    struct indirectly_readable_traits<_Tp>
+    : __detail::__cond_value_type<typename _Tp::value_type>
+    { };
+
+  // LWG 3446 doesn't add this, but it's needed for the case where
+  // value_type and element_type are both present, but not the same type.
+  template<__detail::__has_member_value_type _Tp>
+    requires __detail::__has_member_element_type<_Tp>
+    struct indirectly_readable_traits<_Tp>
+    { };
+
   namespace __detail
   {
     template<typename _Tp>
diff --git a/libstdc++-v3/include/bits/locale_classes.h b/libstdc++-v3/include/bits/locale_classes.h
index ab90682cde2..dc446d71907 100644
--- a/libstdc++-v3/include/bits/locale_classes.h
+++ b/libstdc++-v3/include/bits/locale_classes.h
@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Cache>
       friend struct __use_cache;
 
-    //@{
+    ///@{
     /**
      *  @brief  Category values.
      *
@@ -104,7 +104,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     static const category messages	= 1L << 5;
     static const category all		= (ctype | numeric | collate |
 					   time  | monetary | messages);
-    //@}
+    ///@}
 
     // Construct/copy/destroy:
 
@@ -645,11 +645,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
@@ -818,11 +818,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate<_CharT>
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT               char_type;
       typedef basic_string<_CharT> string_type;
-      //@}
+      ///@}
 
       explicit
       collate_byname(const char* __s, size_t __refs = 0)
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index 3e0ae8776c9..7b9a1208798 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -1671,11 +1671,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __numpunct_cache<_CharT>  __cache_type;
 
     protected:
@@ -1953,11 +1953,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -2000,7 +2000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, bool& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2063,9 +2063,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, unsigned long long& __v)  const
       { return this->do_get(__in, __end, __io, __err, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2106,7 +2106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       get(iter_type __in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long double& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric parsing.
@@ -2193,7 +2193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  return __ret;
 	}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2270,7 +2270,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
 	     long double&) const;
 #endif
-      //@}
+      ///@}
     };
 
   template<typename _CharT, typename _InIter>
@@ -2294,11 +2294,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT		char_type;
       typedef _OutIter		iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id		id;
@@ -2332,7 +2332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2389,9 +2389,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  unsigned long long __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2441,7 +2441,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill,
 	  long double __v) const
       { return this->do_put(__s, __io, __fill, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric formatting.
@@ -2492,7 +2492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual
       ~num_put() { }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2550,7 +2550,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual iter_type
       do_put(iter_type, ios_base&, char_type, long double) const;
 #endif
-      //@}
+      ///@}
     };
 
   template <typename _CharT, typename _OutIter>
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.h b/libstdc++-v3/include/bits/locale_facets_nonio.h
index b76eac435bd..a8dbce2eb9c 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.h
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.h
@@ -369,11 +369,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -798,11 +798,11 @@ _GLIBCXX_END_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1025,11 +1025,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __moneypunct_cache<_CharT, _Intl>     __cache_type;
 
     private:
@@ -1201,7 +1201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       frac_digits() const
       { return this->do_frac_digits(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Return pattern for money values.
        *
@@ -1240,7 +1240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       pattern
       neg_format() const
       { return this->do_neg_format(); }
-      //@}
+      ///@}
 
     protected:
       /// Destructor.
@@ -1469,12 +1469,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1621,12 +1621,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     class money_put : public locale::facet
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1800,11 +1800,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
diff --git a/libstdc++-v3/include/bits/mask_array.h b/libstdc++-v3/include/bits/mask_array.h
index 579cd59e59a..845a1d6570a 100644
--- a/libstdc++-v3/include/bits/mask_array.h
+++ b/libstdc++-v3/include/bits/mask_array.h
@@ -205,7 +205,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
index cba11299360..2bcac1b41b1 100644
--- a/libstdc++-v3/include/bits/random.h
+++ b/libstdc++-v3/include/bits/random.h
@@ -1673,7 +1673,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
   };
 
-  /* @} */ // group random_generators
+  /// @} group random_generators
 
   /**
    * @addtogroup random_distributions Random Number Distributions
@@ -1949,7 +1949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator>>(std::basic_istream<_CharT, _Traits>&,
 	       std::uniform_real_distribution<_RealType>&);
 
-  /* @} */ // group random_distributions_uniform
+  /// @} group random_distributions_uniform
 
   /**
    * @addtogroup random_distributions_normal Normal Distributions
@@ -3504,7 +3504,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_normal
+  /// @} group random_distributions_normal
 
   /**
    * @addtogroup random_distributions_bernoulli Bernoulli Distributions
@@ -4400,7 +4400,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_bernoulli
+  /// @} group random_distributions_bernoulli
 
   /**
    * @addtogroup random_distributions_poisson Poisson Distributions
@@ -6046,9 +6046,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_poisson
+  /// @} group random_distributions_poisson
 
-  /* @} */ // group random_distributions
+  /// @} *group random_distributions
 
   /**
    * @addtogroup random_utilities Random Number Utilities
@@ -6099,9 +6099,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     std::vector<result_type> _M_v;
   };
 
-  /* @} */ // group random_utilities
+  /// @} group random_utilities
 
-  /* @} */ // group random
+  /// @} group random
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/refwrap.h b/libstdc++-v3/include/bits/refwrap.h
index 717aa01629c..4b84ac7f039 100644
--- a/libstdc++-v3/include/bits/refwrap.h
+++ b/libstdc++-v3/include/bits/refwrap.h
@@ -391,7 +391,7 @@ _GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)
     cref(reference_wrapper<_Tp> __t) noexcept
     { return { __t.get() }; }
 
-  // @}
+  /// @}
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 4032fd7559b..aa442e17656 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -402,7 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @name Constants
        * std [28.8.1](1)
        */
-      //@{
+      ///@{
       static constexpr flag_type icase = regex_constants::icase;
       static constexpr flag_type nosubs = regex_constants::nosubs;
       static constexpr flag_type optimize = regex_constants::optimize;
@@ -413,7 +413,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       static constexpr flag_type awk = regex_constants::awk;
       static constexpr flag_type grep = regex_constants::grep;
       static constexpr flag_type egrep = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -915,9 +915,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *
        * @param __s Another matched sequence to compare to this one.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const sub_match& __s) const
@@ -925,13 +925,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
       /**
        * @{
-       * @brief Compares this sub_match to a string.
+       * @brief Compares this `sub_match` to a string.
        *
-       * @param __s A string to compare to this sub_match.
+       * @param __s A string to compare to this `sub_match`.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const string_type& __s) const
@@ -940,7 +940,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       int
       compare(const value_type* __s) const
       { return this->_M_str().compare(__s); }
-      // @}
+      /// @}
 
       /// @cond undocumented
       // Non-standard, used by comparison operators
@@ -1648,7 +1648,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	       const sub_match<_Bi_iter>& __m)
     { return __os << __m.str(); }
 
-  // @} relates sub_match
+  /// @} relates sub_match
 
   // [7.10] Class template match_results
 
@@ -1702,7 +1702,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 28.10 Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>			   value_type;
       typedef const value_type&				   const_reference;
       typedef value_type&				   reference;
@@ -1713,13 +1713,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       typedef _Alloc					   allocator_type;
       typedef typename __iter_traits::value_type 	   char_type;
       typedef std::basic_string<char_type>		   string_type;
-      //@}
+      ///@}
 
     public:
       /**
        * @name 28.10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1763,7 +1763,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       ~match_results() = default;
 
-      //@}
+      ///@}
 
       // 28.10.2, state:
       /**
@@ -1776,7 +1776,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 28.10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1804,12 +1804,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       empty() const noexcept
       { return size() == 0; }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.4 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1929,7 +1929,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       cend() const noexcept
       { return this->end(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.5 Formatting
@@ -1939,7 +1939,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * escape sequences accepted by these functions are determined by
        * their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @pre   ready() == true
@@ -1990,12 +1990,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	return __result;
       }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.6 Allocator
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -2004,12 +2004,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       get_allocator() const noexcept
       { return _Base_type::get_allocator(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 28.10.7 Swap
        */
-       //@{
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -2021,7 +2021,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	_Base_type::swap(__that);
 	swap(_M_begin, __that._M_begin);
       }
-      //@}
+      ///@}
 
     private:
       template<typename, typename, typename>
@@ -2148,7 +2148,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2610,7 +2610,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       return __result;
     }
 
-  //@}
+  ///@}
 
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
@@ -2973,7 +2973,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
 
-  //@} // group regex
+  ///@} // group regex
 
 _GLIBCXX_END_NAMESPACE_CXX11
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index d1ef05d1477..b7165f19cec 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -392,7 +392,7 @@ namespace __detail
       _StateIdT _M_end;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_compiler.h b/libstdc++-v3/include/bits/regex_compiler.h
index e68c4184c5a..809ae419f5e 100644
--- a/libstdc++-v3/include/bits/regex_compiler.h
+++ b/libstdc++-v3/include/bits/regex_compiler.h
@@ -552,7 +552,7 @@ namespace __detail
 #endif
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_constants.h b/libstdc++-v3/include/bits/regex_constants.h
index 5f096ac6226..2926bec42ba 100644
--- a/libstdc++-v3/include/bits/regex_constants.h
+++ b/libstdc++-v3/include/bits/regex_constants.h
@@ -50,7 +50,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
   {
     _S_icase,
@@ -216,7 +216,7 @@ namespace regex_constants
   operator^=(syntax_option_type& __a, syntax_option_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -227,7 +227,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
   {
@@ -407,9 +407,9 @@ namespace regex_constants
   operator^=(match_flag_type& __a, match_flag_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 } // namespace regex_constants
-/* @} */ // group regex
+/// @} group regex
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_error.h b/libstdc++-v3/include/bits/regex_error.h
index 09e9288788c..b150002ceff 100644
--- a/libstdc++-v3/include/bits/regex_error.h
+++ b/libstdc++-v3/include/bits/regex_error.h
@@ -44,7 +44,7 @@ namespace regex_constants
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
 
   enum error_type
     {
@@ -119,7 +119,7 @@ namespace regex_constants
    */
   constexpr error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 } // namespace regex_constants
 
   // [7.8] Class regex_error
@@ -161,7 +161,7 @@ namespace regex_constants
     friend void __throw_regex_error(regex_constants::error_type, const char*);
   };
 
-  //@} // group regex
+  ///@} // group regex
 
   void
   __throw_regex_error(regex_constants::error_type __ecode);
diff --git a/libstdc++-v3/include/bits/regex_executor.h b/libstdc++-v3/include/bits/regex_executor.h
index b66c1280454..599928d79a7 100644
--- a/libstdc++-v3/include/bits/regex_executor.h
+++ b/libstdc++-v3/include/bits/regex_executor.h
@@ -250,7 +250,7 @@ namespace __detail
       bool                                                  _M_has_sol;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index 0fc3ed41078..93ef4c66f38 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -264,7 +264,7 @@ namespace __detail
       void (_Scanner::* _M_eat_escape)();
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 0c393e23132..0baec4e0882 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -661,7 +661,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // C++20
 #endif // C++17
 
-  // @}
+  /// @}
 
   /**
    * @brief  A non-owning observer for a pointer owned by a shared_ptr
@@ -888,8 +888,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
-  // @} relates shared_ptr
-  // @} group pointer_abstractions
+  /// @} relates shared_ptr
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/shared_ptr_atomic.h b/libstdc++-v3/include/bits/shared_ptr_atomic.h
index 13eb7f44a82..ce2e260702d 100644
--- a/libstdc++-v3/include/bits/shared_ptr_atomic.h
+++ b/libstdc++-v3/include/bits/shared_ptr_atomic.h
@@ -87,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     atomic_is_lock_free(const shared_ptr<_Tp>* __p)
     { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
 
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic load for shared_ptr objects.
@@ -123,7 +123,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
     { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic store for shared_ptr objects.
@@ -162,7 +162,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline void
     atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
     { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic exchange for shared_ptr objects.
@@ -207,7 +207,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_exchange_explicit(__p, std::move(__r),
 					   memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic compare-and-swap for shared_ptr objects.
@@ -325,10 +325,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_compare_exchange_weak_explicit(__p, __v,
 	  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
-  // @} relates shared_ptr
-  // @} group pointer_abstractions
+  /// @} relates shared_ptr
+  /// @} group pointer_abstractions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index ff578e66117..f0232c36be9 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1362,7 +1362,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	bool
 	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
-      // @}
+      /// @}
 
     protected:
       // This constructor is non-standard, it is used by allocate_shared.
diff --git a/libstdc++-v3/include/bits/slice_array.h b/libstdc++-v3/include/bits/slice_array.h
index de33342e252..d875fc225b3 100644
--- a/libstdc++-v3/include/bits/slice_array.h
+++ b/libstdc++-v3/include/bits/slice_array.h
@@ -276,7 +276,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/specfun.h b/libstdc++-v3/include/bits/specfun.h
index f85d15d4d46..60cba06d011 100644
--- a/libstdc++-v3/include/bits/specfun.h
+++ b/libstdc++-v3/include/bits/specfun.h
@@ -1196,7 +1196,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  // @} group mathsf
+  /// @} group mathsf
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
@@ -1380,7 +1380,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
     }
 
-  // @}
+  /// @}
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace __gnu_cxx
 #endif // __STRICT_ANSI__
diff --git a/libstdc++-v3/include/bits/std_function.h b/libstdc++-v3/include/bits/std_function.h
index e2bf9b91850..8c5aba56787 100644
--- a/libstdc++-v3/include/bits/std_function.h
+++ b/libstdc++-v3/include/bits/std_function.h
@@ -537,7 +537,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Functor>       _Functor* target() noexcept;
 
       template<typename _Functor> const _Functor* target() const noexcept;
-      // @}
+      /// @}
 #endif
 
     private:
diff --git a/libstdc++-v3/include/bits/std_mutex.h b/libstdc++-v3/include/bits/std_mutex.h
index 56c853a3fdc..2e92a1a40d3 100644
--- a/libstdc++-v3/include/bits/std_mutex.h
+++ b/libstdc++-v3/include/bits/std_mutex.h
@@ -171,7 +171,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       mutex_type&  _M_device;
     };
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 #endif // C++11
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 3959dd7899d..2d7f7e11b3f 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -1836,7 +1836,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       }
 
       // called by the second initialize_dispatch above
-      //@{
+      ///@{
       /**
        *  @brief Fills the deque with whatever is in [first,last).
        *  @param  __first  An input iterator.
@@ -1857,7 +1857,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	void
 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
 			    std::forward_iterator_tag);
-      //@}
+      ///@}
 
       /**
        *  @brief Fills the %deque with copies of value.
@@ -1941,7 +1941,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  }
       }
 
-      //@{
+      ///@{
       /// Helper functions for push_* and pop_*.
 #if __cplusplus < 201103L
       void _M_push_back_aux(const value_type&);
@@ -1958,7 +1958,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       void _M_pop_back_aux();
 
       void _M_pop_front_aux();
-      //@}
+      ///@}
 
       // Internal insert functions follow.  The *_aux functions do the actual
       // insertion work when all shortcuts fail.
@@ -2081,7 +2081,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _M_shrink_to_fit();
 #endif
 
-      //@{
+      ///@{
       /// Memory-handling helpers for the previous internal insert functions.
       iterator
       _M_reserve_elements_at_front(size_type __n)
@@ -2108,10 +2108,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_new_elements_at_back(size_type __new_elements);
-      //@}
+      ///@}
 
 
-      //@{
+      ///@{
       /**
        *  @brief Memory-handling helpers for the major %map.
        *
@@ -2137,7 +2137,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
-      //@}
+      ///@}
 
 #if __cplusplus >= 201103L
       // Constant-time, nothrow move assignment when source object's memory
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index d950e896928..49c9a5c17d2 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -369,7 +369,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         { return __t.operator->(); }
     };
 
-  //@{
+  ///@{
   /**
    *  @param  __x  A %reverse_iterator.
    *  @param  __y  A %reverse_iterator.
@@ -503,7 +503,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
 #endif // C++20
-  //@}
+  ///@}
 
 #if __cplusplus < 201103L
   template<typename _Iterator>
@@ -932,7 +932,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return insert_iterator<_Container>(__x, __i); }
 #endif
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -2183,7 +2183,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #endif // C++20
 
-  // @} group iterators
+  /// @} group iterators
 
   template<typename _Iterator>
     auto
diff --git a/libstdc++-v3/include/bits/stl_iterator_base_types.h b/libstdc++-v3/include/bits/stl_iterator_base_types.h
index aa02af59dc6..09279976bd6 100644
--- a/libstdc++-v3/include/bits/stl_iterator_base_types.h
+++ b/libstdc++-v3/include/bits/stl_iterator_base_types.h
@@ -79,7 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @defgroup iterators Iterators
    *  Abstractions for uniform iterating through various underlying types.
   */
-  //@{ 
+  ///@{
 
   /**
    *  @defgroup iterator_tags Iterator Tags
@@ -88,7 +88,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  are.  Different underlying algorithms can then be used based on the
    *  different operations supported by different iterator types.
   */
-  //@{ 
+  ///@{
   ///  Marking input iterators.
   struct input_iterator_tag { };
 
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// Contiguous iterators point to objects stored contiguously in memory.
   struct contiguous_iterator_tag : public random_access_iterator_tag { };
 #endif
-  //@}
+  ///@}
 
   /**
    *  @brief  Common %iterator class.
@@ -238,7 +238,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __iterator_category(const _Iter&)
     { return typename iterator_traits<_Iter>::iterator_category(); }
 
-  //@}
+  ///@}
 
 #if __cplusplus >= 201103L
   template<typename _Iter>
diff --git a/libstdc++-v3/include/bits/stl_map.h b/libstdc++-v3/include/bits/stl_map.h
index 2772d11462e..0bf9333fe62 100644
--- a/libstdc++-v3/include/bits/stl_map.h
+++ b/libstdc++-v3/include/bits/stl_map.h
@@ -816,7 +816,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
 #if __cplusplus >= 201103L
       /**
@@ -878,7 +878,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					     std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Template function that attempts to insert a range of elements.
@@ -1036,7 +1036,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %map.
@@ -1152,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // [23.3.1.3] map operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1175,9 +1175,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1200,9 +1200,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1221,10 +1221,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1239,10 +1239,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1265,9 +1265,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1290,9 +1290,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1310,9 +1310,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1330,9 +1330,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1359,9 +1359,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1392,7 +1392,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multimap.h b/libstdc++-v3/include/bits/stl_multimap.h
index 65f4d0117a4..38164810523 100644
--- a/libstdc++-v3/include/bits/stl_multimap.h
+++ b/libstdc++-v3/include/bits/stl_multimap.h
@@ -551,7 +551,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Inserts a std::pair into the %multimap.
@@ -597,7 +597,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					    std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief A template function that attempts to insert a range
@@ -707,7 +707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %multimap.
@@ -827,7 +827,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multimap operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -849,9 +849,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -873,9 +873,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -891,10 +891,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -909,10 +909,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -935,9 +935,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -960,9 +960,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -980,9 +980,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1000,9 +1000,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1027,9 +1027,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1058,7 +1058,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multiset.h b/libstdc++-v3/include/bits/stl_multiset.h
index bf6ae7de095..a0e635e00dc 100644
--- a/libstdc++-v3/include/bits/stl_multiset.h
+++ b/libstdc++-v3/include/bits/stl_multiset.h
@@ -720,7 +720,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multiset operations:
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of elements to be located.
@@ -736,10 +736,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -754,12 +754,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -792,9 +792,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -827,9 +827,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -857,9 +857,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -896,7 +896,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_numeric.h b/libstdc++-v3/include/bits/stl_numeric.h
index f95c86a0d48..06cb1ce5259 100644
--- a/libstdc++-v3/include/bits/stl_numeric.h
+++ b/libstdc++-v3/include/bits/stl_numeric.h
@@ -403,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       return ++__result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 #undef _GLIBCXX_MOVE_IF_20
 
diff --git a/libstdc++-v3/include/bits/stl_pair.h b/libstdc++-v3/include/bits/stl_pair.h
index 491c599076e..053c4236ace 100644
--- a/libstdc++-v3/include/bits/stl_pair.h
+++ b/libstdc++-v3/include/bits/stl_pair.h
@@ -542,7 +542,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 #endif // __cplusplus >= 201103L
 
-  // @} relates pair
+  /// @} relates pair
 
   /**
    *  @brief A convenience wrapper for creating a pair from two objects.
diff --git a/libstdc++-v3/include/bits/stl_set.h b/libstdc++-v3/include/bits/stl_set.h
index da426650815..246c47a110a 100644
--- a/libstdc++-v3/include/bits/stl_set.h
+++ b/libstdc++-v3/include/bits/stl_set.h
@@ -115,14 +115,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef _Key     key_type;
       typedef _Key     value_type;
       typedef _Compare key_compare;
       typedef _Compare value_compare;
       typedef _Alloc   allocator_type;
-      //@}
+      ///@}
 
     private:
       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
@@ -135,7 +135,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
 
     public:
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Alloc_traits::pointer		 pointer;
       typedef typename _Alloc_traits::const_pointer	 const_pointer;
@@ -150,7 +150,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
       typedef typename _Rep_type::size_type		 size_type;
       typedef typename _Rep_type::difference_type	 difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Rep_type::node_type;
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // set operations:
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements.
        *  @param  __x  Element to located.
@@ -755,10 +755,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -773,12 +773,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -811,9 +811,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -846,9 +846,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -876,9 +876,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -915,7 +915,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_tree.h b/libstdc++-v3/include/bits/stl_tree.h
index 5be15afa257..21b72cebf2e 100644
--- a/libstdc++-v3/include/bits/stl_tree.h
+++ b/libstdc++-v3/include/bits/stl_tree.h
@@ -698,7 +698,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  : _Node_allocator(__a), _Base_key_compare(__comp)
 	  { }
 #else
-	  _Rb_tree_impl(_Rb_tree_impl&&) = default;
+	  _Rb_tree_impl(_Rb_tree_impl&&)
+	    noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+	  = default;
 
 	  explicit
 	  _Rb_tree_impl(_Node_allocator&& __a)
diff --git a/libstdc++-v3/include/bits/stl_uninitialized.h b/libstdc++-v3/include/bits/stl_uninitialized.h
index 3109a89462d..5f75f69d3a2 100644
--- a/libstdc++-v3/include/bits/stl_uninitialized.h
+++ b/libstdc++-v3/include/bits/stl_uninitialized.h
@@ -1033,7 +1033,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// @endcond
 #endif
 
-  // @} group memory
+  /// @} group memory
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/stream_iterator.h b/libstdc++-v3/include/bits/stream_iterator.h
index bd5ba2a80c0..f53cadf5c24 100644
--- a/libstdc++-v3/include/bits/stream_iterator.h
+++ b/libstdc++-v3/include/bits/stream_iterator.h
@@ -177,7 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : public iterator<output_iterator_tag, void, void, void, void>
     {
     public:
-      //@{
+      ///@{
       /// Public typedef
 #if __cplusplus > 201703L
       using difference_type = ptrdiff_t;
@@ -185,7 +185,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef basic_ostream<_CharT, _Traits> ostream_type;
-      //@}
+      ///@}
 
     private:
       ostream_type*	_M_stream;
@@ -249,7 +249,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return *this; }
     };
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/streambuf_iterator.h b/libstdc++-v3/include/bits/streambuf_iterator.h
index d3f1610fc8d..d77ecc5f9cb 100644
--- a/libstdc++-v3/include/bits/streambuf_iterator.h
+++ b/libstdc++-v3/include/bits/streambuf_iterator.h
@@ -53,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
 #if __cplusplus < 201103L
       typedef _CharT& reference; // Changed to _CharT by LWG 445
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename _Traits::int_type		int_type;
       typedef basic_streambuf<_CharT, _Traits>		streambuf_type;
       typedef basic_istream<_CharT, _Traits>		istream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -241,7 +241,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
 #if __cplusplus > 201703L
       using difference_type = ptrdiff_t;
@@ -250,7 +250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef _Traits			       traits_type;
       typedef basic_streambuf<_CharT, _Traits> streambuf_type;
       typedef basic_ostream<_CharT, _Traits>   ostream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -499,7 +499,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __i._M_c = __eof;
     }
 
-// @} group iterators
+/// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
index d0e4cefadd7..05fe652cf36 100644
--- a/libstdc++-v3/include/bits/unique_ptr.h
+++ b/libstdc++-v3/include/bits/unique_ptr.h
@@ -906,7 +906,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return compare_three_way()(__x.get(), static_cast<pointer>(nullptr));
     }
 #endif
-  // @} relates unique_ptr
+  /// @} relates unique_ptr
 
   /// @cond undocumented
   template<typename _Up, typename _Ptr = typename _Up::pointer,
@@ -971,7 +971,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Tp, typename... _Args>
     inline typename _MakeUniq<_Tp>::__invalid_type
     make_unique(_Args&&...) = delete;
-  // @} relates unique_ptr
+  /// @} relates unique_ptr
 #endif // C++14
 
 #if __cplusplus > 201703L && __cpp_concepts
@@ -989,7 +989,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 #endif // C++20
 
-  // @} group pointer_abstractions
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/unordered_map.h b/libstdc++-v3/include/bits/unordered_map.h
index 0071d62e462..d75e89240c4 100644
--- a/libstdc++-v3/include/bits/unordered_map.h
+++ b/libstdc++-v3/include/bits/unordered_map.h
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -114,9 +114,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -128,7 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -209,6 +209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )
       : _M_h(std::move(__umap._M_h), __a)
       { }
 
@@ -324,7 +325,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_map.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -346,7 +347,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_map.
@@ -358,7 +359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -557,7 +558,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
 
@@ -590,9 +591,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 		      pair<iterator, bool>>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -628,7 +629,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
 	{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -773,7 +774,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_map.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -795,7 +796,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -903,7 +904,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_map.
        *  @param  __x  Key to be located.
@@ -922,7 +923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -948,7 +949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -964,9 +965,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Subscript ( @c [] ) access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -986,9 +987,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       mapped_type&
       operator[](key_type&& __k)
       { return _M_h[std::move(__k)]; }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -1003,7 +1004,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const mapped_type&
       at(const key_type& __k) const
       { return _M_h.at(__k); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1045,7 +1046,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1059,7 +1060,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1071,7 +1072,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1085,7 +1086,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -1253,7 +1254,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -1261,9 +1262,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -1275,7 +1276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1355,6 +1356,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multimap(unordered_multimap&& __ummap,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )
       : _M_h(std::move(__ummap._M_h), __a)
       { }
 
@@ -1470,7 +1472,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multimap.
@@ -1482,7 +1484,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -1492,7 +1494,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multimap.
@@ -1504,7 +1506,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -1555,7 +1557,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param __x Pair to be inserted (see std::make_pair for easy
@@ -1577,9 +1579,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1613,7 +1615,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
         { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -1666,7 +1668,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multimap.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1688,7 +1690,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -1798,7 +1800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multimap.
        *  @param  __x  Key to be located.
@@ -1817,7 +1819,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1839,7 +1841,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1853,7 +1855,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1895,7 +1897,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1909,7 +1911,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1921,7 +1923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1935,7 +1937,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/bits/unordered_set.h b/libstdc++-v3/include/bits/unordered_set.h
index c9c9e9f38b7..c942978557d 100644
--- a/libstdc++-v3/include/bits/unordered_set.h
+++ b/libstdc++-v3/include/bits/unordered_set.h
@@ -101,16 +101,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -203,6 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )
       : _M_h(std::move(__uset._M_h), __a)
       { }
 
@@ -310,7 +311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_set.
@@ -322,9 +323,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_set.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -402,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __x  Element to be inserted.
@@ -423,9 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<iterator, bool>
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -452,7 +453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -504,7 +505,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node(std::move(__nh)).position; }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_set.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -526,7 +527,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -633,7 +634,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_set.
        *  @param  __x  Element to be located.
@@ -652,7 +653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -678,7 +679,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -694,7 +695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -726,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -744,9 +745,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -764,7 +765,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -916,16 +917,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -937,7 +938,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1044,6 +1045,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multiset(unordered_multiset&& __umset,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )
       : _M_h(std::move(__umset._M_h), __a)
       { }
 
@@ -1124,7 +1126,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multiset.
@@ -1136,9 +1138,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multiset.
@@ -1150,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -1204,7 +1206,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __x  Element to be inserted.
@@ -1219,9 +1221,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1245,7 +1247,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that inserts a range of elements.
@@ -1296,7 +1298,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multiset.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1319,7 +1321,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
 
       /**
@@ -1432,7 +1434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multiset.
        *  @param  __x  Element to be located.
@@ -1451,7 +1453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1473,7 +1475,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1487,7 +1489,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1519,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1537,9 +1539,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1557,7 +1559,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/debug/helper_functions.h b/libstdc++-v3/include/debug/helper_functions.h
index 62d5309257f..9e2d206f06c 100644
--- a/libstdc++-v3/include/debug/helper_functions.h
+++ b/libstdc++-v3/include/debug/helper_functions.h
@@ -64,7 +64,7 @@ namespace __gnu_debug
     {
     private:
       typedef
-      typename std::iterator_traits<_Iterator>::difference_type _ItDiffType;
+	typename std::iterator_traits<_Iterator>::difference_type _ItDiffType;
 
       template<typename _DiffType,
 	       typename = typename std::__is_void<_DiffType>::__type>
@@ -287,6 +287,18 @@ namespace __gnu_debug
     __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>&,
 		  _Size);
 
+  template<typename _InputIterator, typename _Diff>
+    _GLIBCXX_CONSTEXPR
+    inline bool
+    __can_advance(_InputIterator, const std::pair<_Diff, _Distance_precision>&, int)
+    { return true; }
+
+  template<typename _Iterator, typename _Sequence, typename _Category,
+	   typename _Diff>
+    bool
+    __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>&,
+		  const std::pair<_Diff, _Distance_precision>&, int);
+
   /** Helper function to extract base iterator of random access safe iterator
    *  in order to reduce performance impact of debug mode.  Limited to random
    *  access iterator because it is the only category for which it is possible
diff --git a/libstdc++-v3/include/debug/macros.h b/libstdc++-v3/include/debug/macros.h
index 73fb50d0cbd..1f45f8e0adc 100644
--- a/libstdc++-v3/include/debug/macros.h
+++ b/libstdc++-v3/include/debug/macros.h
@@ -104,6 +104,12 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 		      ._M_iterator(_First, #_First)			\
 		      ._M_integer(_Size, #_Size))
 
+#define __glibcxx_check_can_increment_dist(_First,_Dist,_Way)		\
+  _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Dist, _Way), \
+		      _M_message(__gnu_debug::__msg_iter_subscript_oob)	\
+		      ._M_iterator(_First, #_First)			\
+		      ._M_integer(_Way * _Dist.first, #_Dist))
+
 #define __glibcxx_check_can_increment_range(_First1,_Last1,_First2)	\
   do									\
   {									\
@@ -115,7 +121,7 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 			._M_iterator(_Last1, #_Last1),			\
 			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
     _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
-			__gnu_debug::__can_advance(_First2, __dist.first),\
+			__gnu_debug::__can_advance(_First2, __dist, 1), \
 			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
 			._M_iterator(_First2, #_First2)			\
 			._M_integer(__dist.first),			\
@@ -133,7 +139,7 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
 			._M_iterator(_Last1, #_Last1),			\
 			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
     _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
-			__gnu_debug::__can_advance(_First2, -__dist.first),\
+			__gnu_debug::__can_advance(_First2, __dist, -1), \
 			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
 			._M_iterator(_First2, #_First2)			\
 			._M_integer(-__dist.first),			\
diff --git a/libstdc++-v3/include/debug/safe_iterator.h b/libstdc++-v3/include/debug/safe_iterator.h
index 687b844fd75..2f51618dd88 100644
--- a/libstdc++-v3/include/debug/safe_iterator.h
+++ b/libstdc++-v3/include/debug/safe_iterator.h
@@ -405,6 +405,12 @@ namespace __gnu_debug
       bool
       _M_can_advance(difference_type __n, bool __strict = false) const;
 
+      // Can we advance the iterator using @p __dist in @p __way direction.
+      template<typename _Diff>
+	bool
+	_M_can_advance(const std::pair<_Diff, _Distance_precision>& __dist,
+		       int __way) const;
+
       // Is the iterator range [*this, __rhs) valid?
       bool
       _M_valid_range(const _Safe_iterator& __rhs,
@@ -956,6 +962,14 @@ namespace __gnu_debug
 		  _Size __n)
     { return __it._M_can_advance(__n); }
 
+  template<typename _Iterator, typename _Sequence, typename _Category,
+	   typename _Diff>
+    inline bool
+    __can_advance(const _Safe_iterator<_Iterator, _Sequence, _Category>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __it._M_can_advance(__dist, __way); }
+
   template<typename _Iterator, typename _Sequence>
     _Iterator
     __base(const _Safe_iterator<_Iterator, _Sequence,
diff --git a/libstdc++-v3/include/debug/safe_iterator.tcc b/libstdc++-v3/include/debug/safe_iterator.tcc
index 312a88911ee..79a8ee28d97 100644
--- a/libstdc++-v3/include/debug/safe_iterator.tcc
+++ b/libstdc++-v3/include/debug/safe_iterator.tcc
@@ -92,24 +92,32 @@ namespace __gnu_debug
       if (__n == 0)
 	return true;
 
+      std::pair<difference_type, _Distance_precision> __dist = __n < 0
+	? _M_get_distance_from_begin()
+	: _M_get_distance_to_end();
+
       if (__n < 0)
-	{
-	  std::pair<difference_type, _Distance_precision> __dist =
-	    _M_get_distance_from_begin();
-	  return __dist.second == __dp_exact
-	    ? __dist.first >= -__n
-	    : !__strict && __dist.first > 0;
-	}
-      else
-	{
-	  std::pair<difference_type, _Distance_precision> __dist =
-	    _M_get_distance_to_end();
-	  return __dist.second == __dp_exact
-	    ? __dist.first >= __n
-	    : !__strict && __dist.first > 0;
-	}
+	__n = -__n;
+
+      return __dist.second > __dp_sign
+	? __dist.first >= __n
+	: !__strict && __dist.first > 0;
     }
 
+  template<typename _Iterator, typename _Sequence, typename _Category>
+    template<typename _Diff>
+      bool
+      _Safe_iterator<_Iterator, _Sequence, _Category>::
+      _M_can_advance(const std::pair<_Diff, _Distance_precision>& __dist,
+		     int __way) const
+      {
+	return __dist.second == __dp_exact
+	  ? _M_can_advance(__way * __dist.first)
+	  : _M_can_advance(__way * (__dist.first == 0
+				    ? 0
+				    : __dist.first < 0 ? -1 : 1));
+      }
+
   template<typename _Iterator, typename _Sequence, typename _Category>
     typename _Distance_traits<_Iterator>::__type
     _Safe_iterator<_Iterator, _Sequence, _Category>::
@@ -191,19 +199,12 @@ namespace __gnu_debug
 
       /* Determine iterators order */
       __dist = _M_get_distance_to(__rhs);
-      switch (__dist.second)
+      if (__dist.second != __dp_equality)
 	{
-	case __dp_equality:
-	  if (__dist.first == 0)
-	    return true;
-	  break;
-
-	case __dp_sign:
-	case __dp_exact:
 	  // If range is not empty first iterator must be dereferenceable.
-	  if (__dist.first > 0)
-	    return !__check_dereferenceable || _M_dereferenceable();
-	  return __dist.first == 0;
+	  return __dist.first == 0
+	    || (__dist.first > 0
+		&& (!__check_dereferenceable || _M_dereferenceable()));
 	}
 
       // Assume that this is a valid range; we can't check anything else.
@@ -224,9 +225,8 @@ namespace __gnu_debug
       __dist = std::make_pair(__rhs.base() - this->base(), __dp_exact);
 
       // If range is not empty first iterator must be dereferenceable.
-      if (__dist.first > 0)
-	return this->_M_dereferenceable();
-      return __dist.first == 0;
+      return __dist.first == 0
+	|| (__dist.first > 0 && this->_M_dereferenceable());
     }
 } // namespace __gnu_debug
 
@@ -244,7 +244,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__copy_move_a<_IsMove>(__first.base(), __last.base(),
@@ -261,7 +261,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __result._M_can_advance(__dist.first, true))
@@ -283,7 +283,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, __dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
@@ -311,7 +311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__copy_move_backward_a<_IsMove>(
@@ -328,7 +328,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __result._M_can_advance(-__dist.first, true))
@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;
       __glibcxx_check_valid_range2(__first, __last, __dist);
-      __glibcxx_check_can_increment(__result, -__dist.first);
+      __glibcxx_check_can_increment_dist(__result, __dist, -1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
@@ -416,7 +416,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	return std::__equal_aux(__first1.base(), __last1.base(), __first2);
@@ -431,7 +431,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_sign
 	  && __first2._M_can_advance(__dist.first, true))
@@ -450,7 +450,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;
       __glibcxx_check_valid_range2(__first1, __last1, __dist);
-      __glibcxx_check_can_increment(__first2, __dist.first);
+      __glibcxx_check_can_increment_dist(__first2, __dist, 1);
 
       if (__dist.second > ::__gnu_debug::__dp_equality)
 	{
diff --git a/libstdc++-v3/include/debug/stl_iterator.h b/libstdc++-v3/include/debug/stl_iterator.h
index 6044f3588d9..02adb6e3c06 100644
--- a/libstdc++-v3/include/debug/stl_iterator.h
+++ b/libstdc++-v3/include/debug/stl_iterator.h
@@ -52,6 +52,13 @@ namespace __gnu_debug
     __can_advance(const std::reverse_iterator<_Iterator>& __it, _Size __n)
     { return __can_advance(__it.base(), -__n); }
 
+  template<typename _Iterator, typename _Diff>
+    inline bool
+    __can_advance(const std::reverse_iterator<_Iterator>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __can_advance(__it.base(), __dist, -__way); }
+
   template<typename _Iterator, typename _Sequence>
     inline std::reverse_iterator<_Iterator>
     __base(const std::reverse_iterator<_Safe_iterator<
@@ -101,6 +108,13 @@ namespace __gnu_debug
     __can_advance(const std::move_iterator<_Iterator>& __it, _Size __n)
     { return __can_advance(__it.base(), __n); }
 
+  template<typename _Iterator, typename _Diff>
+    inline bool
+    __can_advance(const std::move_iterator<_Iterator>& __it,
+		  const std::pair<_Diff, _Distance_precision>& __dist,
+		  int __way)
+    { return __can_advance(__it.base(), __dist, __way); }
+
   template<typename _Iterator>
     inline auto
     __unsafe(const std::move_iterator<_Iterator>& __it)
diff --git a/libstdc++-v3/include/debug/unordered_map b/libstdc++-v3/include/debug/unordered_map
index 17fbba3aade..54a8cba1c7b 100644
--- a/libstdc++-v3/include/debug/unordered_map
+++ b/libstdc++-v3/include/debug/unordered_map
@@ -136,6 +136,7 @@ namespace __debug
 
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -160,7 +161,7 @@ namespace __debug
 	unordered_map(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
@@ -168,20 +169,20 @@ namespace __debug
 		      size_type __n,
 		      const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, hasher(), key_equal(), __a)
+      : unordered_map(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, __hf, key_equal(), __a)
+      : unordered_map(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_map() = default;
@@ -831,6 +832,7 @@ namespace __debug
 
       unordered_multimap(unordered_multimap&& __umap,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -854,26 +856,26 @@ namespace __debug
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, __hf, key_equal(), __a)
+      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multimap() = default;
diff --git a/libstdc++-v3/include/debug/unordered_set b/libstdc++-v3/include/debug/unordered_set
index 4d30852186c..609cf42a076 100644
--- a/libstdc++-v3/include/debug/unordered_set
+++ b/libstdc++-v3/include/debug/unordered_set
@@ -133,6 +133,7 @@ namespace __debug
 
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -144,38 +145,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_set(size_type __n, const allocator_type& __a)
-	: unordered_set(__n, hasher(), key_equal(), __a)
+      : unordered_set(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__n, __hf, key_equal(), __a)
+      : unordered_set(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n, const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_set(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, hasher(), key_equal(), __a)
+      : unordered_set(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, __hf, key_equal(), __a)
+      : unordered_set(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_set() = default;
@@ -701,6 +702,7 @@ namespace __debug
 
       unordered_multiset(unordered_multiset&& __uset,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -712,38 +714,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_multiset(size_type __n, const allocator_type& __a)
-	: unordered_multiset(__n, hasher(), key_equal(), __a)
+      : unordered_multiset(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__n, __hf, key_equal(), __a)
+      : unordered_multiset(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, __hf, key_equal(), __a)
+      : unordered_multiset(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multiset() = default;
diff --git a/libstdc++-v3/include/decimal/decimal b/libstdc++-v3/include/decimal/decimal
index 8863d7e2a13..0e7e274716a 100644
--- a/libstdc++-v3/include/decimal/decimal
+++ b/libstdc++-v3/include/decimal/decimal
@@ -484,7 +484,7 @@ namespace decimal
 
 #define _GLIBCXX_USE_DECIMAL_ 1
 } // namespace decimal
-  // @} group decimal
+  /// @} group decimal
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/experimental/any b/libstdc++-v3/include/experimental/any
index 43455de479f..9b68f12c471 100644
--- a/libstdc++-v3/include/experimental/any
+++ b/libstdc++-v3/include/experimental/any
@@ -412,7 +412,7 @@ inline namespace fundamentals_v1
 	return std::move(*__p);
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -479,7 +479,7 @@ inline namespace fundamentals_v1
 	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
@@ -555,7 +555,7 @@ inline namespace fundamentals_v1
       _S_manage(_Op, const any*, _Arg*) { }
     };
 
-  // @} group any
+  /// @} group any
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/array b/libstdc++-v3/include/experimental/array
index 427bf8567cf..d3ee87101eb 100644
--- a/libstdc++-v3/include/experimental/array
+++ b/libstdc++-v3/include/experimental/array
@@ -104,7 +104,7 @@ template <typename _Tp, size_t _Nm>
     return experimental::__to_array(__a, make_index_sequence<_Nm>{});
   }
 
-  // @} group make_array
+  /// @} group make_array
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/bits/fs_dir.h b/libstdc++-v3/include/experimental/bits/fs_dir.h
index ae67ae95015..dcffd65bb5e 100644
--- a/libstdc++-v3/include/experimental/bits/fs_dir.h
+++ b/libstdc++-v3/include/experimental/bits/fs_dir.h
@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_fwd.h b/libstdc++-v3/include/experimental/bits/fs_fwd.h
index 535a800584f..4c80401ac14 100644
--- a/libstdc++-v3/include/experimental/bits/fs_fwd.h
+++ b/libstdc++-v3/include/experimental/bits/fs_fwd.h
@@ -279,7 +279,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_regular_file(file_status) noexcept;
   bool is_symlink(file_status) noexcept;
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_ops.h b/libstdc++-v3/include/experimental/bits/fs_ops.h
index 61611ba53eb..5b0aad4e3ae 100644
--- a/libstdc++-v3/include/experimental/bits/fs_ops.h
+++ b/libstdc++-v3/include/experimental/bits/fs_ops.h
@@ -288,7 +288,7 @@ inline namespace v1
   path temp_directory_path();
   path temp_directory_path(error_code& __ec);
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 69b823a3466..c5fc3beed1f 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -1268,7 +1268,7 @@ namespace __detail
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace v1
 } // namespace filesystem
diff --git a/libstdc++-v3/include/experimental/buffer b/libstdc++-v3/include/experimental/buffer
index 0b04b71286c..d319785fb25 100644
--- a/libstdc++-v3/include/experimental/buffer
+++ b/libstdc++-v3/include/experimental/buffer
@@ -172,7 +172,7 @@ inline namespace v1
     buffer_sequence_end(const _Cont& __c) -> decltype(__c.end())
     { return __c.end(); }
 
-  // @}
+  /// @}
 
 
   /** @brief buffer type traits
@@ -250,7 +250,7 @@ inline namespace v1
   template<typename _Tp>
     constexpr bool is_dynamic_buffer_v = is_dynamic_buffer<_Tp>::value;
 
-  // @}
+  /// @}
 
   /// buffer size
   template<typename _ConstBufferSequence>
@@ -727,7 +727,7 @@ inline namespace v1
       return net::read(__stream, __b, __completion_condition, __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous read operations
    * @{
@@ -775,7 +775,7 @@ inline namespace v1
 			     std::forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #if 0
   /** @brief synchronous write operations:
@@ -811,7 +811,7 @@ inline namespace v1
     size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b,
                  _CompletionCondition __completion_condition, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous write operations
    * @{
@@ -839,7 +839,7 @@ inline namespace v1
                        _CompletionCondition __completion_condition,
                        _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
   /** @brief synchronous delimited read operations
    * @{
@@ -856,7 +856,7 @@ inline namespace v1
     size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b,
                       string_view __delim, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous delimited read operations
    * @{
@@ -871,7 +871,7 @@ inline namespace v1
                           _DynamicBuffer&& __b, string_view __delim,
                           _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
 #endif
   /// @}
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index add9b09192d..697e724a9d1 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -126,7 +126,7 @@ namespace ip
   struct v4_mapped_t {};
   constexpr v4_mapped_t v4_mapped;
 
-  // @}
+  /// @}
 
   /// An IPv4 address.
   class address_v4
@@ -541,7 +541,7 @@ namespace ip
   operator>=(const address_v4& __a, const address_v4& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 comparisons
    * @{
@@ -585,7 +585,7 @@ namespace ip
   operator>=(const address_v6& __a, const address_v6& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address comparisons
    * @{
@@ -623,7 +623,7 @@ namespace ip
   operator>=(const address& __a, const address& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v4 creation
    * @{
@@ -695,7 +695,7 @@ namespace ip
   make_address_v4(string_view __str)
   { return make_address_v4(__str, __throw_on_error{"make_address_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 creation
    * @{
@@ -867,7 +867,7 @@ namespace ip
   make_address_v6(string_view __str)
   { return make_address_v6(__str, __throw_on_error{"make_address_v6"}); }
 
-  // @}
+  /// @}
 
   /** ip::address creation
    * @{
@@ -912,7 +912,7 @@ namespace ip
   make_address(string_view __str)
   { return make_address(__str, __throw_on_error{"make_address"}); }
 
-  // @}
+  /// @}
 
   /// ip::address I/O
   template<typename _CharT, typename _Traits>
@@ -1093,7 +1093,7 @@ namespace ip
 
   typedef basic_address_range<address_v4> address_v4_range;
 
-  // @}
+  /// @}
 
   /** An IPv6 address range.
    * @{
@@ -1134,7 +1134,7 @@ namespace ip
 
   typedef basic_address_range<address_v6> address_v6_range;
 
-  // @}
+  /// @}
 
   bool
   operator==(const network_v4& __a, const network_v4& __b) noexcept;
@@ -1307,7 +1307,7 @@ namespace ip
   operator!=(const network_v4& __a, const network_v4& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 comparisons
    * @{
@@ -1324,7 +1324,7 @@ namespace ip
   operator!=(const network_v6& __a, const network_v6& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v4 creation
    * @{
@@ -1356,7 +1356,7 @@ namespace ip
   make_network_v4(string_view __str)
   { return make_network_v4(__str, __throw_on_error{"make_network_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 creation
    * @{
@@ -1384,7 +1384,7 @@ namespace ip
   make_network_v6(string_view __str)
   { return make_network_v6(__str, __throw_on_error{"make_network_v6"}); }
 
-  // @}
+  /// @}
 
   /// ip::network_v4 I/O
   template<typename _CharT, typename _Traits>
@@ -1566,7 +1566,7 @@ namespace ip
 	       const basic_endpoint<_InternetProtocol>& __b)
     { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /// basic_endpoint I/O
   template<typename _CharT, typename _Traits, typename _InternetProtocol>
@@ -1640,7 +1640,7 @@ namespace ip
 	       const basic_resolver_entry<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** Base class defining flags for name/address resolution.
    * @{
@@ -1706,7 +1706,7 @@ namespace ip
 
   // TODO define resolver_base::flags static constants for C++14 mode
 
-  // @}
+  /// @}
 
   /** Container for results of name/address resolution.
    * @{
@@ -1788,7 +1788,7 @@ namespace ip
 	       const basic_resolver_results<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Perform name/address resolution.
   template<typename _InternetProtocol>
@@ -2071,7 +2071,7 @@ namespace ip
   host_name()
   { return host_name(std::allocator<char>{}, __throw_on_error{"host_name"}); }
 
-  // @}
+  /// @}
 
   /// The TCP byte-stream protocol.
   class tcp
@@ -2126,7 +2126,7 @@ namespace ip
   operator!=(const tcp& __a, const tcp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// The UDP datagram protocol.
   class udp
@@ -2165,7 +2165,7 @@ namespace ip
   operator!=(const udp& __a, const udp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Restrict a socket created for an IPv6 protocol to IPv6 only.
   struct v6_only : __sockopt_crtp<v6_only, bool>
@@ -2395,7 +2395,7 @@ namespace ip
 
   } // namespace multicast
 
-  // @}
+  /// @}
 
 } // namespace ip
 } // namespace v1
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index 370e95ae83e..33c509678c1 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -910,8 +910,8 @@ inline namespace fundamentals_v1
     make_optional(_Tp&& __t)
     { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }
 
-  // @} relates experimental::optional
-  // @} group optional
+  /// @} relates experimental::optional
+  /// @} group optional
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/propagate_const b/libstdc++-v3/include/experimental/propagate_const
index b1b70cab879..d7034d6f724 100644
--- a/libstdc++-v3/include/experimental/propagate_const
+++ b/libstdc++-v3/include/experimental/propagate_const
@@ -422,7 +422,7 @@ inline namespace fundamentals_v2
       return __pt._M_t;
     }
 
-  // @} group propagate_const
+  /// @} group propagate_const
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/socket b/libstdc++-v3/include/experimental/socket
index 4c47348373b..725fee4e71a 100644
--- a/libstdc++-v3/include/experimental/socket
+++ b/libstdc++-v3/include/experimental/socket
@@ -2285,7 +2285,7 @@ inline namespace v1
       protocol_type _M_protocol;
     };
 
-  // @}
+  /// @}
 
   /** @brief Socket streams
    * @{
@@ -2456,7 +2456,7 @@ inline namespace v1
       __streambuf_type _M_sb;
     };
 
-  // @}
+  /// @}
 
   /** @brief synchronous connect operations
    * @{
@@ -2577,7 +2577,7 @@ inline namespace v1
 			  __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous connect operations
    * @{
@@ -2627,11 +2627,11 @@ inline namespace v1
 				forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #endif  // _GLIBCXX_HAVE_UNISTD_H
 
-  // @}
+  /// @}
 
 } // namespace v1
 } // namespace net
diff --git a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
index f497cfec53d..38286b8ac47 100644
--- a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
@@ -516,7 +516,7 @@ namespace __gnu_pbds
     swap(gp_hash_table& other)
     { base_type::swap(other); }
   };
-  //@} hash-based
+  ///@} hash-based
 #undef PB_DS_GP_HASH_BASE
 
 
@@ -780,7 +780,7 @@ namespace __gnu_pbds
     swap(trie& other)
     { base_type::swap(other); }
   };
-  //@} branch-based
+  ///@} branch-based
 #undef PB_DS_TRIE_BASE
 #undef PB_DS_TRIE_NODE_AND_IT_TRAITS
 
@@ -852,10 +852,10 @@ namespace __gnu_pbds
     swap(list_update& other)
     { base_type::swap(other); }
   };
-  //@} list-based
+  ///@} list-based
 #undef PB_DS_LU_BASE
 
-  // @} group containers-pbds
+  /// @} group containers-pbds
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
index 1dc3f86c08b..9fec9a078cb 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
@@ -63,6 +63,12 @@ namespace __gnu_pbds
 {
   namespace detail
   {
+    /**
+     *  @ingroup pbds
+     *
+     *  @{
+     */
+
     /// Specialization for pairing_heap.
     template<typename _VTp, typename Cmp_Fn, typename _Alloc>
       struct container_base_dispatch<_VTp, Cmp_Fn, _Alloc, pairing_heap_tag,
@@ -107,7 +113,7 @@ namespace __gnu_pbds
 	/// Dispatched type.
 	typedef thin_heap<_VTp, Cmp_Fn, _Alloc> 		type;
       };
-    //@} group pbds
+    ///@} group pbds
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
index f77a6226768..8bed5906e78 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename tree_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
index f446af4effc..e24fc4d1f51 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename trie_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
index 4e91ed142e9..c2138ea09da 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
@@ -191,7 +191,7 @@ namespace __gnu_pbds
 	store_extra			       	m_store_extra_indicator;
 	no_throw_indicator 		 	m_no_throw_copies_indicator;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/exception.hpp b/libstdc++-v3/include/ext/pb_ds/exception.hpp
index b8013928eb3..95c5771bf95 100644
--- a/libstdc++-v3/include/ext/pb_ds/exception.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/exception.hpp
@@ -87,7 +87,7 @@ namespace __gnu_pbds
   inline void
   __throw_resize_error()
   { _GLIBCXX_THROW_OR_ABORT(resize_error()); }
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
index d2010fc28cc..6dca5e1a6f6 100644
--- a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
@@ -51,6 +51,7 @@ namespace __gnu_pbds
   /**
    *  @defgroup heap-based Heap-Based
    *  @ingroup containers-pbds
+   *
    *  @{
    */
 
@@ -151,6 +152,6 @@ namespace __gnu_pbds
     swap(priority_queue& other)
     { base_type::swap(other); }
   };
+ ///@} heap-based
 } // namespace __gnu_pbds
- //@} heap-based
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
index 46dc11447ae..8d2b61e19cd 100644
--- a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
@@ -113,7 +113,7 @@ namespace __gnu_pbds
    */
   struct range_invalidation_guarantee : public point_invalidation_guarantee
   { };
-  //@}
+  ///@}
 
 
   /**
@@ -184,8 +184,8 @@ namespace __gnu_pbds
 
   /// Thin heap.
   struct thin_heap_tag : public priority_queue_tag { };
-  //@}
-  //@}
+  ///@}
+  ///@}
 
 
   /**
@@ -438,7 +438,7 @@ namespace __gnu_pbds
 	reverse_iteration = base_type::reverse_iteration
       };
   };
-  //@}
+  ///@}
 
 
   namespace detail
@@ -448,7 +448,7 @@ namespace __gnu_pbds
 	     typename Policy_Tl = null_type>
       struct container_base_dispatch;
   } // namespace detail
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/random b/libstdc++-v3/include/ext/random
index 25d725015ec..bbd8c61e5d4 100644
--- a/libstdc++-v3/include/ext/random
+++ b/libstdc++-v3/include/ext/random
@@ -1043,7 +1043,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ndy(result_type(0), __p.sigma())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1295,7 +1295,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd(__p.mu(), __p.omega() / __p.mu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1540,7 +1540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ud()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1801,7 +1801,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd2(__p.nu(), __p.mu() / __p.nu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -2040,7 +2040,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      +1.5707963267948966192313216916397514L)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3303,7 +3303,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3709,7 +3709,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p), _M_uosd()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index e13292296d3..d6397a08531 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -488,7 +488,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return static_cast<_ValueType>(std::move(*__p));
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -547,7 +547,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index 2161cbed0d2..d511dfe7b60 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -1549,7 +1549,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #endif // C++2a
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/bit b/libstdc++-v3/include/std/bit
index f22ee528555..2b24f0d450b 100644
--- a/libstdc++-v3/include/std/bit
+++ b/libstdc++-v3/include/std/bit
@@ -34,7 +34,23 @@
 #if __cplusplus >= 201402L
 
 #include <type_traits>
-#include <ext/numeric_traits.h>
+
+#if _GLIBCXX_HOSTED
+# include <ext/numeric_traits.h>
+#else
+# include <limits>
+/// @cond undocumented
+namespace __gnu_cxx
+{
+  template<typename _Tp>
+    struct __int_traits
+    {
+      static constexpr int __digits = std::numeric_limits<_Tp>::digits;
+      static constexpr _Tp __max = std::numeric_limits<_Tp>::max();
+    };
+}
+/// @endcond
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
diff --git a/libstdc++-v3/include/std/bitset b/libstdc++-v3/include/std/bitset
index 5364e59f466..681f2116d67 100644
--- a/libstdc++-v3/include/std/bitset
+++ b/libstdc++-v3/include/std/bitset
@@ -961,7 +961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #endif
 
       // 23.3.5.2 bitset operations:
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __rhs  A same-sized bitset.
@@ -988,9 +988,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	this->_M_do_xor(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __position  The number of places to shift.
@@ -1022,9 +1022,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These versions of single-bit set, reset, flip, and test are
        *  extensions from the SGI version.  They do no range checking.
@@ -1065,7 +1065,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT
       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
 		!= static_cast<_WordT>(0)); }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -1144,7 +1144,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator~() const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __position  Index into the %bitset.
@@ -1166,7 +1166,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _GLIBCXX_CONSTEXPR bool
       operator[](size_t __position) const
       { return _Unchecked_test(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %bitset.
@@ -1300,7 +1300,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       size() const _GLIBCXX_NOEXCEPT
       { return _Nb; }
 
-      //@{
+      ///@{
       /// These comparisons for equality/inequality are, well, @e bitwise.
       bool
       operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
@@ -1311,7 +1311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator!=(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_equal(__rhs); }
 #endif
-      //@}
+      ///@}
 
       /**
        *  @brief Tests the value of a bit.
@@ -1352,7 +1352,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       none() const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       bitset<_Nb>
       operator<<(size_t __position) const _GLIBCXX_NOEXCEPT
@@ -1361,7 +1361,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bitset<_Nb>
       operator>>(size_t __position) const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this) >>= __position; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1421,7 +1421,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       }
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1456,9 +1456,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __result ^= __y;
       return __result;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief Global I/O operators for bitsets.
    *
@@ -1548,7 +1548,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
       return __os << __tmp;
     }
-  //@}
+  ///@}
 
 _GLIBCXX_END_NAMESPACE_CONTAINER
 } // namespace std
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 1eab4b74cb7..62a200c73b0 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     struct common_type<chrono::time_point<_Clock, _Duration>>
     { using type = chrono::time_point<_Clock, _Duration>; };
 
-  // @} group chrono
+  /// @} group chrono
 
   namespace chrono
   {
@@ -1007,7 +1007,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		 const time_point<_Clock, _Dur2>& __rhs)
       { return !(__lhs < __rhs); }
 
-    // @}
+    /// @}
 
     // Clocks.
 
@@ -1127,7 +1127,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     using local_days = local_time<days>;
 #endif // C++20
 
-    // @}
+    /// @}
   } // namespace chrono
 
 #if __cplusplus > 201103L
diff --git a/libstdc++-v3/include/std/complex b/libstdc++-v3/include/std/complex
index f2917b8c368..ebd1e5a0d39 100644
--- a/libstdc++-v3/include/std/complex
+++ b/libstdc++-v3/include/std/complex
@@ -324,7 +324,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   // Operators:
-  //@{
+  ///@{
   ///  Return new complex value @a x plus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -352,9 +352,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x minus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -382,9 +382,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x times @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -412,9 +412,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r *= __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x divided by @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -442,7 +442,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r /= __y;
       return __r;
     }
-  //@}
+  ///@}
 
   ///  Return @a x.
   template<typename _Tp>
@@ -456,7 +456,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator-(const complex<_Tp>& __x)
     { return complex<_Tp>(-__x.real(), -__x.imag()); }
 
-  //@{
+  ///@{
   ///  Return true if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -473,9 +473,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline _GLIBCXX_CONSTEXPR bool
     operator==(const _Tp& __x, const complex<_Tp>& __y)
     { return __x == __y.real() && _Tp() == __y.imag(); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return false if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -492,7 +492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
     { return __x != __y.real() || _Tp() != __y.imag(); }
 #endif
-  //@}
+  ///@}
 
   ///  Extraction operator for complex values.
   template<typename _Tp, typename _CharT, class _Traits>
@@ -1548,7 +1548,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 #endif
 
-  // @} group complex_numbers
+  /// @} group complex_numbers
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/condition_variable b/libstdc++-v3/include/std/condition_variable
index a08cfc62705..82a3afec563 100644
--- a/libstdc++-v3/include/std/condition_variable
+++ b/libstdc++-v3/include/std/condition_variable
@@ -453,7 +453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   } // end inline namespace
 
-  // @} group condition_variables
+  /// @} group condition_variables
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/fstream b/libstdc++-v3/include/std/fstream
index efc99d1e5a5..0f02938cb1d 100644
--- a/libstdc++-v3/include/std/fstream
+++ b/libstdc++-v3/include/std/fstream
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool                      _M_reading;
       bool                      _M_writing;
 
-      //@{
+      ///@{
       /**
        *  Necessary bits for putback buffer management.
        *
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char_type*		_M_pback_cur_save;
       char_type*		_M_pback_end_save;
       bool			_M_pback_init;
-      //@}
+      ///@}
 
       // Cached codecvt facet.
       const __codecvt_type* 	_M_codecvt;
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09f4af6fe7c..ceb1959e3b7 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1767,7 +1767,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // _GLIBCXX_ASYNC_ABI_COMPAT
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group futures
+  /// @} group futures
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/iostream b/libstdc++-v3/include/std/iostream
index f988342b90a..970c0e4fecc 100644
--- a/libstdc++-v3/include/std/iostream
+++ b/libstdc++-v3/include/std/iostream
@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  startup and termination. For more information, see the section of the
    *  manual linked to above.
   */
-  //@{
+  ///@{
   extern istream cin;		/// Linked to standard input
   extern ostream cout;		/// Linked to standard output
   extern ostream cerr;		/// Linked to standard error (unbuffered)
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern wostream wcerr;	/// Linked to standard error (unbuffered)
   extern wostream wclog;	/// Linked to standard error (buffered)
 #endif
-  //@}
+  ///@}
 
   // For construction of filebuffers for cout, cin, cerr, clog et. al.
   static ios_base::Init __ioinit;
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 407c1ccda49..5454f87a38e 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -107,7 +107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -133,9 +133,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Extractors
        *
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown if badbit is set in the exceptions mask.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief  Integer arithmetic extractors
        *  @param  __n A variable of builtin integral type.
@@ -199,9 +199,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator>>(unsigned long long& __n)
       { return _M_extract(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic extractors
        *  @param  __f A variable of builtin floating point type.
@@ -221,7 +221,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __istream_type&
       operator>>(long double& __f)
       { return _M_extract(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Basic arithmetic extractors
@@ -257,7 +257,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       operator>>(__streambuf_type* __sb);
-      //@}
+      ///@}
 
       // [27.6.1.3] unformatted input
       /**
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       gcount() const
       { return _M_gcount; }
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Input Functions
        *
@@ -600,7 +600,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       seekg(off_type, ios_base::seekdir);
-      //@}
+      ///@}
 
     protected:
       basic_istream()
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character extractors
    *  @param  __in  An input stream.
@@ -760,9 +760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
     { return (__in >> reinterpret_cast<char&>(__c)); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  Character string extractors
    *  @param  __in  An input stream.
@@ -807,7 +807,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
     { return (__in >> reinterpret_cast<char*>(__s)); }
-  //@}
+  ///@}
 
   /**
    *  @brief  Template class basic_iostream
diff --git a/libstdc++-v3/include/std/memory b/libstdc++-v3/include/std/memory
index 3b3fec0d95c..eea472e8600 100644
--- a/libstdc++-v3/include/std/memory
+++ b/libstdc++-v3/include/std/memory
@@ -177,7 +177,7 @@ undeclare_no_pointers(char*, size_t) { }
 /// The type of pointer safety supported by the implementation.
 inline pointer_safety
 get_pointer_safety() noexcept { return pointer_safety::relaxed; }
-// @}
+/// @}
 
 #if __cplusplus > 201703L
 #define __cpp_lib_assume_aligned 201811L
diff --git a/libstdc++-v3/include/std/mutex b/libstdc++-v3/include/std/mutex
index 3c619f87040..dc846f015aa 100644
--- a/libstdc++-v3/include/std/mutex
+++ b/libstdc++-v3/include/std/mutex
@@ -738,7 +738,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index bd70a52019b..6ad73d9713b 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -693,7 +693,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
index 9a80adf3a5a..97ff1cee4e6 100644
--- a/libstdc++-v3/include/std/ostream
+++ b/libstdc++-v3/include/std/ostream
@@ -96,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -132,9 +132,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Inserters
        *
@@ -153,7 +153,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief Integer arithmetic inserters
        *  @param  __n A variable of builtin integral type.
@@ -205,9 +205,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator<<(unsigned long long __n)
       { return _M_insert(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic inserters
        *  @param  __f A variable of builtin floating point type.
@@ -231,7 +231,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __ostream_type&
       operator<<(long double __f)
       { return _M_insert(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Pointer arithmetic inserters
@@ -274,9 +274,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       operator<<(__streambuf_type* __sb);
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Output Functions
        *
@@ -339,7 +339,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       write(const char_type* __s, streamsize __n);
-      //@}
+      ///@}
 
       /**
        *  @brief  Synchronizing the stream buffer.
@@ -485,7 +485,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character inserters
    *  @param  __out  An output stream.
@@ -568,9 +568,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;
 #endif // _GLIBCXX_USE_WCHAR_T
 #endif // C++20
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  String inserters
    *  @param  __out  An output stream.
@@ -664,7 +664,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
 #endif // _GLIBCXX_USE_WCHAR_T
 #endif // C++20
-  //@}
+  ///@}
 
   // Standard basic_ostream manipulators
 
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index 8e00222c2e8..446585f0003 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -222,11 +222,6 @@ namespace ranges
 	&& __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>
 	&& convertible_to<_Vp, tuple_element_t<1, _Tp>>;
 
-    template<typename _Tp>
-      concept __iterator_sentinel_pair
-	= !range<_Tp> && __pair_like<_Tp>
-	&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;
-
   } // namespace __detail
 
   enum class subrange_kind : bool { unsized, sized };
@@ -387,16 +382,6 @@ namespace ranges
 	     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
       -> subrange<_It, _Sent, subrange_kind::sized>;
 
-  template<__detail::__iterator_sentinel_pair _Pr>
-    subrange(_Pr)
-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;
-
-  template<__detail::__iterator_sentinel_pair _Pr>
-    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<
-						     tuple_element_t<0, _Pr>>>)
-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,
-		  subrange_kind::sized>;
-
   template<borrowed_range _Rng>
     subrange(_Rng&&)
       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
@@ -973,7 +958,7 @@ namespace views
       {
 	if (_M_stream != nullptr)
 	  *_M_stream >> _M_object;
-	return _Iterator{*this};
+	return _Iterator{this};
       }
 
       constexpr default_sentinel_t
@@ -994,8 +979,8 @@ namespace views
 	_Iterator() = default;
 
 	constexpr explicit
-	_Iterator(basic_istream_view& __parent) noexcept
-	  : _M_parent(std::__addressof(__parent))
+	_Iterator(basic_istream_view* __parent) noexcept
+	  : _M_parent(__parent)
 	{ }
 
 	_Iterator(const _Iterator&) = delete;
@@ -1292,65 +1277,50 @@ namespace views
 
   } // namespace views
 
-  // XXX: the following algos are copied from ranges_algo.h to avoid a circular
-  // dependency with that header.
+  // The following simple algos are transcribed from ranges_algo.h to avoid
+  // having to include that entire header.
   namespace __detail
   {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
+    template<typename _Iter, typename _Sent, typename _Tp>
       constexpr _Iter
-      find_if(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
+      find(_Iter __first, _Sent __last, const _Tp& __value)
       {
 	while (__first != __last
-	    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	       && !(bool)(*__first == __value))
 	  ++__first;
 	return __first;
       }
 
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
+    template<typename _Iter, typename _Sent, typename _Pred>
       constexpr _Iter
-      find_if_not(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
+      find_if(_Iter __first, _Sent __last, _Pred __pred)
       {
 	while (__first != __last
-	    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	       && !(bool)std::__invoke(__pred, *__first))
 	  ++__first;
 	return __first;
       }
 
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr const _Tp&
-      min(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {})
+    template<typename _Iter, typename _Sent, typename _Pred>
+      constexpr _Iter
+      find_if_not(_Iter __first, _Sent __last, _Pred __pred)
       {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __b),
-			  std::__invoke(__proj, __a)))
-	  return __b;
-	else
-	  return __a;
+	while (__first != __last
+	       && (bool)std::__invoke(__pred, *__first))
+	  ++__first;
+	return __first;
       }
 
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
+    template<typename _Iter1, typename _Sent1, typename _Iter2, typename _Sent2>
       constexpr pair<_Iter1, _Iter2>
-      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
-	       _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})
+      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2)
       {
 	while (__first1 != __last1 && __first2 != __last2
-	       && (bool)std::__invoke(__pred,
-				      std::__invoke(__proj1, *__first1),
-				      std::__invoke(__proj2, *__first2)))
-	{
-	  ++__first1;
-	  ++__first2;
-	}
+	       && (bool)ranges::equal_to{}(*__first1, *__first2))
+	  {
+	    ++__first1;
+	    ++__first2;
+	  }
 	return { std::move(__first1), std::move(__first2) };
       }
   } // namespace __detail
@@ -1482,9 +1452,9 @@ namespace views
 	_Iterator() = default;
 
 	constexpr
-	_Iterator(filter_view& __parent, _Vp_iter __current)
+	_Iterator(filter_view* __parent, _Vp_iter __current)
 	  : _M_current(std::move(__current)),
-	    _M_parent(std::__addressof(__parent))
+	    _M_parent(__parent)
 	{ }
 
 	constexpr _Vp_iter
@@ -1574,8 +1544,8 @@ namespace views
 	_Sentinel() = default;
 
 	constexpr explicit
-	_Sentinel(filter_view& __parent)
-	  : _M_end(ranges::end(__parent._M_base))
+	_Sentinel(filter_view* __parent)
+	  : _M_end(ranges::end(__parent->_M_base))
 	{ }
 
 	constexpr sentinel_t<_Vp>
@@ -1615,23 +1585,23 @@ namespace views
       begin()
       {
 	if (_M_cached_begin._M_has_value())
-	  return {*this, _M_cached_begin._M_get(_M_base)};
+	  return {this, _M_cached_begin._M_get(_M_base)};
 
 	__glibcxx_assert(_M_pred.has_value());
 	auto __it = __detail::find_if(ranges::begin(_M_base),
 				      ranges::end(_M_base),
 				      std::ref(*_M_pred));
 	_M_cached_begin._M_set(_M_base, __it);
-	return {*this, std::move(__it)};
+	return {this, std::move(__it)};
       }
 
       constexpr auto
       end()
       {
 	if constexpr (common_range<_Vp>)
-	  return _Iterator{*this, ranges::end(_M_base)};
+	  return _Iterator{this, ranges::end(_M_base)};
 	else
-	  return _Sentinel{*this};
+	  return _Sentinel{this};
       }
     };
 
@@ -1710,9 +1680,9 @@ namespace views
 	  _Iterator() = default;
 
 	  constexpr
-	  _Iterator(_Parent& __parent, _Base_iter __current)
+	  _Iterator(_Parent* __parent, _Base_iter __current)
 	    : _M_current(std::move(__current)),
-	      _M_parent(std::__addressof(__parent))
+	      _M_parent(__parent)
 	  { }
 
 	  constexpr
@@ -1825,17 +1795,17 @@ namespace views
 	  friend constexpr _Iterator
 	  operator+(_Iterator __i, difference_type __n)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
+	  { return {__i._M_parent, __i._M_current + __n}; }
 
 	  friend constexpr _Iterator
 	  operator+(difference_type __n, _Iterator __i)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
+	  { return {__i._M_parent, __i._M_current + __n}; }
 
 	  friend constexpr _Iterator
 	  operator-(_Iterator __i, difference_type __n)
 	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current - __n}; }
+	  { return {__i._M_parent, __i._M_current - __n}; }
 
 	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
 	  // 3483. transform_view::iterator's difference is overconstrained
@@ -1946,13 +1916,13 @@ namespace views
 
       constexpr _Iterator<false>
       begin()
-      { return _Iterator<false>{*this, ranges::begin(_M_base)}; }
+      { return _Iterator<false>{this, ranges::begin(_M_base)}; }
 
       constexpr _Iterator<true>
       begin() const
 	requires range<const _Vp>
 	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::begin(_M_base)}; }
+      { return _Iterator<true>{this, ranges::begin(_M_base)}; }
 
       constexpr _Sentinel<false>
       end()
@@ -1960,7 +1930,7 @@ namespace views
 
       constexpr _Iterator<false>
       end() requires common_range<_Vp>
-      { return _Iterator<false>{*this, ranges::end(_M_base)}; }
+      { return _Iterator<false>{this, ranges::end(_M_base)}; }
 
       constexpr _Sentinel<true>
       end() const
@@ -1972,7 +1942,7 @@ namespace views
       end() const
 	requires common_range<const _Vp>
 	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::end(_M_base)}; }
+      { return _Iterator<true>{this, ranges::end(_M_base)}; }
 
       constexpr auto
       size() requires sized_range<_Vp>
@@ -2127,14 +2097,14 @@ namespace views
       size() requires sized_range<_Vp>
       {
 	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
+	return std::min(__n, static_cast<decltype(__n)>(_M_count));
       }
 
       constexpr auto
       size() const requires sized_range<const _Vp>
       {
 	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
+	return std::min(__n, static_cast<decltype(__n)>(_M_count));
       }
     };
 
@@ -2529,9 +2499,9 @@ namespace views
 	  _Iterator() = default;
 
 	  constexpr
-	  _Iterator(_Parent& __parent, _Outer_iter __outer)
+	  _Iterator(_Parent* __parent, _Outer_iter __outer)
 	    : _M_outer(std::move(__outer)),
-	      _M_parent(std::__addressof(__parent))
+	      _M_parent(__parent)
 	  { _M_satisfy(); }
 
 	  constexpr
@@ -2653,8 +2623,8 @@ namespace views
 	  _Sentinel() = default;
 
 	  constexpr explicit
-	  _Sentinel(_Parent& __parent)
-	    : _M_end(ranges::end(__parent._M_base))
+	  _Sentinel(_Parent* __parent)
+	    : _M_end(ranges::end(__parent->_M_base))
 	  { }
 
 	  constexpr
@@ -2702,7 +2672,7 @@ namespace views
 	constexpr bool __use_const
 	  = (__detail::__simple_view<_Vp>
 	     && is_reference_v<range_reference_t<_Vp>>);
-	return _Iterator<__use_const>{*this, ranges::begin(_M_base)};
+	return _Iterator<__use_const>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
@@ -2710,7 +2680,7 @@ namespace views
 	requires input_range<const _Vp>
 	  && is_reference_v<range_reference_t<const _Vp>>
       {
-	return _Iterator<true>{*this, ranges::begin(_M_base)};
+	return _Iterator<true>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
@@ -2719,10 +2689,10 @@ namespace views
 	if constexpr (forward_range<_Vp> && is_reference_v<_InnerRange>
 		      && forward_range<_InnerRange>
 		      && common_range<_Vp> && common_range<_InnerRange>)
-	  return _Iterator<__detail::__simple_view<_Vp>>{*this,
+	  return _Iterator<__detail::__simple_view<_Vp>>{this,
 							 ranges::end(_M_base)};
 	else
-	  return _Sentinel<__detail::__simple_view<_Vp>>{*this};
+	  return _Sentinel<__detail::__simple_view<_Vp>>{this};
       }
 
       constexpr auto
@@ -2735,9 +2705,9 @@ namespace views
 		      && forward_range<range_reference_t<const _Vp>>
 		      && common_range<const _Vp>
 		      && common_range<range_reference_t<const _Vp>>)
-	  return _Iterator<true>{*this, ranges::end(_M_base)};
+	  return _Iterator<true>{this, ranges::end(_M_base)};
 	else
-	  return _Sentinel<true>{*this};
+	  return _Sentinel<true>{this};
       }
     };
 
@@ -2856,14 +2826,14 @@ namespace views
 	  _OuterIter() = default;
 
 	  constexpr explicit
-	  _OuterIter(_Parent& __parent) requires (!forward_range<_Base>)
-	    : _M_parent(std::__addressof(__parent))
+	  _OuterIter(_Parent* __parent) requires (!forward_range<_Base>)
+	    : _M_parent(__parent)
 	  { }
 
 	  constexpr
-	  _OuterIter(_Parent& __parent, iterator_t<_Base> __current)
+	  _OuterIter(_Parent* __parent, iterator_t<_Base> __current)
 	    requires forward_range<_Base>
-	    : _M_parent(std::__addressof(__parent)),
+	    : _M_parent(__parent),
 	      _M_current(std::move(__current))
 	  { }
 
@@ -2881,21 +2851,31 @@ namespace views
 	  constexpr _OuterIter&
 	  operator++()
 	  {
+	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+	    // 3505. split_view::outer-iterator::operator++ misspecified
 	    const auto __end = ranges::end(_M_parent->_M_base);
 	    if (__current() == __end)
 	      return *this;
 	    const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};
 	    if (__pbegin == __pend)
 	      ++__current();
+	    else if constexpr (__detail::__tiny_range<_Pattern>)
+	      {
+		__current() = __detail::find(std::move(__current()), __end,
+					     *__pbegin);
+		if (__current() != __end)
+		  ++__current();
+	      }
 	    else
 	      do
 		{
 		  auto [__b, __p]
-		    = __detail::mismatch(std::move(__current()), __end,
-					 __pbegin, __pend);
-		  __current() = std::move(__b);
+		    = __detail::mismatch(__current(), __end, __pbegin, __pend);
 		  if (__p == __pend)
-		    break;
+		    {
+		      __current() = __b;
+		      break;
+		    }
 		} while (++__current() != __end);
 	    return *this;
 	  }
@@ -3089,25 +3069,25 @@ namespace views
       {
 	if constexpr (forward_range<_Vp>)
 	  return _OuterIter<__detail::__simple_view<_Vp>>{
-	      *this, ranges::begin(_M_base)};
+	      this, ranges::begin(_M_base)};
 	else
 	  {
 	    _M_current = ranges::begin(_M_base);
-	    return _OuterIter<false>{*this};
+	    return _OuterIter<false>{this};
 	  }
       }
 
       constexpr auto
       begin() const requires forward_range<_Vp> && forward_range<const _Vp>
       {
-	return _OuterIter<true>{*this, ranges::begin(_M_base)};
+	return _OuterIter<true>{this, ranges::begin(_M_base)};
       }
 
       constexpr auto
       end() requires forward_range<_Vp> && common_range<_Vp>
       {
 	return _OuterIter<__detail::__simple_view<_Vp>>{
-	    *this, ranges::end(_M_base)};
+	    this, ranges::end(_M_base)};
       }
 
       constexpr auto
@@ -3116,7 +3096,7 @@ namespace views
 	if constexpr (forward_range<_Vp>
 		      && forward_range<const _Vp>
 		      && common_range<const _Vp>)
-	  return _OuterIter<true>{*this, ranges::end(_M_base)};
+	  return _OuterIter<true>{this, ranges::end(_M_base)};
 	else
 	  return default_sentinel;
       }
@@ -3388,6 +3368,10 @@ namespace views
 	{ std::get<_Nm>(__t) }
 	  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;
       };
+
+    template<typename _Tp, size_t _Nm>
+      concept __returnable_element
+	= is_reference_v<_Tp> || move_constructible<tuple_element_t<_Nm, _Tp>>;
   }
 
   template<input_range _Vp, size_t _Nm>
@@ -3395,6 +3379,7 @@ namespace views
       && __detail::__has_tuple_element<range_value_t<_Vp>, _Nm>
       && __detail::__has_tuple_element<remove_reference_t<range_reference_t<_Vp>>,
 				       _Nm>
+      && __detail::__returnable_element<range_reference_t<_Vp>, _Nm>
     class elements_view : public view_interface<elements_view<_Vp, _Nm>>
     {
     public:
@@ -3452,10 +3437,23 @@ namespace views
       template<bool _Const>
 	struct _Iterator
 	{
+	private:
 	  using _Base = __detail::__maybe_const_t<_Const, _Vp>;
 
 	  iterator_t<_Base> _M_current = iterator_t<_Base>();
 
+	  static constexpr decltype(auto)
+	  _S_get_element(const iterator_t<_Base>& __i)
+	  {
+	    if constexpr (is_reference_v<range_reference_t<_Base>>)
+	      return std::get<_Nm>(*__i);
+	    else
+	      {
+		using _Et = remove_cv_t<tuple_element_t<_Nm, range_reference_t<_Base>>>;
+		return static_cast<_Et>(std::get<_Nm>(*__i));
+	      }
+	  }
+
 	  friend _Iterator<!_Const>;
 
 	public:
@@ -3488,8 +3486,8 @@ namespace views
 	  { return std::move(_M_current); }
 
 	  constexpr decltype(auto)
-	    operator*() const
-	  { return std::get<_Nm>(*_M_current); }
+	  operator*() const
+	  { return _S_get_element(_M_current); }
 
 	  constexpr _Iterator&
 	  operator++()
@@ -3499,7 +3497,7 @@ namespace views
 	  }
 
 	  constexpr void
-	  operator++(int) requires (!forward_range<_Base>)
+	  operator++(int)
 	  { ++_M_current; }
 
 	  constexpr _Iterator
@@ -3544,7 +3542,7 @@ namespace views
 	  constexpr decltype(auto)
 	  operator[](difference_type __n) const
 	    requires random_access_range<_Base>
-	  { return std::get<_Nm>(*(_M_current + __n)); }
+	  { return _S_get_element(_M_current + __n); }
 
 	  friend constexpr bool
 	  operator==(const _Iterator& __x, const _Iterator& __y)
diff --git a/libstdc++-v3/include/std/ratio b/libstdc++-v3/include/std/ratio
index 83c8c792793..293ed9a8e7c 100644
--- a/libstdc++-v3/include/std/ratio
+++ b/libstdc++-v3/include/std/ratio
@@ -567,7 +567,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   typedef ratio<         1000000000000000, 1> peta;
   typedef ratio<      1000000000000000000, 1> exa;
 
-  // @} group ratio
+  /// @} group ratio
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/shared_mutex b/libstdc++-v3/include/std/shared_mutex
index 414dce3a1b7..edfd4e4e523 100644
--- a/libstdc++-v3/include/std/shared_mutex
+++ b/libstdc++-v3/include/std/shared_mutex
@@ -846,7 +846,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/stdexcept b/libstdc++-v3/include/std/stdexcept
index 49161d5d0d2..43b84cda398 100644
--- a/libstdc++-v3/include/std/stdexcept
+++ b/libstdc++-v3/include/std/stdexcept
@@ -299,7 +299,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     virtual ~underflow_error() _GLIBCXX_NOTHROW;
   };
 
-  // @} group exceptions
+  /// @} group exceptions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/streambuf b/libstdc++-v3/include/std/streambuf
index 7cb4fabbb89..5c6267e8e7e 100644
--- a/libstdc++-v3/include/std/streambuf
+++ b/libstdc++-v3/include/std/streambuf
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_streambuf
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -133,12 +133,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename traits_type::int_type 		int_type;
       typedef typename traits_type::pos_type 		pos_type;
       typedef typename traits_type::off_type 		off_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /// This is a non-standard type.
       typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
-      //@}
+      ///@}
 
       friend class basic_ios<char_type, traits_type>;
       friend class basic_istream<char_type, traits_type>;
@@ -234,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_buf_locale; }
 
       // [27.5.2.2.2] buffer management and positioning
-      //@{
+      ///@{
       /**
        *  @brief  Entry points for derived buffer functions.
        *
@@ -276,7 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       int
       pubsync() { return this->sync(); }
-      //@}
+      ///@}
 
       // [27.5.2.2.3] get area
       /**
@@ -474,7 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { }
 
       // [27.5.2.3.1] get area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the get area.
        *
@@ -493,7 +493,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       egptr() const { return _M_in_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the read position.
@@ -521,7 +521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
       // [27.5.2.3.2] put area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the put area.
        *
@@ -540,7 +540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       epptr() const { return _M_out_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the write position.
diff --git a/libstdc++-v3/include/std/string_view b/libstdc++-v3/include/std/string_view
index f05ff32d9e5..da23f9bc855 100644
--- a/libstdc++-v3/include/std/string_view
+++ b/libstdc++-v3/include/std/string_view
@@ -22,7 +22,7 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-/** @file string_view
+/** @file include/string_view
  *  This is a Standard C++ Library header.
  */
 
diff --git a/libstdc++-v3/include/std/system_error b/libstdc++-v3/include/std/system_error
index f92b4345895..d376610e761 100644
--- a/libstdc++-v3/include/std/system_error
+++ b/libstdc++-v3/include/std/system_error
@@ -262,7 +262,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
     { return (__os << __e.category().name() << ':' << __e.value()); }
 
-  // @}
+  /// @}
 
   error_condition make_error_condition(errc) noexcept;
 
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index b1ed458ba21..f25e74a685e 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -428,7 +428,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
   }
 
-  // @} group threads
+  /// @} group threads
 
 #ifdef __cpp_lib_jthread
 
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index be2e70dc06a..f5d08973765 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -595,7 +595,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return _M_data[__i];
     }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1245,7 +1245,7 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
     { return std::__addressof(__va[0]) + __va.size(); }
 #endif // C++11
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index fa0284d9738..0a754fb4196 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -23,7 +23,7 @@
 // <http://www.gnu.org/licenses/>.
 
 /** @file variant
- *  This is the <variant> C++ Library header.
+ *  This is the `<variant>` C++ Library header.
  */
 
 #ifndef _GLIBCXX_VARIANT
diff --git a/libstdc++-v3/include/tr1/cmath b/libstdc++-v3/include/tr1/cmath
index 0ad4121e895..c4a3ad4bb35 100644
--- a/libstdc++-v3/include/tr1/cmath
+++ b/libstdc++-v3/include/tr1/cmath
@@ -1057,7 +1057,7 @@ namespace tr1
 
 #endif // __cplusplus < 201103L
 
-  // @}
+  /// @}
 
 #endif /* _GLIBCXX_USE_C99_MATH_TR1 */
 
@@ -1618,7 +1618,7 @@ namespace tr1
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  // @} tr1_math_spec_func
+  /// @} tr1_math_spec_func
 
 } // namespace tr1
 
@@ -1698,7 +1698,7 @@ namespace tr1
       return __detail::__hyperg<__type>(__a, __b, __c, __x);
     }
 
-  // @} tr1_math_spec_func
+  /// @} tr1_math_spec_func
 
 } // namespace tr1
 
diff --git a/libstdc++-v3/include/tr1/complex b/libstdc++-v3/include/tr1/complex
index 3c9e6e27b30..9a4ee8cf128 100644
--- a/libstdc++-v3/include/tr1/complex
+++ b/libstdc++-v3/include/tr1/complex
@@ -411,7 +411,7 @@ namespace tr1
     pow(const std::complex<_Tp>& __x, const std::complex<_Tp>& __y)
     { return std::pow(__x, __y); }
 
-// @} group complex_numbers
+/// @} group complex_numbers
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/random.h b/libstdc++-v3/include/tr1/random.h
index 3f777cb0321..20ea2edbbe9 100644
--- a/libstdc++-v3/include/tr1/random.h
+++ b/libstdc++-v3/include/tr1/random.h
@@ -1543,7 +1543,7 @@ namespace tr1
 #endif
   };
 
-  /* @} */ // group tr1_random_generators
+  /// @} group tr1_random_generators
 
   /**
    * @addtogroup tr1_random_distributions Random Number Distributions
@@ -2046,7 +2046,7 @@ namespace tr1
       bool      _M_easy;
     };
 
-  /* @} */ // group tr1_random_distributions_discrete
+  /// @} group tr1_random_distributions_discrete
 
   /**
    * @addtogroup tr1_random_distributions_continuous Continuous Distributions
@@ -2403,9 +2403,9 @@ namespace tr1
       result_type _M_l_d;
     };
 
-  /* @} */ // group tr1_random_distributions_continuous
-  /* @} */ // group tr1_random_distributions
-  /* @} */ // group tr1_random
+  /// @} group tr1_random_distributions_continuous
+  /// @} group tr1_random_distributions
+  /// @} group tr1_random
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/regex b/libstdc++-v3/include/tr1/regex
index 1efbcf86789..7d7ed6131a9 100644
--- a/libstdc++-v3/include/tr1/regex
+++ b/libstdc++-v3/include/tr1/regex
@@ -53,7 +53,7 @@ namespace tr1
  * @defgroup tr1_regex Regular Expressions
  * A facility for performing regular expression pattern matching.
  */
- //@{
+ ///@{
 
 /** @namespace std::regex_constants
  *  @brief ISO C++ 0x entities sub namespace for regex.
@@ -63,7 +63,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
     {
       _S_icase,
@@ -174,7 +174,7 @@ namespace regex_constants
    */
   static const syntax_option_type egrep      = 1 << _S_egrep;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -185,7 +185,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
     {
@@ -315,12 +315,12 @@ namespace regex_constants
    */
   static const match_flag_type format_first_only = 1 << _S_first_only;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
  
   enum error_type
     {
@@ -396,7 +396,7 @@ namespace regex_constants
    */
   static const error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 }
 
   // [7.8] Class regex_error
@@ -735,7 +735,7 @@ namespace regex_constants
        * @name Constants
        * tr1 [7.8.1] std [28.8.1]
        */
-      //@{
+      ///@{
       static const regex_constants::syntax_option_type icase
         = regex_constants::icase;
       static const regex_constants::syntax_option_type nosubs
@@ -756,7 +756,7 @@ namespace regex_constants
         = regex_constants::grep;
       static const regex_constants::syntax_option_type egrep
         = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -1787,7 +1787,7 @@ namespace regex_constants
       /**
        * @name 10.? Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>                             value_type;
       typedef typename _Base_type::const_reference            const_reference;
       typedef const_reference                                 reference;
@@ -1799,13 +1799,13 @@ namespace regex_constants
       typedef _Allocator                                      allocator_type;
       typedef typename iterator_traits<_Bi_iter>::value_type  char_type;
       typedef basic_string<char_type>                         string_type;
-      //@}
+      ///@}
   
     public:
       /**
        * @name 10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1841,12 +1841,12 @@ namespace regex_constants
       ~match_results()
       { }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1874,12 +1874,12 @@ namespace regex_constants
       empty() const
       { return size() == 0; }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.3 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1988,7 +1988,7 @@ namespace regex_constants
       { return _Base_type::end(); }
 #endif
 
-      //@}
+      ///@}
 
       /**
        * @name 10.4 Formatting
@@ -1998,7 +1998,7 @@ namespace regex_constants
        * and escape sequences accepted by these functions are
        * determined by their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @todo Implement this function.
@@ -2017,12 +2017,12 @@ namespace regex_constants
 	     regex_constants::match_flag_type __flags
 	     = regex_constants::format_default) const;
 
-      //@} 
+      ///@}
 
       /**
        * @name 10.5 Allocator
        */
-      //@{ 
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -2031,12 +2031,12 @@ namespace regex_constants
       //get_allocator() const;
       using _Base_type::get_allocator;
       
-      //@} 
+      ///@}
 
       /**
        * @name 10.6 Swap
        */
-       //@{ 
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -2049,7 +2049,7 @@ namespace regex_constants
 	std::swap(_M_prefix,  __that._M_prefix);
 	std::swap(_M_suffix,  __that._M_suffix);
       }
-      //@} 
+      ///@}
       
     private:
       bool       _M_matched;
@@ -2105,7 +2105,7 @@ namespace regex_constants
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2432,7 +2432,7 @@ namespace regex_constants
       return __result;
     }
 
-  //@}
+  ///@}
 
   // tr1 [7.12.1] std [28.12] Class template regex_iterator
   /**
@@ -2718,7 +2718,7 @@ namespace regex_constants
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
   
-  //@}
+  ///@}
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
index 1591bc5a494..634679dfc45 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset
+++ b/libstdc++-v3/include/tr2/dynamic_bitset
@@ -748,7 +748,7 @@ namespace tr2
 	}
 
       // 23.3.5.2 dynamic_bitset operations:
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __rhs  A same-sized dynamic_bitset.
@@ -789,9 +789,9 @@ namespace tr2
 	this->_M_do_dif(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __pos The number of places to shift.
@@ -823,7 +823,7 @@ namespace tr2
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -905,7 +905,7 @@ namespace tr2
       operator~() const
       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __pos  Index into the %dynamic_bitset.
@@ -921,7 +921,7 @@ namespace tr2
       const_reference
       operator[](size_type __pos) const
       { return _M_unchecked_test(__pos); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %dynamic_bitset.
@@ -1052,7 +1052,7 @@ namespace tr2
       none() const
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       dynamic_bitset
       operator<<(size_type __pos) const
@@ -1061,7 +1061,7 @@ namespace tr2
       dynamic_bitset
       operator>>(size_type __pos) const
       { return dynamic_bitset(*this) >>= __pos; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1115,7 +1115,7 @@ namespace tr2
       }
 
 
-  //@{
+  ///@{
   /// These comparisons for equality/inequality are, well, @e bitwise.
 
   template<typename _WordT, typename _Alloc>
@@ -1141,10 +1141,10 @@ namespace tr2
     operator>=(const dynamic_bitset<_WordT, _Alloc>& __lhs,
 	       const dynamic_bitset<_WordT, _Alloc>& __rhs)
     { return !(__lhs < __rhs); }
-  //@}
+  ///@}
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1192,7 +1192,7 @@ namespace tr2
       __result -= __y;
       return __result;
     }
-  //@}
+  ///@}
 
   /// Stream output operator for dynamic_bitset.
   template <typename _CharT, typename _Traits,
diff --git a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
index f0b57aeee55..eec5872fc2e 100644
--- a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
+++ b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
@@ -61,6 +61,6 @@
 #define ATOMIC_POINTER_LOCK_FREE	__GCC_ATOMIC_POINTER_LOCK_FREE
 #endif
 
-// @} group atomics
+/// @} group atomics
 
 #endif
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
index 863eb91e7f0..992e6f8f256 100644
--- a/libstdc++-v3/libsupc++/exception
+++ b/libstdc++-v3/libsupc++/exception
@@ -111,7 +111,7 @@ namespace std
   int uncaught_exceptions() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 #endif
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 namespace __gnu_cxx
diff --git a/libstdc++-v3/libsupc++/exception.h b/libstdc++-v3/libsupc++/exception.h
index 47c6eeaee23..8ade3ea9cc3 100644
--- a/libstdc++-v3/libsupc++/exception.h
+++ b/libstdc++-v3/libsupc++/exception.h
@@ -45,7 +45,7 @@ namespace std
    * @defgroup exceptions Exceptions
    * @ingroup diagnostics
    *
-   * Classes and functions for reporting errors via exception classes.
+   * Classes and functions for reporting errors via exceptions.
    * @{
    */
 
@@ -75,6 +75,8 @@ namespace std
     what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
   };
 
+  /// @}
+
 } // namespace std
 
 }
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
index fb38a3d203f..f1592c84afe 100644
--- a/libstdc++-v3/libsupc++/exception_ptr.h
+++ b/libstdc++-v3/libsupc++/exception_ptr.h
@@ -214,7 +214,7 @@ namespace std
 #endif
     }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/libsupc++/nested_exception.h b/libstdc++-v3/libsupc++/nested_exception.h
index 1a9c603ae49..04302521e2e 100644
--- a/libstdc++-v3/libsupc++/nested_exception.h
+++ b/libstdc++-v3/libsupc++/nested_exception.h
@@ -159,7 +159,7 @@ namespace std
     rethrow_if_nested(const _Ex& __ex)
     { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/libsupc++/new_opa.cc b/libstdc++-v3/libsupc++/new_opa.cc
index b935936e19a..732fe827cda 100644
--- a/libstdc++-v3/libsupc++/new_opa.cc
+++ b/libstdc++-v3/libsupc++/new_opa.cc
@@ -26,7 +26,6 @@
 #include <bits/c++config.h>
 #include <stdlib.h>
 #include <stdint.h>
-#include <bits/exception_defines.h>
 #include <bit>
 #include "new"
 
@@ -44,6 +43,7 @@ using std::new_handler;
 using std::bad_alloc;
 
 #if ! _GLIBCXX_HOSTED
+using std::size_t;
 extern "C"
 {
 # if _GLIBCXX_HAVE_ALIGNED_ALLOC
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index edfb91fc6c5..812f39fe253 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -1907,10 +1907,9 @@ path::_M_split_cmpts()
 	  _M_cmpts.type(_Type::_Multi);
 	  _M_cmpts.reserve(_M_cmpts.size() + buf.size());
 	  auto output = _M_cmpts._M_impl->end();
-	  for (auto& c : buf)
+	  for (const auto& c : buf)
 	    {
-	      auto pos = c.str.data() - _M_pathname.data();
-	      ::new(output++) _Cmpt(c.str, c.type, pos);
+	      ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));
 	      ++_M_cmpts._M_impl->_M_size;
 	    }
 	  next = buf.begin();
@@ -1930,9 +1929,8 @@ path::_M_split_cmpts()
       auto output = _M_cmpts._M_impl->end();
       for (int i = 0; i < n; ++i)
 	{
-	  auto c = buf[i];
-	  auto pos = c.str.data() - _M_pathname.data();
-	  ::new(output++) _Cmpt(c.str, c.type, pos);
+	  const auto& c = buf[i];
+	  ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));
 	  ++_M_cmpts._M_impl->_M_size;
 	}
     }
diff --git a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
index 119b199ddff..25d1c9b5aca 100644
--- a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mtype,
 	       mtype&&, const typename mtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::map<int, int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<std::pair<const int, int>>> amtype;
+
+static_assert( std::is_nothrow_move_constructible<amtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::map<int, int, not_noexcept_less> emtype;
 
+static_assert( !std::is_nothrow_move_constructible<emtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emtype, emtype&&,
 	       const typename emtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
index 44c3015a282..af545ae297c 100644
--- a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mmtype,
 	       mmtype&&, const typename mmtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multimap<int, int, std::less<int>,
+		      not_noexcept_move_constructor_alloc<std::pair<const int, int>>> ammtype;
+
+static_assert( std::is_nothrow_move_constructible<ammtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multimap<int, int, not_noexcept_less> emmtype;
 
+static_assert( !std::is_nothrow_move_constructible<emmtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emmtype, emmtype&&,
 	       const typename emmtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
index 225b2206ad4..ed4d9128606 100644
--- a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mstype,
 	       mstype&&, const typename mstype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multiset<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> amstype;
+
+static_assert( std::is_nothrow_move_constructible<amstype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multiset<int, not_noexcept_less> emstype;
 
+static_assert( !std::is_nothrow_move_constructible<emstype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emstype, emstype&&,
 	       const typename emstype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
index acd84a8fcd0..dc96236a668 100644
--- a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<stype,
 	       stype&&, const typename stype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::set<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> astype;
+
+static_assert( std::is_nothrow_move_constructible<astype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::set<int, not_noexcept_less> estype;
 
+static_assert( !std::is_nothrow_move_constructible<estype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<estype, estype&&,
 	       const typename estype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
new file mode 100644
index 00000000000..473a5f1ce47
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
@@ -0,0 +1,69 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+// { dg-xfail-run-if "PR c++/65816" { *-*-* } }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..f859ec939d0
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
+			not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..b6b5b473553
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
new file mode 100644
index 00000000000..0a5ef1113d9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
@@ -0,0 +1,81 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <utility>
+#include <unordered_map>
+#include <vector>
+
+#include <testsuite_hooks.h>
+#include <testsuite_counter_type.h>
+#include <testsuite_allocator.h>
+
+void test01()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+
+  std::vector<pair<int, counter_type>> insts { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  typedef unordered_map<int, counter_type> Map;
+  Map m;
+
+  counter_type::reset();
+
+  m.insert(make_move_iterator(insts.begin()), make_move_iterator(insts.end()));
+
+  VERIFY( m.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+void test02()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+  using __gnu_test::propagating_allocator;
+
+  typedef propagating_allocator<pair<const int, counter_type>, false> Alloc;
+  typedef unordered_map<int, counter_type,
+			hash<int>, equal_to<int>,
+			Alloc> Map;
+
+  Alloc a1(1);
+  Map m1(3, a1);
+  m1 = { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  Alloc a2(2);
+  Map m2(3, a2);
+  m2 = { { 3, 0 }, { 4, 1 }, { 5, 2 } };
+
+  counter_type::reset();
+
+  m2 = move(m1);
+
+  VERIFY( m1.empty() );
+  VERIFY( m2.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..98e2b017ca9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,
+				       not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..e51ad5065a8
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..8511cb95421
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,
+				      not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..1ccb8b0cf41
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
new file mode 100644
index 00000000000..37110dd6eb0
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
@@ -0,0 +1,69 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+// { dg-xfail-run-if "PR c++/65816" { *-*-* } }
+
+#include <unordered_set>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
new file mode 100644
index 00000000000..b209f7627f5
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
@@ -0,0 +1,47 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+#include <testsuite_allocator.h>
+
+template<typename Alloc, typename T = typename Alloc::value_type>
+  using Set = std::unordered_set<T, std::hash<T>, std::equal_to<T>, Alloc>;
+
+// PR libstdc++/99985 - invalid constexpr function in C++11 mode
+
+void
+test01()
+{
+  using A = std::allocator<int>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( noexcept( Set<A>(std::move(s), a) ), "non-throwing" );
+}
+
+void
+test02()
+{
+  using A = __gnu_test::uneq_allocator<long>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( ! noexcept( Set<A>(std::move(s), a) ), "throwing" );
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..44db4aec6cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_set<int, std::hash<int>, std::equal_to<int>,
+				 not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..65df57613ae
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc b/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
index b503b0cdc1e..3c9c3927153 100644
--- a/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
+++ b/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
@@ -141,3 +141,29 @@ struct J
 // iterator_traits<J> matches constrained specialization in the library,
 // so use its value_type.
 static_assert( check_alias<J, int> );
+
+struct I2
+{
+  using element_type = int;
+};
+// iterator_traits<I2> is not specialized, and no standard specialization
+// matches, so use indirectly_readable_traits.
+static_assert( check_alias<I2, std::indirectly_readable_traits<I2>::value_type> );
+
+// LWG 3446
+struct I3
+{
+  using value_type = long;
+  using element_type = const long;
+};
+// iterator_traits<I3> is not specialized, and no standard specialization
+// matches, so use indirectly_readable_traits.
+static_assert( check_alias<I3, std::indirectly_readable_traits<I3>::value_type> );
+
+// Correction to LWG 3446
+struct I4
+{
+  using value_type = int;
+  using element_type = long;
+};
+static_assert( ! has_alias<I4> );
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc b/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc
new file mode 100644
index 00000000000..041d222d079
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/copy/debug/99402.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-D_GLIBCXX_DEBUG" }
+// { dg-do run }
+
+#include <algorithm>
+#include <set>
+#include <vector>
+
+// PR libstdc++/99402
+
+using namespace std;
+
+int main()
+{
+    // any container with non-random access iterators:
+    const set<int> source = { 0, 1 };
+    vector<int> dest(1);
+    copy(source.begin(), ++source.begin(), dest.begin());
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
index cf3724025f7..16175c4072a 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc
@@ -18,7 +18,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 8.4.9 path decomposition [path.decompose]
+// C++17 30.10.8.4.9 path decomposition [fs.path.decompose]
 
 #include <filesystem>
 #include <testsuite_hooks.h>
@@ -64,9 +64,32 @@ test02()
   }
 }
 
+void
+test03()
+{
+  const std::string narrow = "there/are/no/wrong/turns/only/unexpected/paths";
+  const path::string_type s(narrow.begin(), narrow.end());
+  const auto s1 = s.substr(0, s.length() - 6);    // remove "/paths"
+  const auto s2 = s1.substr(0, s1.length() - 16); // remove "/only/..."
+
+  // PR libstdc++/99805
+  path p = path::string_type(s);
+  auto pp = p.parent_path();
+  VERIFY( pp.native() == s1 );
+  pp = pp.parent_path().parent_path();
+  VERIFY( pp.native() == s2 );
+
+  path from_lval(s);
+  pp = from_lval.parent_path();
+  VERIFY( pp.native() == s1 );
+  pp = pp.parent_path().parent_path();
+  VERIFY( pp.native() == s2 );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
index b77d6a29e3d..5fffdd97691 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v6/members.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <sstream>
diff --git a/libstdc++-v3/testsuite/std/ranges/97600.cc b/libstdc++-v3/testsuite/std/ranges/97600.cc
new file mode 100644
index 00000000000..d992318259d
--- /dev/null
+++ b/libstdc++-v3/testsuite/std/ranges/97600.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+// PR libstdc++/97600
+
+#include <sstream>
+#include <ranges>
+
+void
+test01()
+{
+  std::ranges::basic_istream_view<int, char, std::char_traits<char>> v;
+  v.begin();
+  static_assert(std::ranges::range<decltype(v)>);
+}
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
index 94dd7c94505..2e15250d31e 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
@@ -89,10 +89,26 @@ test03()
   VERIFY( (next(b_const, 2) - b_const) == 2 );
 }
 
+void
+test05()
+{
+  // LWG 3502
+  std::vector<int> vec = {42};
+  auto r1 = vec
+    | views::transform([](auto c) { return std::make_tuple(c, c); })
+    | views::keys;
+  VERIFY( ranges::equal(r1, (int[]){42}) );
+
+  std::tuple<int, int> a[] = {{1,2},{3,4}};
+  auto r2 = a | views::keys;
+  VERIFY( r2[0] == 1 && r2[1] == 3 );
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
index fe895827fc5..661b55dca2c 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
@@ -152,6 +152,17 @@ test08()
   VERIFY( i == v.end() );
 }
 
+void
+test10()
+{
+  // LWG 3505
+  auto to_string = [] (auto r) {
+    return std::string(r.begin(), ranges::next(r.begin(), r.end()));
+  };
+  auto v = "xxyx"sv | views::split("xy"sv) | views::transform(to_string);
+  VERIFY( ranges::equal(v, (std::string_view[]){"x", "x"}) );
+}
+
 int
 main()
 {
@@ -163,4 +174,5 @@ main()
   test06();
   test07();
   test08();
+  test10();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc b/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
index 5c2f1de45ad..3d21774c966 100644
--- a/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
+++ b/libstdc++-v3/testsuite/std/ranges/subrange/lwg3282_neg.cc
@@ -29,3 +29,18 @@ struct Base {};
 struct Derived : Base {};
 subrange<Derived*> sd;
 subrange<Base*> sb = sd; // { dg-error "conversion" }
+
+void
+test_lwg3404()
+{
+  // LWG 3404. Finish removing subrange's conversions from pair-like
+  std::pair<char*, char*> p;
+  subrange sb1(p);			// { dg-error "no matching function" }
+  // { dg-error "class template argument deduction" "" { target *-*-* } 38 }
+  subrange sb2(p, p.second - p.first);	// { dg-error "no matching function" }
+  // { dg-error "class template argument deduction" "" { target *-*-* } 40 }
+
+  // { dg-prune-output "in requirements with" }
+  // { dg-prune-output "template constraint failure" }
+  // { dg-prune-output "unsatisfied constraints" }
+}
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index 2be23318cd4..982fdf70563 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,11 @@
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* generate_libstdcxx_web_docs: Add --disable-multilib to
+	configure command.
+
 2021-04-08  Release Manager
 
 	* GCC 10.3.0 released.
diff --git a/maintainer-scripts/generate_libstdcxx_web_docs b/maintainer-scripts/generate_libstdcxx_web_docs
index 74886356bc7..29572172761 100755
--- a/maintainer-scripts/generate_libstdcxx_web_docs
+++ b/maintainer-scripts/generate_libstdcxx_web_docs
@@ -43,7 +43,7 @@ do
   [ $dir == 'libstdc++-v3' ] || disabled_libs="$disabled_libs --disable-$dir"
 done
 set -x
-${SRCDIR}/configure --enable-languages=c,c++ --disable-gcc $disabled_libs --docdir=/docs
+${SRCDIR}/configure --enable-languages=c,c++ --disable-gcc --disable-multilib $disabled_libs --docdir=/docs
 eval `grep '^target=' config.log`
 make configure-target
 # If the following step fails with an error like
