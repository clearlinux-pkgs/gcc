GCC Administrator (4):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Iain Sandoe (1):
      coroutines: Update TREE_SIDE_EFFECTS on inserted bind exprs.

Jakub Jelinek (11):
      Bump BASE-VER.
      c: Fix ICE with _Atomic side-effect in nested fn param decls [PR94842]
      diagnostics: get_option_html_page fixes
      x86: Fix *vec_dupv4hi constraints [PR94942]
      combine: Don't replace SET_SRC with REG_EQUAL note content if SET_SRC has side-effects [PR94873]
      riscv: Fix up riscv_atomic_assign_expand_fenv [PR94950]
      c++: Don't synthesize sfk_comparison method multiple times [PR94907]
      c++: Avoid strict_aliasing_warning on dependent types or expressions [PR94951]
      c-family: Fix error-recovery ICE on __builtin_speculation_safe_value [PR94968]
      testsuite: Improve g++.dg/ext/attr-parm-1.C testcase [PR94946]
      tree: Avoid variable sharing in get_narrower [PR94724]

Jonathan Wakely (1):
      libstdc++: Replace deduced return type in ranges::iter_move (PR 92894)

Marek Polacek (2):
      c++: ICE in value_dependent_expression_p in C++98 mode [PR94938]
      c++: Parenthesized-init of aggregates accepts invalid code [PR94885]

Mark Eggleston (1):
      Fortran : Spurious warning message with -Wsurprising PR59107

Martin Liska (2):
      Fix optindex entries for 2 options.
      Fix typo in fprofile-prefix-path.

Sebastian Huber (1):
      RTEMS: Improve GCC specification

Uros Bizjak (1):
      alpha: Implement the PR94780 fix for alpha.

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 4149c39eec6..23127993ac0 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-10.1.0
+10.1.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index caef1920f92..d89e3c66c77 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,76 @@
+2020-05-11  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2020-05-05  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rtems.h (RTEMS_STARTFILE_SPEC): Define if undefined.
+	(RTEMS_ENDFILE_SPEC): Likewise.
+	(STARTFILE_SPEC): Update comment.  Add RTEMS_STARTFILE_SPEC.
+	(ENDFILE_SPEC): Add RTEMS_ENDFILE_SPEC.
+	(LIB_SPECS): Support -nodefaultlibs option.
+	* config/or1k/rtems.h (RTEMS_STARTFILE_SPEC): Define.
+	(RTEMS_ENDFILE_SPEC): Likewise.
+	* config/rs6000/rtems.h (RTEMS_STARTFILE_SPEC): Likewise.
+	(RTEMS_ENDFILE_SPEC): Likewise.
+	* config/v850/rtems.h (RTEMS_STARTFILE_SPEC): Likewise.
+	(RTEMS_ENDFILE_SPEC): Likewise.
+
+2020-05-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-05-11  Martin Liska  <mliska@suse.cz>
+
+	PR c/95040
+	* common.opt: Fix typo in option description.
+
+2020-05-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94724
+	* tree.c (get_narrower): Reuse the op temporary instead of
+	shadowing it.
+
+2020-05-07  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for the first assignments to
+	fenv_var and new_fenv_var.
+
+2020-05-07  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-05-07  Martin Liska  <mliska@suse.cz>
+
+	* doc/invoke.texi: Fix 2 optindex entries.
+
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94950
+	* config/riscv/riscv-builtins.c (riscv_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for first assignment to old_flags.
+
+	PR rtl-optimization/94873
+	* combine.c (combine_instructions): Don't optimize using REG_EQUAL
+	note if SET_SRC (set) has side-effects.
+
+	2020-05-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94942
+	* config/i386/mmx.md (*vec_dupv4hi): Use xYw constraints instead of Yv.
+
+	2020-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* opts.c (get_option_html_page): Instead of hardcoding a list of
+	options common between C/C++ and Fortran only use gfortran/
+	documentation for warnings that have CL_Fortran set but not
+	CL_C or CL_CXX.
+
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 10.1.1.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 61259afda37..75eacd1efbc 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,11 @@
+202-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94968
+	* c-common.c (speculation_safe_value_resolve_params): Return false if
+	error_operand_p (val2).
+	(resolve_overloaded_builtin) <case BUILT_IN_SPECULATION_SAFE_VALUE_N>:
+	Remove extraneous semicolon.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 4e46178d595..d164f1e2f1f 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -6716,6 +6716,8 @@ speculation_safe_value_resolve_params (location_t loc, tree orig_function,
       tree val2 = (*params)[1];
       if (TREE_CODE (TREE_TYPE (val2)) == ARRAY_TYPE)
 	val2 = default_conversion (val2);
+      if (error_operand_p (val2))
+	return false;
       if (!(TREE_TYPE (val) == TREE_TYPE (val2)
 	    || useless_type_conversion_p (TREE_TYPE (val), TREE_TYPE (val2))))
 	{
@@ -7400,7 +7402,7 @@ resolve_overloaded_builtin (location_t loc, tree function,
       {
 	tree new_function, first_param, result;
 	enum built_in_function fncode
-	  = speculation_safe_value_resolve_call (function, params);;
+	  = speculation_safe_value_resolve_call (function, params);
 
 	if (fncode == BUILT_IN_NONE)
 	  return error_mark_node;
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 42bc68ea556..7fb870148da 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,14 @@
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94842
+	* c-decl.c (set_labels_context_r): In addition to context-less
+	LABEL_DECLs adjust also LABEL_DECLs with context equal to
+	parent function if any.
+	(store_parm_decls): Adjust comment.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index 0b7f4376dd3..b3e05be0af8 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -9722,15 +9722,18 @@ store_parm_decls_from (struct c_arg_info *arg_info)
   store_parm_decls ();
 }
 
-/* Called by walk_tree to look for and update context-less labels.  */
+/* Called by walk_tree to look for and update context-less labels
+   or labels with context in the parent function.  */
 
 static tree
 set_labels_context_r (tree *tp, int *walk_subtrees, void *data)
 {
+  tree ctx = static_cast<tree>(data);
   if (TREE_CODE (*tp) == LABEL_EXPR
-      && DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == NULL_TREE)
+      && (DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == NULL_TREE
+	  || DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == DECL_CONTEXT (ctx)))
     {
-      DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) = static_cast<tree>(data);
+      DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) = ctx;
       *walk_subtrees = 0;
     }
 
@@ -9800,7 +9803,11 @@ store_parm_decls (void)
 	 gotos, labels, etc.  Because at that time the function decl
 	 for F has not been created yet, those labels do not have any
 	 function context.  But we have the fndecl now, so update the
-	 labels accordingly.  gimplify_expr would crash otherwise.  */
+	 labels accordingly.  gimplify_expr would crash otherwise.
+	 Or with nested functions the labels could be created with parent
+	 function's context, while when the statement is emitted at the
+	 start of the nested function, it needs the nested function's
+	 context.  */
       walk_tree_without_duplicates (&arg_info->pending_sizes,
 				    set_labels_context_r, fndecl);
       add_stmt (arg_info->pending_sizes);
diff --git a/gcc/combine.c b/gcc/combine.c
index 4c324f38660..f69413a34d0 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -1485,6 +1485,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)
 	      if ((set = single_set (temp)) != 0
 		  && (note = find_reg_equal_equiv_note (temp)) != 0
 		  && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST
+		  && ! side_effects_p (SET_SRC (set))
 		  /* Avoid using a register that may already been marked
 		     dead by an earlier instruction.  */
 		  && ! unmentioned_reg_p (note, SET_SRC (set))
diff --git a/gcc/common.opt b/gcc/common.opt
index d33383b523c..65a82410abc 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -2210,7 +2210,7 @@ Enum(profile_update) String(prefer-atomic) Value(PROFILE_UPDATE_PREFER_ATOMIC)
 
 fprofile-prefix-path=
 Common Joined RejectNegative Var(profile_prefix_path)
-Remove prefix from absolute path before manging name for -fprofile-generate= and -fprofile-use=.
+Remove prefix from absolute path before mangling name for -fprofile-generate= and -fprofile-use=.
 
 fprofile-generate
 Common
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 7e5d1cbb0c4..49b5a24d4b0 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -9775,8 +9775,8 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
     = build_fn_decl ("__ieee_set_fp_control",
 		     build_function_type_list (void_type_node, NULL));
   mask = build_int_cst (long_unsigned_type_node, ~SWCR_STATUS_MASK);
-  ld_fenv = build2 (MODIFY_EXPR, long_unsigned_type_node,
-		    fenv_var, build_call_expr (get_fpscr, 0));
+  ld_fenv = build4 (TARGET_EXPR, long_unsigned_type_node, fenv_var,
+		    build_call_expr (get_fpscr, 0), NULL_TREE, NULL_TREE);
   masked_fenv = build2 (BIT_AND_EXPR, long_unsigned_type_node, fenv_var, mask);
   hold_fnclex = build_call_expr (set_fpscr, 1, masked_fenv);
   *hold = build2 (COMPOUND_EXPR, void_type_node,
@@ -9797,8 +9797,8 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
        __atomic_feraiseexcept (new_fenv_var);  */
 
   new_fenv_var = create_tmp_var_raw (long_unsigned_type_node);
-  reload_fenv = build2 (MODIFY_EXPR, long_unsigned_type_node, new_fenv_var,
-			build_call_expr (get_fpscr, 0));
+  reload_fenv = build4 (TARGET_EXPR, long_unsigned_type_node, new_fenv_var,
+			build_call_expr (get_fpscr, 0), NULL_TREE, NULL_TREE);
   restore_fnenv = build_call_expr (set_fpscr, 1, fenv_var);
   atomic_feraiseexcept = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);
   update_call
diff --git a/gcc/config/i386/mmx.md b/gcc/config/i386/mmx.md
index c3f195bb34a..472f90f9bc1 100644
--- a/gcc/config/i386/mmx.md
+++ b/gcc/config/i386/mmx.md
@@ -1613,10 +1613,10 @@
    (set_attr "mode" "DI")])
 
 (define_insn_and_split "*vec_dupv4hi"
-  [(set (match_operand:V4HI 0 "register_operand" "=y,Yv,Yw")
+  [(set (match_operand:V4HI 0 "register_operand" "=y,xYw,Yw")
 	(vec_duplicate:V4HI
 	  (truncate:HI
-	    (match_operand:SI 1 "register_operand" "0,Yv,r"))))]
+	    (match_operand:SI 1 "register_operand" "0,xYw,r"))))]
   "(TARGET_MMX || TARGET_MMX_WITH_SSE)
    && (TARGET_SSE || TARGET_3DNOW_A)"
   "@
diff --git a/gcc/config/or1k/rtems.h b/gcc/config/or1k/rtems.h
index 94731435f44..d4b8fef3dc7 100644
--- a/gcc/config/or1k/rtems.h
+++ b/gcc/config/or1k/rtems.h
@@ -28,3 +28,6 @@
 	builtin_assert ("system=rtems");	\
     }						\
   while (0)
+
+#define RTEMS_STARTFILE_SPEC "crtbegin%O%s"
+#define RTEMS_ENDFILE_SPEC "crtend%O%s"
diff --git a/gcc/config/riscv/riscv-builtins.c b/gcc/config/riscv/riscv-builtins.c
index 201fdb52f20..a45108e0355 100644
--- a/gcc/config/riscv/riscv-builtins.c
+++ b/gcc/config/riscv/riscv-builtins.c
@@ -283,8 +283,8 @@ riscv_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   tree fsflags = GET_BUILTIN_DECL (CODE_FOR_riscv_fsflags);
   tree old_flags = create_tmp_var_raw (RISCV_ATYPE_USI);
 
-  *hold = build2 (MODIFY_EXPR, RISCV_ATYPE_USI, old_flags,
-		  build_call_expr (frflags, 0));
+  *hold = build4 (TARGET_EXPR, RISCV_ATYPE_USI, old_flags,
+		  build_call_expr (frflags, 0), NULL_TREE, NULL_TREE);
   *clear = build_call_expr (fsflags, 1, old_flags);
   *update = NULL_TREE;
 }
diff --git a/gcc/config/rs6000/rtems.h b/gcc/config/rs6000/rtems.h
index 6ce05bfc6d6..40db6606f17 100644
--- a/gcc/config/rs6000/rtems.h
+++ b/gcc/config/rs6000/rtems.h
@@ -292,3 +292,6 @@
   "%{mads|myellowknife|mmvme|msim:%G %L %G;" \
   "!mcall-*|mcall-linux:" GNU_USER_TARGET_LINK_GCC_C_SEQUENCE_SPEC ";" \
   ":%G %L %G}"
+
+#define RTEMS_STARTFILE_SPEC "ecrti%O%s rtems_crti%O%s crtbegin%O%s"
+#define RTEMS_ENDFILE_SPEC "crtend%O%s rtems_crtn%O%s ecrtn%O%s"
diff --git a/gcc/config/rtems.h b/gcc/config/rtems.h
index 55d568f83b5..30ad6258949 100644
--- a/gcc/config/rtems.h
+++ b/gcc/config/rtems.h
@@ -22,15 +22,25 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+#ifndef RTEMS_STARTFILE_SPEC
+#define RTEMS_STARTFILE_SPEC "crti%O%s crtbegin%O%s"
+#endif
+
+#ifndef RTEMS_ENDFILE_SPEC
+#define RTEMS_ENDFILE_SPEC "crtend%O%s crtn%O%s"
+#endif
+
 /*
- * Dummy start/end specification to let linker work as
- * needed by autoconf scripts using this compiler.
+ * The crt0.o is a dummy start file to let the linker work as needed by
+ * autoconf scripts using this compiler.
  */
 #undef STARTFILE_SPEC
-#define STARTFILE_SPEC "crt0.o%s"
+#define STARTFILE_SPEC "%{!qrtems:crt0%O%s} " \
+"%{qrtems:%{!nostdlib:%{!nostartfiles:" RTEMS_STARTFILE_SPEC "}}}"
 
 #undef ENDFILE_SPEC
-#define ENDFILE_SPEC   ""
+#define ENDFILE_SPEC \
+"%{qrtems:%{!nostdlib:%{!nostartfiles:" RTEMS_ENDFILE_SPEC "}}}"
 
 /*
  * Some targets do not set up LIB_SPECS, override it, here.
@@ -38,10 +48,10 @@
 #define STD_LIB_SPEC "%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"
 
 #undef LIB_SPEC
-#define LIB_SPEC "%{!qrtems: " STD_LIB_SPEC "} " \
-"%{!nostdlib: %{qrtems: --start-group \
- -lrtemsbsp -lrtemscpu \
- -latomic -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
+#define LIB_SPEC "%{!qrtems:" STD_LIB_SPEC "} " \
+"%{qrtems:%{!nostdlib:%{!nodefaultlibs:" \
+"--start-group -lrtemsbsp -lrtemscpu -latomic -lc -lgcc --end-group} " \
+"%{!qnolinkcmds:-T linkcmds%s}}}"
 
 #define TARGET_POSIX_IO
 
diff --git a/gcc/config/v850/rtems.h b/gcc/config/v850/rtems.h
index 3f7d39a2cd1..e261ea3b417 100644
--- a/gcc/config/v850/rtems.h
+++ b/gcc/config/v850/rtems.h
@@ -39,3 +39,6 @@
 %{!mv850es:%{!mv850e1:%{mv*:-mv%*}} \
 %{m8byte-align:-m8byte-align} \
 %{mgcc-abi:-mgcc-abi}}"
+
+#define RTEMS_STARTFILE_SPEC ""
+#define RTEMS_ENDFILE_SPEC ""
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index e99485b12db..b009a7810ca 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,47 @@
+2020-05-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2020-05-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/95003
+	* coroutines.cc (build_actor_fn): Ensure that bind scopes
+	are marked as having side-effects where necessary.
+	(replace_statement_captures): Likewise.
+	(morph_fn_to_coro): Likewise.
+
+2020-05-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2020-05-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/94885
+	* typeck2.c (process_init_constructor_record): Return PICFLAG_ERRONEOUS
+	if an initializer element was erroneous.
+
+2020-05-07  Marek Polacek  <polacek@redhat.com>
+	
+	Backported from mainline
+	2020-05-06  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/94938
+	* pt.c (tsubst_copy_and_build): Call type_dependent_expression_p_push
+	instead of uses_template_parms.  Move the warning_sentinels after the
+	RECURs.
+
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94951
+	* typeck.c (cp_strict_aliasing_warning): New function.
+	(cp_build_indirect_ref_1, build_reinterpret_cast_1): Use
+	it instead of strict_aliasing_warning.
+
+	PR c++/94907
+	* method.c (defaulted_late_check): Don't call synthesize_method
+	on constexpr sfk_comparison if it has been called on it already.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/cp/coroutines.cc b/gcc/cp/coroutines.cc
index e90d3d5a3b3..db687c32b97 100644
--- a/gcc/cp/coroutines.cc
+++ b/gcc/cp/coroutines.cc
@@ -1971,8 +1971,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,
   current_stmt_tree ()->stmts_are_full_exprs_p = 1;
   tree stmt = begin_compound_stmt (BCS_FN_BODY);
 
-  /* ??? Can we dispense with the enclosing bind if the function body does
-     not start with a bind_expr? (i.e. there's no contained scopes).  */
   tree actor_bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);
   tree top_block = make_node (BLOCK);
   BIND_EXPR_BLOCK (actor_bind) = top_block;
@@ -2423,8 +2421,8 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,
 		       continue_label, continuation, 2};
   cp_walk_tree (&actor_body, await_statement_expander, &data, NULL);
 
-  actor_body = pop_stmt_list (actor_body);
-  BIND_EXPR_BODY (actor_bind) = actor_body;
+  BIND_EXPR_BODY (actor_bind) = pop_stmt_list (actor_body);
+  TREE_SIDE_EFFECTS (actor_bind) = true;
 
   finish_compound_stmt (stmt);
   DECL_SAVED_TREE (actor) = pop_stmt_list (actor_outer);
@@ -2889,6 +2887,7 @@ replace_statement_captures (tree *stmt, void *d)
 	}
     }
   BIND_EXPR_BLOCK (aw_bind) = b_block;
+  TREE_SIDE_EFFECTS (aw_bind) = TREE_SIDE_EFFECTS (BIND_EXPR_BODY (aw_bind));
   *stmt = aw_bind;
 }
 
@@ -3602,10 +3601,13 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)
 	{
 	  tree tlist = NULL_TREE;
 	  append_to_statement_list_force (fnbody, &tlist);
+	  TREE_SIDE_EFFECTS (tlist) = TREE_SIDE_EFFECTS (fnbody);
 	  BIND_EXPR_BODY (update_body) = tlist;
 	}
       tree new_body_list = NULL_TREE;
-      append_to_statement_list_force (update_body, &new_body_list);
+      TREE_SIDE_EFFECTS (update_body) = true;
+      append_to_statement_list (update_body, &new_body_list);
+      TREE_SIDE_EFFECTS (new_body_list) = true;
       fnbody = new_body_list;
     }
 
@@ -4301,7 +4303,9 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)
   /* Finish up the ramp function.  */
   BIND_EXPR_VARS (gro_context_bind) = gro_bind_vars;
   BIND_EXPR_BODY (gro_context_bind) = pop_stmt_list (gro_context_body);
+  TREE_SIDE_EFFECTS (gro_context_bind) = true;
   BIND_EXPR_BODY (ramp_bind) = pop_stmt_list (ramp_body);
+  TREE_SIDE_EFFECTS (ramp_bind) = true;
 
   /* We know the "real" promise and have a frame layout with a slot for each
      suspend point, so we can build an actor function (which contains the
@@ -4420,6 +4424,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)
 	  BLOCK_SUPERCONTEXT (replace_blk) = tcb_block;
 	  BLOCK_SUBBLOCKS (tcb_block) = replace_blk;
 	  BIND_EXPR_BLOCK (fnbody) = tcb_block;
+	  TREE_SIDE_EFFECTS (fnbody) = true;
 	}
     }
   else if (pedantic)
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index fb2dd47013f..47f96aa845e 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -2939,7 +2939,7 @@ defaulted_late_check (tree fn)
     {
       /* If the function was declared constexpr, check that the definition
 	 qualifies.  Otherwise we can define the function lazily.  */
-      if (DECL_DECLARED_CONSTEXPR_P (fn))
+      if (DECL_DECLARED_CONSTEXPR_P (fn) && !DECL_INITIAL (fn))
 	synthesize_method (fn);
       return;
     }
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index d28585efd17..b8f03d18541 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -19408,14 +19408,16 @@ tsubst_copy_and_build (tree t,
       {
 	/* If T was type-dependent, suppress warnings that depend on the range
 	   of the types involved.  */
-	bool was_dep = uses_template_parms (t);
+	bool was_dep = type_dependent_expression_p_push (t);
+
+	tree op0 = RECUR (TREE_OPERAND (t, 0));
+	tree op1 = RECUR (TREE_OPERAND (t, 1));
+
 	warning_sentinel s1(warn_type_limits, was_dep);
 	warning_sentinel s2(warn_div_by_zero, was_dep);
 	warning_sentinel s3(warn_logical_op, was_dep);
 	warning_sentinel s4(warn_tautological_compare, was_dep);
 
-	tree op0 = RECUR (TREE_OPERAND (t, 0));
-	tree op1 = RECUR (TREE_OPERAND (t, 1));
 	tree r = build_x_binary_op
 	  (input_location, TREE_CODE (t),
 	   op0,
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 8e3188a415d..13d9602c32b 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -3318,6 +3318,22 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,
     return rval;
 }
 
+/* Like c-family strict_aliasing_warning, but don't warn for dependent
+   types or expressions.  */
+
+static bool
+cp_strict_aliasing_warning (location_t loc, tree type, tree expr)
+{
+  if (processing_template_decl)
+    {
+      tree e = expr;
+      STRIP_NOPS (e);
+      if (dependent_type_p (type) || type_dependent_expression_p (e))
+	return false;
+    }
+  return strict_aliasing_warning (loc, type, expr);
+}
+
 /* The implementation of the above, and of indirection implied by other
    constructs.  If DO_FOLD is true, fold away INDIRECT_REF of ADDR_EXPR.  */
 
@@ -3360,10 +3376,10 @@ cp_build_indirect_ref_1 (location_t loc, tree ptr, ref_operator errorstring,
 	  /* If a warning is issued, mark it to avoid duplicates from
 	     the backend.  This only needs to be done at
 	     warn_strict_aliasing > 2.  */
-	  if (warn_strict_aliasing > 2)
-	    if (strict_aliasing_warning (EXPR_LOCATION (ptr),
-					 type, TREE_OPERAND (ptr, 0)))
-	      TREE_NO_WARNING (ptr) = 1;
+	  if (warn_strict_aliasing > 2
+	      && cp_strict_aliasing_warning (EXPR_LOCATION (ptr),
+					     type, TREE_OPERAND (ptr, 0)))
+	    TREE_NO_WARNING (ptr) = 1;
 	}
 
       if (VOID_TYPE_P (t))
@@ -7777,7 +7793,7 @@ build_reinterpret_cast_1 (location_t loc, tree type, tree expr,
       expr = cp_build_addr_expr (expr, complain);
 
       if (warn_strict_aliasing > 2)
-	strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
+	cp_strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
 
       if (expr != error_mark_node)
 	expr = build_reinterpret_cast_1
@@ -7891,7 +7907,7 @@ build_reinterpret_cast_1 (location_t loc, tree type, tree expr,
 
       if (warn_strict_aliasing <= 2)
 	/* strict_aliasing_warning STRIP_NOPs its expr.  */
-	strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
+	cp_strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
 
       return build_nop_reinterpret (type, expr);
     }
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 56fd9bafa7e..9e5d145a6cd 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -1661,7 +1661,11 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,
 	      ++idx;
 	    }
 	}
-      if (next)
+      if (next == error_mark_node)
+	/* We skip initializers for empty bases/fields, so skipping an invalid
+	   one could make us accept invalid code.  */
+	return PICFLAG_ERRONEOUS;
+      else if (next)
 	/* Already handled above.  */;
       else if (DECL_INITIAL (field))
 	{
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 527d362533a..f98161391a0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -11399,7 +11399,7 @@ default, GCC emits an error message when an inconsistent profile is detected.
 This option is enabled by @option{-fauto-profile}.
 
 @item -fprofile-partial-training
-@opindex fprofile-use
+@opindex fprofile-partial-training
 With @code{-fprofile-use} all portions of programs not executed during train
 run are optimized agressively for size rather than speed.  In some cases it is
 not practical to train all possible hot paths in the program. (For
@@ -13393,6 +13393,7 @@ location.  If you combine the option with multiple source files,
 the @file{.gcno} file will be overwritten.
 
 @item -fprofile-prefix-path=@var{path}
+@opindex fprofile-prefix-path
 
 This option can be used in combination with
 @option{profile-generate=}@var{profile_dir} and
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index fb2537dd8ec..5ccf52a45b4 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,20 @@
+2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+    
+	Backported from mainline
+	2020-05-11  Janus Weil  <janus@gcc.gnu.org>
+		    Dominique d'Humieres  <dominiq@lps.ens.fr>
+    
+	PR fortran/59107
+	* gfortran.h: Rename field resolved as resolve_symbol_called
+	and assign two 2 bits instead of 1.
+	* interface.c (check_dtio_interface1): Use new field name.
+	(gfc_find_typebound_dtio_proc): Use new field name.
+	* resolve.c (gfc_resolve_intrinsic): Replace check of the formal
+	field with resolve_symbol_called is at least 2, if it is not
+	set the field to 2.  (resolve_typebound_procedure): Use new field
+	name.  (resolve_symbol): Use new field name and check whether it
+	is at least 1, if it is not set the field to 1.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 4e1da8c88a0..7094791e871 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -1621,7 +1621,10 @@ typedef struct gfc_symbol
   /* Set if the symbol is used in a function result specification .  */
   unsigned fn_result_spec:1;
   /* Used to avoid multiple resolutions of a single symbol.  */
-  unsigned resolved:1;
+  /* = 2 if this has already been resolved as an intrinsic,
+       in gfc_resolve_intrinsic,
+     = 1 if it has been resolved in resolve_symbol.  */
+  unsigned resolve_symbol_called:2;
   /* Set if this is a module function or subroutine with the
      abreviated declaration in a submodule.  */
   unsigned abr_modproc_decl:1;
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index ba1c8bc322e..f33c6632b45 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -5015,7 +5015,7 @@ check_dtio_interface1 (gfc_symbol *derived, gfc_symtree *tb_io_st,
     gfc_error ("DTIO procedure %qs at %L must be a subroutine",
 	       dtio_sub->name, &dtio_sub->declared_at);
 
-  if (!dtio_sub->resolved)
+  if (!dtio_sub->resolve_symbol_called)
     gfc_resolve_formal_arglist (dtio_sub);
 
   arg_num = 0;
@@ -5149,7 +5149,8 @@ gfc_find_typebound_dtio_proc (gfc_symbol *derived, bool write, bool formatted)
   gfc_symtree *tb_io_st = NULL;
   bool t = false;
 
-  if (!derived || !derived->resolved || derived->attr.flavor != FL_DERIVED)
+  if (!derived || !derived->resolve_symbol_called
+      || derived->attr.flavor != FL_DERIVED)
     return NULL;
 
   /* Try to find a typebound DTIO binding.  */
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index fd3b025a84f..88ba88d8bf3 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1753,9 +1753,11 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)
   gfc_intrinsic_sym* isym = NULL;
   const char* symstd;
 
-  if (sym->formal)
+  if (sym->resolve_symbol_called >= 2)
     return true;
 
+  sym->resolve_symbol_called = 2;
+
   /* Already resolved.  */
   if (sym->from_intmod && sym->ts.type != BT_UNKNOWN)
     return true;
@@ -13909,7 +13911,7 @@ resolve_typebound_procedure (gfc_symtree* stree)
     {
       /* If proc has not been resolved at this point, proc->name may
 	 actually be a USE associated entity. See PR fortran/89647. */
-      if (!proc->resolved
+      if (!proc->resolve_symbol_called
 	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
 	{
 	  gfc_symbol *tmp;
@@ -15154,9 +15156,9 @@ resolve_symbol (gfc_symbol *sym)
   gfc_array_spec *as;
   bool saved_specification_expr;
 
-  if (sym->resolved)
+  if (sym->resolve_symbol_called >= 1)
     return;
-  sym->resolved = 1;
+  sym->resolve_symbol_called = 1;
 
   /* No symbol will ever have union type; only components can be unions.
      Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION
diff --git a/gcc/opts.c b/gcc/opts.c
index c212a1a57dc..4429d82e61f 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -3141,25 +3141,15 @@ get_option_html_page (int option_index)
     return "gcc/Static-Analyzer-Options.html";
 
 #ifdef CL_Fortran
-  if (cl_opt->flags & CL_Fortran)
-    {
-      switch (option_index)
-	{
-	default:
-	  /* Most Fortran warnings are documented on this page.  */
-	  return "gfortran/Error-and-Warning-Options.html";
-
-	case OPT_Wdate_time:
-	case OPT_Wconversion:
-	case OPT_Wconversion_extra:
-	case OPT_Wmissing_include_dirs:
-	case OPT_Wopenmp_simd:
-	  /* These warnings are marked in fortran/lang.opt as
-	     "Documented in C" and thus use the common
-	     Warning-Options page below.  */
-	  break;
-	}
-    }
+  if ((cl_opt->flags & CL_Fortran) != 0
+      /* If it is option common to both C/C++ and Fortran, it is documented
+	 in gcc/ rather than gfortran/ docs.  */
+      && (cl_opt->flags & CL_C) == 0
+#ifdef CL_CXX
+      && (cl_opt->flags & CL_CXX) == 0
+#endif
+     )
+    return "gfortran/Error-and-Warning-Options.html";
 #endif
 
   return "gcc/Warning-Options.html";
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 348894049cc..b98472df541 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,51 @@
+2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+    
+	Backported from mainline
+	2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/59107
+	* gfortran.dg/pr59107.f90: New test.
+
+2020-05-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2020-05-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/95003
+	* g++.dg/coroutines/torture/pr95003.C: New test.
+
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94946
+	* g++.dg/ext/attr-parm-1.C: Enable the test also for lp64 x86, use
+	sysv_abi and ms_abi attributes in that case instead of fastcall and
+	no attribute.
+
+	PR c/94968
+	* gcc.dg/pr94968.c: New test.
+
+	Backported from mainline
+	2020-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94951
+	* g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C: New test.
+
+	PR c++/94907
+	* g++.dg/cpp2a/spaceship-synth8.C: New test.
+
+	PR rtl-optimization/94873
+	* gcc.dg/pr94873.c: New test.
+
+	2020-05-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94942
+	* gcc.target/i386/pr94942.c: New test.
+
+	2020-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94842
+	* gcc.dg/pr94842.c: New test.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/gcc/testsuite/g++.dg/coroutines/torture/pr95003.C b/gcc/testsuite/g++.dg/coroutines/torture/pr95003.C
new file mode 100644
index 00000000000..eda785827ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/coroutines/torture/pr95003.C
@@ -0,0 +1,50 @@
+// { dg-do run }
+
+#include "../coro.h"
+#include "../coro1-ret-int-yield-int.h"
+
+// This tests that, when we insert bind scopes to contain variables that
+// have been promoted from compiler temporaries to extend their lifetimes
+// to a containing full expression, the inserted bind scopes have their
+// tree-side-effects set.
+
+struct Awaitable {
+  int v;
+  Awaitable (int _v) : v(_v) {}
+  bool await_ready() { return false; }
+  void await_suspend(std::coroutine_handle<coro1::promise_type>) {}
+  int await_resume() { return v; }
+  auto operator co_await() { return *this; }
+};
+
+coro1
+my_coro
+(int x)
+{
+  int sum = 0;
+  for (unsigned i = 0; i < 100; ++i) {
+    sum += co_await Awaitable{x+1};
+  }
+  co_return sum;
+}
+
+int main ()
+{
+  PRINT ("main: create coro1");
+  struct coro1 f_coro = my_coro (0);
+
+  PRINT ("main: OK -- looping");
+
+  do {
+    f_coro.handle.resume();
+  } while (!f_coro.handle.done());
+
+  int y = f_coro.handle.promise().get_value();
+  if (y != 100)
+    {
+      PRINTF ("main: y is wrong : %d, should be 100\n", y);
+      abort ();
+    }
+  puts ("main: done");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/paren-init26.C b/gcc/testsuite/g++.dg/cpp2a/paren-init26.C
new file mode 100644
index 00000000000..0b98ebf43bb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/paren-init26.C
@@ -0,0 +1,14 @@
+// PR c++/94885 - paren-init of aggregates accepts invalid code.
+// { dg-do compile { target c++2a } }
+
+template <typename T, typename = decltype(T(0))> // { dg-error "could not convert" }
+void foo();
+
+struct base {};
+struct derived : base {};
+
+void
+bar()
+{
+  foo<derived>(); // { dg-error "no matching function" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/spaceship-synth8.C b/gcc/testsuite/g++.dg/cpp2a/spaceship-synth8.C
new file mode 100644
index 00000000000..d0d68c7fa6f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/spaceship-synth8.C
@@ -0,0 +1,12 @@
+// PR c++/94907
+// { dg-do compile { target c++2a } }
+
+namespace std { struct strong_ordering { }; }
+
+struct E;
+struct D {
+  virtual std::strong_ordering operator<=>(const struct E&) const = 0;
+};
+struct E : D {
+  std::strong_ordering operator<=>(const E&) const override = default;
+};
diff --git a/gcc/testsuite/g++.dg/ext/attr-parm-1.C b/gcc/testsuite/g++.dg/ext/attr-parm-1.C
index cc53a2ce328..681a652de1f 100644
--- a/gcc/testsuite/g++.dg/ext/attr-parm-1.C
+++ b/gcc/testsuite/g++.dg/ext/attr-parm-1.C
@@ -1,6 +1,11 @@
-// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ia32 } } }
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ia32 || lp64 } } } }
 // PR 94946
 class a {
+#ifdef __LP64__
+  template <typename b> a(b(__attribute__((sysv_abi)) *c)());
+  template <typename b> a(b(__attribute__((ms_abi)) *c)());
+#else
   template <typename b> a(b (*)());
   template <typename b> a(b(__attribute__((fastcall)) *c)());
+#endif
 };
diff --git a/gcc/testsuite/g++.dg/warn/Wdiv-by-zero-3.C b/gcc/testsuite/g++.dg/warn/Wdiv-by-zero-3.C
new file mode 100644
index 00000000000..424eb0c3d49
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wdiv-by-zero-3.C
@@ -0,0 +1,17 @@
+// PR c++/94938
+
+template <typename T, int N> int
+foo (T t, int i)
+{
+  int m1 = 10 / t;
+  int m2 = 10 / i;
+  int m3 = 10 / (sizeof(T) - sizeof(int)); // { dg-warning "division by" }
+  int m4 = 10 / N; // { dg-warning "division by" }
+  return m1 + m2 + m3 + m4;
+}
+
+void
+f ()
+{
+  foo<int, 0>(0, 0);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C b/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C
new file mode 100644
index 00000000000..d0375042e42
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C
@@ -0,0 +1,12 @@
+// PR c++/94951
+// { dg-do compile }
+// { dg-options "-O2 -Wall" }
+
+struct A { int a; };
+template <int N>
+struct B : public A
+{
+  static B<N> foo () { B<N> t; t.a = 4; return t; }	// { dg-bogus "dereferencing type-punned pointer will break strict-aliasing rules" }
+};
+
+B<0> b = B<0>::foo ();
diff --git a/gcc/testsuite/g++.dg/warn/Wtype-limits4.C b/gcc/testsuite/g++.dg/warn/Wtype-limits4.C
new file mode 100644
index 00000000000..3ae44b4f25a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wtype-limits4.C
@@ -0,0 +1,23 @@
+// PR c++/94938
+// { dg-additional-options "-Wtype-limits" }
+
+template<unsigned N> struct B { unsigned arr[N]; };
+template<> struct B<1u> { int arr[10]; };
+
+template <unsigned N> bool
+foo(B<N> l)
+{
+  int i = 0;
+  return l.arr[i] < 0;
+}
+
+void
+j()
+{
+  B<1u> b;
+  foo (b);
+  B<2u> b2;
+  // I think that in this instantiation we could warn, but it breaks
+  // gcc bootstrap (marek 5/2020).
+  foo (b2);
+}
diff --git a/gcc/testsuite/g++.dg/warn/template-2.C b/gcc/testsuite/g++.dg/warn/template-2.C
new file mode 100644
index 00000000000..1d29528b2ac
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/template-2.C
@@ -0,0 +1,22 @@
+// PR c++/94938 - ICE in value_dependent_expression_p in C++98 mode.
+// { dg-do compile }
+
+template <typename> struct S { S(); S(bool); };
+
+struct C {
+  bool operator()(S<float>);
+};
+
+S<float> fn (bool);
+
+template<typename T> void
+foo (T)
+{
+  S<float> s;
+  S<float> x = fn(false || C()(s));
+}
+
+int main ()
+{
+  foo(int());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash10.C b/gcc/testsuite/g++.old-deja/g++.pt/crash10.C
index a84b19004ee..012e3d0c11b 100644
--- a/gcc/testsuite/g++.old-deja/g++.pt/crash10.C
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash10.C
@@ -6,6 +6,7 @@ public:
   enum { val = (N == 0) ? M : GCD<N, M % N>::val };
 // { dg-error "constant expression" "valid" { target *-*-* } .-1 }
 // { dg-message "template argument" "valid" { target *-*-* } .-2 }
+// { dg-warning "division by" "" { target *-*-* } .-3 }
 };
 
 int main() {
diff --git a/gcc/testsuite/gcc.dg/pr94842.c b/gcc/testsuite/gcc.dg/pr94842.c
new file mode 100644
index 00000000000..33d9d42644c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94842.c
@@ -0,0 +1,11 @@
+/* PR c/94842 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+_Atomic float x = 5;
+
+void
+foo (void)
+{
+  void bar (float y[(int) (x += 2)]) {}
+}
diff --git a/gcc/testsuite/gcc.dg/pr94873.c b/gcc/testsuite/gcc.dg/pr94873.c
new file mode 100644
index 00000000000..36152176fbf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94873.c
@@ -0,0 +1,27 @@
+/* PR rtl-optimization/94873 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O -fno-merge-constants -fno-split-wide-types -fno-tree-fre" } */
+
+__attribute__((noipa)) void
+foo (const char *p, int q)
+{
+  if (p[0] != '%' || p[1] != '0' || p[2] != '2' || p[3] != 'x' || p[4] != '\0')
+    __builtin_abort ();
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  if ((unsigned char) q != 0x95)
+    __builtin_abort ();
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  if ((unsigned char) q != 0)
+    __builtin_abort ();
+#endif
+}
+
+int
+main ()
+{
+  union U { __int128 a; char b[sizeof (__int128)]; };
+  char x = ((union U){ .a = 0xF4409395252B9560ULL}).b[1];
+  for (unsigned i = 0; i < sizeof (x); i++)
+    foo ("%02x", i[(volatile unsigned char *) &x]);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94968.c b/gcc/testsuite/gcc.dg/pr94968.c
new file mode 100644
index 00000000000..e8b282139c4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94968.c
@@ -0,0 +1,8 @@
+/* PR c/94968 */
+/* { dg-do compile } */
+
+int
+foo (void)
+{ 
+  __builtin_speculation_safe_value (1, x);	/* { dg-error "undeclared" } */
+}						/* { dg-message "each undeclared identifier is reported only once" "" { target *-*-* } .-1 } */
diff --git a/gcc/testsuite/gcc.target/i386/pr94942.c b/gcc/testsuite/gcc.target/i386/pr94942.c
new file mode 100644
index 00000000000..b20f7a62e91
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94942.c
@@ -0,0 +1,24 @@
+/* PR target/94942 */
+/* { dg-do compile } */
+/* { dg-options "-O -flive-range-shrinkage -ftree-vrp -mavx512vl -mno-avx512bw -Wno-div-by-zero" } */
+
+typedef unsigned __attribute__((__vector_size__(8))) U;
+typedef short __attribute__((__vector_size__(8))) V;
+typedef char __attribute__((__vector_size__(16))) W;
+typedef int __attribute__((__vector_size__(16))) Z;
+int i, j, n, o;
+W k;
+Z l;
+char m;
+
+U
+foo (U q, long long r, V s)
+{
+  Z t = (i & i - (Z){10} & 4) - (0 != j);
+  Z u = o * (j * l);
+  s -= (char)__builtin_clrsbll (n);
+  W v = (k | k >> m + (W){4}) % 0;
+  W w = v + (W)t + (W)u;
+  U x = ((union { W a; U b; })w).b + q + (U)s + (U)r;
+  return x;
+}
diff --git a/gcc/testsuite/gfortran.dg/pr59107.f90 b/gcc/testsuite/gfortran.dg/pr59107.f90
new file mode 100644
index 00000000000..a84328f0851
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr59107.f90
@@ -0,0 +1,11 @@
+! { dg-compile }
+! { dg-options "-Wsurprising" }
+
+! There should be no surprising warnings
+
+program p
+  Integer :: nargs
+  intrinsic :: command_argument_count
+  nargs = command_argument_count()
+end
+
diff --git a/gcc/tree.c b/gcc/tree.c
index e451401822c..397474900ff 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -8889,7 +8889,7 @@ get_narrower (tree op, int *unsignedp_ptr)
 	return win;
       auto_vec <tree, 16> v;
       unsigned int i;
-      for (tree op = win; TREE_CODE (op) == COMPOUND_EXPR;
+      for (op = win; TREE_CODE (op) == COMPOUND_EXPR;
 	   op = TREE_OPERAND (op, 1))
 	v.safe_push (op);
       FOR_EACH_VEC_ELT_REVERSE (v, i, op)
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 70e296622e7..55d975b84fc 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,17 @@
+2020-05-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-05-01  Jonathan Wakely  <jwakely@redhat.com>
+		    Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/92894
+	* include/bits/iterator_concepts.h (ranges::__cust_imove::_IMove):
+	Add trait to determine return type and an alias for it.
+	(ranges::__cust_imove::_IMove::operator()): Use __result instead of
+	deduced return type.
+	* testsuite/24_iterators/customization_points/92894.cc: New test.
+	* testsuite/24_iterators/indirect_callable/92894.cc: New test.
+
 2020-05-07  Release Manager
 
 	* GCC 10.1.0 released.
diff --git a/libstdc++-v3/include/bits/iterator_concepts.h b/libstdc++-v3/include/bits/iterator_concepts.h
index b598532089e..c5b6247cde7 100644
--- a/libstdc++-v3/include/bits/iterator_concepts.h
+++ b/libstdc++-v3/include/bits/iterator_concepts.h
@@ -89,6 +89,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       struct _IMove
       {
       private:
+	template<typename _Tp>
+	  struct __result
+	  { using type = iter_reference_t<_Tp>; };
+
+	template<typename _Tp>
+	  requires __adl_imove<_Tp>
+	  struct __result<_Tp>
+	  { using type = decltype(iter_move(std::declval<_Tp>())); };
+
+	template<typename _Tp>
+	  requires (!__adl_imove<_Tp>)
+	  && is_lvalue_reference_v<iter_reference_t<_Tp>>
+	  struct __result<_Tp>
+	  { using type = remove_reference_t<iter_reference_t<_Tp>>&&; };
+
 	template<typename _Tp>
 	  static constexpr bool
 	  _S_noexcept()
@@ -100,16 +115,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  }
 
       public:
-	template<typename _Tp>
-	  requires __adl_imove<_Tp> || requires(_Tp& __e) { *__e; }
-	  constexpr decltype(auto)
+	// The result type of iter_move(std::declval<_Tp>())
+	template<std::__detail::__dereferenceable _Tp>
+	  using __type = typename __result<_Tp>::type;
+
+	template<std::__detail::__dereferenceable _Tp>
+	  constexpr __type<_Tp>
 	  operator()(_Tp&& __e) const
 	  noexcept(_S_noexcept<_Tp>())
 	  {
 	    if constexpr (__adl_imove<_Tp>)
 	      return iter_move(static_cast<_Tp&&>(__e));
-	    else if constexpr (is_reference_v<iter_reference_t<_Tp>>)
-	      return std::move(*__e);
+	    else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
+	      return static_cast<__type<_Tp>>(*__e);
 	    else
 	      return *__e;
 	  }
diff --git a/libstdc++-v3/testsuite/24_iterators/customization_points/92894.cc b/libstdc++-v3/testsuite/24_iterators/customization_points/92894.cc
new file mode 100644
index 00000000000..197268fe5e3
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/customization_points/92894.cc
@@ -0,0 +1,52 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <iterator>
+
+using namespace std;
+
+// Define our own of version of indirectly_readable_impl here,
+// to check the use of iter_move even if the real concept in
+// <bits/iterator_concepts.h> no longer uses iter_move.
+template<class In>
+concept indirectly_readable_impl
+  = requires(const In in)
+      {
+	typename iter_value_t<In>;
+	typename iter_reference_t<In>;
+	typename iter_rvalue_reference_t<In>;
+	{ *in } -> same_as<iter_reference_t<In>>;
+	{ ranges::iter_move(in) } -> same_as<iter_rvalue_reference_t<In>>;
+      };
+
+template<class T> requires indirectly_readable_impl<projected<T*, identity>>
+  void algo(T)
+  { }
+
+void
+test01()
+{
+  // PR libstdc++/92894
+  // Verify that the use of range::iter_move above doesn't cause odr-use of
+  // projected<local-class-type, identity>::operator* (which is not defined).
+  struct X { };
+  X a;
+  algo(a);
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/indirect_callable/92894.cc b/libstdc++-v3/testsuite/24_iterators/indirect_callable/92894.cc
new file mode 100644
index 00000000000..3408c76bde1
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/indirect_callable/92894.cc
@@ -0,0 +1,55 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <iterator>
+
+using std::projected;
+using std::identity;
+using std::indirect_unary_predicate;
+
+template<typename T,
+	 indirect_unary_predicate<projected<T*, identity>> Pred>
+  constexpr void
+  all_of(T*, Pred)
+  { }
+
+void
+test01()
+{
+  // PR libstdc++/92894
+  struct X { };
+  X x;
+  all_of(&x, [](X&) { return false; });
+}
+
+template<class R, class Proj = identity,
+	 indirect_unary_predicate<projected<R, Proj>> Pred>
+  constexpr void
+  find_if(R, Pred, Proj = {})
+  { }
+
+void
+test02()
+{
+  // PR 94241
+  struct s { int m; };
+  s r[] = { s{0}, s{1}, s{2}, s{3} };
+  find_if(r, [](auto const) { return true; });
+}
