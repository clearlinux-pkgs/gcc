Alexandre Oliva (1):
      [PR105324] libstdc++: testsuite: pr105324 requires FP from_char

GCC Administrator (3):
      Daily bump.
      Daily bump.
      Daily bump.

H.J. Lu (2):
      libsanitizer: cherry-pick commit b226894d475b from upstream
      x86: Add missing .note.GNU-stack to assembly source

Jakub Jelinek (2):
      Bump BASE-VER
      c++: Don't emit deprecated warnings or unavailable errors on lambda declarations

Jonathan Wakely (2):
      libstdc++: Fix deserialization for std::normal_distribution [PR105502]
      libstdc++: Fix test that fails on Solaris [PR104731]

Michael Meissner (1):
      rs6000: Ignore fusion option flags for inlining test [PR102059]

Patrick Palka (2):
      libstdc++: Don't use std::tolower in <charconv> [PR103911]
      c++: ICE during aggr CTAD for member tmpl [PR105476]

Richard Biener (6):
      tree-optimization/105394 - vector lowering of compares
      tree-optimization/105437 - BB vect with extern defs of throwing stmts
      Fixup OPTION_SET_P usage in finish_options
      middle-end/105461 - opts processing of -fvar-tracking
      tree-optimization/105484 - VEC_SET and EH
      middle-end/105376 - invalid REAL_CST for DFP constant

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 76e3cb0ce82..9925a567602 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,10 @@
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* gennews (files): Add files for GCC 12.
+
 2022-05-06  Release Manager
 
 	* GCC 12.1.0 released.
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 77903b35f3a..a5545292c4e 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-12.1.0
+12.1.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 609fd421e6b..375565c834c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,66 @@
+2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06   Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/102059
+	* config/rs6000/rs6000.cc (rs6000_can_inline_p): Ignore -mpower8-fusion
+	and -mpower10-fusion options for inlining purposes.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105376
+	* tree.cc (build_real): Special case dconst* arguments
+	for decimal floating point types.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105484
+	* gimple-isel.cc (gimple_expand_vec_set_expr): Clean EH, return
+	whether the CFG changed.
+	(gimple_expand_vec_exprs): When the CFG changed, clean it up.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-03  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105461
+	* opts.cc (finish_options): Match the condition to
+	disable flag_var_tracking to that of process_options.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-03  Richard Biener  <rguenther@suse.de>
+
+	* opts.cc: #undef OPTIONS_SET_P.
+	(finish_options): Use opts_set instead of OPTIONS_SET_P.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* tree-vect-slp.cc (vect_schedule_slp_node): Handle the
+	case where last_stmt alters control flow.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105394
+	* tree-vect-generic.cc (expand_vector_condition): Adjust
+	comp_width for non-integer mode masks as well.
+
 2022-05-06  Release Manager
 
 	* GCC 12.1.0 released.
diff --git a/gcc/config/rs6000/rs6000.cc b/gcc/config/rs6000/rs6000.cc
index bc619592b9e..4030864aa1a 100644
--- a/gcc/config/rs6000/rs6000.cc
+++ b/gcc/config/rs6000/rs6000.cc
@@ -25350,6 +25350,11 @@ rs6000_can_inline_p (tree caller, tree callee)
 	    }
 	}
 
+      /* Ignore -mpower8-fusion and -mpower10-fusion options for inlining
+	 purposes.  */
+      callee_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+      explicit_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+
       /* The callee's options must be a subset of the caller's options, i.e.
 	 a vsx function may inline an altivec function, but a no-vsx function
 	 must not inline a vsx function.  However, for those options that the
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 411bd5a959b..1ffada88326 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,21 @@
+2022-05-06  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105476
+	* pt.cc (maybe_aggr_guide): Set processing_template_decl when
+	partially instantiating the guide's parameter list.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* lambda.cc: Include decl.h.
+	(maybe_add_lambda_conv_op): Temporarily override deprecated_state to
+	UNAVAILABLE_DEPRECATED_SUPPRESS.
+
 2022-05-06  Release Manager
 
 	* GCC 12.1.0 released.
diff --git a/gcc/cp/lambda.cc b/gcc/cp/lambda.cc
index 65579edc316..ce49e28cd4c 100644
--- a/gcc/cp/lambda.cc
+++ b/gcc/cp/lambda.cc
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "toplev.h"
 #include "gimplify.h"
 #include "target.h"
+#include "decl.h"
 
 /* Constructor for a lambda expression.  */
 
@@ -1193,9 +1194,14 @@ maybe_add_lambda_conv_op (tree type)
 	}
     }
   else
-    call = build_call_a (callop,
-			 direct_argvec->length (),
-			 direct_argvec->address ());
+    {
+      /* Don't warn on deprecated or unavailable lambda declarations, unless
+	 the lambda is actually called.  */
+      auto du = make_temp_override (deprecated_state,
+				    UNAVAILABLE_DEPRECATED_SUPPRESS);
+      call = build_call_a (callop, direct_argvec->length (),
+			   direct_argvec->address ());
+    }
 
   CALL_FROM_THUNK_P (call) = 1;
   SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);
diff --git a/gcc/cp/pt.cc b/gcc/cp/pt.cc
index 81f7ef5c42b..254586c7700 100644
--- a/gcc/cp/pt.cc
+++ b/gcc/cp/pt.cc
@@ -29556,7 +29556,11 @@ maybe_aggr_guide (tree tmpl, tree init, vec<tree,va_gc> *args)
 	 PARMS, so that its template level is properly reduced and we don't get
 	 mismatches when deducing types using the guide with PARMS.  */
       if (member_template_p)
-	parms = tsubst (parms, DECL_TI_ARGS (tmpl), complain, init);
+	{
+	  ++processing_template_decl;
+	  parms = tsubst (parms, DECL_TI_ARGS (tmpl), complain, init);
+	  --processing_template_decl;
+	}
     }
   else if (TREE_CODE (init) == TREE_LIST)
     {
diff --git a/gcc/gimple-isel.cc b/gcc/gimple-isel.cc
index a8f7a0d25d0..4b309a05a9a 100644
--- a/gcc/gimple-isel.cc
+++ b/gcc/gimple-isel.cc
@@ -49,22 +49,23 @@ along with GCC; see the file COPYING3.  If not see
      _8 = .VEC_SET (_7, i_4(D), _1);
      u = _8;  */
 
-static gimple *
+static bool
 gimple_expand_vec_set_expr (struct function *fun, gimple_stmt_iterator *gsi)
 {
   enum tree_code code;
   gcall *new_stmt = NULL;
   gassign *ass_stmt = NULL;
+  bool cfg_changed = false;
 
   /* Only consider code == GIMPLE_ASSIGN.  */
   gassign *stmt = dyn_cast<gassign *> (gsi_stmt (*gsi));
   if (!stmt)
-    return NULL;
+    return false;
 
   tree lhs = gimple_assign_lhs (stmt);
   code = TREE_CODE (lhs);
   if (code != ARRAY_REF)
-    return NULL;
+    return false;
 
   tree val = gimple_assign_rhs1 (stmt);
   tree op0 = TREE_OPERAND (lhs, 0);
@@ -98,12 +99,15 @@ gimple_expand_vec_set_expr (struct function *fun, gimple_stmt_iterator *gsi)
 	  gimple_set_location (ass_stmt, loc);
 	  gsi_insert_before (gsi, ass_stmt, GSI_SAME_STMT);
 
+	  basic_block bb = gimple_bb (stmt);
 	  gimple_move_vops (ass_stmt, stmt);
-	  gsi_remove (gsi, true);
+	  if (gsi_remove (gsi, true)
+	      && gimple_purge_dead_eh_edges (bb))
+	    cfg_changed = true;
 	}
     }
 
-  return ass_stmt;
+  return cfg_changed;
 }
 
 /* Expand all VEC_COND_EXPR gimple assignments into calls to internal
@@ -297,6 +301,7 @@ gimple_expand_vec_exprs (struct function *fun)
   basic_block bb;
   hash_map<tree, unsigned int> vec_cond_ssa_name_uses;
   auto_bitmap dce_ssa_names;
+  bool cfg_changed = false;
 
   FOR_EACH_BB_FN (bb, fun)
     {
@@ -311,7 +316,7 @@ gimple_expand_vec_exprs (struct function *fun)
 	      gsi_replace (&gsi, g, false);
 	    }
 
-	  gimple_expand_vec_set_expr (fun, &gsi);
+	  cfg_changed |= gimple_expand_vec_set_expr (fun, &gsi);
 	  if (gsi_end_p (gsi))
 	    break;
 	}
@@ -323,7 +328,7 @@ gimple_expand_vec_exprs (struct function *fun)
 
   simple_dce_from_worklist (dce_ssa_names);
 
-  return 0;
+  return cfg_changed ? TODO_cleanup_cfg : 0;
 }
 
 namespace {
diff --git a/gcc/opts.cc b/gcc/opts.cc
index e5e3119a980..2ffbf429b7b 100644
--- a/gcc/opts.cc
+++ b/gcc/opts.cc
@@ -35,6 +35,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "version.h"
 #include "selftest.h"
 
+/* In this file all option sets are explicit.  */
+#undef OPTION_SET_P
+
 static void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);
 
 /* Names of fundamental debug info formats indexed by enum
@@ -1317,7 +1320,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,
 	debug_info_level = DINFO_LEVEL_NONE;
     }
 
-  if (!OPTION_SET_P (debug_nonbind_markers_p))
+  if (!opts_set->x_debug_nonbind_markers_p)
     debug_nonbind_markers_p
       = (optimize
 	 && debug_info_level >= DINFO_LEVEL_NORMAL
@@ -1326,15 +1329,14 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,
 
   /* Note -fvar-tracking is enabled automatically with OPT_LEVELS_1_PLUS and
      so we need to drop it if we are called from optimize attribute.  */
-  if (debug_info_level == DINFO_LEVEL_NONE
-      && !OPTION_SET_P (flag_var_tracking))
+  if (debug_info_level < DINFO_LEVEL_NORMAL)
     flag_var_tracking = false;
 
   /* One could use EnabledBy, but it would lead to a circular dependency.  */
-  if (!OPTION_SET_P (flag_var_tracking_uninit))
+  if (!opts_set->x_flag_var_tracking_uninit)
      flag_var_tracking_uninit = flag_var_tracking;
 
-  if (!OPTION_SET_P (flag_var_tracking_assignments))
+  if (!opts_set->x_flag_var_tracking_assignments)
     flag_var_tracking_assignments
       = (flag_var_tracking
 	 && !(flag_selective_scheduling || flag_selective_scheduling2));
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 2f7ffdfac60..41c2037a6b0 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,75 @@
+2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06   Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/102059
+	* gcc.target/powerpc/pr102059-4.c: New test.
+
+2022-05-06  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-02  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR testsuite/105433
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512fp16/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512fp16/m512h/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-06  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105476
+	* g++.dg/cpp2a/class-deduction-aggr13.C: New test.
+	* g++.dg/cpp2a/class-deduction-aggr13a.C: New test.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105376
+	* gcc.dg/pr105376.c: New testcase.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp23/lambda-attr1.C: New test.
+	* g++.dg/cpp23/lambda-attr2.C: New test.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105484
+	* gcc.dg/torture/pr105484.c: New testcase.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-03  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105461
+	* gcc.dg/pr105461.c: New testcase.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* g++.dg/vect/pr105437.cc: New testcase.
+
 2022-05-06  Release Manager
 
 	* GCC 12.1.0 released.
diff --git a/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
new file mode 100644
index 00000000000..a653c732fca
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
@@ -0,0 +1,37 @@
+// P2173R1 - Attributes on Lambda-Expressions
+// { dg-do compile { target c++11 } }
+
+void
+foo (bool x, bool y)
+{
+  auto a = [][[noreturn]] () {};	// { dg-warning "'noreturn' function does return" }
+  if (x)
+    a ();
+  auto b = [][[noreturn]] {};		// { dg-warning "'noreturn' function does return" }
+  if (y)
+    b ();
+  auto c = [] [[ deprecated ]] () {};	// { dg-bogus "is deprecated" }
+  c ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+  auto d = [][[deprecated]] {};		// { dg-bogus "is deprecated" }
+  d ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+#if __cpp_generic_lambdas >= 201304
+  auto e = [] [[deprecated]] (auto x) {};	// { dg-bogus "is deprecated" }
+  e (0.0);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(auto:1\\\)>\[^\n\r]*' is deprecated" "" { target c++14 } }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto f = [] <typename T> [[deprecated]] (T) {};	// { dg-bogus "is deprecated" }
+  f (1);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(T\\\)>\[^\n\r]*' is deprecated" "" { target c++20 } }
+#endif
+  auto g = [][[nodiscard]](int) { return 1; };
+  g (1);				// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(int\\\)>', declared with attribute 'nodiscard'" }
+  auto h = [] [[nodiscard]] { return 0; };
+  h ();					// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>', declared with attribute 'nodiscard'" }
+  auto i = [] [[ gnu::unavailable ]] () {};
+  auto j = [][[gnu::unavailable]] {};
+#if __cpp_generic_lambdas >= 201304
+  auto k = [] [[gnu::unavailable]] (auto x) {};	// { dg-bogus "is unavailable" }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto l = [] <typename T> [[gnu::unavailable]] (T) {};	// { dg-bogus "is unavailable" }
+#endif
+}
diff --git a/gcc/testsuite/g++.dg/cpp23/lambda-attr2.C b/gcc/testsuite/g++.dg/cpp23/lambda-attr2.C
new file mode 100644
index 00000000000..0392b179b86
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp23/lambda-attr2.C
@@ -0,0 +1,19 @@
+// P2173R1 - Attributes on Lambda-Expressions
+// { dg-do compile { target c++11 } }
+
+void
+foo (bool x, bool y)
+{
+  auto i = [] [[ gnu::unavailable ]] () {};
+  i ();			// { dg-error "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is unavailable" }
+  auto j = [][[gnu::unavailable]] {};
+  j ();			// { dg-error "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is unavailable" }
+#if __cpp_generic_lambdas >= 201304
+  auto k = [] [[gnu::unavailable]] (auto x) {};	// { dg-bogus "is unavailable" }
+  k (0.0);		// { dg-error "'foo\\\(bool, bool\\\)::<lambda\\\(auto:1\\\)>\[^\n\r]*' is unavailable" "" { target c++14 } }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto l = [] <typename T> [[gnu::unavailable]] (T) {};	// { dg-bogus "is unavailable" }
+  l (1);		// { dg-error "'foo\\\(bool, bool\\\)::<lambda\\\(T\\\)>\[^\n\r]*' is unavailable" "" { target c++20 } }
+#endif
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13.C
new file mode 100644
index 00000000000..d3b21c722c8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13.C
@@ -0,0 +1,11 @@
+// PR c++/105476
+// { dg-do compile { target c++17 } }
+
+template<class> struct Visitor_functor;
+
+template<class> struct Events {
+  template<class... Fn> struct Visitor : Visitor_functor<Fn>::type_t... { };
+};
+
+using ev_t = Events<int>;
+ev_t::Visitor v = { {} }; // { dg-error "too many initializers" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13a.C b/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13a.C
new file mode 100644
index 00000000000..69ae5dd4b60
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr13a.C
@@ -0,0 +1,18 @@
+// PR c++/105476
+// { dg-do compile { target c++20 } }
+// A valid version of class-deduction-aggr13.C.
+
+template<class> struct Visitor_functor;
+
+template<> struct Visitor_functor<int> {
+  using type_t = int;
+};
+
+template<class T> struct Events {
+  template<class Fn=T> struct Visitor {
+    Visitor_functor<Fn>::type_t t;
+  };
+};
+
+using ev_t = Events<int>;
+ev_t::Visitor v = { {} };
diff --git a/gcc/testsuite/g++.dg/vect/pr105437.cc b/gcc/testsuite/g++.dg/vect/pr105437.cc
new file mode 100644
index 00000000000..b3b440debef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr105437.cc
@@ -0,0 +1,24 @@
+// { dg-do compile }
+
+struct ControlClass
+{
+    virtual ~ControlClass();
+
+    int Width;
+    int Height;
+    unsigned IsToRepaint : 1;
+};
+
+struct SelectClass : ControlClass
+{
+    SelectClass(void);
+};
+
+int Non_Folded_Value();
+
+SelectClass::SelectClass(void)
+{
+    int factor = Non_Folded_Value();
+    Width = 32 << factor;
+    Height = 24 << factor;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105376.c b/gcc/testsuite/gcc.dg/pr105376.c
new file mode 100644
index 00000000000..f19ecf4aab2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105376.c
@@ -0,0 +1,9 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O -g" } */
+
+void
+foo (_Decimal64 d, _Decimal64 e)
+{
+  d -= -d;
+  d *= -e;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105461.c b/gcc/testsuite/gcc.dg/pr105461.c
new file mode 100644
index 00000000000..1e6743ccac2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105461.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fassociative-math -fsignaling-nans -fvar-tracking  -w" } */
+
+int
+bar (float *x, int y)
+{
+  *x = y;
+
+  return *x;
+}
+
+__attribute__ ((optimize ("O2"))) void
+foo (float *x, int y)
+{
+  int a = bar (x, y);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105484.c b/gcc/testsuite/gcc.dg/torture/pr105484.c
new file mode 100644
index 00000000000..f2a5eb8a7ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105484.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop" } */
+/* { dg-additional-options "-march=cannonlake" { target x86_64-*-* i?86-*-* } } */
+
+typedef int __attribute__((__vector_size__ (16))) V;
+
+void bar (int i);
+
+void
+foo (int i)
+{
+  V v;
+  __builtin_mul_overflow (7, i, &v[i]);
+  bar ((V){}[3]);
+}
diff --git a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
index b4a4a140e54..db08f52a34f 100644
--- a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
+++ b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
@@ -300,3 +300,4 @@ iamcu_noprintf:
 	.align 4
 .LCiamcu_noprintf1:
 	.long	1132527616
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102059-4.c b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
new file mode 100644
index 00000000000..5fe66f8af4b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Verify that power10 can explicity include functions compiled for power8.
+   The issue was -mcpu=power8 enables -mpower8-fusion, but -mcpu=power9 or
+   -mcpu=power10 do not set power8-fusion by default.  Thus when doing this
+   compilation, they would get an error that the inline function failed in its
+   inlining due to having incompatible options.  */
+
+static inline int __attribute__ ((always_inline,target("cpu=power8")))
+foo (int *b)
+{
+  *b += 10;
+  return *b;
+}
+
+int
+bar (int *a)
+{
+  *a = foo (a);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
index 7a8ed03d119..2f8d3a09c6b 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
@@ -82,3 +82,4 @@ snapshot_ret:
 	.comm	xmm_regs,256,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
index 73a59191d6d..77b3480ac32 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
@@ -79,3 +79,4 @@ snapshot_ret:
 	.comm	ymm_regs,512,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
index 0ef82876dd9..2e3306c44cb 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
@@ -95,3 +95,4 @@ snapshot_ret:
 	.comm	zmm_regs,2048,64
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/asm-support.S
index 7849acd2649..0793acf048b 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/asm-support.S
@@ -79,3 +79,4 @@ snapshot_ret:
 	.comm	xmm_regs,256,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S
index 73a59191d6d..77b3480ac32 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S
@@ -79,3 +79,4 @@ snapshot_ret:
 	.comm	ymm_regs,512,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m512h/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m512h/asm-support.S
index 0ef82876dd9..2e3306c44cb 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m512h/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m512h/asm-support.S
@@ -95,3 +95,4 @@ snapshot_ret:
 	.comm	zmm_regs,2048,64
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
index 7b891a140dc..f5dff4c10ab 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
@@ -30,6 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef __ELF__
 # define FN_TYPE(fn) .type fn,@function
 # define FN_SIZE(fn) .size fn,.-fn
+	.section	.note.GNU-stack,"",@progbits
 #else
 # define FN_TYPE(fn)
 # define FN_SIZE(fn)
diff --git a/gcc/tree-vect-generic.cc b/gcc/tree-vect-generic.cc
index 8b7227e8b58..e5bd9dc7c76 100644
--- a/gcc/tree-vect-generic.cc
+++ b/gcc/tree-vect-generic.cc
@@ -1122,6 +1122,9 @@ expand_vector_condition (gimple_stmt_iterator *gsi, bitmap dce_ssa_names)
       tree atype = build_nonstandard_integer_type (prec, 1);
       a = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, atype, a);
     }
+  else if (!a_is_comparison
+	   && VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (a)))
+    comp_width = vector_element_bits_tree (TREE_TYPE (a));
 
   int nunits = nunits_for_known_piecewise_op (type);
   vec_alloc (v, nunits);
@@ -1148,7 +1151,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi, bitmap dce_ssa_names)
 		       build_zero_cst (TREE_TYPE (a)));
 	}
       else
-	aa = tree_vec_extract (gsi, cond_type, a, width, index);
+	aa = tree_vec_extract (gsi, cond_type, a, comp_width, comp_index);
       result = gimplify_build3 (gsi, COND_EXPR, inner_type, aa, bb, cc);
       if (!CONSTANT_CLASS_P (result))
 	constant_p = false;
diff --git a/gcc/tree-vect-slp.cc b/gcc/tree-vect-slp.cc
index 805dd7e10e2..0d400c00df1 100644
--- a/gcc/tree-vect-slp.cc
+++ b/gcc/tree-vect-slp.cc
@@ -7302,6 +7302,13 @@ vect_schedule_slp_node (vec_info *vinfo,
 	  gcc_assert (seen_vector_def);
 	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
 	}
+      else if (is_ctrl_altering_stmt (last_stmt))
+	{
+	  /* We split regions to vectorize at control altering stmts
+	     with a definition so this must be an external which
+	     we can insert at the start of the region.  */
+	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
+	}
       else if (is_a <bb_vec_info> (vinfo)
 	       && gimple_bb (last_stmt) != gimple_bb (stmt_info->stmt)
 	       && gimple_could_trap_p (stmt_info->stmt))
diff --git a/gcc/tree.cc b/gcc/tree.cc
index 3c39be4f501..4cf3785270b 100644
--- a/gcc/tree.cc
+++ b/gcc/tree.cc
@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "escaped_string.h"
 #include "gimple-range.h"
 #include "gomp-constants.h"
+#include "dfp.h"
 
 /* Tree code classes.  */
 
@@ -2383,6 +2384,26 @@ build_real (tree type, REAL_VALUE_TYPE d)
   REAL_VALUE_TYPE *dp;
   int overflow = 0;
 
+  /* dconst{1,2,m1,half} are used in various places in
+     the middle-end and optimizers, allow them here
+     even for decimal floating point types as an exception
+     by converting them to decimal.  */
+  if (DECIMAL_FLOAT_MODE_P (TYPE_MODE (type))
+      && d.cl == rvc_normal
+      && !d.decimal)
+    {
+      if (memcmp (&d, &dconst1, sizeof (d)) == 0)
+	decimal_real_from_string (&d, "1");
+      else if (memcmp (&d, &dconst2, sizeof (d)) == 0)
+	decimal_real_from_string (&d, "2");
+      else if (memcmp (&d, &dconstm1, sizeof (d)) == 0)
+	decimal_real_from_string (&d, "-1");
+      else if (memcmp (&d, &dconsthalf, sizeof (d)) == 0)
+	decimal_real_from_string (&d, "0.5");
+      else
+	gcc_unreachable ();
+    }
+
   /* ??? Used to check for overflow here via CHECK_FLOAT_TYPE.
      Consider doing it via real_convert now.  */
 
diff --git a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp
index 0c260b6b516..4f22c78a183 100644
--- a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp
@@ -463,7 +463,11 @@ static void GetTls(uptr *addr, uptr *size) {
 #elif SANITIZER_GLIBC && defined(__x86_64__)
   // For aarch64 and x86-64, use an O(1) approach which requires relatively
   // precise ThreadDescriptorSize. g_tls_size was initialized in InitTlsSize.
+#  if SANITIZER_X32
+  asm("mov %%fs:8,%0" : "=r"(*addr));
+#  else
   asm("mov %%fs:16,%0" : "=r"(*addr));
+#  endif
   *size = g_tls_size;
   *addr -= *size;
   *addr += ThreadDescriptorSize();
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index ea745c2f816..a8e513d9238 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,35 @@
+2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105502
+	* include/bits/random.tcc
+	(operator>>(basic_istream<C,T>&, normal_distribution<R>&)):
+	Update state when __state_avail is false.
+	* testsuite/26_numerics/random/normal_distribution/operators/serialize.cc:
+	Check that deserialized object equals serialized one.
+
+2022-05-06  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/103911
+	* src/c++17/floating_from_chars.cc (find_end_of_float): Accept
+	two delimeters for the exponent part in the form of a possibly
+	NULL string of length two.  Don't use std::tolower.
+	(pattern): Adjust calls to find_end_of_float accordingly.
+
+2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	PR c++/105324
+	* testsuite/20_util/from_chars/pr105324.cc: Guard test body
+	with conditional for floating-point overloads of from_char.
+
 2022-05-06  Release Manager
 
 	* GCC 12.1.0 released.
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index 6c72e991007..87a16a21336 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -1961,7 +1961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool __saved_avail;
       if (__is >> __mean >> __stddev >> __saved_avail)
 	{
-	  if (__saved_avail && (__is >> __x._M_saved))
+	  if (!__saved_avail || (__is >> __x._M_saved))
 	    {
 	      __x._M_saved_available = __saved_avail;
 	      __x.param(param_type(__mean, __stddev));
diff --git a/libstdc++-v3/src/c++17/floating_from_chars.cc b/libstdc++-v3/src/c++17/floating_from_chars.cc
index e7f3a58cf18..5d2a931d5dd 100644
--- a/libstdc++-v3/src/c++17/floating_from_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_from_chars.cc
@@ -40,7 +40,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <cstring>
-#include <cctype>
 #include <locale.h>
 #include <bits/functexcept.h>
 #if _GLIBCXX_HAVE_XLOCALE_H
@@ -142,10 +141,10 @@ namespace
 
   // Find initial portion of [first, last) containing a floating-point number.
   // The string `digits` is either `dec_digits` or `hex_digits`
-  // and `exp` is 'e' or 'p' or '\0'.
+  // and `exp` is "eE", "pP" or NULL.
   const char*
   find_end_of_float(const char* first, const char* last, const char* digits,
-		    char exp)
+		    const char *exp)
   {
     while (first < last && strchr(digits, *first) != nullptr)
       ++first;
@@ -155,7 +154,7 @@ namespace
 	while (first < last && strchr(digits, *first))
 	  ++first;
       }
-    if (first < last && exp != 0 && std::tolower((unsigned char)*first) == exp)
+    if (first < last && exp != nullptr && (*first == exp[0] || *first == exp[1]))
       {
 	++first;
 	if (first < last && (*first == '-' || *first == '+'))
@@ -237,7 +236,7 @@ namespace
 
 	if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	  {
-	    last = find_end_of_float(first + neg, last, digits, 'p');
+	    last = find_end_of_float(first + neg, last, digits, "pP");
 #ifndef __cpp_exceptions
 	    if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	      {
@@ -261,7 +260,7 @@ namespace
 	if ((last - first) > buffer_resource::guaranteed_capacity())
 	  {
 	    last = find_end_of_float(first + neg, last, digits,
-				     "e"[fmt == chars_format::fixed]);
+				     fmt == chars_format::fixed ? nullptr : "eE");
 #ifndef __cpp_exceptions
 	    if ((last - first) > buffer_resource::guaranteed_capacity())
 	      {
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
index cecb17e41cc..ef24b4c5c7b 100644
--- a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
+++ b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
@@ -5,10 +5,12 @@
 
 int main()
 {
+#if __cpp_lib_to_chars >= 201611L // FP from_char not available otherwise.
   // PR libstdc++/105324
   // std::from_chars() assertion at floating_from_chars.cc:78
   std::string s(512, '1');
   s[1] = '.';
   long double d;
   std::from_chars(s.data(), s.data() + s.size(), d);
+#endif
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
index 9d8f8278fb3..d4f9f374643 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
@@ -25,6 +25,7 @@
 
 #include <random>
 #include <sstream>
+#include <testsuite_hooks.h>
 
 void
 test01()
@@ -37,10 +38,43 @@ test01()
   str << u;
 
   str >> v;
+  VERIFY( u == v );
+}
+
+void
+test_pr105502()
+{
+  // PR libstdc++/105502 std::normal_distribution deserialization issue
+  std::stringstream str;
+  std::normal_distribution<> d{1, 2}, d2;
+  std::minstd_rand0 g;
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = true
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = false
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
 }
 
 int main()
 {
   test01();
-  return 0;
+  test_pr105502();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
index 1f297a731a3..1c8ea4c9249 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
@@ -28,35 +28,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
